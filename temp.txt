*kt_dev_01*                                                     tw=100, utf-8

/^[#=]{
Use #{ for a group and ={ for a item


Write what you know and konw what you write. - EXC++, Herb Sutter

An expert is a man who has made all the mistakes that can be made, in a very
narrow field. -Nils Bohr


TODO:
2. how to implement shared_ptr for multi-threaded without using locks?
3. how to solve when there are same symbols in different objects in the same namespace?

KT KB. CPP

#{ gcc
|kt_dev_guti_000| gnu core util sites
|kt_dev_gcc_000| gcc-compile-script
|kt_dev_gcc_001| gcc-error: two or more data types in declaration specifiers <bool> 
|kt_dev_gcc_002| gcc-error: ISO C++ forbids declaration of 'UseStatic' with no type [-fpermissive]
|kt_dev_gcc_003| error: invalid conversion from 'Singleton*' to 'MySingleton*' [-fpermissive]
|kt_dev_gcc_004| error: variable-sized object 'out' may not be initialised
|kt_dev_gcc_005| error: expected '}' at end of input
|kt_dev_gcc_006| error: expected specifier-qualifier-list before 'X' or error: 'X' does not name a type 
|kt_dev_gcc_007| error: expected '=', ',', ';', 'asm' or '__attribute__' before
|kt_dev_gcc_008| warn: deprecated conversion from string constant to 'char*' [-Wwrite-strings]
|kt_dev_gcc_009| gcc-error: jump to case label and crosses initialisation of 
|kt_dev_gcc_010| error: dereferencing pointer to incomplete type
*kt_dev_gcc_011* error: void value not ignored as it ought to be
*kt_dev_gcc_011* error-cpp-preprocessor
*kt_dev_gcc_011* error-invalid-storage-class
*kt_dev_gcc_012* warn: may be used uninitialized in this function -Wmaybe-uninitialized

*kt_dev_gcc_100* gcc-doc gcc-header
*kt_dev_gcc_100* cpp-standard
*kt_dev_gcc_100* cpp-nullptr
|kt_dev_gcc_101| gcc-typeof
|kt_dev_gcc_102| gcc: link: link script
|kt_dev_gcc_103| gcc: link: link order and cyclic dependencies
|kt_dev_gcc_104| gcc: C90 and C99 
|kt_dev_gcc_105| gcc likely and unlikely 
|kt_dev_gcc_106| gcc: link: lrt
|kt_dev_gcc_107| gcc: link: sysroot and rpath-link
|kt_dev_gcc_110| gcc-attributes
|kt_dev_gcc_111| gcc: profiling
|kt_dev_gcc_113| gcc: options: warning

*kt_dev_gcc_200* gcc-cpp
|kt_dev_gcc_201| gcc-cpp-header-guard
*kt_dev_gcc_201* gcc-cpp-defined
|kt_dev_gcc_202| gcc-cpp-get-filename-without-full-path
*kt_dev_gcc_203* gcc-cpp-isystem option
*kt_dev_gcc_204* gcc-cpp-use
*kt_dev_gcc_204* gcc-cpp-issue
*kt_dev_gcc_205* gcc-cpp-vaarg
*kt_dev_gcc_206* gcc-cpp-stringification
*kt_dev_gcc_207* gcc-cpp-concatenation
*kt_dev_gcc_208* cpp-stringification

#{ cxx
*kt_dev_cxx_0000* cxx-code-ansi-color
*kt_dev_cxx_0000* cxx-twos-complement
*kt_dev_cxx_0000* cxx-builtin-type
*kt_dev_cxx_0000* cxx-type-limits
*kt_dev_cxx_0000* cxx-address-alignment
*kt_dev_cxx_0000* cxx-cast cpp-pointer-handle
*kt_dev_cxx_0000* cxx-issue-incremental-build
*kt_dev_cxx_0001* cxx-volatile
|kt_dev_lang_002| stdio
|kt_dev_lang_003| #error and #warning
*kt_dev_cpp_0004* cpp-postfix-increase
*kt_dev_cpp_0004* expr-chain
|kt_dev_lang_008| type and printf
|kt_dev_lang_011| expr-literal
*kt_dev_cpp_0004* pointer-and-array
*kt_dev_cpp_0004* pointer-null
*kt_dev_cpp_0004* pointer-reading
*kt_dev_cpp_0004* cpp-pointer-cstring
*kt_dev_cpp_0004* cpp-sizeof
|kt_dev_lang_014| printf-format
|kt_dev_lang_015| expr-control-flow
*kt_dev_cpp_0000* cpp-loop cpp-for cpp-while cpp-side-effect
|kt_dev_lang_016| cpp-precedence
*kt_dev_lang_016* cpp-order-evaluation cpp-side-effect
*kt_dev_lang_016* expr-unary
*kt_dev_lang_016* expr-assign
*kt_dev_lang_016* expr-conditional (the ?: operator)
*kt_dev_lang_017* cpp-style-name
|kt_dev_lang_020| cpp-style-bracing-allman
|kt_dev_lang_021| cpp-style-comments
*kt_dev_lang_021* cpp-style-layout
*kt_dev_lang_018* style-space
*kt_dev_lang_018* style-order-of-header

#{ cpp
*kt_dev_cpp_0000* cpp-reference
|kt_dev_cpp_0000| cxx-oop
*kt_dev_cpp_0000* cpp-init-form
*kt_dev_cpp_005* cpp-init-copy-form
|kt_dev_cpp_005| cpp-list-init cpp-initializer-list
|kt_dev_cpp_003| cpp-ctor
*kt_dev_cpp_018* cpp-dtor cpp-non-virtial-destruction-problem
*kt_dev_cpp_003* cpp-default-argument
*kt_dev_cpp_003* cpp-copy-control
*kt_dev_cpp_004* cpp-copy-assign-self
*kt_dev_cpp_003* cpp-pass-by-reference cpp-reference
*kt_dev_cpp_003* cpp-vexing-parse
*kt_dev_cpp_004* cpp-copy-dyn-resource cpp-ex-hasptr-example
|kt_dev_cpp_006| cpp-copy-swap {copy-and-swap-idiom}
*kt_dev_cpp_004* cpp-copy-control cpp-ex-message-example
*kt_dev_cpp_004* cpp-copy-control-move cpp-move cpp-ex-strvec-example
*kt_dev_cpp_004* cpp-copy-control-move-rvalue-reference
*kt_dev_cpp_004* cpp-copy-control-move-std-move
*kt_dev_cxx_0000* cxx-ex-query-example cpp-interface
*kt_dev_cxx_0000* cxx-ex-strblob-example
*kt_dev_cxx_0000* cxx-abc cxx-ex-quote-example cxx-refactoring
*kt_dev_cpp_200* cpp-abc-call-in-dtor
*kt_dev_cpp_004* cpp-copy-preventing-copies cpp-delete
|kt_dev_cxx_0000| cxx-function-matching
|kt_dev_cpp_028| cpp-namespace *cpp-pattern-handle*
|kt_dev_cpp_021| cpp-overload-operator
*kt_dev_cpp_005* cpp-builtin-conversion
*kt_dev_cpp_005* cpp-integer-division
*kt_dev_cpp_005* cpp-type-conversion cpp-explicit
|kt_dev_cpp_010| cpp-temp-object
*kt_dev_cpp_010* cpp-return cpp-rvo
|kt_dev_cpp_009| cpp-return cpp-undefined
*kt_dev_cpp_005* cpp-conversion-to-bool
*kt_dev_cpp_005* cpp-conversion-to-bool-stream
|kt_dev_cpp_008| cpp-const
*kt_dev_cpp_008* cpp-const-temporary
*kt_dev_cpp_008* cpp-const-member-function cpp-this
|kt_dev_cpp_008| cpp-const-bitwise
*kt_dev_cpp_008* cpp-const-logical
*kt_dev_cpp_008* cpp-const-mutable
*kt_dev_cpp_008* const-read: logical and physical state
*kt_dev_cpp_008* const-read: constness on logical state
*kt_dev_cpp_008* const-read-const-correctness, part 1
*kt_dev_cpp_008* cpp-const-read-correctness
|kt_dev_cpp_011| cpp-inline {empty-ctor-represenstaion}
*kt_dev_cpp_014* cpp-auto
|kt_dev_cpp_014| cpp-decltype cpp-typedef cpp-struct
|kt_dev_cpp_016| cpp-pointer-array
*kt_dev_cpp_016* cpp-static
|kt_dev_cpp_017| cpp-static-members and class const {class-method} {class-const}
*kt_dev_cpp_0000* cpp-except
|kt_dev_cpp_019| except-dtor-ctor
*kt_dev_cpp_019* except-noexcept
*kt_dev_cpp_019* cpp-except-safety
*kt_dev_cpp_019* except-disable
*kt_dev_cpp_019* except-terminate-call-tree
|kt_dev_cpp_019| except-case
|kt_dev_cpp_019| except-blanket catch and hidden exception
*kt_dev_cpp_019* except-and-finally
*kt_dev_cpp_021* cpp-code-check
|kt_dev_cpp_022| cpp-inheri
*kt_dev_cpp_022* cpp-inheri-virtual
*kt_dev_cpp_022* cpp-inheri-ctor-init
*kt_dev_cpp_022* cpp-access-control
*kt_dev_cpp_022* cpp-cast cpp-named-cast
*kt_dev_cpp_022* cpp-rtti
*kt_dev_cxx_0000* cxx-override
*kt_dev_cxx_0000* cxx-override-ref: C++ under the hood, Scott Meyers
*kt_dev_cpp_023* cpp-class-model
*kt_dev_cpp_023* cpp-class-model avoid-public
*kt_dev_cpp_023* cpp-class-model not-abuse-inheritance
*kt_dev_cxx_0000* cxx-pattern-template-method
*kt_dev_cxx_0000* cxx-pattern-pimpl cpp-minimise-compile-time
*kt_dev_cxx_0000* cxx-pattern-interface
*kt_dev_cxx_0000* cxx-pattern-singleton
*kt_dev_cxx_0000* cxx-pattern-factory
*kt_dev_cxx_0000* cxx-pattern-strategy
*kt_dev_cxx_0000* cxx-pattern-observer
*kt_dev_cpp_024* cpp-incomplete-type forward-declaration
*kt_dev_cpp_024* cpp-empty-base-class-optimization
*kt_dev_cpp_0000* cpp-design-defines-problem
*kt_dev_cpp_0000* cpp-design-by-contract 
*kt_dev_cpp_0000* cpp-design-define-variable
*kt_dev_cpp_0000* cpp-design-no-reference-to-internals
*kt_dev_cpp_0000* cpp-design-interface-first
*kt_dev_cpp_0000* cpp-new-delete
|kt_dev_cpp_025| random
|kt_dev_cpp_026| cpp-enum
|kt_dev_cpp_029| cpp-nested-class
*kt_dev_cpp_029* cpp-regex

*kt_dev_cpp_050* cpp-template-function
*kt_dev_cpp_050* cpp-template-class
*kt_dev_cpp_050* cpp-template-type-member
*kt_dev_cpp_050* cpp-template-default-argument
*kt_dev_cpp_050* cpp-template-member
*kt_dev_cpp_050* cpp-template-explicit-instantiation
*kt_dev_cpp_050* cpp-template-efficiency-on-deleter
|kt_dev_cpp_050| cpp-template-explicit-argument
|kt_dev_cpp_051| cpp-template-type-traits cpp-type-traits
|kt_dev_cpp_052| cpp-template-argument-deduction std-move
*kt_dev_cpp_053* cpp-template-std-forward
*kt_dev_cpp_053* cpp-template-overload
|kt_dev_cpp_053| cpp-template-variadic
|kt_dev_cpp_054| cpp-template-specialization
*kt_dev_cpp_054* template-inheritance
*kt_dev_cpp_060* template-initialize-type-member

*kt_dev_cpp_100* read-virtual-function-call-mechanism
|kt_dev_cpp_102| ref: MEC++24 understand the cost of virtual functions
|kt_dev_cpp_103| ref: others
|kt_dev_cpp_104| ref: why singletons are controversial


|kt_dev_cpp_300| case: framework {tizen-case}
|kt_dev_cpp_301| case: wrapper
|kt_dev_cpp_302| case: porting layer
|kt_dev_cpp_303| case: inheritance {how-gcc-build-vtable}
|kt_dev_cpp_304| case: overload

#{ stl follow <what-container-consideration> for points to consider
|kt_dev_stl_000| cpp-stl
|kt_dev_stl_001| cpp-pair cpp-tuple
|kt_dev_stl_002| std::ref
*kt_dev_cpp_0000* cpp-bool-in-condition

*kt_dev_cpp_0000* cpp-container
*kt_dev_cpp_0000* cpp-container-element-type
*kt_dev_cpp_0000* cpp-container-common-operations
*kt_dev_cpp_0000* cpp-container-insert-erase cpp-iter-invalidate
*kt_dev_cpp_0000* cpp-container-remove
*kt_dev_cpp_0000* cpp-container-performance
*kt_dev_cpp_0000* cpp-container-sequential cpp-container-performance
*kt_dev_cpp_0000* cpp-container-cpp-vector
*kt_dev_cpp_0000* cpp-container-cpp-vector-bool
*kt_dev_cpp_0000* cpp-container-cpp-deque
*kt_dev_cpp_0000* cpp-container-cpp-array
*kt_dev_cpp_0000* cpp-container-cpp-list
*kt_dev_cpp_0000* cpp-container-cpp-forward-list

*kt_dev_cpp_0000* cpp-container-associative
*kt_dev_cpp_0000* cpp-container-cpp-set cpp-multiset
*kt_dev_cpp_0000* cpp-container-cpp-map cpp-multimap cpp-size-t
|kt_dev_cpp_0000| cpp-container-cpp-unordered
|kt_dev_cpp_0000| cpp-container-adaptor containers {stack} {queue}
*kt_dev_cpp_0000* cpp-container-print-elements

*kt_dev_cpp_0000* cpp-iter
*kt_dev_cpp_0000* cpp-iter-array
*kt_dev_cpp_0000* cpp-iter-adapters
*kt_dev_cpp_0000* cpp-iter-external-and-internal

|kt_dev_stl_063| cpp-fobj cpp-function-object cpp-functor
|kt_dev_stl_063| cpp-fobj-predicate
|kt_dev_stl_063| cpp-fobj-lambda cpp-lambda C++11
*kt_dev_stl_063* cpp-fobj-as-argument
*kt_dev_stl_063* cpp-fobj-pass-by-reference
*kt_dev_stl_063* cpp-fobj-predefined
*kt_dev_stl_064* cpp-fobj-function-type
*kt_dev_stl_064* cpp-fobj-type cpp-function-pointer
*kt_dev_stl_065* cpp-fobj-bind cpp-bind
*kt_dev_stl_066* cpp-fobj-bind-member-function
*kt_dev_stl_060* cpp-algo
*kt_dev_stl_069* cpp-algo-nonmodifying
*kt_dev_stl_070* cpp-algo-copy

*kt_dev_cpp_000* cpp-stream cpp-cout cpp-cin

|kt_dev_stl_070| cpp-string
|kt_dev_stl_071| cpp-string-code
|kt_dev_stl_071| cpp-string-operations
|kt_dev_stl_072| string-find 
|kt_dev_stl_073| cpp-string-numeric-conversion cpp-boost-lexical-cast
|kt_dev_stl_074| stl-string: iterator support
*kt_dev_stl_075* cpp-stringstream
*kt_dev_stl_075* stl-string: seg fault

|kt_dev_stl_080| cpp-bitset

|kt_dev_stl_100| cpp-sp-raii cpp-raii
|kt_dev_stl_101| cpp-sp-shared
|kt_dev_stl_102| cpp-sp-weak
*kt_dev_stl_102* cpp-sp-exception
*kt_dev_stl_103* cpp-sp-unique
*kt_dev_stl_103* cpp-sp-delete sp-deleter
*kt_dev_stl_103* cpp-sp-unique: can store unique_ptr in a container?
*kt_dev_stl_104* sp-misuse
*kt_dev_stl_104* sp-shared-from-this
*kt_dev_stl_105* smart pointer: gotw #102: exception safety
|kt_dev_stl_102| smart pointer: internal: auto_ptr
*kt_dev_stl_103* sp-shared-implement
*kt_dev_stl_101* sp-shared-code
*kt_dev_stl_104* sp-thread-safety
|kt_dev_stl_104| smart pointer: examples
|kt_dev_stl_106| when to use which containers

|kt_dev_stl_110| cpp-allocator
|kt_dev_stl_111| gcc stl impl files

#{ MORE EFFECTIVE C++ 1ST, 1996, 25TH PRINTING
|kt_dev_mecpp_001| 16: 80-20 rule and profiler
|kt_dev_mecpp_002| 17: lazy evaluation
|kt_dev_mecpp_003| 18: over-eager evaluation
|kt_dev_mecpp_004| 
|kt_dev_mecpp_005| 25: reference-counting
|kt_dev_mecpp_006| 28: log entry
|kt_dev_mecpp_007| link-combine C and C++
|kt_dev_mecpp_008| 32: program in the future tense

#{ EFFECTIVE STL 3RD
|kt_dev_estl_001| design: 02: illusion of container-independent code


*kt_dev_ccon_000* cpp-chrono cpp-time

#{ c++ concurrent in action
|kt_dev_ccon_000| cpp-con-thread
|kt_dev_ccon_001| std-threadad: copy callables and arguments. lifetime issue
|kt_dev_ccon_002| std-threadad: join and detach
*kt_dev_ccon_003* cpp-con-race-condition cpp-data-race
|kt_dev_ccon_004| std::mutex and inherent race in thread-safe stack
*kt_dev_ccon_005* cpp-con-lock-guard cpp-deadlock
|kt_dev_ccon_006| cpp-con-unique-lock
|kt_dev_ccon_007| std::unique_lock and transferring mutex
|kt_dev_ccon_008| std::unique_lock and granulity
|kt_dev_ccon_009| std::call_once and protecting during initialization
|kt_dev_ccon_010| boost::shared_lock and read-write lock
|kt_dev_ccon_011| recursive lock
|kt_dev_ccon_012| std::condition_variable
|kt_dev_ccon_013| thread-safe queue
|kt_dev_ccon_014| cpp-con-task-model cpp-future
*kt_dev_ccon_014* cpp-con-async
|kt_dev_ccon_016| wait(): wait and poll
|kt_dev_ccon_017| std::packaged_task
|kt_dev_ccon_018| std::promise
|kt_dev_ccon_019| std::shared_future in multiple threads

|kt_dev_ccon_002| std::future


#{ BLUSHES OR BUGS
|kt_dev_blush_001| accessing neighbors in array

#{ design
|kt_dev_design_001| generic structure access

|kt_dev_uml_001| aggragation

|kt_dev_ref_001| references
|kt_dev_ref_002| sites




#{============================================================================
#{ GCC
={============================================================================
*kt_dev_gcc_0000* gcc-coreutils

http://www.gnu.org/software/coreutils/
git clone git://git.sv.gnu.org/coreutils coreutils


={============================================================================
*kt_dev_gcc_000* gcc-compile-script

#!/bin/bash
g++ -g -std=c++0x $1


={============================================================================
*kt_dev_gcc_000* gcc-build-cmake

https://cmake.org/download/
$ ./configure --prefix=/home/NDS-UK/kyoupark/toolchains
$ make
$ make install


={============================================================================
*kt_dev_gcc_001* gcc-error: two or more data types in declaration specifiers

This error happened under gcc c build when include a header having:

#ifndef __cplusplus
typedef uint8_t bool;
#endif

Thought that it means duplication defined in somewhere and tried:


<1> no error
#include <stdio.h>

typedef unsigned char bool;
typedef unsigned char bool;


<2> errors
#include <stdio.h>

typedef unsigned char bool;
typedef int bool;

testerrfunc.c:4:13: error: conflicting types for 'bool'
testerrfunc.c:3:23: note: previous declaration of 'bool' was here


<3>
#include <stdio.h>

#define bool unsigned char
typedef int bool;

c:4:13: error: two or more data types in declaration specifiers
c:4:1: warning: useless type name in empty declaration [enabled by default]

This expands to "typedef int unsigned char;" Hence error.


<4>
no error
#define bool unsigned char
#define bool unsigned char

#define MYBOOL 1
#define MYBOOL 3
sam01.cpp:6:0: warning: "MYBOOL" redefined [enabled by default]


{stdbool.h} {preprocessor-options}
Tried to preprocessor output using "-E" option but not that useful. But found
following line from the output and when followed that file, found what went
wrong:

From -E output using GCC 453.  
# 1 "/usr/lib/gcc/armv7l-tizen-linux-gnueabi/4.5.3/include/stdbool.h" 1 3 4

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */

#ifndef _STDBOOL_H
#define _STDBOOL_H

#ifndef __cplusplus

#define bool	_Bool
#define true	1
#define false	0

#else /* __cplusplus */

/* Supporting <stdbool.h> in C++ is a GCC extension.  */
#define _Bool	bool
#define bool	bool
#define false	false
#define true	true

#endif /* __cplusplus */

/* Signal that all the definitions are present.  */
#define __bool_true_false_are_defined	1
#endif	/* stdbool.h */

note: 
This header is not automatically included when use stdio.h. So what's the real
issues here?

From GCC: http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Data-Types

1.2 Keywords

Keywords are special identifiers reserved for use as part of the programming
language itself. You cannot use them for any other purpose. 

ISO C99 adds the following keywords:
     inline _Bool _Complex _Imaginary

So the issue is that "_Bool" is a keyword. Okay, why key keyword?


={============================================================================
*kt_dev_gcc_002* gcc-error: ISO C++ forbids declaration of X with no type [-fpermissive]

<1>
class UseStaic
{
  public:
    UseStatic() { std::cout << "Use staic ctor" << std::endl; }

  private:
    Sclass m_sclass;
};

Happened when made a typo in class name and meant to be class UseStatic.
Basically, not able to find UseStatic type.

<2> when missed void return.
template <typename T>
PRINT_ELEMENTS( T& coll, const string optstr="" )
{
  cout << optstr;

  for( const auto &elem : coll )
    cout << elem << " ";

  cout << endl;
}

error: ISO C++ forbids declaration of ‘PRINT_ELEMENTS’ with no type
[-fpermissive]


{fpermissive}
-fpermissive

Downgrade some diagnostics about nonconformant code from errors to warnings.
Thus, using -fpermissive allows some nonconforming code to compile. 


{when-missed-include}

<example-one>

#include < iostream>
// #include < stack>

using namespace std;

int main()
{
	int n;
	double item;
	stack<double> numbers;
	...
}

usestack.cpp:11:2: error: 'stack' was not declared in this scope
usestack.cpp:11:8: error: expected primary-expression before 'double'
usestack.cpp:11:8: error: expected ';' before 'double'


<example-two>

#include < iostream>
// #include < stack>

int main()
{
	int n;
	double item;
	std::stack<double> numbers;
	...
}

usestack.cpp:8:2: error: 'stack' is not a member of 'std'
usestack.cpp:8:13: error: expected primary-expression before 'double'
usestack.cpp:8:13: error: expected ';' before 'double'

Does it mean that it gives more reason not to use using-directive?


==============================================================================
*kt_dev_gcc_003*	error: invalid conversion from 'Singleton*' to 'MySingleton*' [-fpermissive]

This is an error when tried convert from base to derived.

class Singleton
{
	protected:
	Singleton() {};

	public:
	virtual Singleton* Instance();

	protected:
	static Singleton* m_pins;
};

Singleton* Singleton::m_pins = 0;

Singleton* Singleton::Instance() 
{
	if( m_pins == 0 )
	{
		std::cout << "Singleton::Instance" << std::endl;
		//m_pins = new Singleton;
	}

	return m_pins;
}

class MySingleton : public Singleton
{
	public:
	virtual MySingleton* Instance();
};

MySingleton* MySingleton::Instance() 
{
	if( m_pins == 0 )
	{
		std::cout << "MySingleton::Instance" << std::endl;
		//_pins = new MySingleton;
	}

	return m_pins; // error
}

usestatic.cpp: In member function 'virtual MySingleton* MySingleton::Instance()':
usestatic.cpp:106:9: error: invalid conversion from 'Singleton*' to 'MySingleton*' [-fpermissive]


==============================================================================
*kt_dev_gcc_004*	error: variable-sized object 'out' may not be initialised

void Merge( Entry* array, Position length, Position start, Position middle, Position end )
{
	Entry out[length];			// this works fine but not inited.
	Entry out[length] = {0};	// this causes an error
	Entry out[30] = {0};			// this works
}


I am assuming that you are using a C99 compiler (with support for dynamically sized arrays). The
problem in your code is that at the time when the compilers sees your variable declaration it cannot
know how many elements there are in the array (I am also assuming here, from the compiler error that
length is not a compile time constant). 

So should use memset or alloc in a function. [KT] Think from compiler perspective.

==============================================================================
*kt_dev_gcc_005*	error: expected ‘}’ at end of input


#include <iostream>
#include "Fsm.h"

int main()
{
	std::cout << "--{ main " << std::endl;

	std::cout << "--} main " << std::endl;
}

main.cpp:9:1: error: expected ‘}’ at end of input

Have got this error and puzzled since there is not much in this file. Interestingly when remove
fsm.h include, builds. So thought it may not find this header? Spend some time to change makefile to
specify current directory in the gcc command line. This turns out that in fsm.h, there is a missing
closing brace and this cause this error.

#ifdef __cplusplus
extern "C"
{
#endif

  ...

//#ifdef __cplusplus
//}
//#endif


==============================================================================
*kt_dev_gcc_006*  error: expected specifier-qualifier-list before 'X' or error: 'X' does not name a type 

error: 'X' does not name a type 

This happens when there is no typedef or types declared before its use.

error: expected specifier-qualifier-list before 'X' or error: 'X' does not name a type 

This is the same as above but more difficult to find because it happes when include a lot of headers
and there is dependencies between them.

<buffer.h>

#include "semaphore.h" // here one of struct uses some from st.h
#include "st.h"

<buffer.c>

#include "buffer.h"
#include "st.h"

In file included from buffer.h:1, from buffer.c:4: 
semaphore.h:4: error: expected specifier-qualifier-list before 'st_cond_t'

This shows the order is important in header inclusion.

This also happens when use the same header guard for two different headers. This effectvely do not
include necessary header and hence the error.

#ifndef __MH5W_GPI_H__
#define __MH5W_GPI_H__


={============================================================================
*kt_dev_gcc_007*  error: expected '=', ',', ';', 'asm' or '__attribute__' before

<case-01>
Like this case when use CPP features in C, this is very obvious so errors are clear.

kit@kit-vb:~/work$ gcc repmanc.c 
repmanc.c:10:1: error: unknown type name 'class'
repmanc.c:11:1: error: error: expected '=', ',', ';', 'asm' or '__attribute__' before '{' token

<case-02>
However, when there are many header files and they are cascaded each other, this is not obvious.
This happens because C file uses CPP header which defines classes and cannot handle class keyword.

In file included from /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/OSAbstraction.h:10:0,
                 from /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/app/MApp.h:26,
                 from /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/main/view_main.c:28:
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/PCString.h:52:7: error: expected '=', ',',
';', 'asm' or '__attribute__' before 'PCMem'


={============================================================================
*kt_dev_gcc_008*  warning: deprecated conversion from string constant to 'char*' [-Wwrite-strings]

This happens when use string literal for char* member in GCC(g++) but it was fine before in C.

main.cpp:53:74: warning: deprecated conversion from string constant to 'char*' [-Wwrite-strings]

typedef struct fsm_instance {
   char*              name;
   ...
} fsm_instance_t;

fsm_instance_t Foo = { "Fsm", ... };

-Wwrite-strings

When compiling C, give string constants the type "const char[length]" so that copying the address of
one into a non-const char * pointer produces a warning. These warnings help you find at compile time
code that can try to 'write' into a string constant, but only if you have been very careful about
using 'const' in declarations and prototypes. Otherwise, it is just a nuisance. This is why we did not
make -Wall request these warnings.

When compiling C++, warn about the deprecated conversion from string literals to char *. This
warning is enabled by default for C++ programs. 

1) Should consider using std::string name; instead?
Not perferred since need to change other C codes to get c string. .c_str().

2) Should use const in declarations?

typedef struct fsm_instance {
   const char*              name;
   ...
} fsm_instance_t;

But this cause other warnings in other function defs using this strucrue due to const.

3) Should use char* where string literal used.
This (char*) is the easiest way.


={============================================================================
*kt_dev_gcc_009* jump to case label and crosses initialisation of

{code-example}
http://stackoverflow.com/questions/2392655/what-are-the-signs-of-crosses-initialization

<ex>
#include <iostream>
using namespace std;

int main()
{
  int x, y, i;

  cin >> x >> y >> i;

  switch(i) {
    case 1:
      // int r;         // a) okay
      // int r = x + y; // b) fail to compile
      // int r = 1;     // c) fail to compile
      cout << r;
      break;
    case 2:
      r = x - y;
      cout << r;
      break;
  };
}

:14:14: error: jump to case label   // note. this is main error.
:11:17: error:   crosses initialisation of ‘int r’

Why? Why is a) okay?

The Standard says (6.7/3):

It is possible to transfer into a block, but 'not' in a way that 'bypasses'
declarations with 'initialization'. A program that jumps 'from' a point where a
local variable with automatic storage duration is not in scope 'to' a point
where it is in scope is ill-formed unless the variable has POD type (3.9) and is
declared without an initializer (8.5).

note:
KT. from out of switch to inside of switch

1) The problem is that it is possible for r to come to scope without its
initializer being executed. The code would compile fine if you removed the
initializer completely (i.e. the line would read "int r;").

2) It will cause a "crosses initialization" error, because it is possible to
skip the initialization of r, but after that it will still be in scope, even
though it was never created in the first place. NOTE: this is not true since
switch is a single scope. see below examples.

<ex>
:281:10: error: jump to case label
:260:34: error:   crosses initialization of 'std::vector<unsigned char> abortCode'
:284:34: error: redeclaration of 'std::vector<unsigned char> abortCode'
:260:34: error: 'std::vector<unsigned char> abortCode' previously declared here
:295:5: error: jump to case label
:260:34: error:   crosses initialization of 'std::vector<unsigned char> abortCode'

    case SIGNAL_CI_APP_MMI_ABORT_REQ:
260:      std::vector<unsigned char> abortCode;
      ...
      break;

281:case SIGNAL_CI_APP_MMI_ABORT_ACK:
      ...
284:      std::vector<unsigned char> abortCode;

note:
KT. So the switch is a 'single' scope but has multiple blocks(jumps). The
problem is that there is chance to go any block such as default even if it is
not covered in code and this 'skip' the initiailisation. not clear why it causes
a problem but the 'best' thing you can do is to limit the scope of the variable.
That way you'll satisfy both the compiler and the reader. Or declare variables
before switch.

switch(i)
{
  case 1:
    {
      int r = 1;
      cout << r;
    }
    break;
  case 2:
    {
      int r = x - y;
      cout << r;
    }
    break;
};


={============================================================================
*kt_dev_gcc_010* error: dereferencing pointer to incomplete type

error: dereferencing pointer to incomplete type

struct
{
  ...
  Resources *resources;

} Mgr;

typedef struct _Resources {
    ...
    VideoDecoderHandle                 videoDecoder;
    ...
} Resources;

static callback( void* context ) 
{
    // this cause error
    Mgr* mgr = (GstNexusMgr*) context;
    if( VideoDecoder_GetStatus( mgr->resources->videoDecoder, &vset ) );

    // this works okay
    Resources *resources = (Resources *) context;
    if( VideoDecoder_GetStatus( resources->videoDecoder, &vset ) );
}


={============================================================================
*kt_dev_gcc_011* error: void value not ignored as it ought to be

error: void value not ignored as it ought to be

Error rc = N_Playpump_GetSettings(sharedMem->playpump[i], &pset);

/**
Summary:
Get current settings
**/
void N_Playpump_GetSettings(
    N_PlaypumpHandle playpump,
    N_PlaypumpSettings *pSettings /* [out] */
    );


={============================================================================
*kt_dev_gcc_011* error-cpp-preprocessor

Have missed `;` at the end of function declaration.

// <header-two>
VTABLE_GetElement_X(const VTable_t* vtable, uint32_t line)    // error
VTABLE_GetElement_X(const VTable_t* vtable, uint32_t line);   // okay

This header is included in various source and gcc shows errors which seemingly
  comes from completely unrelated.

This is becuase

// source one
#include "header one.h"

// header one
#include ...
#include "<header-two>.h"
#include "<header-three>.h"

Shows errors right from the beginning of <header-three> since <header-two> is
not properly completed by using `;` and affect the rest of preprocessing.


={============================================================================
*kt_dev_gcc_011* error-invalid-storage-class

Have missed ending brace and gets odd errors:

quota_resource.c: In function 'QuotasOnDevice_LimitQuotaSize':
quota_resource.c:4076: error: invalid storage class for function 'QuotasOnDevice_SetSizes'
quota_resource.c:4076: warning: no previous prototype for 'QuotasOnDevice_SetSizes'
quota_resource.c:4076: warning: declaration of 'QuotasOnDevice_SetSizes' shadows a global declaration
quota_resource.c:654: warning: shadowed declaration is here
quota_resource.c: In function 'QuotasOnDevice_SetSizes':
...
and errors on the rest of functions in that file.


PRVFUNC void QuotasOnDevice_LimitQuotaSize(RMF_QUOTA_Instance quota)
{
    if (quota->creationInfo.min_allowed_unit != RMF_QUOTA_SIZE_UNITS_UNDEF)
    {
        // long code
        {
            /*quotas[Idx]->creationInfo.max_size = quotas[Idx]->creationInfo.min_allowed_size;*/
            DIAG_LOG_INFO(gRmfSegmentId, ("max_size is lower than min_allowed_size. Zeroing size"));

            quota->creationInfo.max_size = i64zero;
        }
    // }

    if (quota->creationInfo.max_allowed_unit != RMF_QUOTA_SIZE_UNITS_UNDEF)
    {
        {
            quota->creationInfo.max_size = quota->creationInfo.max_allowed_size;
        }
    }
}


PRVFUNC SYSTEM_STATUS QuotasOnDevice_SetSizes(SYSTEMCOMMON_DEVICE_HANDLE device_handle)
{
}


={============================================================================
*kt_dev_gcc_012* warn: may be used uninitialized in this function -Wmaybe-uninitialized

error: 'value' may be used uninitialized in this function 
  [-Werror=maybe-uninitialized]

This is promoted to error since -Wall used. However, coundn't find easily why
it emited this warning in the code below:


else {
  ErrorEventValue::Enum errVal = ErrorEventValue::other;
  ErrorEventContext::Enum errContext = ErrorEventContext::other;

  if (...) {
    boost::tie(errVal, errContext) =
      mapGStreamerToMediaRouterError_src(error, text_msg, msg->src) ;

  } else if (...) {
    boost::tie(errVal, errContext) =
      mapGStreamerToMediaRouterError_sink(error);

  } else {
    errVal = ErrorEventValue::other;
    errContext = ErrorEventContext::other;
  }

  // ERROR:
  produceEvent(
      boost::bind(&MediaRouterEventListener::ErrorEvent, _1,
        errVal, errContext, text_msg));

  // OK: when use enum directly
  // produceEvent(
  //     boost::bind(&MediaRouterEventListener::ErrorEvent, _1,
  //                 ErrorEventValue::other, ErrorEventContext::other, test_msg));
}


From GCC:

-Wmaybe-uninitialized
    For an automatic variable, if there exists a path from the function entry
    to a use of the variable that is initialized, but there exist some other
    paths for which the variable is not initialized, the compiler emits a
    warning if it cannot prove the uninitialized paths are not executed at run
    time. These warnings are made optional because GCC is not smart enough to
    see all the reasons why the code might be correct in spite of appearing to
    have an error. Here is one example of how this can happen:

              {
                int x;
                switch (y)
                  {
                  case 1: x = 1;
                    break;
                  case 2: x = 4;
                    break;
                  case 3: x = 5;
                  }
                foo (x);
              }

    If the value of y is always 1, 2 or 3, then x is always initialized, but
    GCC doesn't know this. To suppress the warning, you need to provide a
    default case with assert(0) or similar code. 

Cannot see path which goes with unitialized variable. Worse, didn't change
this function. WTF?

https://gcc.gnu.org/wiki/Better_Uninitialized_Warnings


The cause is this: This check applies to not only the current function but
also sub function calls. The 'value' variable in the message is one from
called one and there it is not initialized. When initialize it, error goes
away.

std::pair<> mapGStreamerToMediaRouterError_src(error, text_msg, msg->src)
{
    ErrorEventValue::Enum value;
    ...
}


={============================================================================
*kt_dev_gcc_100* gcc-doc gcc-header

{reference}
http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html
http://gcc.gnu.org/wiki/HomePage
https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/

{gcc-headers}
Has two parts.

For ubuntu:

/usr/lib/gcc/i686-linux-gnu/4.6/include
/usr/include/c++/4.6/

For debian:

/usr/include/c++/4.9.2
/usr/include/x86_64-linux-gnu/c++/4.9/bits$ ll

total 200
drwxr-xr-x 2 root root  4096 Dec 23 09:31 ./
drwxr-xr-x 6 root root  4096 Dec 23 09:31 ../
-rw-r--r-- 1 root root  1924 Dec 25  2014 atomic_word.h
-rw-r--r-- 1 root root  2890 Dec 25  2014 basic_file.h
-rw-r--r-- 1 root root  1849 Dec 25  2014 c++allocator.h
-rw-r--r-- 1 root root 48207 Dec 25  2014 c++config.h
-rw-r--r-- 1 root root  1608 Dec 25  2014 c++io.h
-rw-r--r-- 1 root root  3304 Dec 25  2014 c++locale.h
-rw-r--r-- 1 root root  1333 Dec 25  2014 cpu_defines.h
-rw-r--r-- 1 root root  2242 Dec 25  2014 ctype_base.h
-rw-r--r-- 1 root root  2284 Dec 25  2014 ctype_inline.h
-rw-r--r-- 1 root root  2098 Dec 25  2014 cxxabi_tweaks.h
-rw-r--r-- 1 root root  5177 Dec 25  2014 error_constants.h
-rw-r--r-- 1 root root  2388 Dec 25  2014 extc++.h
-rw-r--r-- 1 root root 24237 Dec 25  2014 gthr-default.h
-rw-r--r-- 1 root root  5608 Dec 25  2014 gthr.h
-rw-r--r-- 1 root root 24237 Dec 25  2014 gthr-posix.h
-rw-r--r-- 1 root root  6788 Dec 25  2014 gthr-single.h
-rw-r--r-- 1 root root  4099 Dec 25  2014 messages_members.h
-rw-r--r-- 1 root root  6177 Dec 25  2014 opt_random.h
-rw-r--r-- 1 root root  1783 Dec 25  2014 os_defines.h
-rw-r--r-- 1 root root  2778 Dec 25  2014 stdc++.h
-rw-r--r-- 1 root root  1741 Dec 25  2014 stdtr1c++.h
-rw-r--r-- 1 root root  2933 Dec 25  2014 time_members.h


={============================================================================
*kt_dev_gcc_100* cpp-standard

Preface

This is a reference manual for the C programming language as implemented by the GNU Compiler
Collection (GCC). Specifically, this manual aims to document:

The 1989 ANSI C standard, commonly known as C89/C90

The 1999 ISO C standard, commonly known as C99, ISO/IEC 9899:1999, to the extent that C99 is
implemented by GCC

The current state of GNU extensions to standard C 

This manual describes C89 as its baseline. C99 features and GNU extensions are explicitly labeled as
such.

By default, GCC will compile code as C89 plus GNU-specific extensions. Much of C99 is supported;
once full support is available, the default compilation dialect will be C99 plus GNU-specific
extensions. (Some of the GNU extensions to C89 ended up, sometimes slightly modified, as standard
language features in C99.)

The C language includes a set of preprocessor directives, which are used for things such as macro
text replacement, conditional compilation, and file inclusion. Although normally described in a C
language manual, the GNU C preprocessor has been thoroughly documented in The C Preprocessor, a
separate manual which covers preprocessing for C, C++, and Objective-C programs, so it is not
included here. 


{C90-C99}
After ANSI produced the official standard for the C programming language in 1989, which became an
international standard in 1990, the C language specification remained relatively static for some
time, while C++ continued to evolve, largely during its own standardization effort. Normative
Amendment 1 created a new standard for C in 1995, but only to correct some details of the 1989
standard and to add more extensive support for international character sets. The standard underwent
further revision in the late 1990s, leading to the publication of ISO/IEC 9899:1999 in 1999, which
was adopted as an ANSI standard in May 2000. The language defined by that version of the standard is
commonly referred to as "C99". 

<for-example>
for(int i = 0; i < 0; i++)
   ;

sam01.c:153:3: error: ‘for’ loop initial declarations are only allowed in C99 mode
sam01.c:153:3: note: use option -std=c99 or -std=gnu99 to compile your code

<for-C99>
The following causes error:
usecomma.cpp:70:42: error: invalid conversion from 'Node* {aka node*}' to 'int' [-fpermissive]
usecomma.cpp:72:22: error: base operand of '->' is not a pointer

{
   // search the end using count
70:   for( int current = 1, pend = list->header; current < list->count; current++)
72:      pend = pend->pnext;
}

{
   // search the end using count
   pend = list->header;
   for( int current = 1; current < list->count; current++)
      pend = pend->pnext;

   or

   // search the end using count
   int current;
   for( current = 1, pend = list->header; current < list->count; current++) 
      pend = pend->pnext;
}

Why? Because cannot define different types in the init part of for. See declaration.

From ISO/IEC 9899-1999

6.8.5 Iteration statements
Syntax

for ( expression opt ; expression opt ; expression opt) statement
for ( declaration expression opt ; expression opt) statement

note: This is why the var declared in a for has a scope
5 An iteration statement is a block whose scope is a strict subset of the scope of its enclosing
block. The loop body is also a block whose scope is a strict subset of the scope of the iteration
statement. 

Now the 'block wrapped around the loop' comes into its own; it explains why the variable i cannot be
accessed outside the loop. You can declare more than one variable, but they must all be of
the-'same' -type:

for (int i = 0, j = sizeof(something); i < j; i++, j--) { ... }


<cpp-03> C++03 C++98 Support in GCC
C++03 replaced the prior revision of the C++ standard, called C++98, and was
later replaced by C++11.

<cpp-11> C++11 C++11
https://isocpp.org/std/the-standard

http://gcc.gnu.org/projects/cxx0x.html

// C++0x was the working name of the ISO C++ 2011 standard, which introduced a
// host of new features into the standard C++ language and library. This project
// sought to implement new C++11 features in GCC, and made it the first compiler
// to bring feature-complete C++11 to C++ programmers.
// 
// C++11 features are available as part of the "mainline" GCC compiler in the
// trunk of GCC's Subversion repository and in GCC 4.3 and later. 
// 
// >
// To enable C++0x support, add the command-line parameter -std=c++0x to your g++
// command line. Or, to enable GNU extensions in addition to C++0x extensions,
//         add -std=gnu++0x to your g++ command line. GCC 4.7 and later support
//         -std=c++11 and -std=gnu++11 as well.
// 
// Important: GCC's support for C++11 is still experimental. Some features were
// implemented based on early proposals, and no attempt will be made to maintain
// backward compatibility when they are updated to match the final C++11
// standard.
// 
// $ g++ -v --help | egrep "\-std"
// 
//   -std=c++0x                  Conform to the ISO 1998 C++ standard, with
//                               extensions that are likely to become a part of
//                               the upcoming ISO C++ standard, dubbed C++0x. Note
//                               that the extensions enabled by this mode are
//                               experimental and may be removed in future
//                               releases of GCC.
// 
// note: when use gcc, got link errors that cannot find STLs. must use g++.
// $ g++ -std=c++0x sample.cpp

// 25.10.2017
// no need to set "-std=c++0x" when use 4.9.2
// g++ (Debian 4.9.2-10) 4.9.2

  -std=c++0x                  `Deprecated` in favor of -std=c++11
  -std=c++11                  Conform to the ISO 2011 C++ standard

C++11 Support in GCC

GCC 4.8.1 was the first feature-complete implementation of the 2011 C++
standard, previously known as C++0x.

This mode can be selected with the -std=c++11 command-line flag, or
-std=gnu++11 to enable GNU extensions as well.

{override-keyword}
Explicit virtual overrides from GCC 4.7

{alias-declaration}
Primers p68. GCC 4.4.5 don't.

class Foo {

  using line_no = vector< string >::size_type;

  typedef vector< string >::size_type line_no;
};


{explicit}
From GCC 45. See *kt_dev_cpp_005* for more.


{in-class-initializers}
For GCC 4.6.3 it emit error:
usecomma.cpp:5:19: sorry, unimplemented: non-static data member initialisers



{cplusplus-macro}
__cplusplus
This macro is defined when the C++ compiler is in use. You can use __cplusplus to test whether a header is compiled by a C compiler or a C++ compiler. This macro is similar to __STDC_VERSION__, in that it expands to a version number. Depending on the language standard selected, the value of the macro is 199711L for the 1998 C++ standard, 201103L for the 2011 C++ standard, 201402L for the 2014 C++ standard, 201703L for the 2017 C++ standard, or an unspecified value strictly larger than 201703L for the experimental languages enabled by -std=c++2a and -std=gnu++2a.


{the-gnu-c++-library}
http://gcc.gnu.org/onlinedocs/libstdc++/index.html


={============================================================================
*kt_dev_gcc_100* cpp-nullptr

{cpp-nullptr}
This is for C++11.

$ gcc sam01.c
sam01.c: In function ‘main’:
sam01.c:7:26: error: ‘nullptr’ undeclared (first use in this function)
sam01.c:7:26: note: each undeclared identifier is reported only once for each function it appears in

$ g++ -g -std=c++0x sam01.c

This new feature especially helps to avoid mistakes that occurred when a null
pointer was interpreted as an `integer` value. For example:

void f(int);
void f(void*);

f(0);       // calls f(int)
f(NULL);    // calls f(int) if NULL is 0, ambiguous otherwise
f(nullptr); // calls f(void*)

<keyword-or-define>
nullptr is a new 'keyword' and literal that has special type and automatically
converts into 'any' other pointer type. Has type std::nullptr_t defined in
<cstddef>, so you can now even overload operations for the case that a null
pointer is passed.

// from SO

How is it a keyword and an instance of a type?

This isn't surprising. Both true and false are keywords and as literals they
have a type ( bool ). nullptr is a pointer literal of type std::nullptr_t, and
it's a prvalue (you cannot take the address of it using &).

4.10 about pointer conversion says that a prvalue of type std::nullptr_t is a
null pointer constant, and that an integral null pointer constant can be
converted to std::nullptr_t. The opposite direction is not allowed. This
allows overloading a function for both pointers and integers, and passing
nullptr to select the pointer version. Passing NULL or 0 would confusingly
select the int version.

A cast of nullptr_t to an integral type needs a reinterpret_cast, and has the
same semantics as a cast of (void*)0 to an integral type (mapping
    implementation defined). A reinterpret_cast cannot convert nullptr_t to
any pointer type. Rely on the implicit conversion if possible or use
static_cast.

The Standard requires that sizeof(nullptr_t) be sizeof(void*).

// c++config.h
namespace std
{
#if __cplusplus >= 201103L
  typedef decltype(nullptr)	nullptr_t;
#endif
}

// g++ (Debian 4.9.2-10) 4.9.2

echo -e "#include <utility>\nint main() { std::pair<bool, const char*> x(false, 0); return 0; }" | g++ --std=c++0x -Wall -x c++ -o foo -

echo -e "#include <utility>\nint main() { const char* const null_ptr = 0; std::pair<bool, const char*> x(false, null_ptr); return 0; }" | g++ -Wall -x c++ -o foo -

echo -e "#include <utility>\nint main() { std::pair<bool, const char*> x(false, 0); return 0; }" | g++ -Wall -x c++ -o foo -

Regardless of "-std=c++0x", comiles well for all cases but fails as:

4.4.5/bits/stl_pair.h:90: error: invalid conversion from 'int' to 'const char*'


={============================================================================
*kt_dev_gcc_101* gcc-typeof

To check actual type of some expression. For example:

http://gcc.gnu.org/onlinedocs/gcc/Typeof.html
http://stackoverflow.com/questions/16832863/behaviour-of-sizeof-in-c-gcc


={============================================================================
*kt_dev_gcc_102* gcc: link script

{relocation-problem}
CNXT embedded platform.

[bin]$ ./arm-linux-uclibcgnueabi-gcc -print-search-dirs
install: /home/wgrobler/platforms/CnxtPecos/M2.1/SRC/host/linux/tools-4.1.1/lib/gcc/arm-linux-uclibcgnueabi/4.1.1/
...
libraries:=/home/ci/views/ci_fosh_pecosa_linux_int/vobs/SYSTEM_BIN/arm1176_gcc_x86_linux_01/bin/../lib/gcc/arm-linux-uclibcgnueabi/4.1.1/
:/home/ci/views/ci_fosh_pecosa_linux_int/vobs/SYSTEM_BIN/arm1176_gcc_x86_linux_01/bin/../lib/gcc/
:/home/wgrobler/platforms/CnxtPecos/M2.1/SRC/host/linux/tools-4.1.1/lib/gcc/arm-linux-uclibcgnueabi/4.1.1/
:/usr/lib/gcc/arm-linux-uclibcgnueabi/4.1.1/
:/home/ci/views/ci_fosh_pecosa_linux_int/vobs/SYSTEM_BIN/arm1176_gcc_x86_linux_01/bin/../lib/gcc/arm-linux-uclibcgnueabi/4.1.1/../../../../arm-linux-uclibcgnueabi/lib/arm-linux-uclibcgnueabi/4.1.1/
:/home/ci/views/ci_fosh_pecosa_linux_int/vobs/SYSTEM_BIN/arm1176_gcc_x86_linux_01/bin/../lib/gcc/arm-linux-uclibcgnueabi/4.1.1/../../../../arm-linux-uclibcgnueabi/lib/
:/home/wgrobler/platforms/CnxtPecos/M2.1/SRC/host/linux/tools-4.1.1/arm-linux-uclibcgnueabi/lib/arm-linux-uclibcgnueabi/4.1.1/
:/home/wgrobler/platforms/CnxtPecos/M2.1/SRC/host/linux/tools-4.1.1/arm-linux-uclibcgnueabi/lib/

When do compile and link, look into a directory one by one in libraries setting above to find
libc.so and libc.a. 

The problem is that try to use fixed specific path to build

/home/ci/views/ci_fosh_pecosa_linux_int/vobs/SYSTEM_BIN/arm1176_gcc_x86_linux_01/bin/../lib/gcc/arm-linux-uclibcgnueabi/4.1.1/../../../../arm-linux-uclibcgnueabi/bin/ld:
cannot find /home/wgrobler/platforms/CnxtPecos/M2.1/SRC/host/linux/tools-4.1.1/lib/libc.so.0
collect2: ld returned 1 exit status

At first, thought that it is a problem of not supporting relocation due to use fixed path. However,
   when have strace log, found libc.so using libraries path and try to find the real library looking
   at the content of libc.so. The libc.so is a text file.

[lib]$ cat libc.so
/* GNU ld script
 * Use the shared library, but some functions are only in
 * the static library, so try that secondarily. */
GROUP ( /home/wgrobler/platforms/CnxtPecos/M2.1/SRC/host/linux/tools-4.1.1/lib/libc.so.0
    /home/wgrobler/platforms/CnxtPecos/M2.1/SRC/host/linux/tools-4.1.1/lib/uclibc_nonshared.a  )

When fixed as below, works fine.

/* GNU ld script
 * Use the shared library, but some functions are only in
 * the static library, so try that secondarily. */
GROUP ( libc.so.0 uclibc_nonshared.a  )


={============================================================================
*kt_dev_gcc_103* gcc: link: link order and cyclic dependencies

{gcc-compliation-process}
Four phase: preprocessing, compilation, assembly and linking. 

<problem> Seen the case that during the porting work, built all files but when starts some funcs
which are part of files which are already built, seeing more errors of missing header files and
undefined symbols. Why?

From online:

Once the object file containing the machine code is produced in the step above, the linking step
makes sure that all the undefined symbols in code are resolved.

Enable warnings using -Wall flag, then you will see warning: Implicit call to function bprint() and
Implicit call to function aprint(). It's is basically compiler recognizes this function during
Linker stage and this does not give any error.

So gcc assumes implicit calls in compilation phase and starts to emit errors when 'actually' use it
which lead to link it. See the below for a correct answer.


{gcc-link-order}

<example>
Used different in link with the same objects. out file has different md5sum depending the link
order:

$ gcc simplemain.o simplefunc.o
$ gcc simplefunc.o simplemain.o

$ md5sum a.out
50b5f88fe5ed8aef16a3decd63a1dce7  a.out
$ md5sum a.out.one 
c33b4d44f06f21e0b378d8d1473b07d8  a.out.one

<reference>
http://eli.thegreenplace.net/2013/07/09/library-order-in-static-linking/

Library order in static linking

July 9th, 2013 at 5:56 am

I'll start with a slightly sneaky but educational example. Suppose we have this code:

volatile char src[] = {1, 2, 3, 4, 5};
volatile char dst[50] = { 0 };

void* memcpy(void* dst, void* src, int len);

int main(int argc, const char* argv[])
{
  memcpy(dst, src, sizeof(src) / sizeof(src[0]));
  return dst[4];
}

It runs just fine and the return value is 5. Now, suppose this is part of a larger project that
consists of many object files and libraries, and somewhere within the project there is a 'library'
that contains this code:

void memcpy(char* aa, char* bb, char* cc) {
  int i;
  for (i = 0; i < 100; ++i) {
    cc[i] = aa[i] + bb[i];
  }
}

If the previous snippet gets linked with this library, what happens? Would you expect it to still
return 5? Return something else? Crash? The answer is: it 'depends' - the result can be either correct
or a segmentation fault. It depends on the 'order' in which the objects and libraries in the project
were fed to the linker.

If you fully understand why this depends on linking order, as well as how to avoid the problem (and
more serious problems, like circular dependencies) then congratulate yourself and move on - this
article is probably not for you. Otherwise, read on.

The basics

Let's start by defining the scope of this article: first, my examples are demonstrating the use of
the gcc and binutils toolchain on Linux. Compatible toolchains (like clang instead of gcc) apply
too. Second, the discussion here resolves around 'static' linking that's done at compile/link time.

To understand why-linking-order-matters, it's first instructional to understand how the linker
works with respect to linking libraries and objects together. Just as a quick reminder - an object
file both provides (exports) external symbols to other objects and libraries, and expects (imports)
symbols from other objects and libraries. For example, in this C code:

int imported(int);

static int internal(int x) {
    return x * 2;
}

int exported(int x) {
    return imported(x) * internal(x);
}

The names of the functions speak for themselves. Let's compile it and look at the symbol table:

$ gcc -c x.c
$ nm x.o
000000000000000e T exported
                 U imported         // note: undefined
0000000000000000 t internal         // note: static. 'lowercase' in nm means local.

This means: exported is an external symbol - defined in the object file and visible from the
outside. imported is an undefined symbol; in other words, the linker is expected to find it
elsewhere. When we talk about linking later, the term undefined can become confusing - so it helps
to remember that this is where it comes from originally. internal is defined within the object but
'invisible' from the outside. 

Now, a library is simply a 'collection' of object files. Just a bunch of object files glued together.
Creating a library is a very trivial operation that doesn't do anything special besides placing many
object files into the same file. This in itself is important, because a horde of object files is not
convenient to deal with. For example, on my system libc.a (the static version of the C library)
consists of almost 1500 object files. It's way nicer to just carry libc.a around.  

The linking process {gcc-link-algorithm}

This section defines the linking process in a somewhat dry, algorithmic manner. This process is the
key to understanding why linking order matters.

Consider a linker invocation:

$ gcc main.o -L/some/lib/dir -lfoo -lbar -lbaz

<caution>
The following do not work:
gcc -lfoo main.c

The linker is almost always invoked through the-compiler-'driver'-gcc when compiling C or C++ code.
This is because the driver knows how to provide the correct command-line arguments to the linker
itself (ld) with all the support libraries, etc. We'll see more of this later.

Anyhow, as you can see the object files and libraries are provided in a certain order on the
command-line, from left to right. This is the-linking-'order'. Here's what the linker does:

<symbol-table>
The linker maintains a symbol table. This symbol table does a bunch of things, but among them is
keeping two lists:

1. A list of symbols 'exported' by all the objects and libraries encountered so far.
2. A list of 'undefined' symbols that the encountered objects and libraries requested to import and
were not found yet.

<for-object-file>
When the linker encounters a new object-file, it looks at:

1.The symbols it exports: these are added to the list of exported symbols mentioned above. If any
symbol is in the undefined list, it's removed from there because it has now been found. If any
symbol has already been in the exported list, we get a "multiple definition" error: two different
objects export the same symbol and the linker is confused.

2. The symbols it imports: these are added to the list of undefined symbols, unless they can be
found in the list of exported symbols.

<for-library>
note: the key is that linker tries to find a symbol only when it's in the 'undefine' list in the
symbol table.

When the linker encounters a new library, things are a bit more interesting. The linker goes over
all the objects in the library. For each one, it 'first' looks at the symbols it exports.

1. If any of the symbols it exports are on the undefined list, the object is 'added' to the link and
the next step is executed. Otherwise, the next step is skipped. note: This means that if it is not
used, this object is not be added to the link. 

2. If the object has been added to the link, it's treated as described above - its undefined and
exported symbols get added to the symbol table. 

3. Finally, if any of the objects in the library has been included in the link, the library is
'rescanned' again - it's possible that symbols imported by the included object can be found in other
objects within the same library.

When the linker finishes, it looks at the symbol table. If any symbols remain in the undefined list
the linker will throw an "undefined reference" error. For example, when you create an executable and
forget to include the file with the main function, you'll get something like:

/usr/lib/x86_64-linux-gnu/crt1.o: In function '_start':
(.text+0x20): undefined reference to 'main'
collect2: ld returned 1 exit status

<rescan>
Note that after the linker has looked at a library, it won't look at it again. Even if it exports
symbols that may be needed by some later library. The only time where a linker goes back to rescan
objects it has already seen, happens within a single library - as mentioned above, once an object
from some library is taken into the link, all other objects in the same library will be rescanned.
Flags passed to the linker can tweak this process - again, we'll see some examples later.

<added-when-really-used>
Also note that when a library is examined, an object file within it can be left out of the link if
it does not provide symbols that the symbol table needs. This is a very important feature of static
linking. The C library I mentioned before makes a heavy use of this feature, by mostly splitting
itself to an-object-per-function. So, for example if the only C standard library function your code
'uses' is strlen, only strlen.o will be taken into the link from libc.a - and your executable will
be very small.

Simple examples note: these examples works on ubuntu as they are shown.

The previous section can be hard to digest, so here are some simple examples that show the process
in action.

Let's start with the most basic case, of linking two objects together:

$ cat simplefunc.c
int func(int i) {
    return i + 21;
}

$ cat simplemain.c
int func(int);

int main(int argc, const char* argv[])
{
    return func(argc);
}

$ gcc -c simplefunc.c
$ gcc -c simplemain.c
$ gcc simplefunc.o simplemain.o
$ ./a.out ; echo $?
22

note: $? means the exit status which is return value in this case.

note: <key> linking order only matters when use a libaray

:~/work$ nm simplefunc.o
00000000 T func

:~/work$ nm simplemain.o 
         U func
00000000 T main

Since these are object files, the linking order does 'not' matter. Object files are always taken into
the link. We can pass them to the linker in reversed order and it still works: 

$ gcc simplemain.o simplefunc.o
$ ./a.out ; echo $?
22

Now let's do something different. Let's put simplefunc.c into a library:

$ ar r libsimplefunc.a simplefunc.o    // ar rs to skip ranlib command.
$ ranlib libsimplefunc.a
$ gcc  simplemain.o -L. -lsimplefunc
$ ./a.out ; echo $?
22

Works like a charm. But note what happens if the linking order is reversed now:

$ gcc  -L. -lsimplefunc  simplemain.o
simplemain.o: In function 'main':
simplemain.c:(.text+0x15): undefined reference to 'func'
collect2: ld returned 1 exit status

Understanding the linking algorithm outlined above makes this case simple to explain. When the
linker encounters libsimplefunc.a, it still hasn't seen simplemain.o, which means that func is not
yet on the undefined list. When the linker looks into the library it sees simplefunc.o that exports
func. But since it doesn't need func, this object file is 'not' included in the link. When the
linker does reach simplemain.o and sees that func is, indeed required, it's added to the undefined
list (because it's not on the exported list). The linker then reaches the end of the link and func
is still undefined.

See how this doesn't happen in the previous linking order - since simplemain.o comes first, func is
on the undefined list before the linker sees the library, so the object file exporting it does get
included.

This brings us to the most important corollary of the linking process outlined above:

If object or library AA needs a symbol from library BB, then AA should come before library BB in the
command-line invocation of the linker. [KT] slightly not correct.


Circular dependency {cyclic-dependencies}

The corollary above is an important summary of the linking process - it's certainly much more
practical to keep in mind because it's so short. But it makes one wonder - what happens if AA needs
a symbol from BB, but BB also needs a symbol from AA? While officially this isn't a good programming
practice, in reality it happens quite a lot. But AA can't come both before and after BB on the
command-line, right? That's just silly. Wait, is it, really?

Let's see an example and start simple. Imagine that instead of simplefunc.c, the func symbol is
provided thus:

$ cat func_dep.c
int bar(int);

int func(int i) {
    return bar(i + 1);
}

$ cat bar_dep.c
int func(int);

int bar(int i) {
    if (i > 3)
        return i;
    else
        return func(i);
}

These two files depend on each other and get placed into different libraries. If we link them in one
order, we fail:

$ gcc  simplemain.o -L.  -lbar_dep -lfunc_dep
./libfunc_dep.a(func_dep.o): In function 'func':
func_dep.c:(.text+0x14): undefined reference to 'bar'
collect2: ld returned 1 exit status

However, the other order does work:

$ gcc  simplemain.o -L. -lfunc_dep -lbar_dep
$ ./a.out ; echo $?
4

Quiz: can you figure out why? Hint: just go over the linking process algorithm with this
command-line. What undefined symbols does the symbol table contain when the linker first sees
-lfunc_dep?

<analysis-on-okay-case>
simplemain:
         U func

symbol table: undefined: func          // needs func

func_dep.a:
         U bar  (import)
00000000 T func (export)               // found func and needs bar 

bar_dep.a:
00000000 T bar  (export)               // found bar
         U func (import)

<analysis-on-not-okay-case>
simplemain:
         U func

symbol table: undefined: func                      // needs func

bar_dep.a:
00000000 T bar  (export)
         U func (import)                           // still needs func

func_dep.a:
         U bar
00000000 T func (undefined reference to 'bar')     // found func and needs bar but link ends.

The symbol table has func but not bar. Hence, error.

But this is a very simple case. Let's look at a trickier one. We'll add a dependency to bar on
another function from libfunc_dep.a, but one that lives in a different object:

$ cat bar_dep.c
int func(int);
int frodo(int);

int bar(int i) {
    if (i > 3)
        return frodo(i);
    else
        return func(i);
}

$ cat frodo_dep.c
int frodo(int i) {
    return 6 * i;
}

We'll recompile all these files into separate objects, and the libfunc_dep.a library will now be:

$ ar r libfunc_dep.a func_dep.o frodo_dep.o
$ ranlib libfunc_dep.a

Here's a drawing of the libraries, with arrows showing the dependencies:

simplemain:
			U func

 libfunc_dep.a        libbar_dep.a
  - func_dep.o  ->  <- - bar_dep.o (need func and frodo)
  - frodo_dep.o     <-

Now linking fails no matter what order we list the libraries in:

U func; func and bar; bar and frodo

$ gcc  -L. simplemain.o -lfunc_dep -lbar_dep
./libbar_dep.a(bar_dep.o): In function 'bar':
bar_dep.c:(.text+0x17): undefined reference to 'frodo'
collect2: ld returned 1 exit status

U func; nothing for bar_dep; func and bar

$ gcc  -L. simplemain.o -lbar_dep -lfunc_dep
./libfunc_dep.a(func_dep.o): In function 'func':
func_dep.c:(.text+0x14): undefined reference to 'bar'
collect2: ld returned 1 exit status

To solve this, consider that it's perfectly valid to list a library more than once on the link; so
in fact, we can provide libfunc_dep.a both before and after libbar_dep.a:

$ gcc  -L. simplemain.o -lfunc_dep -lbar_dep -lfunc_dep
$ ./a.out ; echo $?
24

Another quiz: will the same trick work providing -lbar_dep twice? Why not?

$ gcc  -L. simplemain.o -lbar_dep -lfunc_dep -lbar_dep

U func; nothing for bar_dep; func and bar(U); bar

./libbar.a(bar_dep.o): In function `bar':
bar_dep.c:(.text+0x13): undefined reference to `frodo'
collect2: ld returned 1 exit status

Becase frodo is in the libaray but was not added to the link because of object-per-function-linking.

Using linker flags to control the process

As I've mentioned above, the linker has a number of interesting flags that can be used to control
the process in a fine-grained manner. For example, circular dependency problems can be easily
resolved with --start-group and --end-group. Here's an instructive portion from man ld:

-start-group archives -end-group

The specified archives are searched repeatedly until no new undefined references are created.
Normally, an archive is searched only once in the order that it is specified on the command line. If
a symbol in that archive is needed to resolve an undefined symbol referred to by an object in an
archive that appears later on the command line, the linker would not be able to resolve that
reference. By grouping the archives, they all be searched repeatedly until all possible references
are resolved.

Using this option has a significant performance cost. It is best to use it only when there are
unavoidable circular references between two or more archives.

Here's how this helps in our case:

$ gcc simplemain.o -L. -Wl,--start-group -lbar_dep -lfunc_dep -Wl,--end-group
$ ./a.out ; echo $?
24

It's interesting to note the "significant performance cost" warning in the excerpt above. This
explains why the linking process is the way it is. Presumably, linkers could just re-scan the whole
library list until no new symbols got resolved. This would eliminate most circular-dependency and
linking order problems in the world, but it would also be slow. Linking is already a critical part
of the compilation time of large systems, since it looks at the whole program and requires quite a
bit of memory. It's better to make it as fast as possible for well-behaved programs (that got their
linking order right), and provide special options like groups for the difficult circular dependency
cases. [KT] This is only about cost in linking?

There's at least one another linker flag that can help us resolve the circular dependency here. We
can use the --undefined flag to tell the linker - "buddy, here's a symbol I want you to add to the
undefined list". In our case this makes the link error go away even though the libraries are
specified only once:

$ gcc simplemain.o -L. -Wl,--undefined=bar -lbar_dep -lfunc_dep
$ ./a.out ; echo $?
24

Figuring out why this works is left as an exercise to the reader.

____________________________
Back to the original example

Let's go back to the example this article started with. main assumes it gets the correct memcpy from
the C library, but the memcpy it gets linked with does something else. Assuming the memcpy here was
packed into the libstray_memcpy.a library:

$ gcc  -L. main_using_memcpy.o -lstray_memcpy
$ ./a.out
Segmentation fault (core dumped)

This is the expected behavior. Since -lstray_memcpy was provided after main_using_memcpy.o on the
command-line, it gets linked in. But what happens if the order is reversed:

$ gcc  -L. -lstray_memcpy main_using_memcpy.o
$ ./a.out ; echo $?
5

The program links and works correctly. The reason for this is simple: even without us explicitly
asking for it, gcc asks the linker to link the C library as well. The full linker invocation command
of gcc is pretty complex, and can be examined by passing the -### flag to gcc. But in our case this
amounts to:

$ gcc  -L. -lstray_memcpy main_using_memcpy.o -lc

When the linker sees -lstray_memcpy, the symbol table does not yet have an undefined entry for
memcpy, so the object file with the wrong function does not get linked. The linker adds this
undefined entry only after it sees main_using_memcpy.o. Then, when it reaches -lc, the object file
holding memcpy from the C library does get linked in because by now memcpy is on the undefined list.

Conclusion

The algorithm used by the linker to resolve symbols between objects and libraries is pretty simple.
As long as you keep it in mind, linker errors and related problems should be easy to understand. If
you still run into problematic situations you're not sure how to resolve, this article mentioned two
tools that can be very useful in debugging such problems: one is nm, which shows the symbol table of
an object or a whole library. The other is the -### flag that gcc accepts and as a result shows the
full commands it passes to the underlying tools.

note: KT. When use this option, it appears that linker cannot detect duplicated symbols and use one
of symbols. There are duplicated in the same lib archive but picked up wrong one. 


={============================================================================
*kt_dev_gcc_105* gcc likely and unlikely 

{likey-and-unlikely}
This is built-in function: long __builtin_expect (long exp, long c)

You may use __builtin_expect to provide the compiler with branch prediction information. In general,
you should prefer to use actual profile feedback for this (-fprofile-arcs), as programmers are
notoriously bad at predicting how their programs actually perform. However, there are applications
in which this data is hard to collect.


{reading-two}
http://blog.man7.org/2012/10/how-much-do-builtinexpect-likely-and.html
As the gcc documentation says, you can use this compiler built-in function to give the optimizer a
clue about the likely result of an integer (or Boolean) expression. In the context of an if
statement, this enables the optimizer to reorder the code in a way that gives best performance, by
ensuring that the code that is most likely to execute after the conditional immediately follows the
conditional when the instruction stream is fed to the CPU pipeline.

The __builtin_expect() function takes two arguments: a value to be tested, and the expected result.
Both of these are integral values. The interface is a little clumsy for most uses, since the common
case is that we want to test for "true" (non-zero) or "false" (zero). Thus, the Linux kernel defines
two simpler interfaces: likely() and unlikely() (in include/linux/compiler.h):

    #define likely(x)      __builtin_expect(!!(x), 1)
    #define unlikely(x)    __builtin_expect(!!(x), 0)

In other words, likely(x) means "I expect x is true", and and unlikely(x) means "I expect x is
false".

Here's my test program. The comments should be enough to help you understand some of the more
obscure pieces. Below, I'll just skip to looking at the test results.

The program essentially repeatedly scans a one-million-element integer array whose contents are zero
(in the default case). Using the program, we can time the results of the checks that are performed
either with or without using __builtin_expect().

For example, here we scan the array without  __builtin_expect():

    $ cc -DDONT_EXPECT -O3 builtin_expect_test.c -o bn
    $ time -f "%E real, %U user, %S sys" ./bn 1000
    0, 1000000000
    0:02.68 real,  2.67 user, 0.00 sys

In this case, the program looped one thousand times through the array, to perform a total of one
billion checks, and the real time for execution was 2.68 seconds. (The test machine is an Intel Core
Duo 2.53GHz, and the gcc version is 4.6.3.)

Here's what happens if we employ  __builtin_expect(), telling the compiler that the expected result
of the test is 0.

    [KT] expects 0 and best case
    $ cc -DEXPECT_RESULT=0 -O3 builtin_expect_test.c -o b0
    $ time -f "%E real, %U user, %S sys" ./b0 1000
    0, 1000000000
    0:02.28 real,  2.28 user, 0.00 sys

The execution time fell to 2.28 seconds. In other words (for this particular CPU, compiler version,
and program), __builtin_expect() improved the execution time of each check by 0.4 nanoseconds (0.4
seconds for one billion checks).

Well and good. What if we tell __builtin_expect() to expect the wrong value?

    [KT] expects 1 when all elements are 0 so worst case
    $ cc -DEXPECT_RESULT=1 -O3 builtin_expect_test.c -o b1
    $ time -f "%E real, %U user, %S sys" ./b1 1000
    0, 1000000000
    0:04.19 real,  4.18 user, 0.00 sys

In this case, unsurprisingly, we made each check run slower, by about 1.5 (i.e., 4.19 - 2.68)
nanoseconds. So, should you use __builtin_expect()?  

You should only use __builtin_expect()-or the Linux kernel's likely() and unlikely()-if it's "very
likely" that your code will follow the predicted branch. How much is "very likely"? If you're
looking for actual numbers, the answer will depend on your compiler version, CPU, and code. But to
illustrate that you should generally [avoid] these optimizations unless your code is very likely to
follow one branch, here's some further tests using the above code.

In this test, the program first injects some nonzero values into the array before doing tests for
zero using __builtin_expect(). Nonzero values are placed at every tenth element in the array:

    $ cc -DEXPECT_RESULT=0 -DBREAK_STEP=10 -O3 builtin_expect_test.c -o b0
    $ time -f "%E real, %U user, %S sys" ./b0 1000
    100000000, 900000000
    0:02.79 real,  2.76 user, 0.01 sys

Note what happened. Even though most array elements contained the expected zero value, execution
speed was actually worse (2.79 seconds versus 2.69 seconds) than not using __builtin_expect() at
all! In fact, even when only one in ten thousand values is nonzero, we're still at only roughly the
break-even point:

    $ cc -DEXPECT_RESULT=0 -DBREAK_STEP=10000 -O3 builtin_expect_test.c -o b0
    $ time -f "%E real, %U user, %S sys" ./b0 1000
    100000, 999900000
    0:02.66 real,  2.64 user, 0.00 sys

The point where using these optimizations becomes worthwhile will depend on the factors mention
above, but the point is that you should really only use them when your predicted path is very
likely, and if your predicted path is not very likely, then you're better off avoiding them, as
you'll actually slow your code down a little. Compiler-assisted run-time profiling The gcc
documentation contains the following advice regarding the use of __builtin_expect():

    In general, you should prefer to use actual profile feedback for this (-fprofile-arcs), as
    programmers are notoriously bad at predicting how their programs actually perform. However,
    there are applications in which this data is hard to collect. 

That's good concise advice. To put things another way, the only time you should use
__builtin_expect() is when you can't use compiler-assisted runtime optimization (perhaps because
your program has no easily repeatable pattern of execution-the Linux kernel is an obvious example)
and you are certain that your predicted code path is very (very) likely to be the one that will be
taken.


{reading-one}
This is about branch-prediction and optimisation in a compiler. 

[kedar@ashwamedha ~]$ cat abc.c
int testfun(int x)
{
  // we instruct the compiler, "else" block is more probable by saying that x is more likely to be
  // false(0)
  if(__builtin_expect(x, 0)) 
  {
    x = 5;
    x = x * x;
  }
  else
  {
    x = 6;
  }

  return x;
}
 
[kedar@ashwamedha ~]$ gcc -O2 -c abc.c
[kedar@ashwamedha ~]$ objdump  -d abc.o
 
abc.o:     file format elf32-i386
 
Disassembly of section .text:
 
00000000 :
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   8b 45 08                mov    0x8(%ebp),%eax
   6:   85 c0                   test   %eax,%eax
   8:   75 07                   jne    11 < testfun+0x11 >
   The compiler branches the "if" block and keeps "else" sequential
   a:   b8 06 00 00 00          mov    $0x6,%eax
   f:   c9                      leave
  10:   c3                      ret
  11:   b8 19 00 00 00          mov    $0x19,%eax
  16:   eb f7                   jmp    f < testfun+0xf > 

[kedar@ashwamedha ~]$ cat abc.c
int testfun(int x)
{
  // we instruct the compiler, "if" block is more probable by saying that x is more likely to be
  // true(1), non-zero.
  if(__builtin_expect(x, 1))
  {
    x = 5;
    x = x * x;
  }
  else
  {
    x = 6;
  }

  return x;
}
                                                                                                   
[kedar@ashwamedha ~]$ gcc -O2 -c abc.c
[kedar@ashwamedha ~]$ objdump  -d abc.o
                                                                                                   
abc.o:     file format elf32-i386
                                                                                                   
Disassembly of section .text:
                                                                                                   
00000000 :
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   8b 45 08                mov    0x8(%ebp),%eax
   6:   85 c0                   test   %eax,%eax
   8:   74 07                   je     11 < testfun+0x11 >
   The compiler branches the "else" block and keeps "if" sequential
   a:   b8 19 00 00 00          mov    $0x19,%eax
   f:   c9                      leave
  10:   c3                      ret
  11:   b8 06 00 00 00          mov    $0x6,%eax
  16:   eb f7                   jmp    f < testfun+0xf >
<

 [KT] As shown, the probable cases are placed in sequential and menas in the pipe line. So most of
 case there is no jump.


{example-from-glibc}
#if __GNUC__ >= 3
# define __glibc_unlikely(cond)	__builtin_expect ((cond), 0)
# define __glibc_likely(cond)	__builtin_expect ((cond), 1)
#else
# define __glibc_unlikely(cond)	(cond)
# define __glibc_likely(cond)	(cond)
#endif

if (__glibc_unlikely (*s == L_('\0')))
   goto noconv;


G_LIKELY()

#define G_LIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR(expr), 1))

if (G_LIKELY (random () != 1))
  g_print ("not one");

#define G_UNLIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR(expr), 0))

if (G_UNLIKELY (random () == 1))
  g_print ("a random one");


if (G_UNLIKELY (!stream->caps)) {
    // when "stream->caps" is null, handle error case
}

So, do read code as if there is no likely/unlikely thing.


={============================================================================
*kt_dev_gcc_106* gcc: link: lrt

-lrt 

Means that librt.a to use clock_gettime.


={============================================================================
*kt_dev_gcc_107* gcc: link: sysroot and rpath-link

When not use sysroot with NXP toolchain, cause the problem:

-Wl,-rpath-link=/home/NDS-UK/parkkt/platforms/apollo/gnu_cortex-a9_tools/usr/lib
-Xlinker --end-group -o
/home/NDS-UK/parkkt/TestBuild/APOLLO_01/LittleEndian/components/FOSH/FOSH_App/debug/FOSH_App
/backup/NDS-UK/parkkt/platforms/apollo/gnu_cortex-a9_tools/usr/bin/../lib/gcc/arm-linux-uclibcgnueabi/4.4.0/../../../../arm-linux-uclibcgnueabi/bin/ld:
crt1.o: No such file: No such file or directory


-rpath-link=dir
When using ELF or SunOS, one shared library may require another. This happens when an ld -shared
link includes a shared library as one of the input files.

When the linker encounters such a dependency when doing a non-shared, non-relocatable link, it will
automatically try to locate the required shared library and include it in the link, if it is not
included explicitly. In such a case, the -rpath-link option specifies the first set of directories
to search. The -rpath-link option may specify a sequence of directory names either by specifying a
list of names separated by colons, or by appearing multiple times.

This option should be used with caution as it overrides the search path that may have been hard
compiled into a shared library. In such a case it is possible to use unintentionally a different
search path than the runtime linker would do.

The linker uses the following search paths to locate required shared libraries:

1. Any directories specified by -rpath-link options.

2. Any directories specified by -rpath options. The difference between -rpath and -rpath-link is
that directories specified by -rpath options are included in the executable and used at runtime,
whereas the -rpath-link option is only effective at link time. Searching -rpath in this way is only
  supported by native linkers and cross linkers which have been configured with the --with-sysroot
  option.

3. On an ELF system, for native linkers, if the -rpath and -rpath-link options were not used, search
the contents of the environment variable LD_RUN_PATH.

4. On SunOS, if the -rpath option was not used, search any directories specified using -L options.

5. For a native linker, the search the contents of the environment variable LD_LIBRARY_PATH.

6. For a native ELF linker, the directories in DT_RUNPATH or DT_RPATH of a shared library are
searched for shared libraries needed by it. The DT_RPATH entries are ignored if DT_RUNPATH entries
exist.

7. The default directories, normally /lib and /usr/lib.

8. For a native linker on an ELF system, if the file /etc/ld.so.conf exists, the list of directories
found in that file. 

If the required shared library is not found, the linker will issue a warning and continue with the
link.


={============================================================================
*kt_dev_gcc_110* gcc-attributes

https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Function-Attributes.html

5.24 Declaring Attributes of Functions

In GNU C, you declare certain things about functions which help the compiler
optimize function calls and check your code more carefully.

The keyword __attribute__ allows you to specify special attributes when making a
declaration. This keyword is followed by an attribute specification inside
'double' parentheses. The following attributes are currently defined for
functions on all targets: noreturn, returns_twice, noinline, always_inline,
flatten, pure, const, nothrow, sentinel, format, format_arg,
no_instrument_function, section, constructor, destructor, used, unused,
deprecated, weak, malloc, alias, warn_unused_result, nonnull and
  externally_visible. 
  
Several other attributes are defined for functions on particular target systems.

unused
    This attribute, attached to a function, means that the function is meant to
    be possibly unused. GCC will not produce a warning for this function.

note: can be used on object?

#define ZINC_UNUSED __attribute__((unused))

try
{
  ...
}
catch(ZINC_UNUSED const NS_RUBIDIUM_SYSTEM::NetworkProblemException& e)
{
  ...
}

used
    This attribute, attached to a function, means that code must be emitted for
    the function even if it appears that the function is 'not' referenced. This
    is useful, for example, when the function is referenced only in inline
    assembly.


<visibility>
visibility ("visibility_type")

The visibility attribute on ELF targets causes the declaration to be emitted
with default, hidden, protected or internal visibility.

void __attribute__ ((visibility ("protected")))
f () { /* Do something. */; }

int i __attribute__ ((visibility ("hidden")));
         

See the ELF gABI for complete details, but the short story is:

default
    Default visibility is the normal case for ELF. This value is available for
    the visibility attribute to override other options that may change the
    assumed visibility of symbols.

#define ZINC_EXPORT __attribute__((visibility("default")))


hidden
Hidden visibility indicates that the 'symbol' will not be placed into the
dynamic symbol table, so no other module (executable or shared library) can
reference it 'directly'. 

note: Then 'indirectly'?


internal 
Internal visibility is like hidden visibility, but with additional processor
specific semantics.  Unless otherwise specified by the psABI, GCC defines
internal visibility to mean that the function is never called from another
module. Note that hidden symbols, while they cannot be referenced directly by
other modules, can be referenced indirectly via function pointers. By indicating
that a symbol cannot be called from outside the module, GCC may for instance
omit the load of a PIC register since it is known that the calling function
loaded the correct value.  

protected 
Protected visibility indicates that the symbol will be placed in the dynamic
symbol table, but that references within the defining module will bind to the
local symbol. That is, the symbol cannot be overridden by another module. 

Not all ELF targets support this attribute. 


3.18 Options for Code Generation Conventions

-fvisibility=default | internal | hidden | protected
    Set the default ELF image symbol visibility to the specified option-all
    symbols will be marked with this unless overridden within the code. Using
    this feature can very substantially improve linking and load times of shared
    object libraries, produce more optimized code, provide near-perfect API
    export and prevent symbol clashes. It is strongly recommended that you use
    this in any shared objects you distribute.

    Despite the nomenclature, default always means public ie; available to be
    linked against from outside the shared object. protected and internal are
    pretty useless in real-world usage so the only other commonly used option
    will be hidden. The "default" if -fvisibility isn't specified is default,
    i.e., make every symbol public-this causes the same behavior as previous
    versions of GCC.

    A good explanation of the benefits offered by ensuring ELF symbols have the
    correct visibility is given by "How To Write Shared Libraries" by Ulrich
    Drepper (which can be found at http://people.redhat.com/~drepper/) - however
    a superior solution made possible by this option to marking things hidden
    when the default is public is to make the default hidden and mark things
    public.  This is the norm with DLL's on Windows and with -fvisibility=hidden
    and __attribute__ ((visibility("default"))) instead of __declspec(dllexport)
    you get almost identical semantics with identical syntax. This is a great
    boon to those working with cross-platform projects.

    For those adding visibility support to existing code, you may find `#pragma
    GCC visibility' of use. This works by you enclosing the declarations you
    wish to set visibility for with (for example) `#pragma GCC visibility
    push(hidden)' and `#pragma GCC visibility pop'. Bear in mind that symbol
    visibility should be viewed as part of the API interface contract and thus
    all new code should always specify visibility when it is not the default ie;
    declarations only for use within the local DSO should always be marked
    explicitly as hidden as so to avoid PLT indirection overheads—making this
    abundantly clear also aids readability and self-documentation of the code.
    Note that due to ISO C++ specification requirements, operator new and
    operator delete must always be of default visibility.

    An overview of these techniques, their benefits and how to use them is at
    http://gcc.gnu.org/wiki/Visibility. 


={============================================================================
*kt_dev_gcc_111* gcc: profiling

{how-to-use-gcc-optimisation} {gcc-profiling}
The example program above does have a very predictable, repeatable flow of execution. Let's see what
happens when we use compiler-assisted optimization. Building the programming now involves two steps:
a profiling phase and an optimized compile. In the profiling phase, we build and run an instrumented
version of the executable. We build as follows:

    $ cc -O3 -DDONT_EXPECT -fprofile-generate builtin_expect_test.c -o bn.prof

(The -fprofile-generate option implies -fprofile-arcs, as well as one or two other profiling
options.)

We then run the executable, which generates profiling information that is stored in a file (with the
extension .gcda).

    $ time -f "%E real, %U user, %S sys" ./bn.prof 1000
    0, 1000000000
    0:05.39 real,  5.37 user, 0.00 sys

Note that, because of the instrumentation code, the profiled version runs rather slower that the
normally compiled code.  Running this code created a file containing the profiling results:

    $ ls *.gcda
    builtin_expect_test.gcda

We then employ the -fprofile-use compiler option,which (implicitly) uses the profiling results to
create an optimized executable.

    $ cc -O3 -DDONT_EXPECT -fprofile-use builtin_expect_test.c -o bn.opt

And then we run the optimized program:

    $ time -f "%E real, %U user, %S sys" ./bn.opt 1000
    0, 1000000000
    0:01.95 real,  1.94 user, 0.00 sys

This optimized version runs significantly faster (1.95 versus 2.28 seconds) than our version that
used __builtin_expect(). This is because, in addition to the branching in the if statement, the
branching in the for loops was also optimized.

It's left as an exercise for the reader to show that employing __builtin_expect() (to expect 0) in
conjunction with compiler-assisted optimization doesn't improve things: the compiler already
optimizes the if branching as well as the programmer-directed optimization. One other interesting
exercise  is, of course, to compare the assembler (cc -S) code generated for each of the above
cases. 


={============================================================================
*kt_dev_gcc_113* gcc: options: warnings

https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html

-Wextra
This enables some extra warning flags that are not enabled by -Wall. (This option used to be called
    -W. The older name is still supported, but the newer name is more descriptive.)

              -Wclobbered  
              -Wempty-body  
              -Wignored-qualifiers 
              -Wmissing-field-initializers  
              -Wmissing-parameter-type (C only)  
              -Wold-style-declaration (C only)  
              -Woverride-init  
              -Wsign-compare  
              -Wtype-limits  
              -Wuninitialized  
              -Wunused-parameter (only with -Wunused or -Wall) 
              -Wunused-but-set-parameter (only with -Wunused or -Wall)  
              

The option -Wextra also prints warning messages for the following cases:

        A pointer is compared against integer zero with <, <=, >, or >=.
        (C++ only) An enumerator and a non-enumerator both appear in a conditional expression.
        (C++ only) Ambiguous virtual bases.
        (C++ only) Subscripting an array that has been declared register.
        (C++ only) Taking the address of a variable that has been declared register.
        (C++ only) A base class is not initialized in a derived class's copy constructor. 

<ex>

void x(int val, double dval)
{
    printf("...");
}

$ gcc -Wall -Wextra sample.c 
sample.c: In function 'x':
sample.c:16:12: warning: unused parameter 'val' [-Wunused-parameter]
sample.c:16:24: warning: unused parameter 'dval' [-Wunused-parameter]

#define BSTD_UNUSED(x)  { volatile void *bstd_unused; bstd_unused = (void *)&(x); }

void x(int val, double dval)
{
  BSTD_UNUSED(val);
  BSTD_UNUSED(dval);
  printf("...");
}

$ gcc -Wall -Wextra sample.c 
sample.c: In function 'x':
sample.c:20:3: warning: variable 'bstd_unused' set but not used [-Wunused-but-set-variable]
sample.c:21:3: warning: variable 'bstd_unused' set but not used [-Wunused-but-set-variable]

Emits these warinigs only when used both options and no warning when use only
-Wextra.

Q: what is this macro for? Since shows warning even when used? Only works for
embedded since taken from code on embedded system?


={============================================================================
*kt_dev_gcc_200* gcc-cpp

http://gcc.gnu.org/onlinedocs/cpp/

/usr/bin/cpp

The C preprocessor, often known as cpp, is a "macro processor" that is used
automatically by the C compiler to transform your program before compilation. It
is called a macro processor because it allows you to define 'macros', which are
brief abbreviations for longer constructs. 


={============================================================================
*kt_dev_gcc_201* gcc-cpp-header-guard

2.4 Once-Only Headers

If a header file happens to be included twice, the compiler will process its
contents twice. This is very likely to cause an error, e.g. when the compiler
sees the same structure definition twice. Even if it does not, it will certainly
waste time.

The standard way to prevent this is to enclose the entire real contents of the
file in a conditional, like this:

     /* File foo.  */
     #ifndef FILE_FOO_SEEN
     #define FILE_FOO_SEEN
     
     the entire file
     
     #endif /* !FILE_FOO_SEEN */

This construct is commonly known as a "wrapper #ifndef". When the header is
included again, the conditional will be false, because FILE_FOO_SEEN is defined.
The preprocessor will skip over the entire contents of the file, and the
compiler will not see it twice.

You can put comments outside the wrapper. They will not interfere with this
optimization.

The macro FILE_FOO_SEEN is called the controlling macro or "guard macro". In a
user header file, the macro name should 'not' begin with '_'. In a system header
file, it 'should' begin with '__' to avoid conflicts with user programs. In any
kind of header file, the macro name should contain the name of the file and some
additional text, to avoid conflicts with other header files.  


={============================================================================
*kt_dev_gcc_201* gcc-cpp-defined

3.7.1 Standard Predefined Macros

__cplusplus

This macro is defined when the C++ compiler is in use. You can use __cplusplus
to test whether a header is compiled by a C compiler or a C++ compiler. This
macro is similar to __STDC_VERSION__, in that it expands to a version number.
Depending on the language standard selected, the value of the macro is 

199711L for the 1998 C++ standard,
`201103L for the 2011 C++ standard`, 
201402L for the 2014 C++ standard, 
201703L for the 2017 C++ standard, 

or an unspecified value strictly larger than 201703L for the experimental
  languages enabled by -std=c++2a and -std=gnu++2a.

The 199711L stands for Year=1997, Month = 11 (i.e., November of 1997) -- the
date when the committee approved the standard that the rest of the ISO
approved in early 1998.

For the 2003 standard, there were few enough changes that the committee
(apparently) decided to leave that value unchanged.

For the 2011 standard, it's required to be defined as 201103L, (again,
    year=2011, month = 03) again meaning that the committee approved the
standard as finalized in March of 2011.

For the 2014 standard, it's required to be defined as 201402L, interpreted the
same way as above (February 2014).

For the 2017 standard, it's required to be defined as 201703L (March 2017).

Before the original standard was approved, quite a few compilers normally
defined it to 0 (or just an empty definition like #define __cplusplus) to
signify "not-conforming". When asked for their strictest conformance, many
defined it to 1.

I almost forgot to mention, but one more tidbit about ancient compilers: a few
of the earliest versions of cfront (and probably a few others copying it)
defined c_plusplus instead of __cplusplus. I don't recall it's being defined
to any meaningful value though.


-D name 
Predefine name as a macro, with definition 1. 

-D name=definition
The contents of definition are tokenized and processed as if they appeared
during translation phase three in a '#define' directive. In particular, the
definition will be truncated by embedded newline characters.

If you are invoking the preprocessor from a shell or shell-like program you may
need to use the shell's quoting syntax to protect characters such as spaces that
have a meaning in the shell syntax.

If you wish to define a function-like macro on the command line, write its
argument list with surrounding parentheses before the equals sign (if any).
Parentheses are meaningful to most shells, so you will need to quote the option.
With sh and csh, -D'name(args...)=definition' works.

-D and -U options are processed in the order they are given on the command line.
All -imacros file and -include file options are processed after all -D and -U
options. 

4.2.3 Defined

The special operator defined is used in '#if' and '#elif' expressions to test
whether a certain name is defined as a macro. "defined name" and "defined
(name)" are both expressions whose value is `1` if name is defined as a macro at
the current point in the program, and 0 otherwise. Thus, #if defined MACRO is
precisely equivalent to #ifdef MACRO.

`defined` is useful when you wish to test more than one macro for existence at
once. For example,

     #if defined (__vax__) || defined (__ns16000__)

would succeed if either of the names __vax__ or __ns16000__ is defined as a
macro.

Conditionals written like this:

     #if defined BUFSIZE && BUFSIZE >= 1024

can generally be simplified to just #if BUFSIZE >= 1024, since if BUFSIZE is not
defined, it will be interpreted as having the value zero.

If the defined operator appears as a result of a macro expansion, the C standard
says the behavior is undefined. GNU cpp treats it as a genuine defined operator
and evaluates it normally. It will warn wherever your code uses this feature if
you use the command-line option -pedantic, since other compilers may handle it
differently. 

<ex>
Q: What's the difference between "define _LIMITS_H" and "define _LIMITS_H 1"?

#define SAMPLE
#define SAMPLE 1
#define SAMPLE 2

// This works for all three cases
#ifdef SAMPLE
  printf("sample is def\n");
#endif

// Only emit error for case 1: 
// : error: operator '==' has no left operand
#if SAMPLE == 1
  printf("sample is =1\n");
#endif

// Only emit error for case 1: 
// : error: operator '>' has no left operand
#if SAMPLE > 1
  printf("sample is >1 \n");
#endif

After all, "define MACRO x" is to use macro value and no real needs as a guard
macro.


={============================================================================
*kt_dev_gcc_202* gcc-cpp-get-filename-without-full-path

http://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html#Standard-Predefined-Macros

The standard predefined macros are specified by the relevant language standards, so they are
available with all compilers that implement those standards. Older compilers may not provide all of
them. Their names all start with double underscores.

__cplusplus

This macro is defined when the C++ compiler is in use. You can use __cplusplus to test whether a
header is compiled by a C compiler or a C++ compiler. This macro is similar to __STDC_VERSION__, in
that it expands to a version number. Depending on the language standard selected, the value of the
macro is 199711L, as mandated by the 1998 C++ standard; 201103L, per the 2011 C++ standard; an
unspecified value strictly larger than 201103L for the experimental languages enabled by -std=c++1y
and -std=gnu++1y. 

__FILE__

This macro expands to the name of the current input file, in the form of a C string constant. This
is the path by which the preprocessor opened the file, not the short name specified in '#include' or
as the input file name argument. For example, "/usr/local/include/myheader.h" is a possible
expansion of this macro. [KT] For c files, this is a path from where run gcc to build.

<how-to-get-filename-without-full-path>

char *strrchr(const char *s, int c);
The strrchr() function returns a pointer to the last occurrence of the character c in the string s.

#include <string.h>
#define FILE (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)

int main()
{
   printf("file is %s\n", __FILE__);
   printf("file is %s:%d:%s\n", FILE, __LINE__, __PRETTY_FUNCTION__ );
}

__LINE__

This macro expands to the current input line number, in the form of a decimal integer constant.
While we call it a predefined macro, it's a pretty strange macro, since its "definition" changes
with each new line of source code. 

__FILE__ and __LINE__ are useful in generating an error message to report an inconsistency detected
by the program; the message can state the source line at which the inconsistency was detected. For
example,

     fprintf (stderr, "Internal error: "
                      "negative string length "
                      "%d at %s, line %d.",
              length, __FILE__, __LINE__);

An '#include' directive changes the expansions of __FILE__ and __LINE__ to correspond to the
included file. At the end of that file, when processing resumes on the input file that contained the
'#include' directive, the expansions of __FILE__ and __LINE__ revert to the values they had before
the '#include' (but __LINE__ is then incremented by one as processing moves to the line after the
'#include').

A '#line' directive changes __LINE__, and may change __FILE__ as well. See Line Control.

__func__ and __FUNCTION__ 

C99 introduces __func__, and GCC has provided __FUNCTION__ for a long time. Both
of these are strings containing the name of the current function (there are
    slight semantic differences; see the GCC manual). 'neither' of them is a
macro; the preprocessor does not know the name of the current function. They
tend to be useful in conjunction with __FILE__ and __LINE__, though. 

__PRETTY_FUNCTION__

http://gcc.gnu.org/onlinedocs/gcc/Function-Names.html

GCC provides three magic variables that hold the name of the current function,
    as a string. The first of these is __func__, which is part of the C99
    standard:

The identifier __func__ is implicitly declared by the translator as if,
    immediately following the opening brace of each function definition, the
    declaration

     static const char __func__[] = "function-name";

appeared, where function-name is the name of the lexically-enclosing function.
This name is the unadorned name of the function.

__FUNCTION__ is another name for __func__. Older versions of GCC recognize only
this name. However, it is 'not' standardized. For maximum portability, we
recommend you use __func__, but provide a fallback definition with the
preprocessor:

     #if __STDC_VERSION__ < 199901L
     # if __GNUC__ >= 2
     #  define __func__ __FUNCTION__
     # else
     #  define __func__ "<unknown>"
     # endif
     #endif

In C, __PRETTY_FUNCTION__ is yet another name for __func__. 

>
However, in C++, __PRETTY_FUNCTION__ contains the type signature of the function
as well as its bare name. For example, this program:

     extern "C" {
     extern int printf (char *, ...);
     }
     
     class a {
      public:
       void sub (int i)
         {
           printf ("__FUNCTION__ = %s\n", __FUNCTION__);
           printf ("__PRETTY_FUNCTION__ = %s\n", __PRETTY_FUNCTION__);
         }
     };
     
     int
     main (void)
     {
       a ax;
       ax.sub (0);
       return 0;
     }

gives this output:

     __FUNCTION__ = sub
     __PRETTY_FUNCTION__ = void a::sub(int)  // [KT] seems useful

These identifiers are not preprocessor macros. In GCC 3.3 and earlier, in C
only, __FUNCTION__ and __PRETTY_FUNCTION__ were treated as string literals; they
could be used to initialize char arrays, and they could be concatenated with
other string literals. GCC 3.4 and later treat them as variables, like __func__.
In C++, __FUNCTION__ and __PRETTY_FUNCTION__ have always been variables. 


={============================================================================
*kt_dev_gcc_203* gcc-cpp-isystem option

-isystem dir
Mark it as a system directory, so that it gets the same special treatment as is applied to the
standard system directories. See System Headers. If dir begins with =, then the = will be replaced
by the sysroot prefix; see --sysroot and -isysroot. 

2.8 System Headers

The header files declaring interfaces to the operating system and runtime libraries often cannot be
written in strictly conforming C. Therefore, GCC gives code found in system headers 'special'
treatment. All warnings, other than those generated by '#warning' are suppressed while GCC is
processing a system header. Macros defined in a system header are immune to a few warnings wherever
they are expanded. This immunity is granted on an ad-hoc basis, when we find that a warning
generates lots of false positives because of code in macros defined in system headers.

Normally, only the headers found in specific directories are considered system headers. These
directories are determined when GCC is compiled. There are, however, two ways to make normal headers
into system headers.

The -isystem command line option adds its argument to the list of directories to search for headers,
just like -I. Any headers found in that directory will be considered system headers. 

All directories named by -isystem are searched after all directories named by -I, no matter what
their order was on the command line. If the same directory is named by both -I and -isystem, the -I
option is ignored. GCC provides an informative message when this occurs if -v is used.


={============================================================================
*kt_dev_gcc_204* gcc-cpp-use

{cpp-ndebug} *cpp-assert*
The assert macro is defined in `cassert` header. It depends on a preprocessor
varaible named NDEBUG. If NDEBUG is defined, assert do nothing. By default,
         it's not defined.

If the macro NDEBUG was defined at the moment <assert.h> was last included,
   the macro assert() generates no code, and hence does nothing at all.
   Otherwise, the macro assert() prints an error message to standard error and
   terminates the program by calling abort(3) if expression is 'false' (i.e.,
       compares equal to zero).

<ex>
From ansic, p91. exercise 4-14. Define a macro swap(t,x,y) that interchanges
two arguments of type t. (Block structure will help.)

#define swap(t, x, y) do {\
   t z;\
   z = x;\
   x = y;\
   y = z;\
} while(0)

If use C++ then make it more useful:

#define swap(x, y) do {\
  decltype(x) z;\
  z = x;\
  x = y;\
  y = z;\
} while(0)


{conditional}

#define BSD 3
#define SYSV 4

#define HEHE BSD
//#define HEHE SYSV

#if HEHE == SYSV
  #define HDR "x/sysv.h"
#elif HEHE == BSD
  #define HDR "y/bsd.h"
#endif

int main() {
  printf("hdr %s\n", HDR);
  return 0;
}


{useful-macros}
#define abs(n) ((n) < 0 ? -(n) : (n))

#define EQ(a,b) (!strcmp((a),(b)))
#define LT(a,b) (strcmp((a),(b)) < 0)

#define EQ(a,b) ((a) == (b))
#define LT(a,b) ((a) < (b))

// a is array
#define NELEMENTS(a) (sizeof(a)/sizeof(*(a)))

// build enum and string table
#define FSM_E(x) {x,#x}

static Fsm::fsm_event_t bootEventList[] = {
  FSM_E(BOOT_EVENT_CLOSED),
  FSM_E(BOOT_EVENT_READY),
  ...
  FSM_E(BOOT_EVENT_STOP)
};

enum Events
{
  // BOOT_EVENTS
  BOOT_EVENT_CLOSED = 0x01,
  BOOT_EVENT_READY,
  ...
  BOOT_EVENT_STOP,
};


<ex> define, use, and undef. work?

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
  int iarr[5] = {0};

  for( int i = 0; i < 5; i++)
  {
    printf( "iarr[%d] = %d\n", i, iarr[i]);
  }

#define SET_VALUE_INT(idx, value) \
  do { \
    iarr[idx] = value; \
  } while(0)

  SET_VALUE_INT(2, 1);
  SET_VALUE_INT(3, 1);
  SET_VALUE_INT(4, 1);
#undef SET_VALUE_INT

  for( int i = 0; i < 5; i++)
  {
    printf( "iarr[%d] = %d\n", i, iarr[i]);
  }

  exit(EXIT_SUCCESS);
}

yes, works.


={============================================================================
*kt_dev_gcc_204* gcc-cpp-issue

EC++02, no to preprocessor

Prefer the compiler to the preprocessor because:

* type-checking

* better to decode compile error and to use symbolic debugger. 

#define ASPECT_RATIO 1.653

const double AspectRatio = 1.653

* smaller code (?) since blind substitution could result in multiple copies in
  your object code.

* class-const
class specific const and better encapsulation.

* avoid problem when use macro with an expression

// one

#define CALL_WITH_MAX(a,b) func((a) > (b) ? (a) : (b) )

int a = 5, b = 0;

CALL_WITH_MAX(++a, b);     // a is increased twice
CALL_WITH_MAX(++a, b+10);  // a is increased once since (a > b) is false

// two when the order of evaluation matters

#define square(x)    x*x
init z = 5
square(z+1);

36? No, it is 11.

If want to avoid function call cost, use 'inline' instead.


={============================================================================
*kt_dev_gcc_205* gcc-cpp-vaarg

{variable-arguments}
The va_arg, va_copy, va_end, and va_start macros provide a portable way to access the arguments to a
function when the function takes a variable number of arguments. There are two versions of the
macros: The macros defined in STDARG.H conform to the ISO C99 standard; the macros defined in
VARARGS.H are deprecated but are retained for backward compatibility with code that was written
before the ANSI C89 standard. 

<from-linux>
STDARG(3) Linux Programmer's Manual

NAME
stdarg, va_start, va_arg, va_end, va_copy - variable argument lists

SYNOPSIS
 #include <stdarg.h>

 void va_start(va_list ap, last);
 type va_arg(va_list ap, type); // [KT] see type
 void va_end(va_list ap);
 void va_copy(va_list dest, va_list src);

DESCRIPTION

A function may be called with a [varying-number] of arguments of [varying-types]. The include file
<stdarg.h> declares a type va_list and defines three [macros] for stepping through a list of arguments
whose number and types are not known to the called function.

The called function must declare an object of type va_list which is used by the macros va_start(),
va_arg(), and va_end().

va_start() 

The va_start() macro initializes [ap] for subsequent use by va_arg() and va_end(), and must be called
first.

The argument last is the name of the last argument before the variable argument list, that is, the
last argument of which the calling function knows the type.

Because the address of this argument may be used in the va_start() macro, it should not be declared
as a register variable, or as a function or an array type.

va_arg()

The va_arg() macro expands to an expression that has the type and value of the next argument in the
call. The  argument ap is the va_list ap initialized by va_start(). Each call to va_arg() modifies
ap so that the next call returns the next argument. The argument type is a type name specified so
that the type of a pointer to an object that has the specified type can be obtained simply by
adding a * to type.

The first use of the va_arg() macro after that of the va_start() macro returns the argument after
last. Successive invocations return the values of the remaining arguments.

If there is no next argument, or if type is not compatible with the type of the actual next argument
(as promoted according to the default argument promotions), random errors will occur. ~

If ap is passed to a function that uses va_arg(ap,type) then the value of ap is undefined after the
return of that function.

va_end()

Each invocation of va_start() must be matched by a corresponding invocation of va_end() in the same
function. After the call va_end(ap) the variable ap is undefined. Multiple traversals of the list,
each bracketed by va_start() and va_end() are possible. va_end() may be a macro or a function.

example

#include <iostream>
#include <cstdarg>

void argprint(int num_args, ...)
{
  va_list ap;

  va_start(ap, num_args);
  for( int i = 0; i < num_args; i++)
  {
    std::cout << "arg:" << i << " is " << va_arg(ap, int) << std::endl;
  }

  va_end(ap);
}

int main()
{
  std::cout << "--{ main " << std::endl;

  argprint( 3, 10, 20, 30 );

  std::cout << "--} main " << std::endl;
}

The function foo takes a string of format characters and prints out the argument associated with
each format character based on the type.

#include <stdio.h>
#include <stdarg.h>

void
foo(char *fmt, ...)
{
  va_list ap;
  int d;
  char c, *s;

  va_start(ap, fmt);
  while (*fmt)             // note null is a termination condition
      switch (*fmt++) {    // note see ++
      case 's':              /* string */
          s = va_arg(ap, char *);
          printf("string %s\n", s);
          break;
      case 'd':              /* int */
          d = va_arg(ap, int);
          printf("int %d\n", d);
          break;
      case 'c':              /* char */
          /* need a cast here since va_arg only
             takes fully promoted types */
          c = (char) va_arg(ap, int);
          printf("char %c\n", c);
          break;
      }
  va_end(ap);
}


{snprintf-and-vsnprintf}
#include <stdio.h>

int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);

#include <stdarg.h>

int vprintf(const char *format, va_list ap);
int vfprintf(FILE *stream, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);

The functions vprintf(), vfprintf(), vsprintf(), vsnprintf() are equivalent to the functions
printf(), fprintf(), sprintf(), snprintf(), respectively, except that they are called with a
<va_list> instead of a variable number of arguments.  These  functions  do not call the va_end
macro. Because they invoke the va_arg macro, the value of ap is undefined after the call.  See
stdarg(3).

The functions snprintf() and vsnprintf() do not write more than size bytes (including the
terminating null byte ('\0')). If the output was truncated due to this limit then the return value
is the number of characters (excluding the terminating null byte) which would have been written to
the final string if enough space had been available. Thus, a return value of size or more means that
the output was truncated.  (See also below under NOTES.) If an output error is encountered, a
negative value is returned.


{swallowing-the-semicolon}
http://gcc.gnu.org/onlinedocs/cpp/Swallowing-the-Semicolon.html#Swallowing-the-Semicolon

<keys>
This is only when uses macros which has block, is used like function in a single statement but not
in expression. For example, think

if( do { ... } while(0); )

Not valid code. This trick is useful but macros still has its own limiations.
<keys>

Often it is desirable to define a macro that expands into a compound statement. Consider, for
example, the following macro, that advances a pointer (the argument p says where to find it) across
whitespace characters:

#define SKIP_SPACES(p, limit)  \
{ char *lim = (limit);         \
 while (p < lim) {            \
   if (*p++ != ' ') {         \
     p--; break; }}}

Here backslash-newline is used to split the macro definition, which must be a single logical line,
so that it resembles the way such code would be laid out if not part of a macro definition.

A call to this macro might be SKIP_SPACES (p, lim). Strictly speaking, the call expands to a
compound statement, which is a complete statement with no need for a semicolon to end it. However,
since it looks like a function call, it minimizes confusion if you can use it like a function call,
writing a semicolon afterward, as in SKIP_SPACES (p, lim);

This can cause trouble before 'else' statements, because the semicolon is actually a null statement.
Suppose you write

if (*p != 0)                     // if (*p != 0)
 SKIP_SPACES (p, lim);           //    {...};
else ...                         // else ...

The presence of two statements(the compound statement and a null statement) in between the if
condition and the else makes 'invalid' C code because must be one statement.

sam01.c:161:3: error: 'else' without a previous 'if'

The definition of the macro SKIP_SPACES can be altered to solve this problem, using a do ... while
statement. Here is how:

#define SKIP_SPACES(p, limit)     \
do { char *lim = (limit);         \
    while (p < lim) {            \
      if (*p++ != ' ') {         \
        p--; break; }}}          \
while (0)

Now SKIP_SPACES (p, lim); expands into

if (*p != 0)
   do {...} while (0);
else ...

which is one statement. The loop executes exactly once; most compilers generate no extra code for
it. 

note that there should be NO spaces after \;otherwise compile error.


={============================================================================
*kt_dev_gcc_206* gcc-cpp-stringification

http://gcc.gnu.org/onlinedocs/cpp/Stringification.html#Stringification

Sometimes you may want to convert a macro argument `into a string constant`
Parameters are not replaced inside string constants, but you can use the '#'
preprocessing operator instead. When a macro parameter is used with a leading
'#', the preprocessor replaces it with the literal text of the actual
argument, converted to a string constant. Unlike normal parameter replacement,
the argument is [not-macro-expanded-first]. This is called stringification.

The preprocessor will replace the stringified arguments with string constants.
The C compiler will then combine all the adjacent string constants into one
long string.

Here is an example of a macro definition that uses stringification:

     #define WARN_IF(EXP) \
     do { if (EXP) \
             fprintf (stderr, "Warning: " #EXP "\n"); } \
     while (0)

     WARN_IF (x == 0);
          ==> do { if (x == 0)
                fprintf (stderr, "Warning: " "x == 0" "\n"); } while (0);

The other example from ansic, p90.

#define dprint(expr)    printf(#expr " = %g\n", expr )

dprint(x/y);
   ==> printf( "x/y = %g\n", x/y );

The argument for EXP is substituted once, as-is, into the if statement, and
  once, stringified, into the argument to fprintf. If x were a macro, it would
  be expanded in the if statement, but not in the string.

The do and while (0) are a kludge to make it possible to write WARN_IF (arg);,
    which the resemblance of WARN_IF to a function would make C programmers
      want to do; see Swallowing the Semicolon.

Stringification in C involves more than putting double-quote characters around
the fragment. The preprocessor backslash-escapes the quotes surrounding
embedded string constants, and all backslashes within string and character
constants, in order to get a valid C string constant with the proper contents.
Thus, stringifying p = "foo\n"; results in "p = \"foo\\n\";". However,
backslashes that are not inside string or character constants are not
  duplicated: '\n' by itself stringifies to "\n".

All leading and trailing whitespace in text being stringified is ignored. Any
sequence of whitespace in the middle of the text is converted to a single
space in the stringified result. Comments are replaced by whitespace long
before stringification happens, so they never appear in stringified text.

There is no way to convert a macro argument into a character constant.

If you want to stringify [the-result-of-expansion] of a macro argument, you
have to use [two-levels] of macros.

#define xstr(s) str(s)
#define str(s) #s
#define foo 4

str (foo)
    ==> "foo"  // [KT] is not "4" because not macro-expanded
xstr (foo)
    ==> xstr (4)
    ==> str (4)
    ==> "4"

s is stringified when it is used in str, so it is not macro-expanded first.
But s is an ordinary argument to xstr, so it is completely macro-expanded
before xstr itself is expanded (see Argument Prescan). Therefore, by the time
str gets to its argument, it has already been macro-expanded. 

#include <iostream>

#define PRINT_TRUE true

#define PRINT_STRING(exp) \
   do { \
      std::cout << "arg:" << #exp << std::endl; \
      std::cout << "arg:" << exp << std::endl; } \
   while(0)

#define XPRINT_STRING(s) PRINT_STRING(s)

int main()
{
  std::cout << "--{ main " << std::endl;

  PRINT_STRING(true);
  XPRINT_STRING(true);

  std::cout << "--} main " << std::endl;
}

arg:PRINT_TRUE    // stringified but not expanded
arg:1             // expanded
arg:true          // expanded before stringified
arg:1:            // expanded


<ex>

Although macro expansion does not occur within a quoted string, the text of
the macro arguments can be quoted and treated as a string literal by using the
"#" directive (also known as the "Stringizing Operator"). For example, with
the macro

#define QUOTEME(x) #x

the code

printf("%s\n", QUOTEME(1+2));

will expand to

printf("%s\n", "1+2");

This capability can be used with automatic string literal concatenation to
make debugging macros. For example, the macro in

#define dumpme(x, fmt) printf("%s:%u: %s=" fmt, __FILE__, __LINE__, #x, x)
 
int some_function() {
  int foo;
  /* a lot of complicated code goes here */
  dumpme(foo, "%d");
  /* more complicated code goes here */
}

would print the name of an [expression] and its value, along with the file
name and the line number.


<ex>

#define KT_CREATE(value)	JPA_CREATE( #value, value)

void JPA_CREATE(const char* vname, int value)
{
  printf("JPA_CREATE: value=%s value=%d...\n", vname, value );
}

int main(int argc, char *argv[])
{
  int val = 3;
  int is_this_my_own = 4;

  KT_CREATE(val);
  KT_CREATE(is_this_my_own);

  return;
}

output:
JPA_CREATE: value=val value=3...
JPA_CREATE: value=is_this_my_own value=4...


={============================================================================
*kt_dev_gcc_207* gcc-cpp-concatenation

https://gcc.gnu.org/onlinedocs/cpp/Concatenation.html#Concatenation

3.5 Concatenation

It is often useful `to merge two tokens into one` while expanding macros. This
is called token pasting or token concatenation. The ‘##’ preprocessing
operator performs token pasting. 

When a macro is expanded, the two tokens on either side of each ‘##’ operator
are combined into a single token, which then replaces the ‘##’ and the two
original tokens in the macro expansion. 

Usually both will be identifiers, or one will be an identifier and the other a
preprocessing number. When pasted, they make a longer identifier. This isn't
the only valid case. It is also possible to concatenate two numbers (or a
    number and a name, such as 1.5 and e3) into a number. Also,
multi-character operators such as += can be formed by token pasting.


However, two tokens that don't together form a valid token cannot be pasted
together. For example, you cannot concatenate x with + in either order. If you
try, the preprocessor issues a warning and emits the two tokens. Whether it
puts white space between the tokens is undefined. It is common to find
unnecessary uses of ‘##’ in complex macros. If you get this warning, it is
likely that you can simply remove the ‘##’.

Both the tokens combined by ‘##’ could come from the macro body, but you could
just as well write them as one token in the first place. Token pasting is most
useful when one or both of the tokens comes from a macro argument. If either
of the tokens next to an ‘##’ is a parameter name, it is replaced by its
actual argument before ‘##’ executes. As with stringification, the actual
argument is not macro-expanded first. If the argument is empty, that ‘##’ has
no effect.

Keep in mind that the C preprocessor converts comments to whitespace before
macros are even considered. Therefore, you cannot create a comment by
concatenating ‘/’ and ‘*’. You can put as much whitespace between ‘##’ and its
operands as you like, including comments, and you can put comments in
arguments that will be concatenated. However, it is an error if ‘##’ appears
at either end of a macro body.

Consider a C program that interprets named commands. There probably needs to
be a table of commands, perhaps an array of structures declared as follows:

     struct command
     {
       char *name;
       void (*function) (void);
     };
     
     struct command commands[] =
     {
       { "quit", quit_command },
       { "help", help_command },
       ...
     };

It would be cleaner not to have to give each command name twice, once in the
  string constant and once in the function name. A macro which takes the name
  of a command as an argument can make this unnecessary. The string constant
  can be created with stringification, and the function name by concatenating
  the argument with ‘_command’. Here is how it is done:

     #define COMMAND(NAME)  { #NAME, NAME ## _command }
     
     struct command commands[] =
     {
       COMMAND (quit),
       COMMAND (help),
       ...
     };


={============================================================================
*kt_dev_gcc_208* cpp-stringification

{variadic-macros}

http://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html

A macro can be declared to accept a variable number of arguments much as a function can. The syntax
for defining the macro is similar to that of a function. Here is an example:

     #define eprintf(...) fprintf (stderr, __VA_ARGS__)

This kind of macro is called [variadic]. When the macro is invoked, all the tokens in its argument
list after the last named argument (this eprintf macro has none), including any commas, become the
variable argument. This sequence of tokens replaces the identifier __VA_ARGS__ in the macro body
wherever it appears. Thus, we have this expansion:

     eprintf ("%s:%d: ", input_file, lineno)
          ==>  fprintf (stderr, "%s:%d: ", input_file, lineno)

The variable argument is completely macro-expanded before it is inserted into the macro expansion,
just like an ordinary argument. You may use the '#' and '##' operators to stringify the variable
argument or to paste its leading or trailing token with another token. (But see below for an
important special case for '##'.)

If your macro is complicated, you may want a more [descriptive-name] for the variable argument than
__VA_ARGS__. CPP permits this, as an extension. You may write an argument name immediately before
the '...'; that name is used for the variable argument. The eprintf macro above could be written

     #define eprintf(args...) fprintf (stderr, args)

using this extension. You cannot use __VA_ARGS__ and this extension in the same macro.
 
<possible-problem>

You can have named arguments as well as variable arguments in a variadic macro. We could define
eprintf like this, instead:

     #define eprintf(format, ...) fprintf (stderr, format, __VA_ARGS__)

This formulation looks more descriptive, but unfortunately it is [less-flexible]: you must now
supply at [least-one-argument] after the format string. In standard C, you cannot omit the comma
separating the named argument from the variable arguments. Furthermore, if you leave the variable
argument empty, you will get a [syntax-error], because there will be an extra comma after the format
string.

     eprintf("success!\n", );
          ==> fprintf(stderr, "success!\n", );

GNU CPP has a pair of extensions which deal with this problem. First, you are allowed to leave the
variable argument out entirely:

     eprintf ("success!\n");
          ==> fprintf(stderr, "success!\n", );

 [KT] not works in 4.6 G++. 

Second, the '##' token paste operator has a special meaning when placed between a comma and a
variable argument. If you write

     #define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)

and the variable argument is left out when the eprintf macro is used, then the comma before the '##'
will be deleted. This does not happen if you pass an empty argument, nor does it happen if the token
preceding '##' is anything other than a comma.

     eprintf ("success!\n")
          ==> fprintf(stderr, "success!\n");

 [KT] this works in 4.6 G++.

The above explanation is ambiguous about the case where the only macro parameter is a variable
arguments parameter, as it is meaningless to try to distinguish whether no argument at all is an
empty argument or a missing argument. In this case the C99 standard is clear that the comma must
remain, however the existing GCC extension used to swallow the comma. So CPP retains the comma when
conforming to a specific C standard, and drops it otherwise.

Variadic macros are a new feature in C99. GNU CPP has supported them for a long time, but only with
a named variable argument ('args...', not '...' and __VA_ARGS__). If you are concerned with
portability to previous versions of GCC, you should use only named variable arguments. On the other
hand, if you are concerned with portability to other conforming implementations of C99, you should
use only __VA_ARGS__.

Previous versions of CPP implemented the comma-deletion extension much more generally. We have
restricted it in this release ( [KT] version? ) to minimize the differences from C99. To get the
same effect with both this and previous versions of GCC, the token preceding the special '##' must
be a comma, and there must be white space between that comma and whatever comes immediately before
it:

     #define eprintf(format, args...) fprintf (stderr, format , ##args)


{case-example-one}

Use:

MHEGDebugInfo(eMHVdsm, "_mhvDsmEventCreate %d\n", num);

#if ...

 [KT] see debug output to use both module or single module(mhegdebug).

#define MHEGDebugInfo(comp, ...) {BP_PRINT(MHEGDebugCompToBPComp(comp), CCDebugBP::INFO, __VA_ARGS__);\
                                  MHEGDebugTrace(comp, eMHEGLevelInfo, __FUNCTION__, __VA_ARGS__); }
...

#define MHEGOnlyDebugInfo(comp, ...) (MHEGDebugTrace(comp, eMHEGLevelInfo, __FUNCTION__, __VA_ARGS__))
...

#else

#define MHEGDebugInfo(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelInfo, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugDebug(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelDebug, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugWarning(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelWarning, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugMajor(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelMajor, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugFatal(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelFatal, __FUNCTION__, __VA_ARGS__))

#endif

void MHEGDebugTrace(MHEGComponent comp, MHEGLevel level, const char* functionName, ...)
{
  // Always send to BP print, at least for now.
  if ((s_traceLevels[comp] >= level) && (s_traceLevels[comp] < eMHEGLevelOff))
  {
      va_list ap;
      va_start(ap, functionName);
      char *message = va_arg(ap, char*);
      output(comp, level, functionName, message, ap);
      va_end(ap);
  }
}

#define LINE_LIMIT 1024
static char temp_buffer[LINE_LIMIT + 1]; // Limit all strings to LINE_LIMIT

// [KT] here string is fmt
//
void output(MHEGComponent comp, MHEGLevel level, const char* function, const char* string, va_list arg)
{
   AUTOLOCK();

   // TODO, add support for timestamp.
   // Check for space
   // Construct final string
   long int tick = PCTime::Tick();

   // [KT] #define SNPRINTF snprintf
   int pos = SNPRINTF(temp_buffer, LINE_LIMIT, "[%ld:%ld][%s][%s][%s] ", 
      tick/1000, tick%1000, s_names[comp], s_traceLevelName[level], function);

   // [KT] string is format
   size_t len = vsnprintf(temp_buffer + pos, LINE_LIMIT - pos - 1, string, arg) + pos;
   if (temp_buffer[len - 1] != '\n')
   {
     temp_buffer[len] = '\n';
     len++;
     temp_buffer[len] = '\0';
   }

   BP_PRINTR(CCDebug::DEFAULT, CCDebugBP::INFO, temp_buffer);
}


Tried to use macro only to use frintf but seems not a solution because no way to build "format"
properly. Here get is ["fmt" __LINE__, __FUNC__, "fmt", args... ]

#define MHEGDebugInfo(comp, ...) TLOG("[%d:%s]\n",  __LINE__,  __PRETTY_FUNCTION__, __VA_ARGS__)
#define TLOG(...) fprintf( stderr, __VA_ARGS__)


{case-example-two}

From Tizen:

__pServiceAppImpl is pointer from creating objcets.

/*
 * @param[in]	NID			The Tizen namespace
 * @param[in]	condition		The condition that is expected to be true
 * @param[in]	r			The last result to set
 * @param[in]   ...			The message to display
 */

SysTryReturnResult(NID_APP, __pServiceAppImpl, E_OUT_OF_MEMORY, "[E_OUT_OF_MEMORY] Insufficient memory.");

#ifndef unlikely
#define unlikely(x)  __builtin_expect(!!(x), 0)    // see {likey-and-unlikely}
#endif

#define SysTryReturnVoidResult(NID, condition, r, ...)	\
	do \
	{ \
		if (unlikely(!(condition))) {	\
			SysLogException(NID, r, __VA_ARGS__); \
			return;	\
		} \
	} while (0);

#define SysLogException(NID, r, ...)               SysLogExceptionInternal(NID, r, __PRETTY_FUNCTION__, 
__LINE__, __VA_ARGS__)


void
SysLogExceptionInternal(unsigned long nid, result r, const char* pFunction, int lineNumber, 
const char* pFormat, ...)
{
	va_list args;

	SetLastResult(r);

	if (!logInfo.platformExceptionEnabled)
	{
		return;
	}

	va_start(args, pFormat);

	__PrintSysLog(static_cast<_LogType>(LOG_EXCEPTION), static_cast<LogID>(nid), pFunction, lineNumber, 
	pFormat, args);

	va_end(args);
}

void __PrintSysLog(_LogType type, LogID id, const char* pFunction, int lineNumber, const char* pFormat, 
va_list args)
{
	if (!iniLoaded)
	{
		__InitializeLogInfo();
	}

	if (!__GetEnableInfo(static_cast<LogID>(id)))
	{
		return;
	}

	char logBody[LOG_LEN_MAX];
	snprintf(logBody, LOG_LEN_MAX, "%s(%d) > %s", pFunction, lineNumber, pFormat);
	logBody[LOG_LEN_MAX -1] = '\0';

	char logTag[LOG_MODULE_NAME_LEN_MAX];

	snprintf(logTag, LOG_MODULE_NAME_LEN_MAX, "%s", __GetModuleName(static_cast<LogID>(id)));
	logTag[LOG_MODULE_NAME_LEN_MAX - 1] = '\0';

	switch (type)
	{
	case static_cast<_LogType>(LOG_INFO):
		LOG_VA(LOG_INFO, logTag, logBody, args);
		break;

	case static_cast<_LogType>(LOG_DEBUG):
		LOG_VA(LOG_DEBUG, logTag, logBody, args);
		break;

	case static_cast<_LogType>(LOG_EXCEPTION):
		ALOG_VA(LOG_ERROR, logTag, logBody, args);
		break;

	case static_cast<_LogType>(LOG_USER):
		ALOG_VA(LOG_ERROR, logTag, logBody, args);
		break;

	default:
		LOG_VA(LOG_DEBUG, LOG_TAG_NULL, logBody, args);
		break;
	}
}

#ifndef LOG_VA
#define LOG_VA(priority, tag, fmt, args) \
    vprint_log(D##priority, tag, fmt, args)
#endif

#define vprint_log(prio, tag, fmt...) \
	__dlog_vprint(LOG_ID_MAIN, prio, tag, fmt)


{case-example-try-catch}

result
ServiceApp::Execute(ServiceAppInstanceFactory pServiceAppFactory, const IList* pArguments)
{
	r = pAppImpl->Construct(pArguments);
	SysTryCatch(NID_APP, !IsFailed(r), r = E_SYSTEM, E_SYSTEM, "[E_SYSTEM] %s.", GetErrorMessage(r));
CATCH:
	delete pServiceApp;

	return r;
}

#define SysTryCatch(NID, condition, expr, r, ...) \
	do \
	{ \
		if (unlikely(!(condition))) {	\
			SysLogException(NID, r, __VA_ARGS__); \
			expr; \
			goto CATCH;	\
		} \
	} while (0);


{case-example-two}

_INFO("main:_terminate:leave\n");

#ifndef _ERR
#define _ERR(fmt, args...) LOGE("[%s:%d] "fmt"\n", __func__, __LINE__, ##args)
#endif

#ifndef _DBG
#define _DBG(fmt, args...) LOGD("[%s:%d] "fmt"\n", __func__, __LINE__, ##args)
#endif

#ifndef _INFO
#define _INFO(fmt, args...) LOGI("[%s:%d] "fmt"\n", __func__, __LINE__, ##args)		[KT] multi-level
#endif

#ifndef LOGI
#define LOGI(...) ((void)LOG(LOG_INFO, LOG_TAG, __VA_ARGS__))
#endif

#ifndef LOGE
#define LOGE(...) ((void)LOG(LOG_ERROR, LOG_TAG, __VA_ARGS__))
#endif

#ifndef LOG
#define LOG(priority, tag, ...) \
	print_log(D##priority, tag, __VA_ARGS__)
#endif

#define print_log(prio, tag, fmt...) \
	__dlog_print(LOG_ID_MAIN, prio, tag, fmt)

int __dlog_vprint(log_id_t log_id, int prio, const char *tag, const char *fmt, va_list ap)
{
    char buf[LOG_BUF_SIZE];

    vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);

    return write_to_log(log_id, prio, tag, buf);
}

int __dlog_print(log_id_t log_id, int prio, const char *tag, const char *fmt, ...)
{
    va_list ap;
    char buf[LOG_BUF_SIZE];

    va_start(ap, fmt);
    vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);
    va_end(ap);

    return write_to_log(log_id, prio, tag, buf);
}

static int __write_to_log_kernel(log_id_t log_id, log_priority prio, const char *tag, const char *msg)
{
	ssize_t ret;
	int log_fd;
	struct iovec vec[3];

	if( log_id < LOG_ID_MAX )
		log_fd = log_fds[log_id];
	else
		return -1; // for TC

	if (!tag)
		  tag = "";

	vec[0].iov_base	= (unsigned char *) &prio;
	vec[0].iov_len	= 1;
	vec[1].iov_base	= (void *) tag;
	vec[1].iov_len	= strlen(tag) + 1;
	vec[2].iov_base	= (void *) msg;
	vec[2].iov_len	= strlen(msg) + 1;

   // [KT] this is sys call
	ret = writev(log_fd, vec, 3);

	return ret;
}

static int __dlog_init(log_id_t log_id, log_priority prio, const char *tag, const char *msg)
{
#ifdef HAVE_PTHREADS
		pthread_mutex_lock(&log_init_lock);
#endif
	// get filtering info

	// open device
	if( write_to_log == __dlog_init)
	{
		log_fds[LOG_ID_MAIN] = open("/dev/"LOG_MAIN, O_WRONLY);
		log_fds[LOG_ID_RADIO] = open("/dev/"LOG_RADIO, O_WRONLY);
		log_fds[LOG_ID_SYSTEM] = open("/dev/"LOG_SYSTEM, O_WRONLY);

		if( log_fds[LOG_ID_MAIN] < 0 || log_fds[LOG_ID_RADIO] < 0 )
		{
			fprintf(stderr, "open log dev is failed\n");
			write_to_log = __write_to_log_null;
		}
		else
			write_to_log = __write_to_log_kernel;

		if( log_fds[LOG_ID_SYSTEM] < 0 )
		{
			log_fds[LOG_ID_SYSTEM] = log_fds[LOG_ID_MAIN];
		}
	}
#ifdef HAVE_PTHREADS
    pthread_mutex_unlock(&log_init_lock);
#endif
	return write_to_log(log_id, prio, tag, msg);
}


{why-ellipses-dangerous}
http://www.learncpp.com/cpp-tutorial/714-ellipses-and-why-to-avoid-them/

Two points:

o no type checks on calling parameters
o no checks on the number of calling parameters

#include <cstdarg> // needed to use ellipses

// The ellipses must be the last parameter
double FindAverage(int nCount, ...)
{
  long lSum = 0;

  // We access the ellipses through a va_list, so let's declare one
  va_list list;

  // We initialize the va_list using va_start. The first parameter is
  // the list to initialize. The second parameter is the last non-ellipse
  // parameter.
  va_start(list, nCount);

  // Loop nCount times
  for (int nArg=0; nArg < nCount; nArg++)
    // We use va_arg to get parameters out of our ellipses
    // The first parameter is the va_list we're using
    // The second parameter is the type of the parameter
    lSum += va_arg(list, int);

  // Cleanup the va_list when we're done.
  va_end(list);

  return static_cast<double>(lSum) / nCount;
}
 
int main()
{
  cout << FindAverage(5, 1, 2, 3, 4, 5) << endl;
  cout << FindAverage(6, 1, 2, 3, 4, 5, 6) << endl;
}

Why ellipses are dangerous

Ellipses offer the programmer a lot of flexibility to implement functions that can take a variable
number of parameters. However, this flexibility comes with some very dangerous downsides.

With regular function parameters, the compiler uses type checking to ensure the types of the
function arguments match the types of the function parameters (or can be implicitly converted so
they match). This helps ensure you don't pass a function an integer when it was expecting a string,
or vice versa. However, note that ellipses parameters have no type declarations. When using
ellipses, the compiler completely suspends type checking for ellipses parameters. This means it is
possible to send arguments of any type to the ellipses! However, the downside is that the compiler
will no longer be able to warn you if you call the function with ellipses arguments that do not make
sense. When using the ellipses, it is completely up to the caller to ensure the function is called
with ellipses arguments that the function can handle. Obviously that leaves quite a bit of room for
error (especially if the caller wasn't the one who wrote the function).

Lets look at an example of a mistake that is pretty subtle:
	
cout << FindAverage(6, 1.0, 2, 3, 4, 5, 6) << endl;

Although this may look harmless enough at first glance, see that the second argument (the first
ellipse argument) is a double instead of an integer. This compiles fine, and produces a somewhat
surprising result:

1.78782e+008

which is a REALLY big number. How did this happen?

As you have learned in previous lessons, a computer stores all data as a sequence of bits. A
variable's type tells the computer how to translate that sequence of bits into a meaningful value.
However, you just learned that the ellipses throw away the variable's type! Consequently, the only
way to get a meaningful value back from the ellipses is to manually tell va_arg() what the expected
type of the next parameter is. This is what the second parameter of va_arg() does. If the actual
parameter type doesn't match the expected parameter type, bad things will usually happen.

In the above FindAverage program, we told va_arg() that our variables are all expected to have a
type of int. Consequently, each call to va_arg() will return the next sequence of bits translated as
an integer.

In this case, the problem is that the double we passed in as the first ellipse argument is 8 bytes,
whereas va_arg(list, int) will only return 4 bytes of data with each call. Consequently, the first
call to va_arg will only read the first 4 types of the double (producing a garbage result), and the
second call to va_arg will read the second 4 bytes of the double (producing another garbage result).
Thus, our overall result is garbage.

Because type checking is suspended, the compiler won't even complain if we do something completely
ridiculous, like this:
	
int nValue = 7; cout << FindAverage(6, 1.0, 2, "Hello, world!", 'G', &nValue, &FindAverage) << endl;

Believe it or not, this actually compiles just fine, and produces the following result on the
author's machine:

1.79766e+008

This result epitomizes the phrase, "Garbage in, garbage out" which is a popular computer science
phrase used primarily to call attention to the fact that computers, unlike humans, will
unquestioningly process the most nonsensical of input data and produce nonsensical output
(wikipedia).

So, in summary, type checking on the parameters is suspended, and we have to trust the caller to
pass in the right type of parameters. If they don't, the compiler won't complain; our program will
just produce garbage (or maybe crash).

<second-problem>
As if that wasn't dangerous enough, we run into a second potential problem. Not only do the ellipses
throw away the type of the parameters, it also throws away the number of parameters in the ellipses!
This means we have to devise our own solution for keeping track of the number of parameters passed
into the ellipses. Typically, this is done in one of two ways:

o One of the fixed parameters is used as a parameter count (this is the solution we use in the
FindAverage example above)

o The ellipse parameters are processed until a sentinel value is reached. A sentinel is a special
value that is used to terminate a loop when it is encountered. For example, we could pick a sentinel
value of 0, and continually process ellipse parameters until we find a 0 (which should be the last
value). Sentinel values only work well if you can find a sentinel value that is not a legal data
value. 

However, even here we run into trouble. For example, consider the following call:

For example:

cout << FindAverage(6, 1, 2, 3, 4, 5) << endl;

On the authors machine at the time of writing, this produced the result:

699773

What happened? We told FindAverage() we were going to give it 6 values, but we only gave it 5.
Consequently, the first five values that va_arg() returns were the ones we passed in. The 6th value
it returns was a garbage value somewhere in the stack. Consequently, we got a garbage answer.

When using a sentinel value, if the caller forgets to include the sentinel, the loop will run
continuously until it runs into garbage that matches the sentinel (or crashes).

Recommendations for safer use of ellipses

First, if possible, do not use ellipses at all! Oftentimes, other reasonable solutions are
available, even if they require slightly more work. For example, in our FindAverage() program, we
could have passed in a dynamically sized array of integers instead. This would have provided both
strong type checking (to make sure the caller doesn't try to do something nonsensical) while
preserving the ability to pass a variable number of integers to be averaged.

Second, if you do use ellipses, do not mix expected argument types within your ellipses if possible.
Doing so vastly increases the possibility of the caller inadvertently passing in data of the wrong
type and va_arg() producing a garbage result.

Third, using a count parameter as part of the argument list is generally safer than using a sentinel
as an ellipses parameter. This forces the user to pick an appropriate value for the count parameter,
which ensures the ellipses loop will terminate after a reasonable number of iterations even if it
produces a garbage value.


#{============================================================================
#{ C AND C++
={============================================================================
*kt_dev_cpp_0000* cxx-code-ansi-color

debug() {
    # Note: echo -e doesn't work on OS X's default bash (3.2).
    printf '\n\033[0;32m%s\n' "$*"
    tput sgr0
}

Esc[Value;...;Valuem 	Set Graphics Mode:

Calls the graphics functions specified by the following values. These specified
functions remain active until the next occurrence of this escape sequence.
Graphics mode changes the colors and attributes of text (such as bold and
    underline) displayed on the screen.
 

Text attributes
0	All attributes off
1	Bold on
4	Underscore (on monochrome display adapter only)
5	Blink on
7	Reverse video on
8	Concealed on
 
Foreground colors
30	Black
31	Red
32	Green
33	Yellow
34	Blue
35	Magenta
36	Cyan
37	White
 
Background colors
40	Black
41	Red
42	Green
43	Yellow
44	Blue
45	Magenta
46	Cyan
47	White
 
Parameters 30 through 47 meet the ISO 6429 standard.

("\033[04;31;47m ansi: \033[m \n" );

#define ESC '\033'
#define EOE 'm'
#define DEFAULT_COLOR "04;31;47"
#define DEFAULT_COLOR "01;31"

int main()
{
    // dark blue
    printf("\033[32m xxxx \033[0m \n");
    printf("\033[" DEFAULT_COLOR "m ansi: \033[m \n" );
    return 0;
}

echo -e "\E[1;31mThe git hook pre-push runs\E[m";


={============================================================================
*kt_dev_cpp_0000* cxx-twos-complement

The int type type on MIPS: size int: 4

signed int  : -219874992
unsigned int : 4075092304

How to get the negative value in `twos-complement`? "NOT X + 1 = -X" which
works in both directions.

    23:    1 0111
NOT 23: 1110 1000   // -24, 0xFFFF FFE8
 ----------------
        1111 1111

NOT 23: 1110 1000
+    1: 0000 0001
 ----------------
   -23: 1110 1001   // -24 + 1, 0xFFFF FFE9


<twos-complement-bit-pattern>

8bits two's complement
------------------------- 128 elements [0,127]
0000 0000    : 0
------------------------- 127 elements 
0000 0001 {{ : 1
0000 0010    : 2
0000 0011    : 3
0000 0100    : 4
...
0111 1111 }} : 127        xxx_MAX                     //         -(127)-2
------------------------- 128 elements [-1, -128]
1000 0000    : -128       xxx_MIN                     // not -0. -(127)-1
------------------------- 127 elements 
1000 0001 {{ : -127 (0111 1110 + 1 = 0111 1111 (127)) // not -1. -(127)
1000 0010    : -126 (0111 1101 + 1 = 0111 1110 (126)) // not -2
...
1111 1110    : -2
1111 1111 }} : -1         Uxxx_MAX
------------------------- 

To get two's complement in programmatic way

uint32_t ins = 0x27BDFFE0 
0010.0111.1011.1101.1111.1111.1110.0000

two's complement
1101.1000.0100.0010.0000.0000.0001.1111      // ~X (not)
+1                                           // +1
--------------------------------------------------
1101.1000.0100.0010.0000.0000.0010.0000      // -X (negate)

(-ins) = 0xD8420020                          // twos-complement, negate
1101.1000.0100.0010.0000.0000.0010.0000


<the-max-negative-num-is-special>
As with 8 bits pattern:

-128 ... 127

As with 32 bits pattern:

0111 1111 1111 1111 1111 1111 1111 1111     // 0x7fffffff, INT_MAX
1000 0000 0000 0000 0000 0000 0000 0000     // 0x80000000, [31...0] INT_MIN

The addition operation in the CPU is agnostic to whether the integer is signed
or unsigned. The bit representation is the same. 

Here `negate` means that -value but not ~value which is bitwise operation.

If you `negate` 0x80000000, _MIN, you get the same again and that is something
to look out for because there is `no-change` in bit representation. This means
abs() has no effect when fed the largest negative number. So bit
representation is 'agnostic' to whether it's signed or unsigned.

int main()
{
  // `max-negative-num` INT_MIN
  int value = ((unsigned int)(~0) >> 1)+1;

  std::bitset<32> bitset2{value};
  std::cout << bitset2 << std::endl;

  // negate `max-negative-num`
  unsigned int minus_value = -value;
  std::bitset<32> bitset3{value};
  std::cout << bitset3 << std::endl;
}

10000000000000000000000000000000
10000000000000000000000000000000

unsigned int x = ~0;    // 11....1 UINT_MAX
             x >>= 1;   // 01....1 INT_MAX

signed   -INT_MAX-1 ... INT_MAX        // -128 ~ 127
unsigned 0          ... UNIT_MAX       // 0 ~ 256

-INT_MAX-2? -INT_MAX-2 becomes INT_MAX since plus and minus moves up/down in bit
representation.


<to-toggle-between-unsigned-and-signed> *interview-quiz*
note: possible interview quiz? 

The bit representation is the same for both signed and unsigned value

>>> 2**8
256
>>> -1 + 2**8
255
>>> bin(-1+2**8)
'0b11111111'

>>> 2**32
4294967296
>>> -1 + 2**32
4294967295L
>>> bin(-1 + 2**32)
'0b11111111111111111111111111111111'
>>> import ctypes
>>> ctypes.c_ulong(-1)
c_ulong(4294967295L)

This means that both has the same offset from 2**8(256) for example.

 |         | -128
 |         | -127, 129
 |         | -126, 130
 |         |
 |11111111 |
1|00000000 | 256

  256-126  = 130     // -126 to unsigned
-(256-130) = 126     // 130 to signed


<ex> The ansic, page 64, exercise 3-4. 
In a two's complement number representation, our version of itoa does 'not'
handle the 'largest' negative number, that is, the value of n equal to -(2 to
    the power (wordsize - 1)). Explain why not. Modify it to print that value
correctly regardless of the machine on which it runs. 

void itoa( int n, char s[] );

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_3:Exercise_4
As shown above, the problem is that negate do not change the max negative value.


// the original version

void itoa( int n, char s[] )
{
  int i, sign;

  if( (sign = n) < 0 )        // record sign
    n = -n;                   // make n positive. 

  i = 0;

  do {                        // generate digits in reverse order
    s[i++] = '0' + n % 10;    // get next digit
  } while( (n /= 10) > 0 );   // delete it.

  if(sign < 0)
    s[i++] = '-';

  s[i] = '\0';

  reverse(s);
}

When n is INT_MIN=-2147483648

* (n /= 10) will be negative since -n has no effect and n is negative. 
  From n=-2147483648 to n=-214748364(0xf3333334)
* do-while loop will run once only since n will be negative
* a single character since INT_MIN % 10 = -8.
* place in the string a '-'

In ansic, p41, arithmetic operators, 
   
"The direction of truncation for / and the sign of result for
% are machine dependent for negative operands, as is the action taken on
overflow or underflow". 


// the revised version

void itoa( int n, char s[] )
{
  int i, sign;

  if( (sign = n) < 0 )
    n = -n;                         // note-3

  i = 0;

  do { 
    s[i++] = '0' + abs(n % 10);     // note-1
  } while( n /= 10 );               // note-2

  if(sign < 0)
    s[i++] = '-';

  s[i] = '\0';

  reverse(s);
}


converted string: -./,),(-*,(     // use the original
converted string: -2147483648     // use the revised


note-2: Change 'while ((n /= 10) > 0)' to 'while (n /= 10)' to make the loop
continue 'divide' and n will eventually equal zero after successive divides by
10, and 'n /= 10' will evaluate to false sooner or later. If use
"while((n/=10)>0)" then handles only positive and stops on the first check since
n/=10 becomes negative.

note-1: Change 'n % 10 + '0 to 'abs(n % 10) + '0, to get the correct character
since n%10 is negative so need to make positive to get correct char back. 
Using abs() here is okay since it was already reduced to smaller one.

note-3: What if use abs(XXX_MIN) here? No effect.


={============================================================================
*kt_dev_cpp_0000* cxx-builtin-type

{data-type} From ansic:

char
int      an integer, typically the natural size of integers on the host machine
float
double

short, long, signed and unsigned 'qualifiers'. short is 'at-least' 16 bits,
  long 'at-least' 32 bits and int either 16 or 32 bits. Each compiler is free
  to choose appropriate sizes for its own hardware.

note:
The char is not singed char. there are char, signed, unsigned types because
whether char is signed or unsigned 'depends' on compiler. From ansic, "whether
plain chars are signed or unsigned is machine-dependent". So recommendation is
that 'not' use char but use signed or unsigned.

The standard header <limits.h> and <float.h> contain symbolic constants for
all of these sizes along with other properties of the machine and compiler.


From C++: 2.1.1 Arithmetic Types

Type        Meaning           Minimum Size
------------------------------------------
bool        boolean           NA
short       short integer     16 bits
int         integer           16 bits
long        long integer      32 bits 
long long   long integer      64 bits           // from C++11

<ex>
The ansic, page 36, exercise 2-1. Write a program to determine the range of
char, short, int, and long variables, both signed and unsigned, by printing
appropriate values from standard headers and by direct computation. Harder if
you compute them: determine the range of the various floating-point types.

#include <limits.h>

#define MY_ULONG_MAX (~(unsigned long)0)

int main(int argc, char* argv[])
{
  printf("ulong max from limits: %luL\n", ULONG_MAX );
  printf("ulong max from calc  : %luL\n", MY_ULONG_MAX );
}

ulong max from limits: 4294967295L
ulong max from calc  : 4294967295L


<use-headers>
From http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_1

#include <stdio.h>
#include <limits.h>

int main(void)
{
  printf("\nBits of type char: %d\n\n", CHAR_BIT);

  printf("Maximum numeric value of type char: %d\n", CHAR_MAX);
  printf("Minimum numeric value of type char: %d\n\n", CHAR_MIN);

  printf("Maximum value of type signed char: %d\n", SCHAR_MAX);
  printf("Minimum value of type signed char: %d\n\n", SCHAR_MIN);

  printf("Maximum value of type unsigned char: %u\n\n", (unsigned) UCHAR_MAX);
  
  printf("Maximum value of type short: %d\n", SHRT_MAX);
  printf("Minimum value of type short: %d\n\n", SHRT_MIN);

  printf("Maximum value of type unsigned short: %u\n\n", (unsigned) USHRT_MAX);

  printf("Maximum value of type int: %d\n", INT_MAX);
  printf("Minimum value of type int: %d\n\n", INT_MIN);

  printf("Maximum value of type unsigned int: %u\n\n", UINT_MAX);

  printf("Maximum value of type long: %ld\n", LONG_MAX);
  printf("Minimum value of type long: %ld\n\n", LONG_MIN);

  printf("Maximum value of type unsigned long: %lu\n", ULONG_MAX);
  printf("Maximum value of type unsigned long long: %llu\n\n", ULLONG_MAX);

  return 0;
}

Bits of type char: 8

Maximum numeric value of type char: 127
Minimum numeric value of type char: -128

Maximum value of type signed char: 127
Minimum value of type signed char: -128

Maximum value of type unsigned char: 255

Maximum value of type short: 32767
Minimum value of type short: -32768

Maximum value of type unsigned short: 65535

Maximum value of type int: 2147483647
Minimum value of type int: -2147483648

Maximum value of type unsigned int: 4294967295

Maximum value of type long: 2147483647
Minimum value of type long: -2147483648

Maximum value of type unsigned long: 4294967295
Maximum value of type unsigned long long: 18446744073709551615


<use-calculation> use variables for each type
Integer solution. Floats to follow. I know 'long long' is not in K&R. Pilcrow
12:00, 31 July 2011 (UTC)

/* calculate the ranges of various types */
#include <stdio.h>
#include <limits.h>

int main(void)
{
  /* integer types */
  unsigned char c;
  unsigned short s;
  unsigned int i;
  unsigned long l;
  unsigned long long ll;

  putchar('\n');
  printf("VALUE RANGES FOR INTEGER TYPES\nUPPERCASE comes from <limits.h>\n"
      "lowercase is calculated.\n\n");

  /* char */
  c = ~0;     // note: this is Uxxx_MAX
  c >>= 1;    // note: this is xxx_MAX. why this work? since it's 'unsigned'
  printf("signed char:   %4d,           %4d\n",-c-1,c);
  printf("SCHAR_MIN:     %4d, SCHAR_MAX %4d\n",SCHAR_MIN,SCHAR_MAX);
  printf("unsigned char: %4u,           %4u\n",0,c*2+1);
  printf("UCHAR_MAX:                     %4u\n",UCHAR_MAX);
  putchar('\n');

  // kt@kt-ub-vb:~/work$ ./a.out 
  // 
  // VALUE RANGES FOR INTEGER TYPES
  // UPPERCASE comes from <limits.h>
  // lowercase is calculated.
  // 
  // signed char:   -128,            127
  // SCHAR_MIN:     -128, SCHAR_MAX  127
  // unsigned char:    0,            255
  // UCHAR_MAX:                      255

  /* short */
  s = ~0;
  s >>= 1;
  printf("signed short:   %6d,           %6d\n",-s-1,s);
  printf("SHRT_MIN:       %6d, SHRT_MAX: %6d\n",SHRT_MIN,SHRT_MAX);
  printf("unsigned short: %6u,           %6u\n",0,s*2+1);
  printf("USHRT_MAX:                        %6u\n",USHRT_MAX);
  putchar('\n');

  /* int */
  i = ~0;
  i >>= 1;
  printf("signed int:    %11d,          %11d\n",-i-1,i);
  printf("INT_MIN:       %11d, INT_MAX: %11d\n",INT_MIN, INT_MAX);
  printf("unsigned int:  %11u,          %11u\n",0,i*2+1);
  printf("UINT_MAX:                            %11u\n",UINT_MAX);
  putchar('\n');

  /* long */
  l = ~0;
  l >>= 1;
  printf("signed long:   %11ld,           %11ld\n",-l-1,l);
  printf("LONG_MIN:      %11ld, LONG_MAX: %11ld\n",LONG_MIN, LONG_MAX);
  printf("unsigned long: %11lu,           %11lu\n",0l,l*2+1);
  printf("ULONG_MAX:                            %11lu\n", ULONG_MAX);
  putchar('\n');


  /* long long */
  ll = ~0;
  ll >>= 1;
  printf("signed long long:   %20lld,            %20lld\n",-ll-1,ll);
  printf("LLONG_MIN:          %20lld, LLONG_MAX: %20lld\n",LLONG_MIN, LLONG_MAX);
  printf("unsigned long long: %20llu,            %20llu\n",0ll,ll*2+1);
  printf("ULLONG_MAX:                                          %20llu\n", ULLONG_MAX);

  return 0;
}


VALUE RANGES FOR INTEGER TYPES
UPPERCASE comes from <limits.h>
lowercase is calculated.

signed char:   -128,            127
SCHAR_MIN:     -128, SCHAR_MAX  127
unsigned char:    0,            255
UCHAR_MAX:                      255

signed short:   -32768,            32767
SHRT_MIN:       -32768, SHRT_MAX:  32767
unsigned short:      0,            65535
USHRT_MAX:                         65535

signed int:    -2147483648,           2147483647
INT_MIN:       -2147483648, INT_MAX:  2147483647
unsigned int:            0,           4294967295
UINT_MAX:                             4294967295

signed long:   -2147483648,            2147483647
LONG_MIN:      -2147483648, LONG_MAX:  2147483647
unsigned long:           0,            4294967295
ULONG_MAX:                             4294967295

signed long long:   -9223372036854775808,             9223372036854775807
LLONG_MIN:          -9223372036854775808, LLONG_MAX:  9223372036854775807
unsigned long long:                    0,            18446744073709551615
ULLONG_MAX:                                          18446744073709551615


={============================================================================
*kt_dev_cpp_0000* cxx-type-limits

<1> To get INT_MAX, 01111111...1,  ((~0)>>1) is wrong. why?

unsigned int val = ((~0) >> 1) +1;            // wrong
unsigned int val = (((unsigned)~0) >> 1) +1;  // okay
unsigned int val = ((unsigned)~0 >> 1) +1;    // okay, since cast is higher

int main()
{
  unsigned int input2 = (~(0)>>1);

  // 1. when use `not operation`, the size and signness is `independant`. The
  // result `depends on the other operand` and done at `compile-time`. 
  //
  // so ~(0) makes "111...11" which don't have size and signness.
  //
  // 2. The signess must be known to compiler when do shift to have guaranteed
  // result. Since do not know signness, use `signed by default` and gets 1
  // for MSB when right-shift
  //
  // *right-shift* Must use `unsigned` to do  `right-shift` in order to have
  // guaranteed 0 values. 
  //
  // so (~(0)>>1) makes "111...11"
  //
  // This is why glibc macro uses unsigned type which set size and signness.
  // from glibc and see exercise 2-1 for examples.
  //
  // # ifndef ULONG_MAX
  // #  define ULONG_MAX ((unsigned long int) ~(unsigned long int) 0)
  // # endif
  // # ifndef LONG_MAX
  // #  define LONG_MAX ((long int) (ULONG_MAX >> 1))
  // # endif


  // input3 works since the result is `independant` but assigned to unsigned.
  // input1 version is shorter version of this.
  
  unsigned int input1 = ~((unsigned int)0)>>1;

  unsigned int input3 = ~0;
  input3 >>=1;

  std::bitset<32> bset1{input1};
  std::cout << bset1 << std::endl;
  std::bitset<32> bset2{input2};
  std::cout << bset2 << std::endl;
  std::bitset<32> bset3{input3};
  std::cout << bset3 << std::endl;
}

01111111111111111111111111111111      // input1
11111111111111111111111111111111      // input2, wrong
01111111111111111111111111111111      // input3


<cpp-shift>
The summary is that for `unsigned`, `zero-filled` when do `right-shift`.

http://msdn.microsoft.com/en-us/library/336xbhcz.aspx

The `left-shift` causes that the bit positions that have been vacated by the
shift operation are zero-filled. 

The `right-shift` causes the bit pattern in shift expression to be shifted to
the right by the number of positions specified by additive-expression. 

For `unsigned` numbers, the bit positions that have been vacated by the shift
operation are `zero-filled`. 

For `signed` numbers, the sign bit is used to fill the vacated bit positions.
In other words, if the number is positive, 0 is used, and if the number is
negative, 1 is used.

The result of a right-shift of a signed negative number is implementation
dependent. Although Visual C++ uses the sign bit to fill vacated bit
positions, there is no guarantee that other implementations also do so.

The ansic says: Right shifting a 'signed' quantity will fill with sign bit
(arithmetic shift) on some machines and with 0 bits (logical shift) on others. 


<2> `left-shift-operator`
To explain this point, try this exercise first:

<ex> *ex-getbits* ansic, p49. 
The function getbits(x, p, n) returns the (right adjusted) n-bit field of x
that begins at position p. For example, getbits( x, 4, 3 ) returns the three
bits; 4, 3, 2, right adjusted.

unsigned getbits( unsigned x, int p, int n );

<wrong>
unsigned getbits( unsigned x, int p, int n );
{
  return x >> (p+1-n) & ~(1 << n);
}

`left-shift` fills 0 but:

~(1<<3)   = ~(1000) = ~(11111000) = 00000111    // wrong
                    = ~(00001000) = 11110111    // real

<correct>
unsigned getbits( unsigned x, int p, int n )    // note unsigned
{
  return (x >> (p+1-n)) & ~(~0 << n);
}

this can be written using variables to make it clearer/easier to understand

unsigned getbits( unsigned x, int p, int n )
{
  unsigned mask = ~(~0 << n);
  unsigned shift = (p+1-n);
  return (x >> shift) & mask;
}


note: to get n num bits on since `not-operator` don't have size and signness.

~(~0 << 2)    : ...0011
((-1) & 0x11) : ...0011


note:
1. "~(~0 << n)" is interesting in making a 'mask' value.
2. Why (p+1-n) for a shift? Since p(position) starts from 0.

7 6 5 4 3 2 1 0   8 7 6 5 4 3 2 1  position
     [* * *]           [* * *]
4+1-3 = 2 shift   5-3 = 2 shift

3. Do not need () since >> is higher than & but advisable to make easier to see.


<analysis> To see the differnece, see the below result.
#include <iostream>
#include <bitset>

int main()
{
  int ival = 1;

  int ival2 = ~( 1 << 3 );
  std::bitset<32> bitset2{ival2};
  std::cout << bitset2 << std::endl;

  int ival3 = ~(~0 << 3 );
  std::bitset<32> bitset3{ival3};
  std::cout << bitset3 << std::endl;

  unsigned int val2 = (~0);
  std::bitset<32> bitset2{val2};
  std::cout << bitset2 << std::endl;

  unsigned int val3 = (~1);
  std::bitset<32> bitset3{val3};
  std::cout << bitset3 << std::endl;
}

11111111111111111111111111110111       // <- 0...0001000 <- 0000001
00000000000000000000000000000111       // <- 1...1111000

11111111111111111111111111111111       // (~0)
11111111111111111111111111111110       // (~1)


<ex>
See use of 'U' which fix the warning like:
: warning: narrowing conversion of ‘-4’ from ‘int’ to ‘long long unsigned int’
since `signed` is default.

#define __DIAG_ALIGNMENT	(4U)
#define DIAG_CMN_ALIGN(x)	(((x) + (__DIAG_ALIGNMENT-1)) &~ (__DIAG_ALIGNMENT-1))


<3> independent-of-size
No difference when tried 'unsigned int'. The point is that "~0" is not the same
as "1". This is "independent of word length" in ansic p49. For example,

x = x & ~077

Set the last 'six' bits of x to zero since "x & ~077" is
`independent-of-word-length` and it thus perferable to, for example, x &
0177700, which assumes that x is a 16-bit quantity. The portable form involves
no extra cost, since ~077 is a constant expression that can be evaluated at
`compile-time` and the value `expands-to-fit` the type of operand that is used
with and that's why said independent.


<ex> *ex-bitcount*
From ansic, p50. The function counts the number of 1 bits in its integer
argument. 

int bitcount( unsigned x );

note: The key is not to use sizeof operator, unsigned argument, and use
independent of type size.

int bitcount( unsigned x )
{
  int b;

  for(b = 0; x != 0; x >>= 1) // for(b = 0; x; x >>= 1), see {operator-assign}
    if( x & 01 )              // x & 1 works as well
      b++;

  return b;
}


<ex> *ex-bitcount*
page 51. exercise 2-9. In a two's complement number system, x &= (x-1) deletes
the rightmost 1-bit in x. Explain why. Use this observation to write a 'faster'
version of bitcount.

Answer:

If x is odd, then (x-1) has the same bit representation as x except that the
rightmost 1-bit becomes a 0. In this case, (x & (x-1)) == (x-1).

x = 5: 5(101) & 4(100) = 100  // 101 -> 100 by having rightmost 1 to 0

If x is even, the end result of anding(&) x and x-1 has the rightmost 1 of x to 0.

x = 4: 4(100) & 3(11)  = 0    // 100 -> 0   by having rightmost 1 to 0
         ^ rightmost 1
x = 6: 6(110) & 5(101) = 100  // 110 -> 100 by having rightmost 1 to 0
          ^ rightmost 1
x = 8: 8(1000) & 7(111) = 0   // 1000 -> 0  by having rightmost 1 to 0

000   0     All even numbers has tailing 0s and it becomes 1 when minus 1
001   1
010   2
011   3
100   4
101   5
110   6
111   7
...

note: This is about careful observation but not a mechanism of borrowing a carry
for example. For both odd and even case, has the effect of having rightmost 1 to
0. So clear 1 from x one by one and no need to check on if to count bits.

note: And(&) is faster than shift operation? Yes and also there is no `if` in
the loop.

int bitcount(unsigned x)
{
  int b;

  for (b = 0; x != 0; x &= (x-1))
    b++;
  return b;
}


<ex>
From ansic, exercise 2-6. Write a function setbits(x,p,n,y) that returns x with
the n bits that begin at position p set to the rightmost n bits of y, leaving
the other bits unchanged.

Had difficult to understand a question. The question is that set n bits of x
starting from p with rightmost n bits of y and return the result.

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_6

int getbits( unsigned x, int p, int n );
int setbits( unsigned x, int p, int n, unsigned y );
void printbits( unsigned x );

// one
return (
    (x & ~(~(~0 << n) << p+1-n))    // set n bits of x to 0. x & ~(mask << shift)
    |
    (
     (~(~0 << n) & y)               // get rightmost n bits of y. mask & y
     << p+1-n                       // shift to be in p pos
    )
    );


// two
// The following function, "getbits", is from K&R p 49 */
// getbits: get n bits from position p
unsigned getbits(unsigned x, int p, int n)
{
  return (x >>(p+1-n) & ~(~0 << n));
}

// asbits - shows integers as bit strings. note <quiz> this is useful as bitset
// Usage:                                
//         asbits(x, sizeof(x), FLAG)    
// FLAG = 1|0, showing if newline desired
void asbits(unsigned x, size_t s, int nl)
{
  int i;

  for(i = s*8-1; i>=0; i--) {
    getbits(x, i, 1)? putchar('1') : putchar('0');
    if(!(i%4))putchar(' ');
  }
  if(nl)putchar('\n');
}

<example>
#include <iostream>

using namespace std;

int getbits( unsigned x, int p, int n );
int setbits( unsigned x, int p, int n, unsigned y );
void printbits( unsigned x );

int getbits( unsigned x, int p, int n )
{
  unsigned mask = ~(~0 << n);
  return (x>>p-n+1) & mask;
}

int setbits( unsigned x, int p, int n, unsigned y )
{
  unsigned xi = x & ~(~(~0<<n) << p-n+1); // xi = x & ~mask << p-n+1;
  unsigned yi = (y & ~(~0<<n)) << p-n+1;  // yi = y & mask << p-n+1;
  return xi | yi;
}

void printbits( unsigned x )
{
  int bits;

  for( bits = sizeof x *8 -1; bits >= 0; bits-- )
  {
    getbits( x, bits, 1 ) ? putchar('1') : putchar('0');
    if( bits % 4 == 0 )
      putchar(' ');
  }
  
  putchar('\n');
}

int main()
{
  unsigned int val1 = 0x558088;
  unsigned int val2 = 0x07507;

  cout << "val1: ";
  printbits( val1 );

  cout << "val2: ";
  printbits( val2 );

  cout << "setb: ";
  printbits( setbits( val1, 14, 3, val2 ));
}

val1: 0000 0000 0101 0101 1000 0000 1000 1000 
val2: 0000 0000 0000 0000 0111 0101 0000 0111 
setb: 0000 0000 0101 0101 1111 0000 1000 1000 
                           ^^^

<key> To set some bits of x with some bits of y, then some bits of x must be 0
before oring.

| XA | 00 | XB |
        OR
| 00 | YY | 00 |

<to-print-a-bits-in-string>
The possible approach is to use right shift one by one, check if it's 0 or 1,
    and save or print it. This approach has a problem since check on LSB, will
    get the reversed output. This is why "asbits" starts from MSB by using
    getbits() but not LSB.

<stack-and-queue>
This reminds me stack and queue.

input: 11101
           ^ start

      0 1 2 3 4 pos in array
      1 1 1 0 1

read(pop) as a stack, FILO          read(get) as a queue, FIFO
note. reversed output
       10111                           11101
           ^ start                         ^ start

if putchar(printf) array for both cases
   11101

if putchar when get it
   10111


<exercise>
From ansic, exercise 2-7. Write a function invert(x,p,n) that returns x with the
n bits that begin at position p inverted (i.e., 1 changed into 0 and vice
    versa), leaving the others unchanged.

// setbits uses y to set x and here xin uses instead.
unsigned invert_mine(unsigned x, int p, int n)
{
  // this makes easier to see a code
  unsigned msk = ~(~0 << n);

  // [*][x ][*] : x
  // [0][1 ][0] : msk << p+1-n
  // [0][x ][0] : (msk << p+1-n) & x
  // [1][x'][1] : ~((msk << p+1-n) & x)
  // [0][1 ][0]
  // [0][x'][0] : &
  unsigned xin = (~((msk << p+1-n) & x)) & msk << p+1-n;

  // this is the same as setbits
  return (x & ~(msk<< p+1-n)) | ((xin & msk)<< p+1-n);
}

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_7    note: xor
GP is in error. Here is a correct solution. Pilcrow 17:45, 31 August 2011 (UTC) 
unsigned invert_online(unsigned x, int p, int n)
{
  return x ^ ((~(~0<<n))<< p+1-n);
  // return x ^ (mask << shift);
}


int main()
{
  unsigned int val1 = 0x558088;

  cout << "val1: ";
  printbits( val1 );

  cout << "invt: ";
  printbits( invert( val1, 14, 3 ));
}

val1: 0000 0000 0101 0101 1000 0000 1000 1000 
invt: 0000 0000 0101 0101 1111 0000 1000 1000 
                           ^^^

<exercise>
From ansic, exercise 2-8. Write a function rightrot(x,n) that returns the value of the integer x
rotated to the right by n bit positions.

note: the keys are
1. Cannot use single mask and bit operation since it 'rotates' so have to use loop.
2. Needs observation when the rightmost bit is either 1 or 0.

1) The type is 'unsigned' so do not need to concern about value when do right shift. If not, need to
know the the length of type, such as sizeof(x).

// one note: prefer this since do not use sizeof and function call
// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_8
unsigned rightrot(unsigned x, unsigned n)
{
  while (n > 0) {
    if ((x & 1) == 1)
      x = (x >> 1) | ~(~0U >> 1);      // note: must use 'U' suffix or unsigned cast
    else
      x = (x >> 1);
    n--;
  }
  return x;
}

// two
// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_8
unsigned int rightrot(unsigned int x, int n)
{
  int m, i;

  for(i=0; i < n; i++) {
    m = getbits(x, 0, 1);
    m <<= (sizeof(m)*8-1);       // notice the use of sizeof
    x >>= 1;
    x |= m;
  }
  return x;
}

int main()
{
  unsigned int val1 = 0x07507;

  cout << "val1: ";
  printbits( val1 );

  cout << "rrot: ";
  printbits( rightrot( val1, 3 ));
}

val1: 0000 0000 0000 0000 0111 0101 0000 0111 
rrot: 1110 0000 0000 0000 0000 1110 1010 0000 
      ^^^

{bitwise-octal}
A leading 0 on an integer constant means 'octal' and this seems better than hex
to use with bit pattern.

0 0
1 01
2 10
3 11
4 100
5 101 
6 110
7 110

0177 1.111.111
0x7F 111.1111


={============================================================================
*kt_dev_cpp_0000* cxx-address-alignment

// general platform alignment. not DMA specific
#define SYSTEM_ALIGNMENT (8)

// check if an address is aligned to the given alignment boundry, 
// note: alignment boundry must be a power of two

#define IS_ALIGNED(addr,alignb) (((((uint32_t)(addr))) & (((unsigned)alignb)-1)) == 0)

// return true so aligned
if (IS_ALIGNED(size, SYSTEM_ALIGNMENT)) 
{
  *p_aligned_size = size;
}
// return false so not aligned
else 
{
  *p_aligned_size = ((size / SYSTEM_ALIGNMENT) + 1) * SYSTEM_ALIGNMENT;
}


Why 'alignment byte -1'? 7(111) in this case. Use the fact that 8 bytes
aligned address always has `xxx000` and AND with `0111` always yields 0.

For 4 bytes, use `011`.

dec   bin
0     0000      & 0111 = 0  // ALIGNED
1     0001      & 0111 = !0
2     0010      & 0111 = !0
3     0011      & 0111 = !0
----------
4     0100      & 0111 = !0 
5     0101      & 0111 = !0
6     0110      & 0111 = !0
7     0111      & 0111 = !0
----------
8     1000      & 0111 = 0  // ALIGNED
9   0 1001
10  0 1010
11  0 1011
----------
12  0 1100
13  0 1101
14  0 1110
15  0 1111
----------
16  1 0000
32 10 0000


<cal-len-by-alignment>

// Make a value or an address multiple of __DIAG_ALIGNMENT

#define __DIAG_ALIGNMENT	(4U)
#define DIAG_CMN_ALIGN(x)	(((x) + (__DIAG_ALIGNMENT-1)) &~ (__DIAG_ALIGNMENT-1))

/* Compute total len of message which goes over IPC */
total_len = (uint32_t)messageLen + (uint32_t)DIAG_CMN_ALIGN(client_name_len) + (uint32_t)DIAG_IPC_MSG_HEADER_SIZE;

// (x+3) & ~3

0     0000      3 , 0011 & 1100 = 0
1     0001      4 , 0100 & 1100 = 4
2     0010      5 , 0101 & 1100 = 4
3     0011      6 , 0110 & 1100 = 4
----------
4     0100      7 , 0111 & 1100 = 4
5     0101      8 , 1000 & 1100 = 8
6     0110      9 , 1001 & 1100 = 8
7     0111      10, 1010 & 1100 = 8


={============================================================================
*kt_dev_cpp_0000* cxx-cast cpp-pointer-handle

Use a pointer variable to hold handle.

#include <iostream>

using namespace std;

typedef void* HANDLE;

int _gval = 2;

int main()
{
  cout << "{ main == " << std::endl;

  HANDLE x = (HANDLE) _gval;

  std::cout << x << std::endl;

  cout << "} main == " << std::endl;
}


={============================================================================
*kt_dev_cpp_0000* cxx-issue-incremental-build

2014.08.

Problem: Found that the old code was used in the long debugging sesseion and
made me wonder why it is still called since moved to new code already? Found
that the state was the mix of new and old code. Quite difficult to debug and to
find out what's happened. Limiation of incremental build or make system?

Why: The problem code is

CPort::CPort()
{
#ifdef FS_SUPPORTED
  _smap.insert( std::pair<std::string, IDriver*>("DSM:", new CFs));
  MHEGDebugDebug(eMPORT, "CFs is created");
#else
  _smap.insert( std::pair<std::string, IDriver*>("DSM:", new CDsm));
  MHEGDebugDebug(eMPORT, "CDsm is created");
#endif
...
}

What will happen when use incremental build after removing this #define? This
file was not changed so not compiled in the build. So other new codes were
compiled without this def and this old code compiled with this def. Therefore,
         had CFs object while believeing CDsm object.


={============================================================================
*kt_dev_cpp_0000* cxx-volatile

This is non-portable feature. For values that is controlled by processes
outside the direct control of the program and might be changed in ways outside
the control of the program.

It's a `directive` to the compiler telling that is shoud not perform
'optimisations' on such objects.

static volatile int T=10;

static storage qualifier gives T static storage duration (C++11 §3.7) and
  internal linkage, while volatile still governs the optimization and
  reordering.


={============================================================================
*kt_dev_lang_002* stdio

{redirection}
When shell runs a program, three files are open, with file descriotors 0, 1, 2, called standard
input, output, and error. For redirectins, shell changes default assignment for 0,1,2 to the named
files. All done by shell, but not by a program.

prog <infile
otherprog | prog
prog >outfile
prog | otherprog


{file-io}
library level                                system level
FILE* fopen( char *name, char *mode);        open
int getc( FILE* fp );
int putc( int c, FILE *fp );

#define getchar()    getc(stdin)
#define putchar(c)   putc((c), stdout)

FILE* stdin       stdout, strerr
      keyboard    screen

Every program has these FILE pointers opened automatically.

<example> simple cat program
#include <stdio.h>
#include <stdlib.h>

void filecopy( FILE *ifp, FILE *ofp )
{
  int c;

  while((c = getc(ifp)) != EOF )
    putc( c, ofp );
}

// cat: concatenate files
main( int argc, char *argv[] )
{
  FILE* fp;

  char *prog = argv[0];

  // no args; copy standard input
  if( argc == 1 )
    filecopy( stdin, stdout );
  else
    while(--argc > 0)
      if((fp = fopen( *++argv, "r" )) == NULL )
      {
        fprintf( stderr, "%s: can't open %s\n", prog, *argv );
        exit(1);
      }
      else
      {
        filecopy(fp, stdout);
        fclose(fp);
      }

  // check stream status
  if( ferror(stdout) )
  {
    fprintf( stderr, "%s: error writing stdout\n", prog );
    exit(2);
  }

  exit(0);
}

<why-stderr>
Output written on stderr normally appears on the screen even if the standard output is redirected.

<freopen>
The freopen in stdio.h enables us to bind a file to stdin so can have < redirection effect.

The freopen() function opens the file whose name is the string pointed to by path and associates the
stream pointed to by stream with it. The original stream (if it exists) is closed. The mode argument
is used just as in the fopen() function. The primary use of the freopen() function is to change the
file associated with a standard text stream (stderr, stdin, or stdout).

freopen("input.txt","r",stdin);     // redirects standard input
freopen("output.txt","w",stdout);   // redirects standard output
int x;
cin>>x;           // reads from input.txt
cout<<x<<endl;    // writes to output.txt

<example> compare with stringstream example
#include <iostream>
#include <string>

using namespace std;

// sample input line
// VOD.L 1 100 184.0 183.7
struct StockLine
{
  string  name;
  int     time;
  int     volume;
  float   high;
  float   low;
};

int main()
{
  StockLine sline;

  freopen("input.txt", "r", stdin);

  while(!feof(stdin))
  {
    cin >> sline.name;
    cin >> sline.time;
    cin >> sline.volume;
    cin >> sline.high;
    cin >> sline.low;

    cout << "{ " 
      << sline.name << ", "
      << sline.time << ", "
      << sline.volume << ", "
      << showpoint 
      << sline.high << ", "
      << sline.low << " }" << endl;
  }
}

// input file
VOD.L 1 100 184.0 183.7
ITV.L 4 45 184.55 183.7

// <Q> Why three lines?
{ VOD.L, 1, 100, 184.000, 183.700 }
{ ITV.L, 4, 45, 184.550, 183.700 }
{ ITV.L, 4, 45, 184.550, 183.700 }

The fixed version:

#include <iostream>
#include <string>

using namespace std;

// sample input line
// VOD.L 1 100 184.0 183.7
struct StockLine
{
  string  name;
  int     time;
  int     volume;
  float   high;
  float   low;
};

int main()
{
  StockLine sline;

  freopen("input.txt", "r", stdin);

  while(!feof(stdin))
  {
    cin >> sline.name;
    cin >> sline.time;
    cin >> sline.volume;
    cin >> sline.high;
    cin >> sline.low;

    if(!feof(stdin))                      // note: difference
    {
      cout << "{ " 
        << sline.name << ", "
        << sline.time << ", "
        << sline.volume << ", "
        << showpoint 
        << sline.high << ", "
        << sline.low << " }" << endl;
    }
  }
}


{readline}
<getline> from ansic, section 1.9, p29.
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#define MAXLINE 1000 // maximum input line size

// <one> notice that it includes '\n'
int mygetline(char line[], int maxlen )
{
  int c, i;

  // <Q1> also notice that ' < maxlen-1' leave one space for a null
  for(i = 0; i < maxlen-1 && ((c = getchar()) != EOF) && c != '\n'; i++)
    line[i] = c;

  // <Q2>
  if( c == '\n')
  {
    line[i] = c;
    ++i;
  }

  line[i] = '\0';
  return i;
}

// <two>
int mygetline(char line[], int maxlen )
{
  int c, i;

  for(i = 0; i < maxlen-1 && ((c = getchar()) != EOF); i++)
    line[i] = c;

  line[i] = '\0';
  return i;
}

// copy 'from' into 'to'; assume 'to' is big enough
void copy( char to[], char from[] )
{
  while( *to++ = *from++ )
    ;
}

// print the longest line from stdin
int main()
{
  int curlen;              // current line length
  int maxlen;              // maximum length seen so far
  char line[MAXLINE];
  char longest[MAXLINE];

  maxlen = 0;
  while(( curlen = mygetline( line, MAXLINE )) > 0 )
  {
    printf("while: %s", line);

    if( curlen > maxlen )
    {
      maxlen = curlen;
      copy( longest, line );
    }
  }

  if( maxlen > 0 )
    printf("%s\n", longest);
}


<Q1> What's the difference between one and two?

one: "...\n"

kt@kt-ub-vb:~/work$ ./a.out 
this is one.
while: this is one.
this is two line.
while: this is two line.
this is three line.
while: this is three line.
this is three line.


two: "...\n...\n...\n" 

kt@kt-ub-vb:~/work$ ./a.out 
this is one.
this is two line.
this is three line.
while: this is one.     // pressed C-d
this is two line.
this is three line.

this is one.            // pressed C-d
this is two line.
this is three line.

Notice that use of 'return' size in this call since starts from 0.

0  1  2  3  4  5  6  (return)
h  e  l  l  o  \n \0
1  2  3  4  5  6  7

<Q2> Does it cause accessing out of array index when \n falls in the last of read loop?
When array size is 10, then 0-9 is valid index. The first loop is for [0,8], and [9] for '\n', and
[10] for '\0'?

{
  for(i = 0; i < maxlen-1 && ((c = getchar()) != EOF) && c != '\n'; i++)
    line[i] = c;

  if( c == '\n')
  {
    line[i] = c;
    ++i;
  }

  line[i] = '\0';
}

NO since when 8th reads '\n' and loop stops so no increase. [8] = '\n' and [9] = '\0'. That is the
first loop is [0,8). The [size-1] is reserved for null to make it a string.

read idx: 0 1 2 3 4 5 6 7 8   9
input   : a a a a a a a a '\n'

If use standard liberay to get line, can use:

char *fgets( char *line, int maxline, FILE *fp);
int fputs( char *line, FILE *fp);

However, getline is more useful since returns the line length.

int getline( char *line, int max )
{
  if( fgets( line, max, stdin ) == NULL )
    return 0;
  else
    return strlen(line);
}


<stdio-getline>
ssize_t getline(char **lineptr, size_t *n, FILE *stream);

int main()
{
  int curlen; // current line length
  int maxlen; // maximum length seen so far
  char line[MAXLINE];
  char longest[MAXLINE];

  char* pline = line;
  size_t max = MAXLINE;

  maxlen = 0;
  while(( curlen = getline( &pline, &max, stdin )) > 0 )
  {
    printf("while: %s", line);

    if( curlen > maxlen )
    {
      maxlen = curlen;
      copy( longest, line );
    }
  }

  if( maxlen > 0 )
    printf("%s\n", longest);
}


{io-stream} C++
The ifstream class binds file to stream and then need a call to read data from
stream such as getline(). Further, istream_iterator {stream-iterator} add
iterator features to a stream. However freopen binds file to stdin and can use
cin >> to read data.

<std-getline>
Without including <fstream>, then compiler emits error since there are getline
from stdio and getline from fstream. Updated since there is no error without
fstream header when use g++.

Why use getline()? When do not want to ignore the whitespace in our input
since >> operator removes leading white spaces and read up to see first white
space. 

<ex> for ifstream
#include <iostream>
#include <fstream>
#include <string>

int main()
{
  std::string line;
  int lnum = 0;
  std::ifstream ifs("sample.SWD", std::ifstream::in );

  // while( std::getline( ifs, line ))
  // {
  //   std::cout << lnum << ":" << line << std::endl;
  //   lnum++;
  // }

  std::getline( ifs, line );

  std::string hid = line.substr( 13, 6 );

  int hidi = std::stoi(hid);
  std:: cout << "hid :" << hid << "hid i: " << hidi << std::endl;

  ifs.close();
}


#include <iostream>
#include <fstream>

int main()
{
    std::ofstream ofile("test-out.txt");

    if( !ofile )
    {
        std::cerr << "cannot open output file" << std::endl;
        exit(EXIT_FAILURE);
    }

    ofile << "0: this is sample output file" << std::endl;
    ofile << "1: this is sample output file" << std::endl;
}


{buffered-io} 
In the previous example, uses getline on file stream but when use it with stdin stream, it behaves
differntly. Why? As with FILE, it is buffered.

<example>
#include <iostream>
#include <string>

using namespace std;

int main()
{
  string line;

  while( cin >> line )
    cout << "cout: " << line << endl;

  cout << "end: " << line << endl;
}

$ ./a.out 
this
cout: this
that
cout: that
this is a long line <enter>
cout: this
cout: is
cout: a
cout: long
cout: line
end: line


={============================================================================
*kt_dev_lang_003* #error and #warning

// stops compilation
#error "unknwon cpu - you need to find out the stack grows downward or upward"

// get a mesg during compilation like:
// NDS_pthread.c:43:4: warning: #warning "xxx2" 
#warning "xxx2"


={============================================================================
*kt_dev_cpp_0004* expr-post-and-pre

{value-and-effect}
There are situations where the 'value' of increase is different from the
'effect'. `post-increase` differs in value and effect.

WHEN n = 5: 

x = n++;    // x has 5; value is 5 and effect is 6.
x = ++n;    // x has 6; value is 6 and effect is 6.

When no value is used and use only effect, pre or post are the same:

// when valus is not used
if( c == '\n' )
   nl++;

// when value is used
int val = 5;

fcall( ++val );   // fcall(6);
fcall( val++ );   // fcall(5);


<ex> *ex-squeeze* 
Delete all c from string s. From C prog language, p47. All these are example
where post version is required.

void squeeze(char s[], int c);

// ansic version
void squeeze(char s[], int c)
{
  int i, j;

  for( i = j = 0; s[i] != '\0'; i++ )
    if( s[i] != c )
      s[j++] = s[i];

  s[j] = '\0';
}

// use one var
void squeeze( char s[], int c )
{
  char* scan;

  for( scan = s; *scan; scan++ )
  {
    // if not matches: copy s[current] = s[sacn] and increase s
    if( *scan != c )
      *s++ = *scan;
  }

  *s = *scan;
}

int main()
{
  char arr[] = "this is a program to squeeze";

  cout << arr << endl;

  squeeze( arr, 'e' );

  cout << arr << endl;
}

this is a program to squeeze
this is a program to squz


<ex> *ex-squeeze-two* ansic, exercise 2-4.
Write an alternate version of squeeze(s1,s2) that deletes each character in the
string s1 that matches 'any' character in the string s2.

The key:

* Use t[] as outer loop and run squeeze() for each char in t[].
* Can use t[] as inner loop.
* Both are O(nm).

// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_4
void squeeze2(char s[], char t[]) {
    int i, j, k;
    for (k = 0; t[k] != '\0'; k++) {
        for (i = j = 0; s[i] != '\0'; i++)      // { squeeze1()
            if (s[i] != t[k])
                s[j++] = s[i];
        s[j] = '\0';                            // }
    }
}

void squeeze_mine( char s[], char t[] )
{
  char *run, *write;

  for(; *t; t++)
  {
    for( write = run = s; *run; run++ )
    {
      if( *run != *t )
        *write++ = *run;
    }

    *write = '\0';
  }
}

int main()
{
  char mesg[] = "hello world";
  char mesg2[] = "hello world";

  printf("mesg : %s\n", mesg );
  squeeze( mesg, "l" );
  printf("mesg : %s\n", mesg );

  printf("mesg2 : %s\n", mesg2 );
  squeeze3( mesg2, "ol" );
  printf("mesg2 : %s\n", mesg2 );
}

mesg : hello world
mesg : heo word
mesg2 : hello world
mesg2 : he wrd


*ex-bitset*
All approaches above has the worst case of O(nm). There is an approach to have
O(n+m) but use more space.

#include <iostream>
#include <vector>

using namespace std;

// Cannot use bset[(*t-'a')] since this assumes input is all lower characters.
// For example, for space char(32) index becomes -65 (32-97) and makes a core.

void squeeze( char s[], char t[] )
{
  vector<bool> bset(256); 

  while(*t)
  {
    bset[*t] = true;
    t++;
  }

  for( char* run = s; *run; run++ )
  {
    // *run is different, that is not in the bset then copy
    if( bset[*run] == false )
      *s++ = *run;
  }

  *s = '\0';
}

mesg : hello world
mesg : heo word
mesg2 : hello world
mesg2 : he wrd


<ex> *ex-any* ansic, exercise 2-5. 
Write the function any(s1,s2), which returns the first location in the string s1
where any character from the string s2 occurs, or -1 if s1 contains no
characters from s2.

note: 
The standard library function strpbrk does the same job but returns a pointer to
the location.

char *strpbrk(const char *s, const char *accept);

// not good since based on the "squeeze" approach which means more work to find
// the first time since key chars can happen any order and did not stop on
// "first" match

int any_mine( char s[], char t[] )
{
  int ret = -1;
  int i;

  // run through t[]
  for(; *t; t++)
  {
    // run through s[]
    for( i = 0; s[i]; i++ )
    {
      // found a match
      if( s[i] == *t )
      {
        // update found index when either it's the first time or found the less
        // than the previous
        if( ret < 0 || i < ret )
        {
          ret = i;
          break;
        }
      }
    }
  }

  return ret;
}


*ex-bitset*
http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_5

Here's a much better solution, by Partha Seetala. This solution has a worst-
case time complexity of only O(n + m) which is considerably better.

It works in a very interesting way. He first defines an array with one element
for each possible character in the character set, and then takes the second
string and 'ticks' the array at each position where the second string contains
the character corresponding to that position. It's then a simple matter to loop
through the first string, quitting as soon as he hits a 'ticked' position in the
array.

#include <stdio.h> /* for NULL */

int any(char *s1, char *s2)
{
  // (b) for full ANSIness, #include <limits.h>, make the array unsigned char,
  // cast as required, and specify an array size of UCHAR_MAX(255) + 1.

  char array[256]; 

  int  i;
  if (s1 == NULL) {
    if (s2 == NULL) {
      return(0);
    } else {
      return(-1);
    }
  }

  // (a) by making this char array[256] = {0}; the first loop becomes
  // unnecessary.
  for(i = 0; i < 256; i++) {
    array[i] = 0;
  }

  while(*s2 != '\0') {
    array[*s2] = 1;
    s2++;
  }

  i = 0;
  while(s1[i] != '\0') {
    if (array[s1[i]] == 1) {
      return(i);
    }
    i++;
  }

  // (c) the return statements' (parentheses) are not required.
  return(-1);
}


={============================================================================
*kt_dev_cpp_0004* cpp-postfix-increase

Use `prefix-version` for all cases except when necessary.

<postfix-asm>
Used gcc and asm for MIPS. When try `postfix`, shows `fetch-and-increase`. No
use of the previous copy; j=i; and i+=i; in asm. However, if use user type
then need to have a previous copy to have the same effect. 

// postfix version

#include <stdio.h>

int main()
{
  int i = 0, j = 0;

  j = i++;
  printf("j is %d\n", j );
  return 0;
}

// asm
00400590 <main>:
  400590:       27bdffd8        addiu   sp,sp,-40
  400594:       afbf0024        sw      ra,36(sp)
  400598:       afbe0020        sw      s8,32(sp)
  40059c:       03a0f021        move    s8,sp       # save sp to s8. s8 is sp.
  4005a0:       afc0001c        sw      zero,28(s8) # i = 0
  4005a4:       afc00018        sw      zero,24(s8) # j = 0           // fetch
  4005a8:       8fc2001c        lw      v0,28(s8)   # v0 = i
  4005ac:       afc20018        sw      v0,24(s8)   # j = i
  4005b0:       8fc2001c        lw      v0,28(s8)   # v0 = i
  4005b4:       24420001        addiu   v0,v0,1     # v0(i) = i+1     // i++
  4005b8:       afc2001c        sw      v0,28(s8)   # i = v0
  4005bc:       3c020040        lui     v0,0x40
  4005c0:       24440690        addiu   a0,v0,1680
  4005c4:       8fc50018        lw      a1,24(s8)   # get j and call print
  4005c8:       0c100124        jal     400490 <printf@plt>
  4005cc:       00000000        nop
  4005d0:       00001021        move    v0,zero
  4005d4:       03c0e821        move    sp,s8
  4005d8:       8fbf0024        lw      ra,36(sp)
  4005dc:       8fbe0020        lw      s8,32(sp)
  4005e0:       27bd0028        addiu   sp,sp,40
  4005e4:       03e00008        jr      ra
  4005e8:       00000000        nop
  4005ec:       00000000        nop


// Use -Os. See how it's done. Just use zero to print and no increase.

00400590 <main>:
  400590:       3c040040        lui     a0,0x40
  400594:       27bdffe0        addiu   sp,sp,-32
  400598:       24840658        addiu   a0,a0,1624
  40059c:       afbf0018        sw      ra,24(sp)
  4005a0:       0c100124        jal     400490 <printf@plt>
  4005a4:       00002821        move    a1,zero
  4005a8:       8fbf0018        lw      ra,24(sp)
  4005ac:       00001021        move    v0,zero
  4005b0:       03e00008        jr      ra
  4005b4:       27bd0020        addiu   sp,sp,32  


// pointer version

#include <stdio.h>

void print_array(int arr[], int len)
{
  int *pend;

  pend = arr+len;

  while( arr != pend )
    printf("arr is : %d\n", *arr++ );
}

int main()
{
  int int_arr[] = { 1,2,3,4,5,6,7,8,9,10};

  print_array(int_arr, sizeof(int_arr)/sizeof(int));

  return 0;
}


004005c0 <print_array>:
  4005c0:       27bdffd8        addiu   sp,sp,-40
  4005c4:       afbf0024        sw      ra,36(sp)
  4005c8:       afbe0020        sw      s8,32(sp)
  4005cc:       03a0f021        move    s8,sp
  4005d0:       afc40028        sw      a0,40(s8)  # save arr
  4005d4:       afc5002c        sw      a1,44(s8)  # save len
  4005d8:       8fc2002c        lw      v0,44(s8)  # get len
  4005dc:       00021080        sll     v0,v0,0x2  # v0 = v0 << 2. 101000 (40) for 10 integers
  4005e0:       00401821        move    v1,v0      # v1 = len
  4005e4:       8fc20028        lw      v0,40(s8)  # get arr
  4005e8:       00621021        addu    v0,v1,v0   # v0 = len + arr {pend}
  4005ec:       afc20018        sw      v0,24(s8)  # save v0
  4005f0:       08100188        j       400620 <print_array+0x60>
  4005f4:       00000000        nop
{4005f8}:       8fc20028        lw      v0,40(s8)  #<2> get arr {inced-arr}
  4005fc:       8c430000        lw      v1,0(v0)   #    get *arr note. {deref} 0($x)
  400600:       8fc20028        lw      v0,40(s8)  #    get arr
  400604:       24420004        addiu   v0,v0,4    #    arr++
  400608:       afc20028        sw      v0,40(s8)  #    save arr++
  40060c:       3c020040        lui     v0,0x40    #    
  400610:       24440750        addiu   a0,v0,1872
  400614:       00602821        move    a1,v1      #    *arr
  400618:       0c10012c        jal     4004b0 <printf@plt>
  40061c:       00000000        nop
{400620}:       8fc30028        lw      v1,40(s8)  # <1> get arr {inced-arr}
  400624:       8fc20018        lw      v0,24(s8)  #   get pend {const}
  400628:       1462fff3        bne     v1,v0,4005f8 <print_array+0x38>    # !=
  40062c:       00000000        nop
  400630:       03c0e821        move    sp,s8
  400634:       8fbf0024        lw      ra,36(sp)
  400638:       8fbe0020        lw      s8,32(sp)
  40063c:       27bd0028        addiu   sp,sp,40
  400640:       03e00008        jr      ra
  400644:       00000000        nop

00400648 <main>:
  400648:       27bdffb8        addiu   sp,sp,-72
  40064c:       afbf0044        sw      ra,68(sp)
  400650:       afbe0040        sw      s8,64(sp)
  400654:       03a0f021        move    s8,sp
  400658:       3c020040        lui     v0,0x40
  40065c:       27c30018        addiu   v1,s8,24
  400660:       24420760        addiu   v0,v0,1888
  400664:       24060028        li      a2,40
  400668:       00602021        move    a0,v1
  40066c:       00402821        move    a1,v0
  400670:       0c100130        jal     4004c0 <memcpy@plt> # may be copy array into stack (24)?
  400674:       00000000        nop
  400678:       27c20018        addiu   v0,s8,24
  40067c:       00402021        move    a0,v0   # arr address
  400680:       2405000a        li      a1,10   # len
  400684:       0c100170        jal     4005c0 <print_array>
  400688:       00000000        nop
  40068c:       00001021        move    v0,zero
  400690:       03c0e821        move    sp,s8
  400694:       8fbf0044        lw      ra,68(sp)
  400698:       8fbe0040        lw      s8,64(sp)
  40069c:       27bd0048        addiu   sp,sp,72
  4006a0:       03e00008        jr      ra
  4006a4:       00000000        nop
        ...
004004c0 <memcpy@plt>:
  4004c0:       3c180040        lui     t8,0x40
  4004c4:       8f1917d8        lw      t9,6104(t8)
  4004c8:       03200008        jr      t9
  4004cc:       271817d8        addiu   t8,t8,6104

See <2> since dereference first and increase later.


<postfix-overload>
MEC++06. `postfix` can be ineffective when used on user-type.

The prefix form of the increment operator is sometimes called - increment and
fetch, while the postfix form is often known as fetch and increment.

How distinguish between prefix and postfix form?


class UPInt {                             // "unlimited precision int"
  public:
    UPInt& operator++();                  // prefix ++
    'const' UPInt operator++(int);        // <postfix> ++
    UPInt& operator--();                  // prefix --
    const UPInt operator--(int);          // <postfix> --

    UPInt& operator+=(int);               // a += operator for UPInts and ints
    ...
};

UPInt i;

++i; // calls i.operator++();
i++; // calls i.operator++(0);             // to distinguish with '++i'
--i; // calls i.operator--();
i--; // calls i.operator--(0);

// prefix form: increment and fetch
UPInt& UPInt::operator++()
{
  *this += 1;                   // increment
  return *this;                 // fetch
}

// postfix form: fetch and increment
const UPInt UPInt::operator++(int)
{
  const UPInt oldValue = *this; // fetch
  ++(*this);                    // increment
  return oldValue;              // return what was fetched
}

The only purpose of the parameter is to 'distinguish' prefix from postfix
function invocation. Many compilers issue warnings if you fail to use named
parameters in the body of the function to which they apply, and this can be
annoying. To avoid such warnings, a common strategy is to omit names for
parameters you don't plan to use; that is what is been done above.


<why-const-in-post-inc> const-return
If you have ever wondered if it makes sense to have functions return const
objects, now you know: sometimes it does as seen above postfix of user type.

If not, it allows this:

UPInt i; i++++;

So to make this behave like premitive type, return const. 

#include <iostream>

using namespace std;

int main()
{
  int i = 2;

  cout << i << endl;

  // x.c:11:6: error: lvalue required as increment operand
  // i++++;

  cout << i << endl;

  ++++i;

  cout << i << endl;
}

2
2
4


<should-prefer-pre-inc-when-use-none-premitive>
The prefix increment function has no such temporaries. This leads to the
possibly startling conclusion that, for efficiency reasons alone, clients of
UPInt should prefer prefix increment to postfix increment unless they really
need the behavior of postfix increment.

When dealing with `user types`, prefix increment should be used whenever
possible, because it is inherently more efficient.

The principle is that postfix increment and decrement should be implemented in
terms of their prefix counterparts. You then need only maintain the prefix
versions, because the postfix versions will automatically behave in a
consistent fashion.

Again, CPR p148 recommends prefix version than postfix because post-inc
increase first and return(yield) the previous copy and it cost extra. May have
no effect for built-in types due to optimization but may be expensive for
`iterators`. 


<when-postfix-is-necessary> search for *when-postfix-is-necessary*

int *ip;

*ip++;      // inc ip itself
(*ip)++;    // inc *ip, not ip


<ex> *ex-strcpy*
// copy t to s; pointer version 
// note that library versions of strcpy() and strncpy() functions return a
// pointer to the destination string dest

void strcpy( char *s, char *t )
{
  while( *s++ = *t++ ) 
    ;
}

For *pbeg++, post-increase is high than dereference(*) so it's the same as
*(pbeg++) but how this behave as *(pbeg); pbeg++; ? because it returns the
previous copy which is `value`. This is how CPR explains and matches to asm
result.

Here there are three operations; fetch, increase and dereference.
post-increase do fetch and increase but return the value before increase and
dereference it.


={============================================================================
*kt_dev_cpp_0004* expr-chain

int v1, v2;
cin >> v1 >> v2;

cout << "Enter numbers:" << endl;

Why work? Because operators returns reference of 'lhs' operand which is `cin`
  and `cout`


={============================================================================
*kt_dev_lang_008* type and printf

<1>
{
  printf("ulong max from limits: %luL\n", ULLONG_MAX );
  printf("ulong max from limits: %lluL\n", ULLONG_MAX );
  cout << "ulong max from limits: " << ULLONG_MAX << endl;
}

ulong max from limits: 4294967295L            //         0xffffffff 
ulong max from limits: 18446744073709551615L  // 0xffffffffffffffff
ulong max from limits: 18446744073709551615

This shows that printf outputs differently depending on specifier used.


<2>
{
  unsigned long long umax = UINT_MAX;

  printf("Maximum value of type unsigned int : %llu, 0x%llx\n\n",
      umax, umax);
}

Maximum value of type unsigned int : 4294967295, 0xffffffff

{
  unsigned long long umax = UINT_MAX;

  printf("Maximum value of type unsigned int : %u, 0x%llx\n\n",
      umax, umax);
}

Maximum value of type unsigned int : 4294967295, 0xffffffff00000000

Why different? printf bug?

{
  unsigned int umax = UINT_MAX;

  printf("value of type unsigned int : %u, 0x%x\n\n",
      umax, umax);
}

value of type unsigned int : 4294967295, 0xffffffff

{
  unsigned int umax = UINT_MAX;

  printf("value of type unsigned int : %llu, 0x%llx\n\n",
      umax, umax);
}

value of type unsigned int : 18446744073709551615, 0x10804875b


note:
Looks like that printf uses pointer depending on specifier used.


<3>
Started from a question that "What would happen when do UINT_MAX*16 and put the
result back to unsigned int?"

{
  unsigned int umax = UINT_MAX;

  printf("value of type unsigned int : %u, 0x%x \n", umax, umax);

  unsigned long long ll = 16*umax;

  or

  unsigned int ll = 16*umax;

  printf("value of type unsigned long: %llu, 0x%llx \n", ll, ll);
}

value of type unsigned int : 4294967295, 0xffffffff
value of type unsigned long: 4294967280, 0xfffffff0


<wrap-around>
The result looks like done 16(2^4) shift regardless of type used. Why is that?
This is due to *wrap-around*

CPM P35.

If we assign an out-of-range value to an object of unsigned type, the result is
the 'remainder' of the value 'modulo' the number of values the 'target' type can
hold. For example, 8-bit unsigned char can hold values from 0 through 255
inclusive. If we assign a value outside this range, the compiler assigns the
remainder of that value modulo 256. Therefore, assigning -1 to an unsigned char
gives that object the value 256.

{
  unsigned int umax = UINT_MAX;

  printf("value of type unsigned int : %u, 0x%x \n", umax, umax);

  unsigned long long ll = 2*umax;

  printf("value of type unsigned long: %llu, 0x%llx\n\n", ll, ll);
}

value of type unsigned int : 4294967295, 0xffffffff
value of type unsigned long: 4294967294, 0xfffffffe


{
  unsigned long long umax = UINT_MAX;

  printf("value of type unsigned int : %llu, 0x%llx \n", umax, umax);

  unsigned long long ll = 2*umax;

  printf("value of type unsigned long: %llu, 0x%llx \n", ll, ll);
}

value of type unsigned int : 4294967295, 0xffffffff
value of type unsigned long: 8589934590, 0x1fffffffe

The above shows that wrap-around happens before promotion.


{
  unsigned long long umax = UINT_MAX;

  printf("value of type unsigned int : %llu, 0x%llx \n", umax, umax);

  unsigned long long ll = 16*umax;

  printf("value of type unsigned long: %llu, 0x%llx \n", ll, ll);
}

value of type unsigned int : 4294967295, 0xffffffff
value of type unsigned long: 68719476720, 0xffffffff0



<Q>
Interesting thing found is that when use calculation to get MIN and MAX, cout
prints out MIN without minus sign but printf do. When use real value as limits.h
do, cout prints out minus sign.

#include <iostream>
#include <climits>
#include <cstdio>

using namespace std;

#define MUINT_MAX (~(unsigned)0)

// #define MINT_MAX ((unsigned)~0>>1)
// #define MINT_MIN (-MINT_MAX-1)

// taken from limits.h
#define MINT_MIN  (-MINT_MAX - 1)
#define MINT_MAX  2147483647

int main()
{
  cout << "uint: " << 0 << " - " << UINT_MAX << endl;
  cout << " int: " << INT_MIN << " - " << INT_MAX << endl;

  cout << "uint: " << 0 << " ~ " << MUINT_MAX << endl;
  cout << " int: " << -MINT_MAX-1 << " ~ " << MINT_MAX << endl;

  printf("signed int : %4d ~ %4d \n", MINT_MIN, MINT_MAX );
}

uint: 0 - 4294967295
 int: -2147483648 - 2147483647
uint: 0 ~ 4294967295
 int: -2147483648 ~ 2147483647            // note:
signed int : -2147483648 ~ 2147483647 


={============================================================================
*kt_dev_lang_011* expr-literal

To specify the type of a literal. Primus p40.

{char-and-char-string-literals}

<prefix>    meaning          type
u           unicode 16 char  char16_t
U           unicode 32 char  char32_t
L           wide char        wchar_t
u8          utf-8            char

L'a'
u8"hi!"


{integer-literals}

<suffix>    minimum type
u/U         unsigned
l/L         long
ll/LL       long long

42ULL       // unsigned long long


{floating-literals}

<suffix>    type
f/F         unsigned
l/L         long double

3.14159L    // long double


={============================================================================
*kt_dev_cpp_0004* cpp-pointer-and-array

A pointer is a 'variable' that contains the address of a variable. In other
words, pointer type variable and variable is a label of address. The type
defines the size of variable. For pointer, defines two things; this is a
pointer and the type that this pointer points to. 

The unary operator*() is the `indirection` or `dereference` operator; when
applied pointer, it accesses the 'object' that pointer points to. The
declaration of the pointer ip is intended as a mnemonic:

int *ip;

It says that the expression '*ip' is an 'int'. *ip is used as an 'ordinary'
int variable. note the implication that a pointer is constrained to point to a
particular kind of object: every pointer points to a specific 'type'. 


<void-pointer> 
There is one exception: a pointer to void is used to hold any 'type' of
pointer but 'cannot' be dereferenced itself.

++*ip;
(*ip)++;

The parentheses are necessary in the second example:

ANSI C explains without them, the expression would increase ip instead of what
it points to, because unary operators like * and ++ associate `right-to-left`.
However, in C++, postfix ++ has higher precedence. The both has the same result.
This effect having a pointer increased used in *ex-strcpy* example. 

Also, any pointer can be cast to void* and back again without loss of
information. See *ex-qsort*


<push-and-pop-idiom>
*p++ = val;    // push val onto stack
val = *--p;    // pop top of stack into val

Here *--p decrements p before fetching the character that p points to since
`right-to-left` applies.


<read-and-write>
variable is a readable lable of address whether or not a pointer, so read or
write to it means to get its content but not the address. 

variable = xxx;   // this is an write operation to a memory.
xxx = variable;   // this is an read operation(fetch) from a memory.


{call-by-value-and-reference}
C passes arguments to function by value.

swap( a, b );

void swap(int x, int y)
{
  int temp;

  temp = x;
  x = y;
  y = temp;
}

swap( &a, &b );

void swap(int *x, int *y)
{
  int temp;

  temp = *x;
  *x = *y;
  *y = temp;
}


{pointer-and-array}
An array is a data structure that is similar to the library vector type but
offers different trade-off. Like vector, array is a container of unnamed object
of a 'single' type. Unlike vector, has 'fixed' size. That run-time advantage
comes at the cost of lost flexibility.

In C++ pointers and arrays are closely interwined. The elements in an array are
objects. When subscript an array, the result is the object at that location in
the array. Array has special property. the compiler automatically substitute
array(name) with a pointer to the first element.

The ansic said the name of array is a 'synonym' for the location of the initial
element.

string name[] = {"one", "two", "three"};
string* p = &name[0];   // same
string* p = name;       // same

This means that operations on array are really operations on pointers.


<cpp-pointer-index> from-ansic, indexing and pointer arithmetic
An array-and-index expression is equivalent to one written as a pointer and
offset. 

The pointer version will in general be 'faster'. There is one difference
between an array name and a pointer that must be kept in mind. A pointer is
variable but array name is 'not' a variable. However when pass an array to a
function call as a argument? This is a variable such as strlen(char *);

a[i] can also be written as *(a+i)

int a[10]; int *pa;

pa = a; pa++;     // okay
a = pa; a++;      // error since array name is not variable

* a[n] has [0, n-1]. So a+n points to the off-the-end.

* q-p+1 means the number of elements from p to q 'inclusive' when q > p and p
  and q are pointers within the array. (inclusive since +1)
  
* q-p is the size when arr[size], p is &arr[0] and q is &arr[`off-the-end`]

* a length of a has +1 than a index. Run loop from [0, n-1] or [1, n]

// index
char array[length];             // 10

[0,9]                           // 10 loops
for( i = 0; i < length; i++ )
   array[i];

[1,10]                          // 10 loops when not need index
while( length-- > 0 )
  *ptr++;


<defining-array>
An array declarator has the form a[d], where a is the name and d is the
dimension. note that the number of elements in an array is 'part' of the array's
'type' so must be known at compile time.  That means the dimension is constant
expression.


<array-subscript>
For library types such as string and vector, subscript type is size_type which
is `unsigned`. So if use negative value, then will be 'converted' to the
unsigned. However, for built-in array, it is not so can have negative subscript.
ansic p100.

int *p = &ia[2];
int j = p[1];
int k = p[-2];


<array-init>
int a3[5] = { 0, 1, 2 };   // { 0, 1, 2, 0, 0 } since value-init the rest
int a4[11] = {};           // { 0,...0 } since value-init all


<difference-between-arr-and-parr> cpp-sizeof cpp-array-begin
int main () {

  int arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
  int* parr = new int[100];

  std::vector<int> ivec( std::begin(arr), std::end(arr) );     // 1. okay
  std::vector<int> ivec( std::begin(parr), std::end(parr) );   // 2. error
  std::vector<int> ivec( std::begin(*parr), std::end(*parr) ); // 3. error
  
  return 0;
}

For 2, error: no matching function for call to ‘begin(int*&)’  // typename int*
For 3, error: no matching function for call to ‘begin(int&)’   // typename int

sam01.cpp:14:41: note: candidates are:
/usr/include/c++/4.6/bits/range_access.h:48:5: note: 
  template<class _Container> decltype (__cont.begin()) std::begin(_Container&)
/usr/include/c++/4.6/bits/range_access.h:58:5: note: 
  template<class _Container> decltype (__cont.begin()) std::begin(const _Container&)
/usr/include/c++/4.6/bits/range_access.h:87:5: note: 
  template<class _Tp, unsigned int _Nm> _Tp* std::begin(_Tp (&)[_Nm])
/usr/include/c++/4.6/initializer_list:86:5: note: 
  template<class _Tp> constexpr const _Tp* std::begin(std::initializer_list<_Tp>)

Why? std::begin() shall work with array? Array is different from block of
memory. Here are the libary implementation:

/usr/include/c++/4.6/bits/range_access.h:87:5:

/**
 *  @brief  Return an iterator pointing to the first element of the array.
 *  @param  arr  Array.
 */
template<class _Tp, size_t _Nm>
  inline _Tp*
  begin(_Tp (&__arr)[_Nm])    // note see the size
  { return __arr; }

/**
 *  @brief  Return an iterator pointing to one past the last element
 *          of the array.
 *  @param  arr  Array.
 */
template<class _Tp, size_t _Nm>
  inline _Tp*
  end(_Tp (&__arr)[_Nm])
  { return __arr + _Nm; }


* Array is 'sized' data structure and size is known at 'compile' time and can be
  used implicitly.

* Array is different.


char parray[] = "this is sample string";
char *pnew = "this is sample string";

printf("0: %0x 1: %0x \n", &parray, &parray[0] );
printf("0: %0x 1: %0x \n", &pnew, &pnew[0] );

0: bfc09896 1: bfc09896
0: bfc09890 1: 80489c5 


<3> decltype seems return char * for both but typeid are different. Why?
decltype( parray ) x;
decltype( pnew ) x;

tid: A22_c  // parray
tid: Pc     // pnew

Since the special conversion in array do not happen when use decltype. Really?
YES.

decltype(arr) x = 100;

$ ./comp.sh sam01.cpp 
.cpp: In function ‘int main()’:
.cpp:13:21: error: array must be initialised with a brace-enclosed initialiser

decltype(arr) x;
int y = x;

$ ./comp.sh sam01.cpp 
.cpp: In function ‘int main()’:
.cpp:14:11: error: invalid conversion from ‘int*’ to ‘int’ [-fpermissive]


<4> `op-sizeof` 
cout << "size: " << sizeof(arr) << endl;
cout << "size: " << sizeof(parr) << endl;
cout << "size: " << sizeof(*parr) << endl;

size: 40
size: 4
size: 4


<complicated-array-declaration>
int arr[6];

arr     0        5
[ ] -> [ ][ ]...[ ]

Here arr, &arr[0], &arr have the same address and arr type is int(*arr)[6]. This
is similar to function pointer definition. The size is part of type, that is,
   int(&)[10] in the following case. The parentheses are needed and read from
   inside to outside. 

int (&arrRef) [ 10 ] = arr;   // refers to an array of ten ints

the reference param is bound to the corresponding arg

void print( int (&arr) [ 10 ])
{
  for( auto elem : arr )
    cout << elem << endl;
}

This could also means the first low of multidimensional array and the both are
the same.

void print( int (*matrix)[10], int rowsize );
void print( int matrix[][10], int rowsize );


<complicated-array-type>
As seen above, array arr type is int(*)[6]. Likewise, state_list is **.

typedef struct fsm_instance {
   char*              name;
   fsm_state_t**      state_list;
   fsm_event_t*       event_list;
   fsm_state_t*       current_state;
   fsm_state_t*       previous_state;
} fsm_instance_t;

static Fsm::fsm_state_t* bootStateList[] = {
  &stateClosed,
  ...
  FSM_INVALID_STATE
};

static Fsm::fsm_event_t bootEventList[] = {
  FSM_E(BOOT_EVENT_CLOSED),
  ...
  FSM_E(BOOT_EVENT_STOP)
};

fsm_instance fsm = { "...", &bootStateList, &bootEventList, ... };


<pointers-to-pointers>
From ansic, p107. A stripped-down sort utility. Can use shell and qsort but need
a data representation that will cope efficiently and conveniently with
variable-length text lines. The array of pointers elimiates the twin problems of
complicated storage management and high overhead of moving elements. This is
similar to difference between contiguous and linked list of sort algorithms. 

[ ] -> defghi         [ ]  +->      defghi      
[ ] -> jklmnopqrst    [ ] -+ +->    jklmnopqrst 
[ ] -> abc            [ ] ---+   -> abc         

<ex>
#include <stdio.h>
#include <string.h>

// max #lines to be sorted
#define MAXLINES 5000         

// Means that 1) is a pointer, 2) an array, and 3) has char * type element.
char *lineptr[MAXLINES];

int readlines( char *lineptr[], int nlines );
int writelines( char *lineptr[], int nlines );

void qsort( char *lineptr, int left, int right );

main()
{
  int nlines;     // number of input line read

  if( (nlines = readlines( lineptr, MAXLINES )) >= 0 )
  {
    qsort( lineptr, 0, nlines-1 );     // see [0, nlines-1]
    writelines( lineptr, nlines );
    return 0;
  }
  else
  {
    printf("error: input too big to sort\n");
    return 1;
  }
}

#define MAXLEN 1000     // max length of any input line

int getline( char *, int );
char *alloc(int);

// read inupt lines
int readlines( char *lineptr[], int maxlines )
{
  int len, nlines;
  char *p, line[MAXLEN];

  nlines = 0;

  while( (len = getline( line, MAXLEN )) > 0 )
    if( nlines >= maxlines || (p = alloc(len)) == NULL )
      return -1;
    else
    {
      line[len-1] = '\0';     // delete newline since getline includes a newline.
      strcpy( p, line );
      lineptr[nlines++] = p;  // this makes [0, nlines-1]
    }

  return nlines;
}

void writelines( char *lineptr[], int nlines )
{
  int i;

  for( i = 0; i < nlines; i++ )
    printf("%s\n", lineptr[i] );
}

// or can be written as
void writelines( char *lineptr[], int nlines )
{
  while( nlines-- > 0 )
    printf("%s\n", *lineptr++ );
}

There should be minor changes to qsort and swap.

void swap( char *v[], int i, int j )
{
  char *temp;     // <diff>

  temp = v[i], v[i] = v[j], v[j] = temp;
}

*ex-qsort*
void qsort( char *v[], int left, int right )
{
  int i, last;

  if( left >= right )
    return;

  swap( v, left, (left+right)/2 );

  last = left;

  for( i = left+1; i <= right; i++ )
   if( strcmp( v[i], v[left] ) < 0 )   // <diff>
     swap( v, ++last, i );

  swap( v, left, last );

  qsort( v, left, last-1 );
  qsort( v, last+1, right );
}


<pointers-and-malloc>
How to use malloc to have pointer array?

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main( int argc, char *argv[] )
{
  // Can use "char* result = malloc(...);" However problem is how to use/access
  // allocated memory afterwards. If use result[0] or result++, it moves 1 but
  // not 4. The compiler warns you as:
  //
  // c:21:13: warning: assignment makes integer from pointer without a cast [enabled by default]
  // c:26:9: warning: assignment from incompatible pointer type [enabled by default]
  //
  // After all, memory is memory and address is address. The 'type' is all about
  // how a compiler 'view' it; how to access it via [] or ++. sub script is
  // pointer arithmetic after all.

  // char *result[5];
  char** result = malloc(5*sizeof(*result));

  result[0] = strdup("one");
  result[1] = strdup("two");
  result[2] = strdup("three");
  result[3] = strdup("four");
  result[4] = NULL; // strdup("five");

  // Since it is 'pointer' type array, pointer++ always moves 4 bytes wheather
  // or not array element has char or int pointer. In other words, pointer size
  // is the same regardless of type.

  char** it;

  // to end loop there should be an element which has NULL.
  for(it=result; it && *it; ++it)
  {
    printf("%s\n", *it);
    free(*it);
  }

  free(result);
}


<pointers-vs-multi-dimensional>
From ansic, p112. When pass two dimensional array to a function f, can be
declared as

f( int daytab[2][13] );
f( int daytab[][13] );
f( int (*daytab)[13] );

The last needs () since [] is higher than *. Othewise, it is an array of 13
pointers to integers. The key is that the number of rows is irrelevant to a
compiler and this is how a compiler see an array in contiguous memory.

[0][13]                [1][13]                [2][13]                ...
<-------- 13 ---------><-------- 13 ---------><-------- 13 --------->

The other case is that followings are the same.

void print( const int* );
void print( const int[] );
void print( const int[10] );

From ansic, p113. Given the definitions:

int a[10][20];
int *b[10];

Then a[3][4] and b[3][4] are 'both' syntactically legal references to a single
int. Here legal means both type is the same but can have different
representation. The a is a true two dimensional array; 200 int-sized locations
have been set aside; 20*row+col. For b, however, only allocates 10 pointers.
When each of b has 20 long, it has 200 plus 10 pointers.

The important advantage of the pointer array is that the rows of the array may
be of different length. So can be one int or array of int. In other words, int
*b[10], int **b[10], int ***b[10] are the same.

char *names[] = { "Illegal month", "Jan", "Feb", "Mar" };

names:
[] -> "Illegal month\0"
[] -> "Jan\0"
[] -> "Feb\0"
[] -> "Mar\0"

char names[][15] = { "Illegal month", "Jan", "Feb", "Mar" };

names:
[] -> "Illegal month\0"
[] -> "Jan\0          "
[] -> "Feb\0          "
[] -> "Mar\0          "


={============================================================================
*kt_dev_cpp_0004* pointer-argv

<ex>
ansic, p116. argv example of option handling such as:

// echo command-line arguments
main( int argc, char *argv[] )
{
  while( --argc > 0 )
    printf("%s%s", *++argv, ( argc > 1 ) ? " " : "" );
    // or
    printf(( argc > 1 ) ? "%s " : "%s", *++argv );

  printf("\n");
  return 0;
}


find -x -n pattern
find -xn pattern

int main( int argc, char *argv[] )
{
  int c;

  // <1>
  while( --argc > 0 && (*++argv)[0] == '-' )
    while( c = *++argv[0] )
      switch(c) 
      {
        case 'x':
          printf("x option\n");
          break;
        case 'n':
          printf("n option\n");
          break;
        default:
          printf("unknown option\n");
          break;
      }

  // <2>
  if( argc != 1 )
    printf("usage: find -n -x pattern\n");

  return 0;
}

In <1>, argv is a pointer variable to a array but not array name so can increase it. so (*++argv)[0]
is the first character of argv[1]. Alternative be **++argv. See the skill of using 0 index without
using argv[i] indexing.

while( --argc > 0 && ((*++argv)[0] == '-' ))    // -
    while( c = *++argv[0] )                     // x or n
      printf("%c\n", c );

The *++argv[0] increments the pointer argv[0] but not argv itself. Since argv is alreay increased,
argv[0] means "-nx or -n", then ++ and * means "n".

(gdb) p argv
$5 = (char **) 0xbffff358
(gdb) p *argv
$6 = 0xbffff4f1 "-nx"

<2> this shall always be 1 if all are processed. If argc != 1 but loops ends, means that there are
argvs which does not start with -.


<example>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
  char arr[] = "abcd";
  char *parr = arr;
    
  printf("%c",   *(arr+0) ); // same as printf("%c",   arr[0] );
  printf("%c",   *(arr+1) ); // same as printf("%c",   arr[1] );
  printf("%c",   *(arr+2) ); // same as printf("%c",   arr[2] );
  printf("%c\n", *(arr+3) ); // same as printf("%c\n", arr[3] );

  printf("%c",   *(parr+0) ); // same as printf("%c",   parr[0] );
  printf("%c",   *(parr+1) ); // same as printf("%c",   parr[1] );
  printf("%c",   *(parr+2) ); // same as printf("%c",   parr[2] );
  printf("%c\n", *(parr+3) ); // same as printf("%c\n", parr[3] );

  // error: subscripted value is neither array nor pointer nor vector
  // printf("%c",   (*parr)[0] );
  // printf("%c",   (*parr)[1] );
  // printf("%c",   (*parr)[2] );
  // printf("%c\n", (*parr)[3] );

  printf("%c",   (&*parr)[0] );
  printf("%c",   (&*parr)[1] );
  printf("%c",   (&*parr)[2] );
  printf("%c\n", (&*parr)[3] );
  
  char *pparr[] = {"this is one line", "this is second line"};
  char **ppchar = pparr;

  printf("%s\n",   ppchar[0] );       // this is one line
  printf("%s\n",   ppchar[1] );       // this is second line

  printf("%c\n",   (*ppchar)[0] );    // t
  printf("%c\n",   (*ppchar)[1] );    // h

  printf("%c\n",   *((*ppchar)+0) );  // t
  printf("%c\n",   *((*ppchar)+1) );  // h
} 


<ex>
Have core file when use argv[x]. Why? Turns out that used:

int main(int argc, char *argv);     // fail
int main(int argc, char **argv);    // okay

#include <stdio.h>

int main(int argc, char **argv)
{
    char *ptr = (char*)argv;
    char **pptr = argv;

    printf("argv[0] = %s\n", argv[0]);

    return;
}

(gdb) p ptr
$1 = 0xbfffef54 "\336\360\377\277"
(gdb) p pptr
$2 = (char **) 0xbfffef54
(gdb) p *ptr
$3 = -34 '\336'
(gdb) p *pptr
$4 = 0xbffff0de "/home/kyoupark/work/a.out"
(gdb) p *(char**)ptr
$5 = 0xbffff0de "/home/kyoupark/work/a.out"
(gdb) p/x *ptr
$6 = 0xde
(gdb) 


<ex> *ex-tail* *ex-interview*
see *kt_dev_glib_006* tail-program for a solution.


{pointer-and-string}
char amessage[] = "now is the time";
char *pmessage = "now is the time";

The important difference is that amessage is an array that is 'initialised' with
string constant. Individual characters may be changed. 

On the other hand, pmessage is a pointer, initialised to point to a string
constant and can be modified but undefined if you try to modify the string
contents.


={============================================================================
*kt_dev_cpp_0004* pointer-null

{null-pointer} 
C gurantees that zero is never a valid address for data. Pointer and integers
are not interchangeable but zero is the sole exception. NULL `symbolic-constant`


={============================================================================
*kt_dev_cpp_0004* pointer-reading

Difference between char *a and char a[]

char * and char [] both are used to access character array, Though functionally
both are same, they are syntactically different. See how both works in order to
access string.

A. How char a[] works?

Consider following example for storing and accessing string using character
array.

char a[] = "HELLO";

In the example string "Hello" is stored in character array 'a'. Character array
  is used to store characters in 'contiguous' memory location. It will take
  following form after 'initialization'. We have not specified array size in
  this example. Each array location will get following values -

a[0] = 'H'
a[1] = 'E'
a[2] = 'L'
a[3] = 'L'
a[4] = 'O'
a[5] = '\0'

It will Looks Like This
array a :  H    E    L    L    O '\0'
         a[0] a[1] a[2] a[3] a[4]


Accessing Individual Element :
Suppose we have to find out a[3] then firstly compiler will check whether 'a' is
array or pointer.  If 'a' is array variable then it starts at the location 'a',
      goes three elements past it, and returns the character there. In this
        method element is accessed sequentially

B. How char *a works?

String "Hello" will be stored at any anonymous location in the form of array. We
even don't know the location where we have stored string, However string will
have its starting address. Syntax of char *a :

char *a = "HELLO";

the above syntax will take following form -

pointer a :  H    E    L    L    O '\0'
           a[0] a[1] a[2] a[3] a[4]
           anonymous array

We have declared pointer of type character i.e pointer variable is able to hold
the address of character variable. Now base address of anonymous array is stored
in character pointer variable. 'a' stores base address of the anonymous
array(unknown array)

Address = [Base Address of Anonymous Array]  + [i]

Accessing Individual Element :

Consider we have to access a[3] then

In short if 'a' is a pointer, it starts at the location "a", gets the pointer
value there, adds 3 to the pointer value, and gets the character pointed to by
that value. In both cases a[3] returns same character but procedure is
different.


={============================================================================
*kt_dev_cpp_0004* cpp-pointer-cstring

<ex> *ex-strlen* ansic, p103.  

* strlen excludes NULL which means `size-1`
* `cpp-cstring` needs an extra space for NULL

int strlen( char *s )
{
  char *p = s;

  while( *p != '\0' )
    p++;

  return p-s;             // size-1 when s[size]
}

int main(int argc, char* argv[])
{
  char input[] = "pointer";

  printf("len: %d, size: %d\n", strlen(input), sizeof(input));
}

len: 7, size: 8     // use right version


<cstring-in-memory>

int main(int argc, char* argv[])
{
  // '\n' is character constant(single character) and "\n" is s string constant 

  char str1[] = "\n"; 
  char str2[] = ""; 
  char str3[] = "one"; 
}

(gdb) p str1
$1 = "\n"
(gdb) p str2
$2 = ""
(gdb) p str3
$3 = "one"

(gdb) p /x str1
$4 = {0xa, 0x0}
(gdb) p /x str2
$5 = {0x0}
(gdb) p /x str3
$6 = {0x6f, 0x6e, 0x65, 0x0}


<ex> *ex-strcat* 
Concatenate t to end of s. s must be big enough. The lib version returns a
pointer of resulting string

void strcat( char s[], char t[] )
{
  int i, j;

  i = j = 0;
  while( s[i] != '\0' )               // find end of
    i++;

  // while( s[i++] = t[j++] )         // copy t
  while( (s[i++] = t[j++]) != '\0' )  // copy t, no `postfix-issue`
    ;
}


<ex> *ex-strcat* 
From ansic, exercise 5-3. Write a pointer version of the function strcat that
we showed in Chapter 2: strcat(s,t) copies the string t to the end of s.

// NOT OK when s is empty
// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_5:Exercise_3
void mstrcat_one(char *s, char *t)
{
  while(*++s); /* Get to the end of the string */
  while((*s++ = *t++));
}

void wrong_strcat(char *s, char *t)
{
  while(*s++)     // `postfix-issue`
    ;

  while(*s++ = *t++)
    ;
}

void mstrcat_four(char *s, char *t)
{
  while(*s)
    s++;

  while(*s++ = *t++)
    ;
}


<ex> *ex-strend* 
From ansic, exercise 5-4. pointer arithmetic
Write the function strend(s,t), which returns 1(found) if the string t occurs
at the end of the string s, and 0 otherwise.

// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_5:Exercise_4
// note: Assumption that s is bigger than t.
// note: Use `postfix-issue` but not a problem here since `effect` used to check
// NULL end.

int strend(char *s, char *t)
{
  s += (strlen(s) - strlen(t));     // increments to the point of comparison
  while (*s++ == *t++)              // tests for equality
    if (*s == '\0')                 // NULL end check
      return 1;
  return 0;
}


int strend(char *s, char *t)
{
  int slen = strlen(s);
  int tlen = strlen(t);

  if( slen >= tlen )
  {
    s += (slen - tlen);

    while (*s++ == *t++)
      if (*s == '\0')
        return 1;

    return 0;
  }

  return -1;
}


{off-the-end} *cpp-end* *cpp-pointer-arithmetic*
Pointer arithmetic or comparison is 'undefined' when use pointers that do not
point to members of the 'same' array. It is not legal to add two pointers
while pointer addition is legal; pointer add integer. 

When substracting a pointer p from another pointer q, q-p, the result is the
number of array elements in the sequence [p:q)

{
    int vi[10]{};
    short vs[10]{};

    cout << "vi[5]: " << &vi[5] << ", vi[3]: " << &vi[3] << endl;
    cout << "vi[5]: " << &vi[5]-2 << endl;
    cout << &vi[5] - &vi[3] << endl;
}

vi[5]: 0x7ffdc7831fb4, vi[3]: 0x7ffdc7831fac
vi[5]: 0x7ffdc7831fac
2


As for `off-the-end` iterator, taking a pointer to the element one beyond the
end of an array is guaranteed to work. This is important for many algorithms
(§4.5, §33.1). However, since such a pointer does not in fact point to an
element of the array, it may not be used for reading or writing. The result of
taking the address of the element before the initial element or beyond
one-past-the-last element is undefined and should be avoided. 

#include <iostream>

using namespace std;

int main()
{
  int arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

  cout << "{";

  for( int* b = arr, *e = &arr[10]; b != e; ++b )
    cout << *b << ", ";

  cout << "}" << endl;
}


<ex> *ex-count-keyword*
ansic p137, Keyword counting program.

#include <stdio.h>
#include <ctype.h>
#include <string.h>

#define MAXWORD 100

struct key 
{
  char *word;
  int count;

  // note: must `ordered-list`
} keytab[NKEYS] = { "auto", 0, "break", 0, ... };

int getword( char *, int );
struct key *binsearch( char *, struct key *, int );

main()
{
  char word[MAXWORD];

  struct key *p;

  while( getword( word, MAXWORD ) != EOF )
    if( isalpha( word[0] ) )
      if((p = binsearch( word, keytab, NKEYS )) != NULL )
        p->count++;

  for( p = keytab; p < keytab + NKEYS; p++ )
    if( p->count > 0 )
      printf("%4d %s\n", p->count, p->word );

  return 0;
}

// See how `binary-search` `equality-version` is changed to use structure.
//
// WHY use `off-the-end` but not the last when use pointer?
//
// [0]      [1]     [2]     [3]     [4]     [5]     OFF
// diff 0   diff 1  diff 2  diff 3  diff 4  diff 5 
//  X                                                Y
//
//  Y - X is `size` and the number of items in between excluding Y. However,
//  when use `offset` from the start, use Y-1 as when use `index`
//

struct key *binsearch( char *word, struct key *tab, int n)
{
  int cond;
  struct key *low = &tab[0];
  struct key *high = &tab[n];       // `off-the-end`
  struct key *mid;

  // "low < high" since use of off-the-end but not because of Binary1/Binary2 difference.
  while( low < high )
  {
    // "high-low" is "size" which is different from (low + (size-1))/2. Howerver, doesn't matter.
    mid = low + ( high-low )/2;

    if((cond = strcmp( word, mid->word )) < 0 )
      high = mid;  // why not mid-1? since high is excluded in while condition. not sure.
    else if( cond > 0 )
      low = mid+1;
    else
      return mid;
  }

  return NULL;
}


<ex>
From CPR p112, `forgettable-version` 

vector<string> text;

// As with interator or pointer, use `pointer-arithmetic` to get the middle.
auto begin = text.begin(), end = text.end();
auto middle = text.begin() + (end-begin)/2;

// while there are still elements to look at and we haven't yet found sought.
while( middle != end && *middle != sought )
{
  if( sought < *middle )
    end = middle;              # throw upper
  else
    begin = middle+1;

  middle = begin + ( end - begin )/2;
}

// when no found, begin, end, and middle are the same.


={============================================================================
*kt_dev_cpp_0004* cpp-sizeof

Queries size of the 'object' or 'type'. Used when actual size of the object
must be known at compile time:

sizeof( type )
sizeof expression/object

Both versions return a constant of type std::size_t *cpp-size-t*

Explanation

* returns size in bytes of the object representation of type.
* returns size in bytes of the object representation of the type, that would be
  returned by expression, if evaluated.  

* Depending on the computer architecture, a byte may consist of 8 or more bits,
  the exact number being recorded in CHAR_BIT.

* sizeof(char), sizeof(signed char), sizeof(unsigned char) always return 1.

* Cannot be used with function types, incomplete types, or bit-field lvalues.

* When applied to a reference, the result is the size of the `referenced-type`

* When applied to a class type, the result is the size of an object of that
  class 'plus' any additional padding required to place such object in an array.

* When applied to an empty class type, always returns 1.
  `cpp-empty-base-class-optimization`


<sizeof-which-version>
sizeof(`type`)
sizeof expression/object

must use sizeof(type) for type since syntatical reson:

val1 = sizeof int;

: error: expected primary-expression before 'int'
: error: expected ';' before 'int


struct nlist {
  struct nlist *next;
  char *name;
  char *defn;
};

int main( int argc, char *argv[] )
{
  char val = sizeof(val);
  printf("sizeof is %d\n", val );

  int *pint;
  printf("sizeof is %d\n", sizeof(*pint));

  struct nlist *plist;
  printf("sizeof is %d\n", sizeof(*plist));  

  // <Q> 4 or 12? 12 since it is the same as printf("sizeof is %d\n",
  // sizeof(struct nlist));
}

Here a pointer points to a 'type' and this is a struct in this case.


<to-get-array-size> cpp-array
Two forms and the 'latter' is 'better' since do not need to be changed if the
type changes.

int length= sizeof(arr)/sizeof(int);
int length= sizeof(arr)/sizeof(arr[0]);

<caveat>
int func()
{
  int arr[] = { ... };
  int length= sizeof(arr)/sizeof(int);
  ...
}

This works fine as expected; sizeof(array) returns a size of an array, but if
you pass array in func, it is converted to a pointer and the return of sizeof
is the size of pointer but not the array.

int func(int arr[])
{
  int length = sizeof(arr)/sizeof(int);   // note: THIS DOESN'T WORK!
  ...
}

Why? {difference-between-arr-and-parr} explains.


<ex>
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
  const char *literal = "DSM:!";

  std::cout << "length is " << sizeof("DSM:!") << std::endl;
  std::cout << "length is " << strlen("DSM:!") << std::endl;
  std::cout << "length is " << sizeof("") << std::endl;
  std::cout << "length is " << strlen("") << std::endl;

  std::cout << "length is " << sizeof(literal) << std::endl;
  std::cout << "length is " << sizeof(*literal) << std::endl;
  std::cout << "length is " << strlen(literal) << std::endl;
}

length is 6   // sizeof
length is 5   // strlen
length is 1   // sizeof
length is 0   // strlen

length is 4   // literal
length is 1
length is 5

The strlen() function calculates the length of the string s, 'excluding' the
terminating null byte ('\0'). In other words, strlen knows about a c string
but sizeof do not. Hence sizeof returns +1 more. 

sizeof is better since it is not a func call and done in compile.


={============================================================================
*kt_dev_lang_014* printf-format

{1} The format argument of printf can be an expression too.
printf((argc>1) ? "%s " : "%s", *++argv );

{2} printf-format
int main()
{
  char *pmesg = "0123456789";

  printf("0: %.*s \n", 2, pmesg );
  printf("0: %.*s \n", 3, pmesg );
  printf("0: %.*s \n", 4, pmesg );
  printf("0: %.*s \n", 5, pmesg );
  printf("0: %.*s \n", 6, pmesg );
}

0: 01
0: 012
0: 0123
0: 01234
0: 012345

$ man 3 printf

   The field width
       An optional decimal digit string (with non-zero first digit) specifying
       a minimum field width.  If the converted value has fewer characters
       than the field width, it will be padded with spaces on the left (or
           right, if the left-adjustment flag has been given).  Instead of a
       decimal digit string one may write "*" or "*m$" (for some decimal
           integer m) to spec- ify  that  the field width is given in the next
       argument, or in the m-th argument, respectively, which must be of type
       int.  A negative field width is taken as a '-' flag followed by a
       positive field width.  In no case does a nonexistent or small field
       width cause truncation of a field; if the result of a conversion is
       wider than the field width, the  field is expanded to contain the
       conversion result.

The precision

An optional precision, in the form of a period ('.') followed by an optional
decimal digit string.  Instead of a decimal digit string one may write "*" or
"*m$" (for some decimal integer m) to specify that the precision is given in
the next  argument,  or in the m-th argument, respectively, which must be of
type int.  If the precision is given as just '.', or the precision is
negative, the precision is taken to be zero.  This gives the minimum number of
digits to appear for d, i, o, u, x, and X conversions, the number of digits to
appear after the radix character for a, A, e, E, f, and F conversions, the
maximum number of significant digits for g and G conversions, or the maximum
number of characters to be printed from a string for s and S conversions.

MHEGDebugDebug(eMHEGengRuntime,"OS-OctetStringVariable Append %.*s, %.*s -> %.*s\n",
              (OctetStringVariableEntry(pEntry).m_osValue).size,
              (OctetStringVariableEntry(pEntry).m_osValue).buf,
              osValue.size, osValue.buf,
              osNewValue.size, osNewValue.buf);

{3} print unsigned long value

printf("ulong max from limits: %luL\n", ULONG_MAX );


<converson>

   Format of the format string
       The format string is a character string, beginning and ending in its
       initial shift state, if any.  The format string is composed of zero or
       more  directives:  ordinary  characters (not  %),  which  are  copied
       unchanged to the output stream; and conversion specifications, each of
       which results in fetching zero or more subsequent arguments.  Each
       conversion specification is introduced by the character %, and ends
       with `a conversion specifier`  


      In between there may be (in this order) zero or more `flags`, an
      optional minimum `field width`, an optional `precision` and an optional
      `length modifier`


   The flag characters

       The character % is followed by zero or more of the following flags:

       #      The value should be converted to an "alternate form".  
       For o conversions, the first character of the output string is made
       zero (by  prefixing  a  0  if  it  was  not  zero already).   
       
       For  x and  X  conversions, a non-zero result has the string "0x" (or
           "0X" for X conversions) prepended to it.  For a, A, e, E, f, F, g,
       and G conversions, the result will always contain a decimal point, even
       if no digits follow it (normally, a decimal point appears in the
           results of those conversions only  if  a  digit  follows).  
       
       For g and G conversions, trailing zeros are not removed from the result
       as they would otherwise be.  For other conversions, the result is
       undefined.

       <ex>
       DIAG_LOG_INFO(g_planner_diag_segment_id, 
           ("Created booked programme handle %#x, session %#x", handle, booking->session->self_handle));

   The conversion specifier

       A character that specifies the type of conversion to be applied.  The
       conversion specifiers and their meanings are:

       d, i   The int argument is converted to signed decimal notation.  The
       precision, if any, gives the minimum number of digits that must appear;
       if the converted value requires fewer digits, it is padded on the left
       with  zeros.  The default precision is 1.  When 0 is printed with an
       explicit precision 0, the output is empty.

       o, u, x, X The  `unsigned-int` argument is converted to unsigned octal (o),
       unsigned decimal (u), or unsigned hexadecimal (x and X) notation.  The
       letters abcdef are used for x conversions; the letters ABCDEF are used
       for X conver- sions.  The precision, if any, gives the minimum number of
       digits that must appear; if the converted value requires fewer digits, it
       is padded on the left with zeros.  The default precision is 1.   When  0
       is  printed with an explicit precision 0, the output is empty.


       a, A   (C99;  not  in  SUSv2,  but  added in SUSv3) For a conversion, the
       `double` argument is converted to hexadecimal notation (using the letters
               abcdef) in the style [-]0xh.hhhhp±; for A conversion the prefix
       0X, the letters ABCDEF, and the exponent separator P is used.  There is
       one hexadecimal digit before the decimal point, and the number of digits
       after it is equal to the precision.  The default precision suffices for
       an  exact  repre- sentation of the value if an exact representation in
       base 2 exists and otherwise is sufficiently large to distinguish values
       of type double.  The digit before the decimal point is unspecified for
       nonnormalized numbers, and nonzero but otherwise unspecified for
       normalized numbers.

<not-use-printf>
#include <cstdio>
#include <iostream>

int main()
{
    double d_val = 3.14;
    int i_val = d_val;
    double d_vval = i_val;

    std::cout << "d_val: " << d_val << ", i_val: " << i_val << std::endl;
    std::cout << "d_val: " << d_val << ", i_val: " << i_val << ", d_vval: " << d_vval << std::endl;

    printf ("d_val: %e, i_val: %e, \n", d_val, i_val );
    printf ("d_val: %e, i_val: %e, d_vval: %e \n", d_val, i_val, d_vval);
}

d_val: 3.14, i_val: 3
d_val: 3.14, i_val: 3, d_vval: 3
d_val: 3.140000e+00, i_val: 3.034283e-86,
d_val: 3.140000e+00, i_val: 3.000000e+00, d_vval: 0.000000e+00


={============================================================================
*kt_dev_lang_015* expr-control-flow

{control-switch}
To emphasize that the cases represent a range of values:

switch(ch)
{
  case 'a': case 'e': case 'i': case 'o': case 'u':
    ...
  break;
}

note: 
It can be useful to define a default label even if there is no work for the case
to indicate that the case was considered.

<switch-under-the-hood>
http://stackoverflow.com/questions/3012011/switch-case-assembly-level-code

Here is the C source:

switch(i)
{
    case 1:
    {
        printf("Case 1\n");
        break;
    }
    case 2:
    {           printf("Case 2\n");
        break;
    }
    case 3:
    {
        printf("Case 3\n");
        break;
    }
    case 4:
    {
        printf("Case 4\n");
        break;
    }
    // omitted to 10:
    default:
    {
        printf("Nothing\n");
        break;
    }
}  

Now the resultant assembly for the same is:

movl    $5, -4(%ebp)
cmpl    $10, -4(%ebp)
ja  L13
movl    -4(%ebp), %eax
sall    $2, %eax
movl    L14(%eax), %eax
jmp *%eax
.section .rdata,"dr"
.align 4
L14:
.long   L13
.long   L3
.long   L4
.long   L5
.long   L6
.long   L7
.long   L8
.long   L9
.long   L10
.long   L11
.long   L12
.text
L3:
movl    $LC0, (%esp)
call    _printf
jmp L2
L4:
movl    $LC1, (%esp)
call    _printf
jmp L2
L5:
movl    $LC2, (%esp)
call    _printf
jmp L2
L6:
movl    $LC3, (%esp)
call    _printf
jmp L2
L7:
movl    $LC4, (%esp)
call    _printf
jmp L2
L8:
movl    $LC5, (%esp)
call    _printf
jmp L2
L9:
movl    $LC6, (%esp)
call    _printf
jmp L2
L10:
movl    $LC7, (%esp)
call    _printf
jmp L2
L11:
movl    $LC8, (%esp)
call    _printf
jmp L2
L12:
movl    $LC9, (%esp)
call    _printf
jmp L2
L13:
movl    $LC10, (%esp)
call    _printf
L2:  

First the code is comparing the i to 10 and jumping to the default case when the
value is greater then 10 (cmpl $10, -4(%ebp) followed by ja L13). The next bit
of code is shifting the input to the left by two (sall $2, %eax) which is the
same as multiple by four (it multiplies by 4 because each entry in the jump
    table is 4 bytes long). So what is had done here is generated an offset into
the jump table. It then loads an address from the jump table (movl L14(%eax),
    %eax) and jumps to it (jmp *%eax).

The `jump-table` is simply a list of addresses (represented in assembly code by
    labels):

L14:
.long   L13
.long   L3
.long   L4
...

One thing to notice is that L13 represents the default case. It is both the
first entry in the jump table (for when i is 0) and is handled specially at the
beginning (when i > 10).

<01>
@puffadder: most modern compilers use heuristics to determine when it's more
efficient to use branches versus a jump table. E.g. if your case levels were say
1, 100 and 1000 you might expect branches to be used. - Paul R Jun 10 '10 at
7:07 

<02>
You have a switch statement with 5 case statements and the cases all have
numbers that are spread far apart so a jump table will not be used, 'if type'
will. {Q} May choose not to use a jump table because there will be entries which
are not used? Up to a compiler?

<switch-grouping>

typedef enum {
  E_01,    //
  E_02,
  E_03,
  E_11,    //
  E_12,
  E_13,
  E_21,    //
  E_22,
  E_23,
  E_31,    //
  E_32,
  E_33
} EVENTS;

typedef enum {
  E_G00, E_G01, E_G02, E_G03, E_GNO
} GROUPS;

int getEventGroup( int events )
{
  switch( events )
  {
    case E_01: case E_02: case E_03:
      return E_G00;
      break;
      ...

    default:
        return E_GNO;
        break;
        std::cout << "IS IT EXECUTED?? " << events << std::endl;
  }
}

int main()
{
  int events = E_11;

  while( cin >> events )
  {
    switch( getEventGroup(events) )
    {
      case E_G00:
        std::cout << "E_G00" << std::endl;
        break;

        ...

      case E_GNO:
          std::cout << "E_GNO" << std::endl;
          break;

      default:
          std::cout << "E_?? " << events << std::endl;
          break;
    }
  }
}

OR

int main()
{
  int events = E_11;

  while( cin >> events )
  {
    switch( events )
    {
      case E_01: case E_02: case E_03:
        std::cout << "E_G00" << std::endl;
        break;

        ...

      case E_GNO:
          std::cout << "E_GNO" << std::endl;
          break;

      default:
          std::cout << "E_?? " << events << std::endl;
          break;
    }
  }
}

The both do the same. The first is a bit clearer at the expense of one function
call?


<does-it-work>
Found it in the real code. Does the line after default get executed? NO.

switch( events )
{
  case E_01: case E_02: case E_03:
    ...
      break;
  default:
    return E_GNO;
    break;
    std::cout << "IS IT EXECUTED?? " << events << std::endl;
}


={============================================================================
*kt_dev_cpp_0000* cpp-loop cpp-for cpp-while cpp-side-effect

The `cpp-for-loop` is preferable when there is a simple initialization and
increment since it keeps the loop control statement 
  `close together and visiable` at the top of the loop.


<cpp-range-for>
The `range-for` is supported from GCC 4.6

Two points:

  * range-for caches `begin()` and `end()` so has risk of using `invalidated-iterators`
  * shall use `const&` in for loop statement to avoid unnecessary copy.
  * do not call end() in every loop

for( T &r : vec )
   r *= 2;

is interpreted as:

for( auto beg = vec.begin(), end = vec.end(); beg != end; ++beg )
{
  T &r = *beg;
  r *= 2;
}

The range for changes way to access element:

{
  for( const auto &elem : coll )
    cout << elem << " ";
}

{
  for (const auto it = coll.cbegin(); it != coll.cend(); ++it)
    cout << *it << " ";
}


<ex> *ex-escape* 
From ansic, exercise 3-2. Write a function escape(s,t) that converts
characters like newline and tab into visible escape sequences like \n and \t
as it copies the string t to s. Use a switch. Write a function for the other
direction as well, converting escape sequences into the real characters.


void escape(char* s, char* t)
{
  // when use "while(*t++)", the result missed out the first char. WHY?
  // since do not use side-effect.

  while( *t )
  {
    switch(*t)
    {
      case '\t':
        *s++ = '\\';    // note to escape
        *s++ = 't';
        break;

      default:
        *s++ = *t;
        break;
    }

    t++;
  }
  
  *s = '\0';
}


  `while(expression)`
    statement

  "If expression is non-zero, statement is executed and expression is
  re-evaluated." 


{cpp-side-effect} from online
A "side effect" is defined by the C++ standard in [intro.execution], by:

Reading an object designated by a volatile glvalue (3.10), modifying an
object, calling a library I/O function, or calling a function that does any of
those operations are all side effects, which are `changes` in the state of the
execution environment.

y = (x = d) * 5; // sets y to 15.

The value returned from x = d, is its main effect. The changing of the value
of x is a side effect.


  ""Therefore, the point is whether or not `evaluation` cause side-effect and 
  use `side-effect` afterwords.""


<ex>
// use pointer arithmetic to return length
int mstrlen_1(const char *s)
{
    const char *p = s;

    while (*s)
        ++s;

    return s-p;
}

// use a variable to return length
int mstrlen_2(const char *s)
{
    unsigned int i = 0;

    while (*s)
    {
        ++s;
        ++i;
    }

    return i;
}

// there is a side-effect but not used. Hence okay.
int mstrlen_3(const char *s)
{
    unsigned int i = 0;

    while (*s++)
        ++i;

    return i;
}

// side-effect is used in getting a length. Hence not okay.
int mstrlen_4(const char s[])
{
  const char *run = s;

  while (*run++)
    ;

  return run-s;
}

// there is a side-effect but not used. Hence okay.
int mstrlen_5(const char s[])
{
  const char *run = s;

  while (*run)
    ++run;

  return run-s;
}

void t_mstrlen()
{
    const char *input = "01234567890123456";

    printf("mstrlen is %d\n", mstrlen_1(input));
    printf("mstrlen is %d\n", mstrlen_2(input));
    printf("mstrlen is %d\n", mstrlen_3(input));
    printf("mstrlen is %d\n", mstrlen_4(input));
    printf("mstrlen is %d\n", mstrlen_5(input));
}

mstrlen is 17
mstrlen is 17
mstrlen is 17
mstrlen is 18
mstrlen is 17


<ex> *ex-strcpy*

void strcpy( char *s, char *t )
{
  while( *s++ = *t++ ) 
    ;
}


Why not show a problem? Evaluation do copy and increase pointers. However
side-effects are not used and no problem. 


<ex> *ex-atoi* atoi second version in ansic p61
#include <ctype.h>

int atoi(char s[])
{
  int i, n, sign;

  // skip white spaces
  for(i = 0; isspace( s[i] ); i++)
    ;

  sign = (s[i] == '-') ? -1 : 1;

  // skip sign
  if( s[i] == '+' || s[i] == '-' )
    i++;

  for(n = 0; isdigit( s[i] ); i++)
    n = n*10 + (s[i]-'0');

  return sign*n;
}


Again shows the side-effect issue. If use the approach as below then miss out
the one char. When there is no leading space, expect i==0 when loop ends but
i==1 since will have the side effect.

int atoi(char s[])
{
  int i, n, sign;

  // skip white spaces
  while( isspace(s[i++]) )
    ;
  ...
}


Two solutions:

int atoi(char s[])
{
  int i, n, sign;

  // skip white spaces
  for(i = 0; isspace( s[i] ); i++)
    ;
}

int atoi(char s[])
{
  int i, n, sign;

  // skip white spaces
  while( isspace(s[i]) )
    i++;
}


<ex>
Similar to ex-bitcount but this gets the number of interation while input has
1 bit so effectly gets MSB position.

#include <iostream>

using namespace std;

int main()
{
  // 1100 1110 0101, [11..0]
  // unsigned int input = 3301;

  unsigned int count = 0;

  // gets 12
  for(count=0; input; input >>= 1)
    ++count;

  // gets 11
  for(count=0; input && (input>>=1);)
    ++count;
  
  // gets 11
  while(input && (input >>= 1))
    ++count;

  cout << "count: " << count << endl;
}


<ex> *ex-expand* 
From ansic, exercise 3-3. Write a function expand(s1,s2) that expands
shorthand notations like a-z in the string s1 into the equivalent complete
list abc...xyz in s2. Allow for letters of either case and digits, and be
prepared to handle cases like a-b-c and a-z0-9 and -a-z . Arrange that a
leading or trailing - is taken literally

#include <stdio.h>
#include <ctype.h>

#define UP(N) ((N) >= 'A' && (N) <= 'Z')
#define LO(N) ((N) >= 'a' && (N) <= 'z')
#define NU(N) ((N) >= '0' && (N) <= '9')
#define AN(N) (UP(N) || LO(N) || NU(N))

// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_3:Exercise_3
// Pilcrow 20:33, 14 September 2011 (UTC) 
int expand_online(const char s1[], char s2[], int sz)
{
  int i, j, temp;

  j=0;
  for(i = 0; s1[i] != '\0'; i++) {
    if(j >= sz) return 0;                                   /* buffer overflow */
    if(i==0 || s1[i] != '-') {                              /* first character or not '-'*/
      s2[j++] = s1[i];
      continue;
    }
    if(s1[i] == '-' && (!AN(s1[i-1]) || !AN(s1[i+1]))) {    /* leading, trailing, isolated '-' */
      s2[j++] = s1[i];
      continue;
    }
    if(s1[i] == '-' && (
          (UP(s1[i-1]) && UP(s1[i+1]) && s1[i-1] < s1[i+1]-1) ||
          (LO(s1[i-1]) && LO(s1[i+1]) && s1[i-1] < s1[i+1]-1) ||
          (NU(s1[i-1]) && NU(s1[i+1]) && s1[i-1] < s1[i+1]-1))) {
      temp = s1[i-1]+1;
      while (temp < s1[i+1]) {
        s2[j++] = temp++;
      }
      continue;
    }
    s2[j++] = s1[i];                                            /* didn't hit any 'continue's */
  }
  s2[j] = '\0';
  return 1;
}

// mine
int check( char a, char b )
{
  // do not support 'z-a-' and this outputs 'a-'
  // if( (isalpha(a) && isalpha(b)) || (isdigit(a) && isdigit(b)) )
  //   return 1;

  if( (isalpha(a) && isalpha(b)) && (a <= b) )
    return 1;

  if( (isdigit(a) && isdigit(b)) && (a <= b) )
    return 1;

  return 0;
}

void expand( const char s1[], char s2[] )
{
  // a-a
  // a-!
  // a-z
  // aa-z
  // a-9
  // a- a-z
  // ---a
  // a-z0-9
  // a-c-f
  // a-0-8 -> 012345678
  // -a-z
  // so "a-" is a signal to check

  // <outline-second>
  // while( s1 is not null )
  // {
  //    // a-z, a-z0-9, a-b-d,
  //    if( s1 is alphabet or number AND s1+1 is - )
  //    {
  //      // check if it is valid token; alpha and alpha or number and number
  //      if(check(s1,s1+2)) // valid
  //      {
  //        for(char first = s1[]; first <= s1+2; )
  //        {
  //          copy first; s2++; first +=1;
  //        }
  //      }
  //      else
  //        copy s1, s1+1 to S2; // 'a-'
  //        s1 += s1+2; // move two
  //    }
  //    else // handles all invaild cases including a leading or trailing - is taken literally
  //    {
  //      copy s1 to s2;
  //      s1++;
  //    }
  //
  //  } // while end

  while( *s1 )
  {
    if( isalnum(*s1) && (*(s1+1) == '-' ) )
    {
      if( check( *s1, *(s1+2)) )
      {
        for( char start = *s1; start < *(s1+2); start +=1 )
          *s2++ = start;

        s1 += 2;
      }
      else
      {
        *s2++ = *s1++;
        *s2++ = *s1++;
      }
    }
    else
    {
      *s2++ = *s1++;
    }
  } // while end

  // note that missed this in the first place
  *s2 = '\0';
}

int main(int argc, char* argv[])
{
  const char *s[] = {   // <pointers-to-pointers>
    "a-z-", 
    "z-a-", 
    "-1-6-",
    "a-ee-a", 
    "a-R-L", 
    "1-9-1",
    "5-5", 
    "C-Y", 
    "a-z0-9", 
    NULL };

  // one
  {
    char result[100]={0};
    int i = 0;

    printf("=============\n");

    while ( s[i] ) {

      /*  Expand and print the next string in our array s[]  */
      expand_online(s[i], result, 99);
      printf("Unexpanded: %s\n", s[i]);
      printf("Expanded  : %s\n", result);
      ++i;
    }
  }

  // two
  {
    char result[100]={0};
    int i = 0;

    printf("=============\n");

    while ( s[i] ) {

      /*  Expand and print the next string in our array s[]  */
      expand(s[i], result);
      printf("Unexpanded: %s\n", s[i]);
      printf("Expanded  : %s\n", result);
      ++i;
    }
  }

  return 0;
} 

Q: //how will the input 5-5-5 can be handled ? will it output to "555" or "55" or "5" ? 

$ ./a.out 
=============
Unexpanded: a-z-
Expanded  : abcdefghijklmnopqrstuvwxyz-
Unexpanded: z-a-
Expanded  : z-a-
Unexpanded: -1-6-
Expanded  : -123456-
Unexpanded: a-ee-a
Expanded  : abcdee-a
Unexpanded: a-R-L
Expanded  : a-R-L
Unexpanded: 1-9-1
Expanded  : 123456789-1
Unexpanded: 5-5
Expanded  : 5-5
Unexpanded: C-Y
Expanded  : CDEFGHIJKLMNOPQRSTUVWXY
Unexpanded: a-z0-9
Expanded  : abcdefghijklmnopqrstuvwxyz0123456789
=============
Unexpanded: a-z-
Expanded  : abcdefghijklmnopqrstuvwxyz-
Unexpanded: z-a-
Expanded  : z-a-
Unexpanded: -1-6-
Expanded  : -123456-
Unexpanded: a-ee-a
Expanded  : abcdee-a
Unexpanded: a-R-L
Expanded  : a-R-L
Unexpanded: 1-9-1
Expanded  : 123456789-1
Unexpanded: 5-5
Expanded  : 5
Unexpanded: C-Y
Expanded  : CDEFGHIJKLMNOPQRSTUVWXY
Unexpanded: a-z0-9
Expanded  : abcdefghijklmnopqrstuvwxyz0123456789


<ex>

// from stl
find(const char_type* __s, std::size_t __n, const char_type& __a)
{
  for (std::size_t __i = 0; __i < __n; ++__i)
    if (eq(__s[__i], __a))
      return __s + __i;
  return 0;
}

// from EXCPC++ p6
find(const char* s, int n, char a)
{
  while(n-- > 0 & toupper(*s) != toupper(a))
  {
    ++s;
  }

  return n >= 0 : s : 0;
}


{cpp-side-effect} {cpp-operator-comma}
The comma operator is a sequence point (as they are && and ||) so the order of
evaluation of the operands is 'fixed'. It is a binary operator that evaluates
its first operand, performs all side effects and discards the result, and then
evaluates the second operand and returns its value.

Any number of expressions separated by commas can form a single expression
because the comma operator is associative. 

The use of the comma operator guarantees that the sub-expressions will be
evaluated in `left-to-right` order, and the value of the last becomes the
value of the entire expression:

x = (y, z);

will do y and, after performing all `side effects`, will discard it, then do z
and finally will set x to z.

Because the comma operator discards its first operand, it is useful where the
first operand has `desirable side effects`, such as in the initializer or the
counting expression of a for loop. Used to produce side effects.

For example, this for statement:

for( p=0; p+=(a&1)*b,a!=1; a>>=1,b<<=1 )
   ...

can be re-written:

p=0;
p+=(a&1)*b;          // see
while (a!=1) {
    ...
    a>>=1;
    b<<=1;
    p+=(a&1)*b;      // see
}

The primary use of the comma operator is `to produce side effects` in the
following situations:

Calling a function
Entering or repeating an iteration loop
Testing a condition
Other situations where a side effect is required but the result of the
expression is not immediately needed

for (i=0; i<2; ++i, f() );

A for statement in which i is incremented and f() is called at each iteration.

if ( f(), ++i, i>1 ) { /* ... */ } 

An if statement in which function f() is called, variable i is incremented,
   and variable i is tested against a value. The first two expressions within
   this comma expression are evaluated before the expression i>1. Regardless
   of the results of the first two expressions, the third is evaluated and its
   result determines whether the if statement is processed.

func( ( ++a, f(a) ) ); 

A function call to func() in which a is incremented, the resulting value is
passed to a function f(), and the return value of f() is passed to func(). The
function func() is passed only a single argument, because the comma expression
is enclosed in parentheses within the function argument list.


{control-break-continue}
<ex> *ex-trim* 
from ansic, p65. Remove trailing blanks, tabs, newlines.

int trim( char s[] )
{
  int n;

  // see `strlen(s)-1`
  for(n = strlen(s)-1; n > 0; n--)
    if( s[n] != ' ' && s[n] != '\t' && s[n] != '\n' )
      break;

  s[n+1] = '\0';
  return n;
}

Sacn backwards looking for the first character that is not a blank, tab or
newline. May perform better than searching from the beginning.

note:
negative or positive in ascii?

for( i = 0; i < n; i++ )
{
  // skip negative elements
  if( a[i] < 0 )
    continue;

  // do positive elements
}


{control-goto}
From ansic, p66, this is handy if the error handling is `nontrivial` and can
occur in several places.

for( ... )
  for( ... )
  {
    ...

    if(disaster)
      goto error:
  }
...

error:
   clean up the mess

The goto can always be written without one.

for( i = 0; i < n; i++ )
   for( j = 0; j < m; j++ )
      if( a[i] == b[j] )
         goto found;          // how about return

// didn't find any common elements

found:
  // got one


found = 0;
for( i = 0; i < n && !found; i++ )     // note !found <goto-alternative>
   for( j = 0; j < m && !found; j++ )
      if( a[i] == b[j] )
         found = 1;

if(found)
  // got one
else
  ...
  // didn't find any common elements


={============================================================================
*kt_dev_lang_016* cpp-precedence

http://en.cppreference.com/w/cpp/language/operator_precedence

From CPR 4.12 P166.

The following table lists the precedence and associativity of C++ operators.
Operators are listed top to bottom, in descending precedence. Where no
associativity follows the above one and same precedence in each segment. 

Precedence Operator, Description, Use, Associativity, (L)eft-to-right

 ::               global scope                  ::name                      L
                  class                         class::name
                  namespace                     namespace::name
 ----------------------------------------------------------------------------
 .                member selector               object.member               L
 ->               member selector               pointer->member
 []               subscript                     expr[ expr ]
 ()               function call                 name( expr_list )
 ()               type construction             type( expr_list )
 ----------------------------------------------------------------------------
 ++               post increment                lvalue++                    R
 --               post decrement                lvalue++
 typeid           type ID                       typeid(type)
 explicit cast    type conversion               cast_name<type> expr
 ----------------------------------------------------------------------------
 ++               pre increment                 ++lvalue++                  R
 --               pre decrement                 --lvalue++
 ~                'bitwise' not                   ~expr
 !                logical not                   !expr
 -                unary minus                   -expr
 +                unary plus                    +expr
 *                `dereference`                   *expr
 (TODO)

3 ++   -- [Prefix] increment and decrement            Right-to-left
  + -                Unary plus(+) and minus(-)
  ! ~                Logical NOT and bitwise NOT
  (type)             Type cast
  *                  Indirection (dereference)
  &                  Address-of
  sizeof             Size-of
  new, new[]         Dynamic memory allocation
  delete, delete[]   Dynamic memory deallocation
 ----------------------------------------------------------------------------
4 .* ->*    Pointer to member                         Left-to-right
 ----------------------------------------------------------------------------
5 * / %     Multiplication, division, and remainder
 ----------------------------------------------------------------------------
6 + -       Addition(+) and subtraction(-)
 ----------------------------------------------------------------------------
7 << >>     'bitwise' left shift and right shift
 ----------------------------------------------------------------------------
8 < <=      For relational operators < and <= respectively
  > >=      For relational operators > and >= respectively
 ----------------------------------------------------------------------------
9 == !=     For [relational] = and != respectively
 ----------------------------------------------------------------------------
10 &        Bitwise AND
 ----------------------------------------------------------------------------
11 ^        Bitwise XOR (exclusive or)
 ----------------------------------------------------------------------------
12 |        Bitwise OR (inclusive or)
 ----------------------------------------------------------------------------
13 &&       Logical AND   `short-circuit-evaluation`
 ----------------------------------------------------------------------------
14 ||       Logical OR
 ----------------------------------------------------------------------------
15 ?:             Ternary conditional                       Right-to-left
   =              Direct [assignment] (provided by default for C++ classes)
   += -=          Assignment by sum and difference
   *=  /=  %=     Assignment by product, quotient, and remainder
   <<= >>=        Assignment by bitwise left shift and right shift
   &=  ^=   |=    Assignment by bitwise AND, XOR, and OR
 ----------------------------------------------------------------------------
16 throw          Throw operator (for exceptions)
 ----------------------------------------------------------------------------
17 ,              Comma                                     Left-to-right 


{io-operators}

CPR p155.

The IO operators are `overloaded-version` of shift operators for IO. An
overloaded operator has the `same-precedence-and-associativity` as the built-in
version of that operator and has `left-associative`.

cout << "hi" << " there" << endl;

executes as

((cout << "hi") << " there") << endl;


={============================================================================
*kt_dev_lang_016* cpp-order-evaluation

{precedence-associativity}

CPR p135.

An expression with two or more operators is a `compound-expression`. Evaluating
compound expression involves `grouping` the operand to the operators.

The value of an expression depends on how the subexpressions are grouped.

`precedence` and `associativity` determine how the operands are grouped. That
is, they determine which parts of the expression are the operands for each of
the operators in the expression. `associativity` determines how to group
operands with the same `precedence`

Users can override these rules by parenthesizing to force a particular grouping
as a subexpression.

`precedence` says nothing about the order in which the operands are evaluated.
This is `order-of-operand-evaluation`.

<ex>
6 + 3 * 4 / 2 + 2;

equivalent to:

((6 + ((3 * 4) / 2)) + 2);

Can think that `inner-group` is evaluated first even if the evaluation order in
that group is unspecified? NO when involves `evaluation`


CPR p138.

<cpp-order-of-evaluation> *cpp-undefined*
The `order-of-operand-evaluation` is `independent` of `precedence` and
`associativity`.

f() + g() * h() + j();

* `precedence` gurantees that the results of g() and h() are multiplied.

* `associativity` guarantees that the result of f() is added to the product of
  g() and h() and that the result of that addition is added to the value of j().

* However, NO guarantees as to the order in which these functions are called.

In other words, for operators that do not specify evaluation order, it is an
`undefined` for an expression to refer to and change the same object. 

note: in gcc, calls f, g, h, and j in order
note: the logical AND(&&) operator guarantees that its lhs operand is evaluated
first.

<ex>
cout << i << " " << ++i << endl;

((((cout << i) << " " ) << ++i) << endl);     // `undefined`

<ex> EXC++47

return string("size = ") + itoa(size_, buf, 10) +
  ", used = " + itoa(used_, buf, 10);

what this really amouts to is something like:

return 
  operator+(
      operator+(operator+(string("size = ") + itoa(size_, buf, 10)),", used = "),
      itoa(used_, buf, 10)
      );

Say size_ is 10 and used_ is 5  the problem is that both uses the same buf
which is overwritten depending on the order.

// when outer opearator+()'s first parameter is evalueated first and that's
// stored in temporary string before the second itoa reuses the buffer.
size = 10, used = 5       

// when outer opearator+()'s second parameter is evalueated first and inner
// itoa will clobber the result of the outer itoa before either value is used.
size = 10, used = 10


<ex> EXC++47

int f (int & x, int y = 1) { return x += y; }
int g (int & x) { return x /= 2; }

int main()
{
    int i = 42;

    // f(43) = 43
    // g(21) = 21
    cout << "f(" << i << ") = " << f(i) << endl;
    cout << "g(" << i << ") = " << g(i) << endl;

    // f(22) = 22, g(21) = 21
    cout << "f(" << i << ") = " << f(i) << ", "
        << "g(" << i << ") = " << g(i) << endl;
}


{ansic} ansic, p53. 
C do not specify the 'order' in which the operands of an operator are
evaluated. 

x = f() + g();    // f may be evaluated before g or vice versa

Function calls, nested assignment statements, and increment and decrement
operators cause *cpp-side-effect* - some variable is changed as a by-product
of the `evaluation` of an expression. In any expression involving side
effects, there can be subtle dependencies on the 'order' in which variables
taking part in the expression are updated.

printf("%d %d\n", ++n, power(2, n));   // WRONG this is not a comma operator

a[i] = i++;

When side effects take place is left to `discretion` of the compiler, since
the best order depends strongly on machine architecture.

<ex>
while (fgets(line, 256, file))
{
  sscanf(line, "%s %d %d %f %f", Stocks[i], &Intervals[i], &Volumes[i], 
      &Highs[i], &Lows[i++]);
}


<ex> see reverse polish calculator
The + and * are commutative operators, the order in which the popped operands
are combined is irrelevant, but for - and / the left and right operands must
be distinguished.

push( pop() - pop () );

This is wrong since the order in which the two calls of pop are evaluated is
not 'defined'.


={============================================================================
*kt_dev_lang_016* expr-unary

The unary negation operator ! converts a non-zero operand into 0 and a zero
operand into 1. A common use of ! is in constructions like:

if(!valid) rather then if(valid==0)

<ex>
From ansic, exercise 2-2. Write a loop equivalent to the for loop above without
using && or ||.

for(i=0; i<lim-1 && (c=getchar()) != '\n' && c != EOF; ++i)
   s[i] = c;

// 01

while (i < (lim - 1))
{
  c = getchar();

  if (c == EOF)
    break;
  else if (c == '\n')
    break;

  s[i++] = c;
}

// 02

for(i=0; i<lim-1 ? (c=getchar()) != '\n' ? c != EOF : 0 : 0; ++i)
   s[i] = c;


={============================================================================
*kt_dev_lang_016* expr-assign

The operator "+=" is called `assignment operator` and most binary operators have
a corresponding assignment operator "op=", where op is + - * / % << >> & ^ |.

note: 
that "expr1 op= expr2" is equivalent to "expr1 = (expr1) op (expr2)" and notice
that () around expr since:

x *= y + 1; means x = x * ( y + 1 ); rather than x = x * y + 1;

note:
that assignment statement, c = getchar(), and the 'type' of an assignement
  expression is the type of its left operand in case of assignement operator.
  The point is that expresssion has a 'type'.

note:
The "&~" is not `assignment opearator` since do not have `=`. No such an
operator and turns out "x & ~y".


={============================================================================
*kt_dev_lang_016* expr-conditional (the ?: operator)

CPR 4.7 151. The conditional operator(the ?: operator):

  `cond` ? `expr1` : `expr2`;

  * often leads to 'succint' code.
  * embed simple if-else logic inside an expression.
  * `cond` is an expression used as a condition.
  * guarantees that only one of expr1 or expr2 is evaluated.

<ex>
Prints newline after every 10th element and after n-th and blank for all other
elements.

for( i = 0; i < n; i++ )
   printf("%6d%c", a[i], (i%10==9 || i==n-1) ? '\n' : ' ' );

printf("You have %d item%s.\n", n, n==1 ? "" : "s" );

<ex> *ex-lower* 
ansic, page 52, exercise 2-10. 
Rewrite the function lower, which converts upper case letters to lower case with
a conditional expression instead of if-else.

int lower(int c);

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_10

ASCII:
  65, 0x41, A (uppercase)
  ...
  97, 0x61, a (lowercase)
  ...

int lower(int c)
{
  return c >= 'A' && c <= 'Z' ? c + 'a' - 'A' : c;
}

note: 
Why ASCII only? This seems to works for ASCII and EBCDIC since both has constant
offset for alphabet chars and sequential values for numbers.

<ex>
Use the same idea but more 'portable' solution since do not depend on the order
of key codes. 

int lower(int c)
{
  char *Uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  char *Lowercase = "abcdefghijklmnopqrstuvwxyz";
  char *p = NULL;

  return NULL == (p = strchr(Uppercase, c)) ? c : *(Lowercase + (p - Uppercase));
}

char *strchr(const char *s, int c);
returns a pointer to the 'first' occurrence of the character c in the string s


{same-type}
The `expr1` and `expr2` are the 'same' type or types that can be converted to a
common type.

<ex>
int cond = 0;
printf("this is char %s\n", cond ? "ture" : cond );

C: warning: pointer/integer type mismatch in conditional expression [enabled by default]
C++: error: operands to ?: have different types ‘const char*’ and ‘int’


{nested}
Nest one conditional operator inside another. This is three-way test. 

note: the nested quickly become unreadable so good idea to nest no more than two
or three.

string finalgrade = (grade < 60) ? "fail" : "pass";

string finalgrade = (grade > 90) ? "high pass" 
                                 : (grade < 60) ? "fail" : "pass";

<ex>
int currentTime =
    presentationTime < bufPos.first ? bufPos.first :
    presentationTime > bufPos.second ? bufPos.second :
    presentationTime;

if(presentationTime < bufPos.first)
    currentTime = bufPos.first;
else if (presentationTime > bufPos.second)
    currentTime = bufPos.second;
else
    currentTime = presentationTime;


{low-precedence}
Has fairly low precedence so usually must parenthesize the conditional
subexpression.

cout << ((grade < 60) ? "fail" : "pass");     // okay
cout << (grade < 60) ? "fail" : "pass";       // prints 1 or 0
cout << grade < 60 ? "fail" : "pass");        // error


={============================================================================
*kt_dev_cxx_0000* cxx-style-name

Q: Is it okay to use like #define _DECLTYPE(_T) typeof(_T) ?

NO.

http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier

From the 2003 C++ Standard:

17.4.3.2.1 Global names [lib.global.names]

Certain sets of names and function signatures are always reserved to the
implementation:

Each name that contains a double underscore (__) or begins with an underscore
followed by an uppercase letter (2.11) is reserved to the implementation for
any use.  

Each name that begins with an underscore is reserved to the implementation for
use as a name in the global namespace.165

165) Such names are also reserved in namespace ::std (17.4.3.1).

C++P 2.3.3
The standard also reserves a set of names for use in the standard library. May
not contain two consecutive underscores, nor can an identifier begin with an
underscore followed immediately by an uppercase letter.


{variable} {classname} {member-function}
Avoid leading underscores for member variables since the standard reserves
some. EXPC++ suggests member variables with trailing underscores.

class TextQuery {
  public:
    explicit TextQuery(double real, double imaginary = 0)
      : real_(real), imaginary_(imaginary)
    {}

  private:
    std::map<std::string, std::shared_ptr<std::set<size_t>>> word_map_;
};


={============================================================================
*kt_dev_lang_020* cpp-style-bracing-allman

{style-allman}
The Allman style is named after Eric Allman. It has been incorrectly referred
to as "ANSI style" supposedly for its use in the documents describing the ANSI
C standard; later adopted as the ISO C international standard, though in fact
those documents use K&R style. It is also sometimes known as "BSD style" since
Allman wrote many of the utilities for BSD Unix although this should not be
confused with the different "BSD KNF style"; see below.

  "This style puts the brace associated with a control statement on the next
  line, indented to the same level as the control statement. Statements within
  the braces are indented to the next level."

while (x == y)
{
    something();
    somethingelse();
}
 

Suggested advantages of this style are that the indented code is clearly set
apart from the containing statement by lines that are almost completely
whitespace and the closing brace lines up in the same column as the opening
brace. Some people feel this makes it easy to find matching braces.
Additionally, the blocking style delineates the actual block of code from the
associated control statement itself. 

Commenting out the control statement, removing the control statement entirely,
           refactoring, or removing of the block of code is less likely to
           introduce syntax errors because of dangling or missing braces.
           Furthermore, it's consistent with brace placement for the
           outer/function block.

Even like this, with conditional compilation:

char c;
#ifdef HAS_GETCH
while ((c = getch()) != EOF)
#else
while ((c = getchar()) != EOF)
#endif
{
    do_something(c);
}


  "No spaces immediately after opening parenthesis nor before closing
  parenthesis. Place a space before the opening parenthesis."

The else/else if keywords belong on a new line. Always use block bracing even
for single line blocks.

if (a == b)
{
    foo = bar;
    boz = jabber;
}
else if (c == d)
{
    foo = jabber;
}
else
{
    boz = baz;
}

<ex>
string FindAddr( list<Employee> emps, string name )
{
  for( list<Employee>::iterator i = emps.begin();
      i != emps.end();
      i++ )
  {
    if( *i == name )
    {
      return i->addr;
    }
  }
  return "";
}


string FindAddr (list<Employee> emps, string name)
{
  for (list<Employee>::iterator i = emps.begin();
      i != emps.end();
      i++)
  {
    if (*i == name)
    {
      return i->addr;
    }
  }
  return "";
}


{k-and-r-style}
The K&R style, so named because it was used in Kernighan and Ritchie's book
The C Programming Language, is commonly used in C. It is also used for C++,
    C#, and other curly brace programming languages.

When adhering to K&R, each function has its opening brace at the next line on
the same indentation level as its header, the statements within the braces are
indented, and the closing brace at the end is on the same indentation level as
the header of the function at a line of its own. The blocks inside a function,
    however, have their opening braces at the same line as their respective
    control statements; closing braces remain in a line of their own, unless
    followed by an else or while keyword.

In this style a control statement with only a single statement in its scope
may omit the braces. The C Programming Language refers to this as fertile soil
for bugs (programming logical errors) and discourages it.

int main(int argc, char *argv[])
{
    ...
    while (x == y) {
        something();
        somethingelse();
 
        if (some_error) {
            /* the curly braces around this code block could be omitted */
            do_correct();
        } else
            continue_as_usual();
    }
 
    finalthing();
    ...
}


={============================================================================
*kt_dev_lang_020* style-comment

<why-needs>

1) no gurantee that only one person maintain whole source tree. works as a team.
no lifetime employment. no unlimited memory.

2) code speaks themselves? not for big and real system which has history such as
field fixes.  project/field specific requirement and one line worth a week long
dev trip. 

Should have comment or reference for more detail or full history.


<words-about-comment> CPR 1.3
An 'incorrect' comment is worse than no comment at all.

<comment-pair>
When a comment pair does span multiple lines, it is often a good idea to
indicate visually that the inner lines are part of a multiline comment.

<comment-out-block>
We often need to comment out a block of code during debugging. Because hat code
might contain nested comment pair, the best way to comment a block of code is to
insert single-line comments at the beginning of each line in the section we want
to ignore.


={============================================================================
*kt_dev_lang_021* cpp-style-layout

{cpp-style-type-declaration} *cpp-base-type*

CPR 2.3.3

declaration = base type + declarators
              int         *p;

There are two style choices:

<1>
This emphasizes that the variable has the indicated compound type.

Foo *msg1, *msg2;

Foo& Foo::operator=( Foo &rhs )
{
  ...
}

<2>
This place the type modifier with the type but defines only one variable per
statement.

Foo* msg1, *msg2;

Foo& Foo::operator=( Foo& rhs )
{
  ...
}

*cpp-remember*
The second seems to be preferable by others.

  * do not define multiple variables in the same line
  * use typedef in template or class code


{layout}
C++ Layout Conventions

Code layout

These guidelines are generally accepted practice. However, when editing pre-existing code please
remember that these guidelines are only to aid readability. As such, if a particular source file
deviates from our current standards, please be "locally consistent" and make your changes fit in
with the style in use there (eg. tabs vs. spaces). Multiple competing coding styles in a file really
harms readability.

If you are making large-scale changes to a file, that might be an opportunity to tidy up the
styling. But don't go changing a whole file when you only want to make a one-line functional change.


Bracing style

New projects should use Allman.


Line Length

Line length is roughly 80 characters maximum. This used to be 120 characters but since a number of
people like to use split-screen editing, 80 characters generally means lines don't wrap in this
mode. Also, printed code doesn't wrap.

This limit of 80 characters isn't a do-or-die hard limit. Sometimes with the verbose syntax of C++
it can be impractical, but generally if there's a chance of putting a line break in there, please do
for the sake of your neighbours, remembering to follow the standard convention of indenting by 4
spaces. 


Trailing space

Never have trailing whitespace. git will show you this as a whitespace error in
red when you look at your diffs and most editors allow you to show just trailing
spaces too.


Non-ASCII Characters

Where possible non-ASCII characters should be represented as escape sequences for the appropriate
unicode code point, e.g. "\uA2DF"

Non-ASCII characters should be rare, and must use UTF-8 format.

The UTF-8 BOM marker shall not be used in files.


Spaces vs. Tabs

Use only spaces, and indent 4 spaces at a time.


Function Declarations and Definitions

Return type on the same line as function name, parameters on the same line if they fit.

If the function is templated place the template definition on the line above.

For pointer and reference parameters do not include a space after the type name, e.g.: void
foo(string* bar, int& baz);


Const

note: Is it something for preference?

The const keyword shall be placed as per this example:

char const* bar             // preferred
const char* bar
 
char const* const baz
// const char* const baz       DISALLOWED !


Function Calls

note: my preference is function( param ). is it less readable?

On one line if it fits; otherwise, wrapped lines should be indented.

Parameters should be followed by a comma and a space. There should be 'no' spaces either side of
parentheses.

E.g.:
var = functionWithRatherLongName(argumentWithRatherLongName, anotherRatherLongNamedArgument,
     aFinalArgumentThatDidntFitOnTheLineAbove);


Conditionals

note: how about if( a ==b )?

No spaces immediately after opening parenthesis nor before closing parenthesis. Place a space
'before' the opening parenthesis.

The else/else if keywords belong on a new line.

Always use block bracing even for single line blocks.

E.g.:
if (a == b)
{
    foo = bar;
    boz = jabber;
}
else if (c == d)
{
    foo = jabber;
}
else
{
    boz = baz;
}

The ternary ? operator is allowed and the expression should be enclosed in parentheses, e.g.:

i = (isFoo ? 42 : 13);


Switch Statements

Switch statements must use braces for blocks. E.g.:

switch (foo)
{
    case 13:
    case 42:
    {
        int bar = foo * 2;
        cout << bar;
        break;
    }
    default:
    {
         cout << foo;
         break;
    }
}


Loops

Empty loop bodies should use {}, e.g.:

while (dispatcher.processNextEvent()) {}


Pointer and Reference Expressions

No spaces around period or arrow. Pointer operators do not have trailing spaces.  E.g.:

foo = jabber.jab();
foo = jabber->jab();
baz = *jabber;


Return Values

Do not surround the return expression with parentheses.  E.g.:

return true;

Unless the return value is a complex expression.  E.g.:

return (a < b);


Preprocessor Directives

Preprocessor directives should be indented as shown below:

#define ZINC_FUNC_TRACE(logger) \
    boost::shared_ptr<NS_ZINC::ScopeLogger> _zinc_func_trace_logger; \
    if((logger).isEnabledFor(NS_ZINC::traceLog)) \
        _zinc_func_trace_logger.reset(new NS_ZINC::ScopeLogger(logger, __PRETTY_FUNCTION__, __FILE__, __LINE__, true));


Constructor Initializer Lists

Can be all on one line or with subsequent lines indented four spaces. The colon that begins the
initialiser-list specification should be at the end of the line of the constructor function rather
than the line of the first element.

All non static class members must be initialised in Constructor initializer list in the order of
their declaration.

E.g.:

MyClass::MyClass(int a_, double b_) :
    a(a_),
    b(b_) {}


Namespace Formatting

The contents of namespaces are 'not' indented.

E.g.:

namespace iron
{
namespace client
{
 
class Event
{
};
 
}
}

However namespaces shall be defined as macros in a file named "macros.h" in the include folder of
the project.

E.g.:

NS_IRON_CLIENT_OPEN
 
class Event
{
};
 
NS_IRON_CLIENT_CLOSE

Exceptions (to the Rules)

Existing Non-conformant Code, where changing this code carries a level of risk. Adding comments,
         however, adds no risk at all, and it should be encouraged where code is currently
         under-documented.

If modifying a file just to convert its style, make this change as a separate changeset, and do not
combine it with actual logical coding changes at the same time.


={============================================================================
*kt_dev_lang_018* style-space

This shows how spaces can changes its reading. Taken from stl code which uses
tabs and tabstops 2. For this example, changes tab to space to show the point.

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
      return 0;
    }

Does this compare function run for loop only once? When changes tabstop, it is
  clear now.

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (lt(__s1[__i], __s2[__i]))
          return -1;
        else if (lt(__s2[__i], __s1[__i]))
          return 1;
      return 0;
    }


={============================================================================
*kt_dev_lang_018* style-order-of-header

Included headers ordering but I think a nice and consistent way of including
them is as all alphabetically in each group:

local project headers
3PS library headers
OS specific headers
standard headers


={============================================================================
*kt_dev_lang_018* cpp-style-class

<class-format>
Sections in `public, protected and private order. `The exceptions to the rule
are that

* a virtual destructor should always be the first virtual function declared in
  the class, regardless of what its access specifier is.

* If, for whatever reason your class has members with different access
  (possibly protected and private members) you may need the private one to be
  initialised first in the constructor.

The words public, protected and private `should not be indented.`

If the class extends more than one abstract class (or interface), separate the
public/protected/private sections by class being extended.

E.g.:

class Hybrid : public Cow, public Sheep
{
public: // Implements Cow
    Milk milk();
    Beef slaughter();
 
public: // Implements Sheep
    Wool shear();
 
public: // Hybrid
    std::auto_ptr<Hybrid> clone() const;
 
private:
    string name;
};


note:

class Hybrid : public Cow {
  private:
    string name milk;

  protected:

  public:
};


* Have public near by class name so that show public interface when looks for
  a class?


<class-header>
For code that will go in a header, use std:: since code inside headers should
not use *using-declaration* 

The reason is that the contents of a header are copied into the including
program's text and every program that includes that header gets that same
using declaration. Might encounter unexpected name conflicts.

class X {
    public:
        using line_no = std::vector<std::string>::size_type;

        X(std::ifstream &);
        QueryResult query(const std::string &) const;

    private:
        std::shared_ptr<std::vector<std::string>> file;
        std::map<std::string, std::shared_ptr<std::set<line_no>>> word_map;
};


* Implements functions in a header? The downside is to use std::


# ============================================================================
#{ CPP
={============================================================================
*kt_dev_cpp_0000* cpp-reference

<cpp-core-guideline>
http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines
https://github.com/CppKorea/CppCoreGuidelines


={============================================================================
*kt_dev_cpp_0000* cxx-oop

The key ideas in OOP are data abstraction, inheritance, and dynamic binding.

* `data-abstration` CPR 254 

Data Abstraction is a programming and design technique that relies on the
`separation of interface and implementation.` 

  * `encapsulation`
    `enforces the separation` of a class interface and implementation and
    hides its implementation. 

Class users need not know or care how the type actually works and can instead
think abstractly about what the type does. 


* `inheritance` 
Can define classes that model the relationships among similar types. 

Conceptually, neither the kind of device nor the character size affects the IO
operations we want to perform. For example, we would like to use >> to read data
regardless of whether we are reading a console window, a disk file, or a string.
Similarly, we would like to use that operator regardless of whether the
characters we read fit in a char or require a wchar_t.

The library lets us ignore the differences among these different kinds of
streams by using inheritance. As with templates, we can use classes related by
inheritance without understanding the details of how inheritance works.

inheritance lets us say that a particular class inherits from another class.
Ordinarily, we can use an object of an inherited class as if it were an object
of the same type as the class from which it inherits.

  * `dynamic-binding` 
    Can use objects of these types while ignoring the details of how they
    differ. This is mechnism to make inheritance work along with virtual
    mechnism and object layout(subobject) scheme.


={============================================================================
*kt_dev_cpp_0000* cpp-init-form

// `default-init`
string s1;                 


// `direct-init`
string s2(s1);           
string dots(10, '.');
string s(dots);
string null_book( "9-999-99999-9" );

// `copy-init when converting-ctor` 
string null_book = "9-999-99999-9"; 
// `copy-init when copy-ctor` but no copy-assign called
string s2 = s1;                     


void f(vector<int>);
f(10);                        // error since ctor that takes a size is explicit
f(vector<int>(10));           // okay


// in constructor
ABEntry::ABEntry(...)
: theName(),                  // var(). same as units_sold(0)
  theAddress(),
  thePhones(),
  numTimesConsulted(0)
{}


// temporary
void doSomething(B bObject);
doSomething(B(28));           // T(val). converting ctor

return pair<string, int>();   // T()


// `default-init` and `value-init`
string* ps = new string;      // default-init
string* ps = new string();    // value-init. new T()

int* pi = new int;            // default-init
int* pi = new int();          // value-init. new T()

vector<T> v3(n, val);         // has n elements with value val
vector<T> v4(n);              // has n copies of a value-init objects


  *cpp-remember*
  The `value-init` uses the form `T()` and is a special or narrow case of
  `default-init`. The value-init only matters for built-in types.


The empty initializer list, {}, is used to indicate that a default value is
desired. 

char buf[max] {};         // array, initialize every char to 0
int x4 {};                // x4 becomes 0

<cpp-static-objects>
If no initializer is specified, a global, namespace, local static, or static
member (collectively called static objects) is initialized to {} of the
appropriate type.


<ex>
#include <iostream>
#include <vector>

using namespace std;

template <typename T>
void PRINT_ELEMENTS( T& coll, const string str="" )
{
    cout << str << ":" << endl;
    cout << "{ ";

    for( auto &elem : coll )
        cout << elem << ", ";

    cout << "}" << endl;
}

int main(int argc, char** argv)
{
    vector<int> ivec;

    for(int i = 0; i < 5; i++ )
    {
        int val;

        ivec.push_back(val);
    }

    PRINT_ELEMENTS(ivec, "default inited");

    vector<int> vivec(5);
    // vector<int> vivec(5, 10);

    PRINT_ELEMENTS(vivec, "value-inited");
}

default-init:
{ 32767, 32767, 32767, 32767, 32767, }

value-init:
{ 10, 10, 10, 10, 10, }


={============================================================================
*kt_dev_cpp_005* cpp-init-copy-form

The `copy-init` and `direct-init` uses `converting-ctor` if
`implicit-conversion` is necessary to make a call succeed and use `copy-ctor`
when not. The both use function matching to select a correct ctor. However,
copy-init implicitly uses converting-ctor.

string null_book = "9-999-99999-9"; // `copy-init when converting-ctor` called
string s2 = s1;                     // `copy-init when copy-ctor` called
string s2(s1);                      // `direct-init when copy-ctor` called
string s2("9-999");                 // `direct-init when converting-ctor` called

Question is "does these above statements involve copy-assign?"

For example, what calls involved in this statments?

    Query q = Query("fiery") & Query("bird") | Query("wind");
            <----------------------------------------------->

calls converting or copy ctor to build right-side of statements. NO copy
assign gets called. this example calls three Query ctor and two overloaded
operators. 


> WordQuery::WordQuery
> Query::Query
> WordQuery::WordQuery
> Query::Query
> WordQuery::WordQuery
> Query::Query

> Query::Query(const Query&): fiery
> Query::Query(const Query&): bird
> AndQuery::AndQuery
> Query::Query(shared_ptr)

> Query::Query(const Query&): (fiery & bird)
> Query::Query(const Query&): wind
> OrQuery::OrQuery
> Query::Query(shared_ptr)


<ex> 
// error since there is no match
#include<iostream>
#include<string>

using namespace std;

class MSTR
{
    private:
        string mesg;

    public:
        MSTR() : mesg() {}

        // copy-ctor
        MSTR( const MSTR &mstr )
        {
            cout << "mstr:copy ctor" << endl;
            mesg = mstr.mesg;
        }
};

int main()
{
    // direct-init
    MSTR m3("mstring three");
}

: In function ‘int main()’:
: error: no 'matching' function for call to ‘MSTR::MSTR(const char [14])’
: note: candidates are:
: note: MSTR::MSTR(const MSTR&)
: note:   no known conversion for argument 1 from ‘const char [14]’ to ‘const MSTR&’
: note: MSTR::MSTR()
: note:   candidate expects 0 arguments, 1 provided


<ex>
// The compiler do "function matching" and found the best match which is
// converting ctor.

#include<iostream>
#include<string>

using namespace std;

class MSTR
{
  private:
    string mesg;

  public:
    MSTR() : mesg() {}

    MSTR(const string &str) : mesg(str)
    { cout << "convert ctor" << endl; }

    MSTR(const char *pchar) : mesg(pchar)
    { cout << "convert ctor" << endl; }

    explicit MSTR(const char *pchar) : mesg(pchar) 
    { cout << "convert ctor" << endl; }

    // copy ctor
    MSTR( const MSTR &mstr )
    {
      cout << "mstr:copy ctor" << endl;
      mesg = mstr.mesg;
    }
};

int main()
{
    // direct-init
    MSTR m3("mstring three");
}


<ex>
// explicit converting-ctor prevent use of copy-init but direct-init is okay
// to use. WHY direct-init is explicit and see *why-direct-init*

#include<iostream>
#include<string>

using namespace std;

class MSTR
{
  private:
    string mesg;

  public:
    MSTR() : mesg() {}

    // converting-ctor
    explicit MSTR(const char *pchar) : mesg(pchar) 
    {
      cout << "convert ctor" << endl;
    }

    // copy-ctor
    MSTR( const MSTR &mstr )
    {
      cout << "mstr:copy ctor" << endl;
      mesg = mstr.mesg;
    }
};

int main()
{
    // copy-init
    MSTR m3 = "mstring three";

    // direct-init uses converthing-ctor
    // MSTR m3("mstring three");
}

: In function ‘int main()’:
: error: conversion from ‘const char [14]’ to non-scalar type ‘MSTR’ requested

note: 
g++ (Debian 4.9.2-10) 4.9.2
: error: conversion from 'const char [14]' to non-scalar type 'MSTR' requested
     MSTR m3 = "mstring three";
               ^

<ex>
#include<iostream>
#include<string>

using namespace std;

class MSTR
{
  private:
    string mesg;

  public:
    MSTR() : mesg() {}

    MSTR(const char *pchar) : mesg(pchar)
    {
      cout << "convert ctor" << endl;
    }

    // copy ctor
    MSTR( const MSTR &mstr )
    {
      cout << "mstr:copy ctor" << endl;
      mesg = mstr.mesg;
    }
};

int main()
{
  MSTR m3("mstring three");       // converting-ctor
  MSTR m3 = "mstring three";      // converting-ctor
}

<ex>
From *cpp-conversion-to-bool-stream*

// operator>> returns stream. Although bool do not have converting ctor,
// stream is implicitly converted to bool since copy-init is used. This means
// copy-init not only mean converting ctor but also any conversion to make it
// succeed.

-    bool read_ok = s >> st;
-    ASSERT_THAT(read_ok, Eq(true));
-
+    s >> st;
+    ASSERT_THAT(s.good(), Eq(true));


={============================================================================
*kt_dev_cpp_005* cpp-list-init cpp-initializer-list

There are many different ways to initialize. C++11 introduced the concept of
generalized `uniform-initialization`, which means that for any initialization. 

*C++11*
Must use -std=c++0x or -std=gnu++0x.

The followings are possible now:

int units_sold = 0;
int units_sold = {0};
int units_sold{0};            // `cpp-list-init`
int units_sold(0);
int units_sold{};

const std::string hybrid_str{"hybrid:"};
int values[] { 1, 2, 3 };
std::vector<int> v{ 2, 3, 5, 7, 11, 13, 17 };
std::vector<std::string> cities{"Berlin", "New York", "London", "Braunschweig", 
    "Cairo", "Cologne" };
std::complex<double> c{4.0,3.0};    // equivalent to c(4.0,3.0)


*cpp-remember*
The good things are:

  * `value-init` for built-in types

An cpp-list-init `forces value-init`, which means that even local variables of
fundamental data types, which usually have an 'undefined' value, are
initialized by zero, or nullptr, if it is a pointer.

int i;      // i has undefined value
int j{};    // j is initialized by 0
int* p;     // p has undefined value
int* q{};   // q is initialized by nullptr

note: 
Why only for built-in type? class type will have default values since ctors
  would do if ctors do the right work.


Use cpp-list-init to use complete object to initialize

struct Token
{
    Kind kind;
    string string_value;
    double number_value;
};

class Token_stream
{
  private:
        // equivalent to {Kind::end,0,0}.
        Token ct{Kind::end};
};

Token Token_stream::get()
{
    switch (ch)
    {
        case 0:
            // equivalent to {Kind::end,0,0}.
            return ct = {Kind::end};

        case ';':
        case '*':
            // equivalent to {Kind::end,0,0}.
            return ct = {static_cast<Kind>(ch)};
    }
}


*cpp-remember*
The `list-form-init` do 'not' allow `narrow-conversion` of 'built-in' type.

int x3{5.0};      // ERROR: narrowing
int x4 = {5.3};   // ERROR: narrowing

Worthwhile to use this property? Since unlikely to directly initialize an int
  from a long double? However such initialization might happen unintentionally
  in template. So YES.

  * use `single-form-of-init` whether it is built-in or class type

  * avoid vexing-parse


<ex>
As with `direct-form-init`, `list-form-init` do not care `exlpicit` on converting-ctor.

#include<iostream>
#include<string>

using namespace std;

class MSTR
{
  private:
    string mesg;

  public:
    MSTR() : mesg() {}

    explicit MSTR(const char *pchar) : mesg(pchar) 
    {
      cout << "convert ctor" << endl;
    }

    // copy ctor
    MSTR( const MSTR &mstr )
    {
      cout << "mstr:copy ctor" << endl;
      mesg = mstr.mesg;
    }
};

int main()
{
    // copy-from, an error
    MSTR m3 = "mstring three";

    // `cpp-brace-init` no error and converting-ctor is used. see that
    // list-init works when there is no such a ctor. converting ctor is
    // called.
    MSTR m3{"mstring three"}; 
}


<list-init-reduce-size>

int main()
{
  vector<int> coll{1,2,3,4,5,6};

  for ( auto it = coll.cbegin(); it < coll.cend(); ++it )
    cout << *it << ' ';

  cout << endl;
}

-rwxr-xr-x  1 kyoupark kyoupark 58848 Sep 20 09:46 a.out*

int main()
{
  vector<int> coll;

  for(int i=1; i <= 6; i++)
    coll.push_back(i);

  for ( auto it = coll.cbegin(); it < coll.cend(); ++it )
    cout << *it << ' ';

  cout << endl;
}

-rwxr-xr-x  1 kyoupark kyoupark 66560 Sep 20 09:45 a.out.old*


{cpp-initializer-list}
To 'support' the concept of initializer lists for user-defined types. It is a
library template type that repersents an 'array' of values of the `same-type`.
The element in a list are always `const`.

Can write a function that takes varying number of arguments.

#include "initializer_list"

initializer_list<int> li; 
initializer_list<string> ls;

Since it's array, it supports begin()/end() and can process elements.

<ex>
void error_msg( initializer_list<string> ls )
{
  for( auto beg = ls.begin(); beg != ls.end(); ++beg )
    cout << *beg << " ";

  cout << endl;
}

<ex>
void error_msg( ErrorCode e, initializer_list<string> ls )
{
  cout << e.msg() << " ";

  for( const auto &elem : ls )
    cout << *elem << " ";

  cout << endl;
}

<ex>
print( {12,3,5,7,11,13,17} );

void print( std::initializer_list<int> vals )
{
  for (auto p=vals.begin(); p!=vals.end(); ++p)  
    std::cout << *p << "\n";
}


={============================================================================
*kt_dev_cpp_003* cpp-ctor

{cpp-ctor-default}
There are operations synthesized by compiler if they are not defined by user
and `only if` they are needed. These are `public and inline` according to
EC++05.

dtor, default-ctor, copy controls; copy ctor, copy assign, move ctor(C++11),
move assign(C++11)


<cpp-deleted>
However, not always possible since there are cases when compiler cannot:

* When a class has reference or const member.
* When there's a class member that don't have default ctor.

// Q:?? * When base class have private on any of synthesized default-operations.
// Suggest that derived synthesized operations only use base synthesized ones?


{default-ctor} default-initialization
The `default-ctor` is a special constructor which takes `no-arguments`.

The recommendation on initialization is to avoid syn-version and do it
explicitly:

`in-class-init` (C++11) or `ctor-init-list`


The reasons to avoid the syn-version:

* The `default-init` for built-in types means `undefined value.`

  The synthesised detault-ctor will use `in-class-init` if there is and
  otherwise `default-init` its member and use default ctor for its class
  member. So undefined value for built-in types and default constructed
  value for user types.

* Compile error when there's a class member that don't have default ctor since
  compiler cannot syn default ctor for this class.

* If defines any other ctor for the class, the compiler do not generates
  default ctor. So if a class requires control to init an object in one case,
  then the class is likely to require control in all cases.

To see when syn versions are useful. see {make-base-class-for-reference-counting}


{constructor-and-const}
The ctor `cannot-be-const`. When create a const object of a class type, the
object does not assume its constness until after the ctor completes the
object's initialisation. Thus, ctor can write to const objects during their
construction.

Tried copy-ctor and compile error:

    FooFoo(const FooFoo& arg) const : foo()
    { cout << "FooFoo's copy ctor: " << endl; }

:38:31: error: constructors may not be cv-qualified


{cpp-default-keyword}
To tell the compiler to create syn version for functions `but-not-limited` to
default ctor. 

For `default-ctor`, if there are other ctor, then compiler will 'not' make a
default ctor and can ask the compiler to create one.

class Sales_data {
  public:
    Sales_data() = default;
    Sales_data(const Sales_data&) = default;
    Sales_data& operator=(const Sales_data &);
    ~Sales_data() = default;
    ...
};

Q: use case other than default ctor?


{in-class-init} *C++11* 
For window_mgr calss to start up with a single, default-inited screen.

class window_mgr {

  private:
   vector<Screen> screens{ Screen(24, 80, ' ') };       // = form 
   vector<Screen> screens = { Screen(24, 80, ' ') };    // direct form
};

class T {
  T() = default;
  T(const string &s) : bookNo(s) {}
  ...
  string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};

The `in-class-init` do like `default-arg` because:

T(const string &s) : bookNo(s) {}

is equivalent to:

T(const string &s) : bookNo(s), units_sole(0), revenue(0) {}

Before C++11 then:

class T {
  T(): bookNo(), units_sold(0), revenue(0.0) {}
  T(const string &s) : bookNo(s) {}
  ...
  string bookNo;
  unsigned units_sold;
  double revenue;
};

  *cpp-remember*
  No semicolon when defines member functions in class definition.

  class T {
    T(): bookNo(), units_sold(0), revenue(0.0) {}
    T(const string &s);
  };


{cpp-ctor-init-list} 
The following is initialization and assignment but not initialization since
members are default initialized `before-ctor-body-runs`. 

ABEntry::ABEntry(...)
{
  theName = name;
  theAddress = address;
  thePhones = phones;
  numTimesConsulted = 0;
}

Why `ctor-init-list`? From CPR 289 and EC++04.

* Efficient than initialization-and-assignment.

  <when-ctor-init-list-is-must>
* By the time the body of ctor begins excuting, initialization is completed so
  there are 'three' cases that must use `ctor-init-list`: 

  const, reference, and class member that do not have a default ctor.

note: 
Again the same reason as recommendation on initialization above. For the last
case, that is because will try to use default-ctor for class memeber data when
there is no ctor initializer but there is no default-ctor and 'no' way to init.
Hence this is error. This applies to all other cases that need a default-ctor
and that's why `default-ctor` is almost nearly required.

class NoDefault {
  public:
    NoDefault(const std::string&);
};

struct A {
  NoDefault my_mem;
};

A a;

:26:5: error: use of deleted function ‘A::A()’
:20:8: note: ‘A::A()’ is implicitly deleted because the default definition 
       would be ill-formed:


note: 
CPR 265. When a data memder is omitted from the ctor-init-list, it is
'implicitly' initialized using the same process as is used by the synthesized
default-ctor. in-class-init if there is or default-init.


Use `ctor-init-list` always:

ABEntry::ABEntry(...)
: theName(name),
  theAddress(address),
  thePhones(phones),
  numTimesConsulted(0)
{}

ABEntry::ABEntry(...)
: theName(),                  // value-init
  theAddress(),
  thePhones(),
  numTimesConsulted(0)
{}

The ctor-initializer is all about making sure that built-in type do not have
undefined values since user type has constructors so no undefined value. Is it
overkill when use constructor initializer for all members since default ctor
will be used when omitted? Use ctor-init-list always since:

* Avoid to remember which memebers may go uninitialized if they are omitted.
* Cover data members which are const or reference.

<syntax> 
Must be done in class definition? NO since can be done in memeber definition in
cpp file.

class Derived: public Base 
{ 
  public: Derived( parms ) : Base( parms ), m_xxx(param), ... 
          { ... }
};


{cpp-init-order-of-member}
CPR 289. Members are initialized in the order in which they appear in the class
definition. The order of initialization often doesn't matter unless one member
is initialized in terms of another.

1. Good idea to write ctor-init in the same order as the members are
declared.

2. Good idea to write member initializer to use the ctor's parameters rather
than another data member from the same object.

// EXC++47
class Array : private ArrayBase, public Container
{
  public:
    Array (size_t startingSize = 10)
      : size_(startingSize),
      buffer_(new T[size_]) {}              // *cpp-error*

  private:
    T* buffer_;
    size_t used_, size_;
};

<cpp-type-member> <cpp-typename> CPR 272
As with data and function member, type member is a local name and is subject
to the access control. Users can use that name.

CPR 259. The data member can be used `regardless of where` they are defined
because the compiler processes classes in two steps; the data member are
compiled first and then function member. 

However, `type member must appear before` they are used. So usually appear at
the beginning of the class.

class Screen {
  public:
    typedef std::string::size_type pos;

    OR

    using pos = std::string::size_type;

  private:
    pos cursor = 0;
};


<type-member-error> CPR 285
An inner scope can redefine a name from an outer scope. However, if that is a
type member, `may not redefine that name.`

typedef double Money;

class Account {
  public:
    Money balance() { return bal; }

  private:
    typedef double Money;
    Money bal;
    ...
};

Although it is an error to redefine a type name, compilers are not required to
diagnose this error. Some compilers will quietly accept such code, even though
the program is in error.

note: VC emits no errors.

<ex>
Some compliers are kind enough to generate a warning if the data members are
listed in the ctor-init in a different order from the order in which the
members are declared.

This is a warning and turned to an error due to compiler flag:

class X {
  // ...
  GstMediaRouterSize videoSize;

  SetSourceReason::Enum setSourceReason;
};

: error: 'X::setSourceReason' will be initialized after
: error:   'GstMediaRouterSize videoSize'
: error:   when initialized here  // points to the ctor.

X::X() :
  ...
  setSourceReason(SetSourceReason::unspecified),
  videoSize(0, 0)                 // points to the ctor.
{}

It solves the errors when changes the order of declaration:

class X {
  // ...
  
  SetSourceReason::Enum setSourceReason;

  GstMediaRouterSize videoSize;
};


<ex> EC++09, no virtual call in ctor or dtor 

Assume that each time a transaction object is created, an appropriate log
entry needs to be created in a log. If it is a derived object, then need to
have a log entry for that type.

Solution?:

class Transaction {
  public:
    Transaction();

    // to make type-dependent-log-entry
    virtual void logTransaction() const = 0;
    ...
};

Transaction::Transaction()
{
  // call
  logTransaction();
}

class BuyTransaction: public Transaction {
  public:
    virtual void logTransaction() const;
    ...
};

class SellTransaction: public Transaction {
  public:
    virtual void logTransaction() const;
    ...
};

// use
{
   BuyTransaction buy;
}

Will it have a log entry of BuyTransaction as expected? NO. Will have the base
class version if there is one. 

C++ don't allow this because when base ctor runs, 'only' base part is created.
Hence base version. If it was allowed, then derived call would access derived
part which is not created or initialized. This is undefined so 'not' allowed.

Remember that construction happens first from base. Also this can be explained
as this is becuase it is static bining at compile time. Has nothing to do with
virtual mechanism since not through reference or pointer.

1. For the example above, some compilers issue a warning. Even if there is no
warnings, there will be a link error unless there is a definition of pure
virtual function. Remember pure virtual can have definition. 

2) Can use normal virtual function (not pure) but still get base version.


<solution>
Make it non-virtual, move up the implementation to log in the tree and pass up
the type-dependent info to the base class in the tree.

class Transaction {
  public:
    explicit Transaction( const std::string& logInfo );

    // non-virtual-func
    void logTransaction( const std::string& logInfo) const;
    ...
};

Transaction::Transaction( const std::string& logInfo )
{
  ...
  logTransaction( logInfo );
}

class BuyTransaction: public Transaction {
  public:
    // pass-log-to-base-class
    BuyTransaction( parameters ) 
      : Transaction( createLogString(parameters) )
    { ... }
    ...
  private:
      'static' std::string createLogString( parameters );
};

See the use of createLogString, helper func, instead of initializing each
member and it is more convenient and consider this when there are many
parameters.

*cpp-static-members* 
Why static? By doing this, there is no danger of accidentally referring to the
BuyTransaction object's as-yet-uninitialized data or function members when
base ctor and part runs.

Why logging call in the base class in the first place? that's becauase it's
common to all type of transactions. So move up as it's abstraction.


{class-invariant}
Such a statement of what is assumed to be true for a class is called a class
invariant, or simply an invariant. It is `the job of a constructor` to establish
the invariant for its class (so that the member functions can rely on it) and
for the member functions to make sure that the invariant holds when they exit. 

Unfortunately, our Vector constructor only partially did its job. It properly
initialized the Vector members, but it failed to check that the arguments
passed to it made sense. Consider:

Vector v(27);

This is likely to cause chaos. Here is a more appropriate definition:

Vector::Vector(int s)
{
  if (s<0) throw length_error{};

  elem = new double[s];

  sz = s;
}


={============================================================================
*kt_dev_cxx_0000* cxx-dtor cxx-non-virtial-destruction-problem

{ctor-order}
Opposite to ctor in destruction order so dtor body runs first and then
implicit member destruction phase.

Under inheritence: 

------------> ctor
base     derived
<------------ dtor

<ex>
namespace OR5 {

using namespace std;

class B0 {
    public:
        B0() { cout << "B0::B0" << endl; }
        ~B0() { cout << "B0::~B0" << endl; }
};

class D1 : public B0 {
    public:
        D1() { cout << "D1::D1" << endl; }
        ~D1() { cout << "D1::~D1" << endl; }
};

}

// = 05 ======
// B0::B0
// D1::D1
// end of main
// D1::~D1
// B0::~B0
 
void t_override_05()
{
    using namespace OR5;

    D1 dobj;
    cout << "end of main" << endl;
}

Unlike `non-virtual-destruction-problem`, this case uses only static binding
and no vtable is involved. The compiler knows only about derived type and do
not emits code to follow vtables.


{syn-version-is-non-virtual} {dtor-in-derived-classes}
The dtor is one of `copy-controls` and means if not defined, the compiler will
make one which is `non-virtual` when the base don't have one.

The virtual is only used in class definition and for other functions, if it's
virtual in base then all overrides in derived classes are virtual. How about
dtor? That's the same. 

Unlike the constructors and assignment operators, the destructor is reponsible
only for destroying the resources allocated by the derived class. From user or
programmer POV.


{cxx-non-virtual-destruction-problem}
EC++07. The problem is that base dtor runs when derived dtor is expected via
derived-to-base pointer is used.

In GCC spec, it will have 'undefined' result but in reality, destroy only the
base part; partially destroyed. In GCC, no runtime error in simple test. 

This is the same for other member functions. That is if miss out virtual
keywords in a base, then will have only base version even if expected derived
version. 

Therefore, there are two cases when override do not happen; one when argument
is different, see `cpp-override-condition`, and one when miss out virtual
keyword in a base as shown here.

<ex>
note that this is a problem only when use dynamic allocation through a base
pointer. Not a problem when use static allocation and derived pointer.

template<typename T>
class Vec : public std::vector<T> {

  public:
    
};

std::vector do not have virtual dtor and it is okay if used only statically. 


<ex>
#include <iostream>

using std::cout; using std::endl;

class Base {
  private:
    int m_iDataABCAnimal;
  public:                                             // <3>
    Base() { cout << "ctor: base" << endl; }
    ~Base() { cout << "dtor: base" << endl; }         // <1>
    virtual ~Base() { cout << "dtor: base" << endl; } // <2>
};

class Derived: public Base {
  private:
    int m_iDataAnimal;
  public:
    Derived() { cout << "ctor: derived" << endl; }
    ~Derived() { cout << "dtor: derived" << endl; }
};

class DDerived: public Derived {
  private:
    int m_iDataDAnimal;
  public:
    DDerived() { cout << "ctor: derived derived" << endl; }
    ~DDerived() { cout << "dtor: derived derived" << endl; }
};

int main()
{
  std::cout << "--{ main " << std::endl;

  Base* pbase = new DDerived;

38:  delete pbase;

  std::cout << "--} main " << std::endl;
}

<1>
--{ main 
ctor: base
ctor: derived
ctor: derived derived
`dtor: base`
--} main 

<2>
--{ main 
ctor: base
ctor: derived
ctor: derived derived
`dtor: derived derived`
`dtor: derived`
`dtor: base`
--} main 

<3> compile error
: In function ‘int main()’:
:12:5: error: ‘Base::~Base()’ is protected
:38:10: error: within this context


{when-use-virtual-dtor}
Due to *non-virtual-destruction-problem* All base class 'must' have virtual
dtor and these are the first and the second at below and as advised in EC++07.

* polymorphic base class
designed for inheritance and defined virtual funcs. 'must' use virtual dtor.

* base class to extend 
designed for inheritance but no virtual funcs. means no overrides and add more
funcs. However, if no virtual dtor, this causes virtual-destruction-problem. 

* a class not to be inherited
designed for no inheritance like STL. DO NOT use virtual-dtor sicne it will
increate a size of instance and make it not portable. *cxx-preventing-inheritance* 


{pure-virtual-dtor}
EC++07. Why use this? Sometimes you have a class that you'd like to be abstract
but you don't have any pure virtual functions. Like <2> base class to extend. 

class AWOW {
  public:
    virtual ~AWOW() = 0;
};

AWOW::~AWOW() {}

The pure-virtual-dtor 'must' have a definition(implementation) and 'must' be
implemeted outside class definitions.

MEC++33. Pure virtual do not mean it has no implementation and means that the
class is abstract and the derived func must be nomal virtual. True, most pure
virtual functions are never implemented, but pure-virtual-dtor are a
special-case. They must be implemented, because they are called whenever a
derived class destructor is invoked.  

<ex>
#include <iostream>

using std::cout; using std::endl;

class Base {
  private:
    int m_iDataABCAnimal;

  public:
    virtual ~Base() {};
    virtual void shout(void)=0;
};

void Base::shout(void)
{ cout << "base shout" << endl; }

class Derived: public Base {
  private:
    int m_iDataAnimal;

  public:
    void sample() { cout << "sample: derived" << endl; }
    void shout(void) { Base::shout(); cout << "derived shout" << endl; }
};

int main()
{
  std::cout << "--{ main " << std::endl;

  Derived d;
  d.shout();

  std::cout << "--} main " << std::endl;
}

--{ main 
base shout
derived shout
--} main 

<ex>
class ABCAnimal {
  public:
    ...
    virtual ~ABCAnimal() = 0;     // pure-virtual-dtor
};

class Lizard: public ABCAnimal {
  public:
    ...                           // no dtor
};

int main(int argc, char** argv)
{
  ABCAnimal* pabc1;
  ABCAnimal* pabc2;

  cout << "end of main" << endl;
}

Upto here, NO comile error and works fine. However, the following emits errors:

int main(int argc, char** argv)
{
  ABCAnimal* pabc1;
  ABCAnimal* pabc2;

  Lizard liz1;

  cout << "end of main" << endl;
}

GCC error is:

/tmp/cciltEbG.o: In function `Lizard::~Lizard()':
abc.cpp:(.text._ZN6LizardD2Ev[_ZN6LizardD5Ev]+0x16): 
  undefined reference to `ABCAnimal::~ABCAnimal()'
collect2: ld returned 1 exit status

To fix this, add implementation:

class ABCAnimal {
  public:
    ...
      virtual ~ABCAnimal() = 0;       // pure dtor
};

ABCAnimal::~ABCAnimal() {}


={============================================================================
*kt_dev_cpp_003* cpp-default-argument

{in-function}
The default argument in function. If a parameter has a default argument, all
the parameters that follow it 'must' also have default arguments. The default
arguments are used from right most arguments that means that user provided
arguments are used from left most.

typedef string::size_type sz;
string screen( sz ht = 24, sz wid = 80, char background = ' ' );
string screen( sz ht = 24, sz wid, char background = ' ');           // ERROR

string window = screen();        // == screen( 24, 80, ' ');
string window = screen(66);      // == screen( 66, 80, ' ');
string window = screen(66,256);  // == screen( 66, 256, ' ');

So consider ordering the parameters in declaration so that those lesat likely
to use a default value appear first. 


{in-ctor}

class T {
  T() = default;
  T(const string s) : bookNo(s) {}
  ...
  string bookNo;
};

equals to: see there is no default ctor here

class T {
  T(const string s = "") : bookNo(s) {}
  ...
  string bookNo;
};


{in-virtual}
The default arg in 'virtual' func will 'always' be used base's one even when
the drived version is run because default arg is 'statically' bound. So the
recommendation is that should use the same argument values in the base and
derived.

Problem case is:

class Shape {
  public:
    enum ShapeColor { Red, Green, Blue };
    virtual void draw( ShapeColor color = Red ) const = 0;
    ...
};

class Rectangle : public Shape {
  public:
    virtual void draw( ShapeColor color = Green ) const;
    ...
};


*cpp-remember*
Use carefully as there are logical cases where need to have args from the same
source. For example, it's logical error when one arg is from def init and the
other is from the user.


={============================================================================
*kt_dev_cpp_003* cpp-copy-control

{copy-control}
copy ctor, copy assign, move ctor(C++11), move assign(C++11)

If not defined, complier will synthesise them. Don't use syn version of copy
controls when use dyn allocated resource. *kt_dev_cpp_004* 


{cpp-copy-ctor} copy-init, pass-by-value
Initialize object `from the other of the same-type` Ask compiler to copy the
right-hand operand into the object being created, and to convert that operand
if necessary.

The first arg is a reference to a class and the rest args can be defaults. 

class Foo {
  Foo(const &Foo);   // wrong
  Foo(const Foo&);   // okay
};

Used in contexts:

* `copy-form-init` for the same type and converting-ctor for different type
* `pass-by-value` function call for `nonreference` type parameter
* `return-by-value` for nonreference type *cppy-copy-ctor-return*

  *cpp-remember*
  converting-ctor will be used if return statement requires conversion.

* `list-form-init`
// ?? implicit 'coversion' using temp object. 

For pass and return by value they are rightly nonreference type and
`copy-inited`. Hence called `copy-ctor`. Defines how pass-by-value is
implemented for the type.


<synthesized-copy-ctor>
Do `memberwise-copy` the members of its argument. The type of each member
determines how that member is copied. Members of class type are copied by the
copy ctor for that class and members of built-in are copied directly.

class Sales_data
{
  public:
    Sales_data( const Sales_data & );

  private:
    std::string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
};

The equivalent copy constructor that would be synthesized:

Sales_data::Sales_data( const Sales_data& orig ):
    bookNo( orig.bookNo ),          // use string copy constructor
    units_sold( orig.units_sold ),  // use direct copy
    revenue( orig.revenue )
{}


<ex>
#include<iostream>
#include<string>
#include<memory>

using namespace std;

class Foo 
{
  public:

    Foo()
    { cout << "Foo's def ctor" << endl; }

    Foo( int val ) 
    { fval = val; }

    Foo( const Foo &f )
    { fval = f.fval; cout << "Foo's copy ctor: " << fval << endl; }

    int get() { return fval; }

  private:
    int fval;
};

class FooFoo
{
  public:
    FooFoo(int val) : foo(val) 
      { cout << "FooFoo's ctor: " << val << endl; }

    // note: calls foo's `copy-ctor`.
    //
    // FooFoo(const FooFoo& arg): foo(arg.foo) 
    // { cout << "FooFoo's copy ctor: " << foo.get() << endl; }

    // note: calls foo's `default-ctor`. value-init
    //
    // FooFoo(const FooFoo& arg): foo() 
    // { cout << "FooFoo's copy ctor: " << foo.get() << endl; }

    // note: calls foo's `default-ctor`. value-init
    //
    // FooFoo(const FooFoo& arg) 
    // { cout << "FooFoo's copy ctor: " << foo.get() << endl; }

  private:
    Foo foo;
};

int main()
{
  FooFoo ax(100);
  FooFoo bx(200);

  // note: both shows the same result. calls copy-ctor.
  FooFoo cx = bx;     // `copy-init`
  FooFoo cx(bx);      // `direct-init`
}

FooFoo's ctor: 100
FooFoo's ctor: 200
Foo's copy ctor: 200
FooFoo's copy ctor: 200


<why-reference-parameter>
Why copy-ctor own parameter `must-be-a-reference`? 

If it is not a reference, then the call would never succeed. To copy-construct
object, use copy-ctor and copy-ctor itself is a function. Need to use copy-ctor
to copy argument and to copy the argument, use copy-ctor. `indefinite-recursive` 

NO. Actualy, compile error:

:35:28: error: invalid constructor; you probably meant ‘FooFoo (const FooFoo&)’


{copy-assign} deleted-copy-controls. reference-member.
As with copy-ctor, cannot use synthesied `copy-assign` when there are reference
and const member data. Because copy assign is 'deleted' if the class has a const
or reference member. CPR 508.

// uses operator-overload and must be a member

class Foo {
  Foo& operator=(const Foo&);
};

The copy-assign controls how objects of its class are assigned

Sales_data trans, accum;
trans = accum;

Assign with different types? Need additional copy-assign.


<assignment-must-return-a-reference-to-this>
EC++10. All assign operations must follow this convention like built-in types
because of 'chain' of assignment and should behave the same as built-in types.

x = y = z = 15;   // right associative

Widget wx, wy, wz;
wx = wy = wz = DefaultWidget;

class Widget {
  public:
    Widget& operator=( const Widget& rhs )
    {
      ...
      return *this;
    }
};


{the-rule-of-three-or-five}
The rule of three (the rule of five in C++11) is a rule of thumb in C++ that
claims if a class defines one of the following it should probably explicitly
define all three:[1]

note: 
Nevertheless, needing either the copy-ctor or the copy-assign does not
(necessarily) indicate the need for a destructor.

note:
Why 3 or 5? Do not need ctor.


<ex> CPR 505
The need of own dtor for a class allocating dynamic resources is obvious.
Since if there's no dtor defined, the syn dtor will `not-run-delete` on the
pointer, ps, so must define own dtor. How possibly the compiler can know what
pointer member points to?

However, the need of own copy ctor and assign is less clear. See what will
happen when use syn versions of copy and assign. 

class HasPtr {
  public:
    HasPtr(const std::string& s = std::string() )  // def arg and def ctor 
      : ps( new std::string(s)), i(0) {}

    ~HasPtr() { delete ps; }

  private:
    std::string* ps;
};


<not-a-choice-of-style>
What are the problems? The syn versions does not operate well for a class using
dyn resource.

HasPtr func(HasPtr hp)  // member-wise copy using a syn copy ctor.
{
  HasPtr ret = hp;      // a syn copy assign. ret and hp points the same.
  ...
  return ret;           // `double free` on ret and hp, when exit a call
}

There still is an issue even if there is no return:

HasPrt p("...");
void func(p);

// p and func's arg points the same. when func exits, func's arg is deleted and
// p has invalid pointer which was already deleted after func().

HasPrt q(p);

// p and q have invalid pointer.

So must define copy-ctor and copy-assign as well. Two methods on what copying an
object will mean: `valuelike or pointerlike` what when copying pointer member
will mean


<for-const-reference-member>
Must define own copy-controls when there are const and reference members because
compiler will not create syn versions since cannot 'rebind' const and reference.

TODO:
How to define user copy controls for these cases? real use case?


{construct-and-copy-all-parts}
EC++12. When having own copy functions(copy-ctor and copy-assign), then means
that you shall have `full responsibility` for copying. Two cases: 

1. When add member variables to a class.

Customer& Customer::operator=( const Customer& rhs )
{
  name = rhs.name;
  return *this;
}

If add new member data, then must update 'all' copy functions and ctors too.
Otherwise, have copy functions to copy 'parts' of object but not all.

2. When defines copy functions for derived class. Have to handle 'base' part
as well because having own copy controls means to have full responsibilities.

class PriorityCustomer: public Customer {
  ...
  PriorityCustomer::PriorityCustomer( const PriorityCustomer& rhs )
  :priority( rhs.priority )
  {
  }

  PriorityCustomer& PriorityCustomer::operator=( const PriorityCustomer& rhs )
  {
    priority = rhs.priority;
    return *this;
  }
};

<problem>
The problem is that this code do nothing about base part and that means: 

For construction, PriorityCustomer ctor will use a default ctor of Customer
and Customer part will be default init. For copy, PriorityCustomer copy-ctor
will do nothing on Customer part and it will remain unchanged. So shall be:

class PriorityCustomer: public Customer {
  ...
  PriorityCustomer::PriorityCustomer( const PriorityCustomer& rhs ) 
  :Customer(rhs),~
  priority( rhs.priority )
  {
  }

  PriorityCustomer& PriorityCustomer::operator=( const PriorityCustomer& rhs )
  { 
    Customer::operator=(rhs); ~
    priority = rhs.priority;
    return *this;
  }
};


={============================================================================
*kt_dev_cpp_004* cpp-copy-assign-self

{self-assign}
EC++11. When implement `copy-assign`, must think about self-assign and
exception-safe.

Why? because there are 'less' obvious self-assignment cases and are the result
of aliasing: having more than one way to refer to an object.

<one> aliasing

a[i] = a[j];   // potential assign to self when i==j
*px = *py;     // potential assign to self when point to the same

<two> aliasing in same class hierarchy since base ptr can point to derived.
Here, rb and *pd might actually be the same.

void doSomething( const Base& rb, Derived* pd );


EXP++38.

Use `direct-self-assign-check` for optimization and use `copy-and-swap-idiom`
for correct implementation.


{direct-self-assign-check}

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  if( this != &rhs )
  {
    // ...
  }
}


{copy-and-swap-idiom}
Classes that define `swap` often use it to define their `copy-assign`. This
`swap`s the lhs operand with a 'copy' of the rhs.

// valuelike
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

To

// HasPtr copy-ctor copies the string in right hand operand into rhs before
// changing left hand operand.
HasPtr& HasPtr::operator=(HasPtr rhs)
{
  swap(*this, rhs);             // see *cpp-copy-swap* for HasPtr::swap()
  return *this;                 // rhs is destroyed, which deletes the old ps.
}

The `copy-and-swap-idiom` is exception-safe which automatically handle
self-assign.

The only code that might throw is the new expression 'inside' the copy-ctor.
If an exception occurs, it will happen before having changed the lhs.

Also EC++11 says the compiler can generate more efficient code by moving
copying from the function body to parameter construction. 


={============================================================================
*kt_dev_cpp_003* cpp-pass-by-reference cpp-reference

{pointer-and-reference} *ex-interview*

EC++20. If you peek under the hood of a C++ compiler, will find that references
are typically implemented as pointers. 

To this question, reference may or may not be the same as pointer. In user
level, there are differences and in compiler level, implemented as pointers.
The reference is a sub set of pointer which is limited in use?


{why-reference}
* No copy made so efficient code
* Syntatic need such as operator[]


{differences}
"No operator operates on a reference" which means operation becomes operation
on underlying object since a reference is another name.

* `no-null-reference` and 'must' be initialized. 

From MEC++01. Always refer to an object. Unlike pointer, no need to check its
validity.

void printDouble( const double& rd )
{ cout << rd; }

vs.

void printDouble( const double* pd )
{
  if(pd)
    cout << *pd;
}

So efficient code.

<2>
Used operator funcs such as operator[]. {Q}

vector<T> v; v[5] = 10;


* `bound-once`

All operations on that reference are actually operations on the object to
which the reference is bound. Reference is `bound-once` but for pointer, can
change pointer itself and can point any other objects.


* `no-reference-to-reference` 

There is no reference to a reference. but there's a pointer to a pointer. 

note: 
This do not mean it's a compile error but mean that don't have the same as
pointer has. This refVal3 binds to iVal but not to refVal. No comile error for
below cases.

int &refVal = iVal;
int &refVal3 = refVal;

int &refVal = iVal;        // the same and no compile error
int &refVal3 = iVal;


<6>
Reference should 'match' to type and cannot bind to a literal.

int &ref = 10;                        // error
double dval = 3.14; int &ref = dval;  // error


* `no-const-reference` whreas reference-to-const
 
There is no const reference but there's a const pointer because a pointer is
object. Like any other const object, const pointer must be initialized.

error: uninitialised const ‘pint’ [-fpermissive]

CPR p50. A reference is not an object. object does not mean only object of
class. A reference defines an `alternative-name` for an object. This is called
binding hence 'must' be initialized.

int *const cpi = &i;    // const-pointer


* `no-address ?` No it's an example showing "no operator operates on a
  reference"

A reference has no address. 

{
  int ival = 100;
  int &iref = ival;
  int &irref = ival;

  cout << "ival : " << ival << endl;
  cout << "iref : " << iref << endl;
  cout << "irref: " << irref << endl;

  cout << "ival : " << &ival << endl;
  cout << "iref : " << &iref << endl;
  cout << "irref: " << &irref << endl;
}

ival : 100
iref : 100
irref: 100
ival : 0xbfead4a4
iref : 0xbfead4a4
irref: 0xbfead4a4


* `no-array-of-reference` no-pointer-to-reference

No array and vector of reference.

int* ptrs[10];
int& refs[10];    // error. no arrays of ref


o C++PL p198. If you need a notion of "no value", pointers offer nullptr.
  There is no equivalent null reference, so if you need a no value using a
  pointer may be most appropriate.


<ex>
EC++20

class Person {
  ...
  private:
    string name;
    string address;
};

class Student: public Person {
  ...
  private:
    string schoolName;
    string schoolAddress;
};

When call this function, it costs six ctor and dtor: x4 string, Person and
Student. 

bool validateStudent(Student s);

Student plato;
validateStudent(plato);

Use refernece to avoid these cost of copying:

bool validateStudent(const Student& s);

The good points: 

* Less expensive since no object creation so more 'performance'. So
  recommendation is that: 

  use `pass-by-value` for built-in, iterator, and `function-object` 
  use `pass-by-reference` for class types.

* The `const` is necessary since in pass-by-value case, the caller know that
  they are shielded from any changes the function might make. To have the same
  for pass-by-reference, need const. 

* Can avoid `sliced-off` problem. For example:

class Window {
  public:
    ...
    std::string name() const;
    virtual void display() const;
};

class WindowWithScrollBars: public Window {
  public:
    ...
    virtual void display() const;
};

void printNameAndDisplay(Window w)  // see
{
  std::out << w.name();
  w.display();
}

WindowWithScrollBars wwsb; 
printNameAndDisplay(wwsb);

Which version of display will be called? Always be the Window::display() since
it is pass-by-value using Window copy ctor and is sliced-offed. Hence Window
object. To fix this, should use pass-by-reference.

void printNameAndDisplay(const Window& w)
{
  std::out << w.name();
  w.display();
}


<ex>
There is a difference between called-by-reference(passed-by-reference) and
called-by-value.

void reset( int i )
{ i = 0; }

int j = 42;
void reset (j); 

what's the value of j here?


void reset( int* pi )
{ *pi = 100; pi = 100; }

int j = 42;
void reset( &j );

what's the value of j here?

Here reference i will be bounded to whatever int object we pass and say "pass an
object" directly. So no need to pass its address.

void reset(int &i)
{ i = 0; }

int j = 42;
reset(j);      // note: no need to pass its address

what's the value of j here?

For called-by-reference, C uses pointers and C++ uses reference. Use C++ way of
doing it.


<ex> *cpp-ex-tree* *cpp-recursive*

TreeNode* TreeInsert( TreeNode* root, TreeNode* newnode )
{
  if(!root)
  {
    root = newnode;
    root->left = root->right = NULL;
  }
  else if( LT(newnode->entry.key, root->entry.key) )
    root->left = TreeInsert( root->left, newnode);
  else
    root->right = TreeInsert( root->right, newnode);

  return root;
}

int main()
{
  TreeNode *proot, *pnode;
  CreateTree( &proot );

  for(int idx = 0; idx < size; idx++)
  {
    pnode = MakeTreeNode( arr[idx] );
    proot = TreeInsert( proot, pnode );
    // TreeInsert( proot, pnode );        // ERROR
  }
  ...
}

The problem is that it does not update proot with the return from TreeInsert
when recursive ends and proot remains null.

Since this passes pointer by value; that is pass by value but value is a
pointer although uses pointer form. The point is that this do not change what
pointer points to but change pointer itself. 


Revised to use `pass by reference`

void TreeInsert( TreeNode** root, TreeNode* newnode )
{
  if(!*root)
  {
    *root = newnode;
    (*root)->left = (*root)->right = NULL;
  }
  else if( LT(newnode->entry.key, (*root)->entry.key) )
    TreeInsert( &((*root)->left), newnode);
  else
    TreeInsert( &((*root)->right), newnode);
}

int main()
{
  for(int idx = 0; idx < size; idx++)
  {
    pnode = MakeTreeNode( arr[idx] );
    TreeInsert( &proot, pnode );
  }
}


The pass by reference is not about the form, pointer or reference, but about
whether it's object itself, 'pointed' object and something referring to.


<ex>
tree example from random-binary-search-tree-template-version

template <typename Entry>
class Binary_tree 
{
   Binary_node<Entry> *root;
};

template <typename Record>
Error_code Search_tree<Record>::insert( const Record &new_data )
{
  return search_and_insert( this->root, new_data );
}

// As with the above example, have to use reference of pointer *cpp-base-type*
// Otherwise, suffers the same problem as TreeInsert().
// 
// Error_code Search_tree<Record>::search_and_insert( 
//  Binary_node<Record> *sub_root, 
//  const Record &new_data); 

template <typename Record>
Error_code Search_tree<Record>::search_and_insert( 
    Binary_node<Record> *&sub_root, 
    const Record &new_data ) 
{
  if( sub_root == NULL )
  {
    sub_root = new Binary_node<Record>(new_data);
    return success;
  }
  else if( new_data < sub_root->data )
    return search_and_insert( sub_root->left, new_data );
  else if( new_data > sub_root->data )
    return search_and_insert( sub_root->right, new_data );
  else 
    return duplicate_error;
}

See how using a reference can make a code simple and neat to implement pass by
reference approach than using a pointer.


{return-reference-vs-copy}
Beware a func that returns copy or reference. QUIZ: maybe a quiz?

class Screen {
  public:
    Screen() : move(0), set(0) {}
    <01> Screen& set_move(int val) { move = val; return *this; }
    <01> Screen& set_move(int val) { move = val; }
    <02> Screen set_move(int val) { move = val; return *this; }
    <02> Screen set_move(int val) { move = val; }
    void set_set(int val) { set = val; }
    void print() { cout << "Screen: move " << move << ", set: " << set << endl; }

  private:
    int move;
    int set;
};

int main()
{
  Screen myscreen;

  // shows that the call and dot operator has the same precedence and left
  // associative. so can use the result of a call to call a member of the
  // resulting object.

  myscreen.set_move(5).set_set(10);
  myscreen.print();
}

<01> return reference
5, 10

<02> return copy
5, 0

Since <02> set_move returns a copy and set_set is called upon the copy, no
changes on myscreen object.


<ex>
// where back() returns a reference
auto &v = container.back();
auto v = container.back();

Which one of these use reference?

void t_type_01()
{
  Screen myscreen;

  auto &rs = myscreen.set_move(5);
  rs.set_set(10);
  myscreen.print();
  cout << "rs is: " << typeid(rs).name() << endl;

  auto cs = myscreen.set_move(5);
  cs.set_set(10);
  myscreen.print();
  cout << "cs is: " << typeid(cs).name() << endl;
}

Screen: move 5, set: 10
rs is: 6Screen
Screen: move 5, set: 10
cs is: 6Screen
end of main


{return-by-value} EC++21

The `pass-by-reference` is great so always use reference? However, there are
cases that must return a copy not a reference such as operator*(). This is a
operator to multiply not to dereferene.

note:
How distinguish between two multiply and dereferene?

// dereferene operator, member
T& operator*() { return *ptr_; }
    
// multiply operator, nonmmber
friend const T operator*( const T &lhs, const T &rhs );


These are tries to save a construction cost by using pass-by-reference. Not
quite right.

<1> 
Use stack but remember a refenrece is a name for some 'existing' object. Here
returns a reference to object that no longer exist.

Rational c = a*b;

class Rational {
  friend const Rational& operator*( const Rational& lhs, const Rational& rhs )
  {
    Rational retult( lhs.n*rhs.n, lhs.d*rhs.d );
    return result;
  }
};


<2> 
Use heap but there is no way to delete in case: 

Rational w, x, y, z;
w = x*y*z;

class Rational {
  friend const Rational& operator*( const Rational& lhs, const Rational& rhs )
  {
    Rational *retult = new Rational( lhs.n*rhs.n, lhs.d*rhs.d );
    return *result;
  }
};


<3> 
Use function static? Not right for multi-threaded and even for
single-threaded.

class Rational {
  friend const Rational& operator*( const Rational& lhs, const Rational& rhs )
  {
    static Rational retult;
    ...
    return result;
  }

  bool operator==( const Rational& lhs, const Rational& rhs);
};

Rational a, b, c, d;

if( (a*b) == (c*d) )
{
  ...
}

This will always true since it is evaluated as

if( operator==( operator*(a,b), operator*(c,d) ) )

Therefore, should return a copy and pay a small cost for correct behavior.

class Rational {
  friend const Rational operator*( const Rational& lhs, const Rational& rhs );
  ...
};

*cpp-remember* C++PL p191
To keep a program readable, it is often best to avoid functions that modify
their arguments. Instead, you can return a value from the function explicitly:

void increment(int &aa) { ++aa; }
int next(int p) { return p+1; }

void g()
{
  int x = 1;
  increment(x);   // x = 2
  x = next(x);    // x = 3
}

The increment(x) notation doesn't give a clue to the reader that x's value is
being modified, the way x = next(x) does. Consequently, "plain" reference
arguments should be used only where the name of the function gives a strong
hint that the reference argument is modified.


={============================================================================
*kt_dev_cpp_003* cpp-vexing-parse

<ex> EXC++42
this is function declaration for a function named t that takes no parameters
and returns T by value.

T t();            // compare with int t();

<ex>
The intention is to have value-init but defines a function.

std::string source();
source = _determineSource((char*)in, &sourcelen, &inIndex, &usePath);

error: assignment of function 'std::string source()'
error: cannot convert 'std::string' to 'std::string()' in assignment

note: 
see 'function' in error message. to use it as intended, create a temporary and
use copy initialzation. not useful.

std::string source = string();

<ex>
CPR 293. Using the default ctor.

Sales_data obj();

if (obj.isbn() == Primer.isbn())

Intended to declare a default-init object but the compiler complains that cannot
  apply member access notation to a function. The correct way:

Sales_data obj;

<ex>
From C++CA 2.1.1, if you pass a 'temporary' rather than a named variable the the
syntax can be the same as that of a fuction declaration.

class background_task;
std::thread my_thread( background_task() );     // T is std::thread

This declares the `function` my_thread that takes a single parameter which is
  pointer to a function taking no parameters and returning a background_task
  object. 
  
However, the intention was to create std::thread `instance` with function object
to run.

Solution?

std::thread my_thread( (background_task()) );   // extra ()
std::thread my_thread{ background_task() };     // brace-init


={============================================================================
*kt_dev_cpp_004* cpp-copy-dyn-resource cpp-ex-hasptr-exmaple

{when-use-resource-has-dyn-lifetime}
* Don't know how many object is needed
* Don't know the exact type of object
* Share data between objects


{valuelike-or-pointerlike}
The topic about valuelike or pointerlike is the difference in how to implement
copy functions of a type. No different in swap discussion.

<valuelike> deep-copy, self-contained-object
The copy and the original are independent since copy underlying object as well.
note: The STL containers and string use valuelike copy.

class HasPtr {
  public:
    HasPtr(const std::string& s = std::string() )  // def arg. 
      : ps( new std::string(s)), i(0) {}
    >
    // copy ctor that copies the string, not just the pointer.
    HasPtr(const HasPtr& p):
        ps( new std::string( *p.ps ));

    // copy assign to free the object's existing string and copy the string from
    // its rhs.
    HasPtr& operator=(const HasPtr& p);

    // dtor to free the string
    ~HasPtr() { delete ps; }

  private:
    std::string* ps; 
    int i;
};

<copy-assign>
Assignment operator typically combine the actions of the dtor and the copy-ctor
since destroys the lhs operand and copies data from the rhs.

Think about self-assign and exception safe. The below covers self-assign and
exception-safe. See *kt_dev_cpp_019* for more on self-assign and exception

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

// WRONG on self-assign and exception-safe
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  delete ps;
  // if it is self-assign, are copying from deleted memory.
  auto newp = new string(*rhs.ps);
  ps = newp;
  return *this;
}

<pointerlike> shallow-copy, own-reference-counting
The copy and the original share underlying object like shared_ptr. To show own
reference counting:

class HasPtr {
  public:
    // see default arg and new size_t
    HasPtr(const std::string& s = std::string() ) 
        : ps( new std::string(s)), i(0), use( new std::size_t(1) ) {}

    // if separate constructors in two. the difference is a cost of temporary.
    // HasPtr() 
    //     : ps( new std::string()), i(0), use( new std::size_t(1) ) {}

    // HasPtr(const std::string &s) 
    //     : ps( new std::string(s)), i(0), use( new std::size_t(1) ) {}

    HasPtr(const HasPtr& p): ps( p.ps ), use( p.use ) { ++*use; };

    HasPtr& operator=(const HasPtr& p);
    ~HasPtr();
      
  private:
    std::string* ps;
    std::size_t* use; 
};

HasPtr::~HasPtr()
{
  if( --*use == 0 )
  {
    delete ps; delete use;
  }
}

The copy assign do dtor and copy constructor. handle self-assign

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  ++*rhs.use;

  // lhs
  if( --*use == 0 )
  {
    delete ps; delete use;
  }

  ps = rhs.ps;
  use = rhs.use;

  return *this;
}


={============================================================================
*kt_dev_cpp_006* cpp-copy-swap 

If a class defines its own swap, the algorithm uses that class-specific
version. Otherwise, uses the swap defined by the library, use std::swap().

{why-swap}

`optimization`

CPR 516. Classes that manages 'resources' often also define a swap. Defining
swap is particularly important for classes that plan to `use with algorithms`
that 'reorder' elements. Such algorithms call swap whenever they need to
exchange two elements. reorder uses copy-assign.

note:
`swap` is more to use with algorithms than to support valuelike classes. Since
as in HasPtr example, the version which uses swap, has a cost of copying
argument and better than the original version. However, pointerlike is still
wins.

// valuelike
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

// HasPtr copy-ctor copies the string in right hand operand into rhs before
// changing left hand operand.
HasPtr& HasPtr::operator=(HasPtr rhs)
{
  swap(*this, rhs);             // see *cpp-copy-swap* for HasPtr::swap()
  return *this;                 // rhs is destroyed, which deletes the old ps.
}


<typical-swap>
The typical swap involves "one copy and two assignments"

T temp = v1;
v1 = v2;
v2 = temp;

HasPtr temp = v1;
v1 = v2;
v2 = temp;

None of this memory allocation is necessary. If could swap its internal
strcture, pointers in this case rather than using library swap, expects
efficiency and constant-time operation. 


<nonmember-friend-swap> 
CPR 516. non-member and friend swap. Take "valuelike" example.

class HasPtr {

  friend void swap( HasPrt&, HasPtr& );         // note: friend

  public:
   HasPtr(const std::string& s = std::string() )
    : ps( new std::string(s)), i(0) {}
        
   ~HasPtr() { delete ps; }

  private:
   std::string* ps;
};

inline void swap( HasPtr& lhs, HasPtr& rhs )
{
  using std::swap;                              // note:  
  swap( lhs.ps, rhs.ps );                       // resolved to std::swap()
  swap( lhs.i, rhs.i );
  
  OR 

  std::swap( lhs.ps, rhs.ps );
  std::swap( lhs.i, rhs.i );
}

Although doesn't matter in this particular case if use std::swap or swap since
there is no type specific swap for built-in types because ps is a pointer to
string, 'must' use 'unqualified' swap but not std::swap to try type specific
version first.

If it was pointerlike, own swap is not necessary. The pointerlike is good for
copy-control and swap.

<swap-and-const>
swap works always regardless of const.Here swap works on built-in type,
     pointer which is not affected by constness check; bitwise const.


`exception-safety`

Like STL containers, provide both memeber and nonmember swap. To have the
member version swap never throw exception because it use swap on built-in
types that never throw exception. This offers the strong excepiton-safety
guarantee.


{swap-resolution}

How "try type version and std version next if there isn't" works? Two things:

{
  using std::swap;
  swap( T, T );
}

* Type specific version is a better match in function matching since std::swap
  is template.

* Use *arg-dependent-lookup* in swap( HasPtr&, HasPtr& ).

note: 
Why not "using std::swap" hide swap(T)? Since it simply add name in the
name-lookup search and the swap(T) is better match than std::swap.


{ex-define-swap-using-specialization}
EC++25. *pattern-pimpl-idiom*

class WidgetImpl {                          // class for Widget data;
   public:                                  // details are unimportant
      ...

   private:
      std::vector<double> v;                // possibly lots of data 
                                            // expensive to copy!
};

class Widget {                              // class using the pimpl-idiom
   public:
      Widget(const Widget& rhs);
>
      Widget& operator=(const Widget& rhs)  // to copy a Widget, copy its
      {                                     // WidgetImpl object. For
       ...                                  // details on implementing
       *pImpl = *(rhs.pImpl);               // operator= in general,
       ...                                  // see Items 10, 11, and 12.
      }
<
   private:
      WidgetImpl *pImpl;                    // ptr to object with this
};                                              

Imagine how expensive it may be when there's no swap for Widget and when use
`std::swap()`

Widget A, B; 
swap(A, B);

All we really need to do is swap their pImpl pointers, but the default swap
algorithm has no way to know that. Instead, it would copy not only three
Widgets, but also three WidgetImpl objects. Very inefficient. Cost three
copies that use 'operator=' of valuelike class. For some types such as
pattern-pimpl-idiom none of these copies are really necessary. How to avoid
these cost? To address this, should provide `type specific` swap to be used
by clients:


<attempt-one> use swap member and total-template-specialization

namespace std {

  template<typename T>          // typical implementation of std::swap;
  void swap(T& a, T& b)         // swaps a's and b's values
  {
    T temp(a);
    a = b;
    b = temp;
  }
}

This is a way to say that to specialize std::swap for Widget. This is called
`total-template-specialization`. See *cpp-template-specialization* 

namespace std {                              

  // note 
  // 1. in std namespace
  // 2. this is a specialized version of std::swap when T is Widget.
  // 3. syntax and own definition.

  template<>                                 
  void swap<Widget>(Widget& a, Widget& b)    
  {
    // to swap Widgets, just swap their pImpl pointers
    swap(a.pImpl, b.pImpl);                  
  }
}

'not' permitted to 'alter' the contents of the std namespace, but we are
allowed to totally specialize standard templates (like swap) for types of our
own creation (such as Widget).

This function will not compile because it is trying to access the pImpl
pointers inside a and b, and they are 'private' so other ways might be:

  * Could declare our specialization a friend, but the convention is different:
    so not consider. 

  * Have a 'public' swap member and specialized std::swap calls member swap.
    It's okay since do not use friend here.

class Widget {                     // same as above, except for the
public:                            // addition of the swap mem func
  ...
  void swap(Widget& other)
  {
    using std::swap;               // the need for this declaration
    swap(pImpl, other.pImpl);      // to swap Widgets, swap their pImpl pointers
  }
  ...
};

namespace std {

  template<>
  void swap<Widget>(Widget& a, Widget& b)
  {
    a.swap(b);                     // to swap Widgets, call member function
  }
}

this works since the specicialised version wins in funcation matching.


<attempt-two> use-template-specialization for class template
However, suppose that Widget and WidgetImpl were class templates instead of
classes. Needs more generic solution but cannot use the same as before since the
specialization would look like:

namespace std {

  template<typename T>                       
  void swap<Widget<T>>(Widget<T>& a, Widget<T>& b)
  {
    a.swap(b);                     // to swap Widgets, call their
  }                                // swap member function
}

This is 'illegal' code since C++ `do not allow 'partial' specialization` for
function template. If this is possible, then it means that can add a template
into std namespace.

The overloading function-template is fine, but std is a special namespace, and
the rules governing it are special, too. It's okay to totally specialize
templates in std, but it's not okay to add new templates (or classes or
    functions or anything else) to std. Undefined behavior.


<attempt-three> solution
This works as well for classes as for class templates. Just don't declare the
non-member to be a specialization or overloading of std::swap.

namespace WidgetStuff {
  // templatized WidgetImpl, etc.
  ...                                     

  // as before, including the swap member function
  template<typename T>                    
  class Widget { ... };                   

  ...

  // overloaded nonmember swap function. not part of the std namespace
  template<typename T>                    
  void swap(Widget<T>& a, Widget<T>& b)
  {
    a.swap(b);
  }
}

This use swap(Widget<T>&, Widget<T>&) through *arg-dependent-lookup*


<why-using-std-swap>
What you desire is to call a type-specific version if there is one, but to
fall back on the general version in std if there's not. Here's how you fulfill
your desire:

template<typename T>
void doSomething(T& obj1, T& obj2)
{
  using std::swap;           // make std::swap available in this function
  ...
  // try the best swap for objects of type T via *arg-dependent-lookup* 
  swap(obj1, obj2);          
  ...
}

There are important subtleties:
1. use unqualified swap to search for class-specific swap version
2. use using std::swap to make it visiable in current scope so fall back on
std::swap when there is no class-specific version.


<attempt-four> 
attempt-treee and plus std::swap specialization when write class but not class
templeate Why? To cover possible wrong use like:

std::swap(obj1, obj2);

This force compiler to consider only the swap in std including any template
specialization. In addition to the type specific swap in a class, have
specialized std::swap to call member swap. This is to make type-specific swap
implementations available to code written in this fashion.


{case-ex}
Used attempt-three and `stl-vector` taken from <vector> template in gcc and
this means stl-vector is `valuelike` 

As shown the reference, to provide special implementations for more complex
types by using function overloading.

template<typename _Tp, typename _Alloc = std::allocator< _Tp >>
class vector : protected _Vector_base<_Tp, _Alloc>
{
  ...

    /**
     *  @brief  Swaps data with another %vector.
     *  @param  x  A %vector of the same element and allocator types.
     *
     *  This exchanges the elements between two vectors in constant time.
     *  (Three pointers, so it should be quite fast.)
     *  Note that the global std::swap() function is specialized such that
     *  std::swap(v1,v2) will feed to this function.
     */
    void
    swap(vector& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
          __x._M_impl._M_end_of_storage);

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 431. Swapping containers with unequal allocators.
      std::__alloc_swap< _Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
    }
  ...
} # end of class template

The key is that this is 'overloaded' global swap() for 'this' type. That means
that every container has member and nonmember swap.

/// See std::vector::swap().
template<typename _Tp, typename _Alloc>
  inline void swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
  { __x.swap(__y); }


{swap-usage}
There are two use cases:
<1>

As with "Widget A, B; swap(A,B);"

vector<string> svec1(10);
vector<string> svec2(24);

swap( svec1, svec2 );

Which swap will this call? The type specific which is nonmember in vector
because *arg-dependent-lookup* try to find nonmember swap and leads to call
member swap as seen vector code above. This is why nonmbmer swap is introduced
in the first place. 

Primers p339. In C++, STL container provides member and nonmember swap and
previously supports member only.

<2>
As with an example of copy-and-swap-idiom, to implement class copy controls. 

<Q> The reference says that this is std::swap implementation
The function swap() is provided to swap the values of two objects. The general
implementation of swap() is defined in <utility> as follows

namespace std {
  template <typename T>
    inline void swap(T& a, T& b) ... {
      T tmp(std::move(a));
      a = std::move(b);
      b = std::move(tmp);
    }
}

So which one is better between type specific swap or std::swap given move
sementics are supported by all containers?


={============================================================================
*kt_dev_cpp_004* cpp-copy-control cpp-ex-message-example

{copy-control-for-bookkeeping} 

example do not allocate dynamic resources but needs copy-controls.

CPR 519. Although copy control is most often needed for classes that allocate
resources, that is not the only reason and some class have bookkeeping or
other actions that copy control must perform.

Folder (set of pointers to Message)  Message (set of pointers to Folder)
[ ][ ][ ][ ][ ]: set                 message text
                                     [ ][ ][ ][ ]: set

Folder (set of pointers to Message)  Message (set of pointers to Folder)
[ ][ ][ ][ ][ ]: set                 message text
                                     [ ][ ][ ][ ]: set
...                                  ...


<lits-of-operations-message-class> how to sketch a class

1. The important requirement to remember:
  Folder has pointers to Messages that is has and Messages has pointers to
  Folders it belongs.

2. Message class provide save() and remove() operations to add or remove a
Message from a specified folder. To create a new Message, specify the contents
of the message but no folder. To put a message call save(). 

3. To copy a message, the copy and the original will be a 'distinct' Message
and shall be in the same 'set' of Folders. Thus copies the contents and to
make the new to appear in the same Folders as the original, must traverse
Folders to add a pointer to the new into each Folder. ADD. copy-ctor

4. To destroy a Message, remove it from the Folders. REMOVE. dtor.

5. To assign a Message, will replace the contents and remove Message from lhs
Folder-set and add that distinct Message to rhs Folder-set. REMOVE and ADD.
copy-assign.

  *cpp-remember*
  The copy assign often does the same work as is needed in the copy ctor and
  dtor. In this example, REMOVE and ADD. In such case the 'common' work should
  be put in private utility functions.


class Message {
  friend class Folder;

  public:
  // folders is implicitly initialized to the empty set
  explicit Message( const std::string &str = "" ): contents(str) {}

  // copy controls to manage pointers to this message
  Message( const Message& );
  Message& operator=( const Message& );
  ~Message();

  // add/remove this message from the specified Folder's set
  void save(Folder&);
  void remove(Folder&);

  private:
  std::string contents;
  std::set<Folder*> folders;

  void add_to_Folders( const Message& );
  void remove_from_Folders();
};

void Message::save( Folder& f )
{
  // add the given Folder to set of Folder of a Message. note: &f is pointer.
  folders.insert( &f );

  // add this Message to set of Message of a Folder
  f.addMsg(this);          
}

void Message::remove( Folder& f )
{
  folders.erase( &f );    
  f.remMsg(this);         
}

// m is the orignal message and add the copy into the set-of-Folders of the
// original.
void Message::add_to_Folders( const Message &m )
{
  for( auto f : m.folders )
    f->addMsg(this);
}

// see no parameter
void Message::remove_from_Folders()
{
  for( auto f : folders )
    f->remMsg(this);

  folders.clear();
}

// copy-ctor. <copying-stl-set>
Message::Message( const Message &m ): 
  contents(m.contents), folders(m.folders)
{
  add_to_Folders(m);
}

// dtor
Message::~Message()
{
  remove_from_Folders();
}

// copy-assign
Message& Message::operator=(const Message& rhs)
{
  remove_from_Folders();    // removes lhs

  contents = rhs.contents;
  folders = rhs.folders;    // <copying-stl-set>

  add_to_Folders(rhs);      // inserts rhs

  return *this;
}

note:
Handle self-assign by removing pointers to this message from lhs before
inserting pointers to rhs. If do inserting first, adding has no effect since
adds the same address(message) to a set in a folder. So would have removed
this from 'all' of its corresponding Folders.

Again, HasPtr example for self-assign and exception safe. 

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;        // removes lhs
  ps = newp;        // inserts rhs
  return *this;
}

The HasPtr example shows that <remove-insert-order> matters for exception-safe
and the Message example shows that it matters for correct behaviour. 


<swap-consideration>
Since the library string and set defines own swap, Message class will benefit
from defining own version of swap to avoid extraneous copies of `contents`
string and `folders` set members. 

However, must update a set of pointers that `Folders` have since after a
swap(m1, m2) call, the `Folders` that had pointed to m1 must now point to m2.

void swap( Message &lhs, Message &rhs )
{
  // not necessary in this case but good habit.
  using std::swap;

  // first pass. remove pointers to each message from Folders
  for( auto f: lhs.folders )
    f->remMsg(&lhs);
  for( auto f: rhs.folders )
    f->remMsg(&rhs);

  swap( lhs.folders, rhs.folders );       // swap(set&, set&). set::swap
  swap( lhs.contents, rhs.contents );     // swap(string&, string&). string::swap

  // second pass. add pointers to each message from Folders
  for( auto f: lhs.folders )
    f->addMsg(&lhs);
  for( auto f: rhs.folders )
    f->addMsg(&rhs);
}


<move-consideration>
The point is that by defining move operations, the Message class can use
`string::move` and `set::move` operations to avoid the overhead of copying the
contents and folders members.

In addition to moving the `folder` member, moving must update each Folder that
points to the original `Message` and both move ctor and assign need to update
Folder pointers. So make it common work.

// move Folder pointers 'from' m 'to' this message
void Message::move_Folders(Message *m)
{
    // use `set move assign` than copy, folders = m->folders
    folders = std::move(m->folders);  

    // use 'folders' for both add and remove but not m.folders
    for( auto f : folders ) 
    {
        f->remMsg(m);
        f->addMsg(this);
    }

    // ensure that destroying m is harmless
    m->folders.clear();
}


  note: no noexcept
  The inserting an element to a `set` might throw since it requires memory to
  be allocated. As a result, unlike HasPtr and StrVec case, will 'not' mark
  move operations as noexcept. 

Q: Whether or not noexcept is necessary requirement on move operations? See
noexcept on move in {conditions-to-use-move}


// move ctor
Message::Message( Message &&m ) 
  : contents(std::move(m.contents))           // string-move-ctor
{
  move_Folders(&m);
}

// move assign
Message& Message::operator=( Message &&rhs )
{
  if( this != &rhs )                          // direct check for self-assign
  {
    // remove lhs from folders
    remove_from_Folders();
    contents = std::move( rhs.contents );     // set-move-assign
    move_Folders(&rhs);
  }

  return *this;
}


={============================================================================
*kt_dev_cpp_004* cpp-copy-control-move cpp-move cpp-ex-strvec-example

In some circumstances, an object is 'immediately' destroyed after it is
copied. In those cases, moving rather than copying the object can provide a
significant performance boost. 

  IO or unique_ptr classes which cannot be copied but can be moved since these
  have a resource such as a pointer or an IO buffer that may not be shared.

note: In previous library, class stored in a container had to be 'copyable'.
Under new standard, can use container on types that cannot be copied so long
as they can be moved.

<own-allocation-example> CPR 524
Some classes need to allocate a varying amount of storage at rum time. Such
classes often can, and if they can, generally 'should' use a library container
to hold their data. However, this strategy does not work for every class. Some
classes need to do own allocation.

StrVec example which is a simplification of the library vector class. Like
vector, supports reallocation. If there is not enough space left, then obtains
new space, moves the existing elements into that space, free the old space,
and adds the new elements.

| 0 | 1 | 2 | 3 | 4 | unconstructed std::string elements |

^                     ^                                  ^
elements              first_free                         cap


StrVec          std::string continuous block      resources to be moved
                  [0]                             [char arrays]
                  [1]                             [char arrays]
                  [2]                             [char arrays]
                  ...


class StrVec {
  public:
    StrVec(): elements(nullptr), first_free(nullptr), cap(nullptr) {}
    StrVec(const StrVec &);  // copy-ctor
    StrVec &operator=(const StrVec &);

    void push_back( const std::string& );
    size_t size() const { return first_free - elements; }
    std::string* begin() const { return elements; }
    std::string* end() const { return first_free; }

  private:

    // *class-variable-case* to use the same allocator object for all StrVec
    static std::allocator<std::string> alloc;

    void chk_n_alloc()
      { if( size() == capacity() ) reallocate(); }

    pair<string*, string*>
      StrVec::alloc_n_copy( const string *begin, const string *end );

    void free();
    std::string *elements;
    std::string *first_free;
    std::string *cap;
};

<copy-context> valuelike

pair<string*, string*>
StrVec::alloc_n_copy( const string *begin, const string *end )
{
  // allocate 'unconstructed' space to hold as many elements as are in the range
  // iterator-arithmetic
  auto data = alloc.allocate( end - begin );     

  // <uninitialized_copy> 'construct' copies of given elements in
  // 'uninitialized' space. return { begin of the new space, past the last it
  // copied } see stl-allocator for detail.

  return { data, uninitialized_copy( begin, end, data ) };
}


// Must call destory() and deallocate(). As with construct() calling type's
// ctor, destory() calls type's dtor.

void StrVec::free()
{
  // may not pass deallocate a null pointer. moves backwards
  if(elements)
  {
    // calls string's dtor
    for( auto p = first_free; p != elements; /* empty */ )
      alloc.destroy(--p);

    alloc.deallocate( elements, cap - elements );
  }
}


StrVec::StrVec( const StrVec &s )
{
  // memeber function to allocate and copy exactly as many elements as in s
  auto newdata = alloc_n_copy( s.begin(), s.end() );
  elements = newdata.first;
  first_free = cap = newdata.second;
}

StrVec::~StrVec() { free(); }

StrVec &StrVec::operator=( const StrVec &rhs )
{
  // for self-assign
  auto data = alloc_n_copy( rhs.begin(), rhs.end() );
  free();
  elements = data.first;
  first_free = cap = data.second;
  return *this;
}

void StrVec::push_back( const string &s )
{
  // When there is no elements, this calls `reallocate()` to allocate
  // 'unconstructed' space.
  chk_n_alloc();

  // note: 
  // The first argument to construct must be a pointer to 'unconstructed'
  // space allocated by `allocate()`. 
  // The second argument determine 'which' constructor to use to construct the
  // object in that space. This is string's copy ctor.
  //
  // *when-postfix-is-necessary*
  alloc.construct( first_free++, s );
}


<reallocation> <why-move-works>
`string is valuelike` and has own memory for those characters. Copying a
string copies the date because after we copy a string, there are two users of
that string. However, when reallocates copies, there will be only `one user`
after the copy and as soon as copy is done, no need to keep the old.

So copying the data in these std::strings in the old is 'unnecessary' in this
case so StrVec's 'performance' will be much better if can avoid the overhead
of allocating and deallocating the char memories for strings themselves each
time we reallocate.


<avoid-copying>
Two facilities by *C++11* 

1. move ctor. 
Several library classes, including string, define so called move constructor.
Presumably the string move ctor copies the pointer rather than allocating
spaces.

2. std::move().
Defined 'utility' header. Two things. must use `std::move()` to 'signal' it
want to use the string move ctor. Otherwise, copy ctor will be used. Use
std::move() not move().

// All pointers points to 'unconstructed' space.
//
// when size() is 0, allocate 1 space, no move, and set pointers accordingly.
// when size() is not 0, allocate two times bigger space, do move and set
// pointers accordingly.

Q: when size() is 0, element and first_free are the same. Then size() returns
0?

void StrVec::reallocate()
{
  auto newcapacity = size() ? 2 * size() : 1;

  auto newdata = alloc.allocate(newcapacity);

  auto dest = newdata;      // start in the new array
  auto elem = elements;     // start in the old array

  // construct() calls string's move ctor. move existing elements.
  for( size_t i = 0; i != size(); ++i )
    alloc.construct( dest++, std::move(*elem++) );

  // this frees up the old allocated memory and std::string element but
  // not string's memory for characters. WHY? since used string's move ctor and
  // means that std::string's dtor is move-aware since string remains in a
  // valid, destructible state.
  free();

  elements = newdata;
  first_free = dest;
  cap = elements + newcapacity;
}

the std::move() returns rvalue that cause construct() to use the string move
ctor.


={============================================================================
*kt_dev_cpp_004* cpp-copy-control-move-rvalue-reference

{lvalue-and-rvalue} cpp-rvalue cpp-lvalue
In C, `lvalue` could stand on the left-hand side of an assignment whereas
`rvalue` could 'not'. In C++ this distinction is less simple. Generally
speaking, lvalue refers to an object's 'identity' (its location in memory)
whereas rvalue refers to object's 'value'(its contents).

*expression-has-a-value*
From ansic: In C, any assignment, such as "c = getchar()" is an expression and
has a value, which is the value of the left hand side after the assignment.
This means that an assignment can appear as part of a larger expression, such
as "while((c = getchar()) != EOF)"

The `lvalue` and `rvalue` are 'properties' of an expression. Expressions yield
or require rvalue/lvalue. Operators 'differ' as to whether require lvalue or
rvalue operands and as to whether return lvalue or rvalues. Some yield or
require lvalues and others yield or require rvalues:

Assignment 'requires' a (non-const) lvalue as its left hand operand and
'yields' its left-hand operand as an lvalue.

The address-of-operator(&) requires an lvalue operand and returns a 'pointer'
to its operand as an rvalue.

<ex> show that x++ returns rvalue which is the previous.
int main(int argc, char* argv[])
{
  int x = 10;
  int* pint;

  pint = &(++x);
  pint = &(x++);        // error since & requires lvalue
}


{lvalue-reference-rvalue-reference}
CPR 226. "Calls to functions that return reference are 'lvalue'" which means
that can be used in the same ways as any other lvalue.

char &get_value(string &str, string::size_type ix)
{
  return str[ix];
}

{
  string s("a value");
  get_value(s, 0) = 'A';  // changes s[0] to A
}


<binding-property> CPR 532 
Cannot bind `lvalue-reference` to expression that requires a conversion, to
literals, or to expression that return an rvalue. 

The `rvalue-reference` is a reference that `must be bound to an rvalue` and is
just another name for an object. Obtained by using '&&' rather than '&'. 

Can bind an `rvalue-reference` to these but cannot 'directly' bind an rvalue
reference to an lvalue.

note: What does "directly" mean? Can do indirectly and see *reference-collapsing*

int i = 42;

int &r = i;             // okay
int &&rr = i;           // error, cannot bind `rvalue-reference` to `lvalue`

int &r2 = i*42;         // error, i*42 is rvalue
const int &r3 = i*42;   // okay  bind `rvalue` to `const-lvalue-reference`
int &&r2 = i*42;        // okay

Functions that return a nonreference type, along with the arithmetic,
relational, bitwise, and `postfix` operations, all yield rvalues.


string f();

string &r2{f()};          // error

f() returns rvalue since returns a value and cannot bind rvalue to lvalue
reference.


<rvalue-is-temporary> implicit move sementics
Looking at the list of rvalue and lvalue expressions, lvalue has 'persitent'
state, whereas rvalue are either literals or 'temporary' objects created in
the course of evaluating expressions.

The `rvalue-reference` can only be bound to temporaries: the referred-to
object is about to be destroyed and there can be `no other users` of that
(move-from) object and only one user of (move-to) object. So the code that
uses an rvalue reference is 'free' to 'take' over resources from the object to
which the reference refers.


={============================================================================
*kt_dev_cpp_004* cpp-copy-control-move-std-move

{std-move}
This is defined in <utility> header and to 'return' rvalue reference to its
given object.

int &&rr = std::move(rr1);
moved-to             moved-from

Essentially to tell or signal compiler that we do 'not' intend to use rr1
again except to 'assign' to it or 'destroy' it. So after move, cannot make any
assumptions about the value of the moved-from object. note: Think a string
case that can destory string object itself and can assign new memory for
characters. 


<why-std-move>
Since there is argument dependant lookup, if user defines move() then
overloading rule picks up the right version. However, std::move is template
and rvalue matches to 'any' type so name collision are more likely but less
likely to be intentional. Therefore, suggest fully qualified one, std::move().


<move-controls> <take-over>
See 'no' `const` on parameter and `noexcept` since do 'not' allocate any new
memory and take over the memory from its argument. See <noexcept-keyword> for
more.

class Foo {
  Foo(const Foo&);   // okay
};

The move-ctor 'must' ensure that the moved-from object is left in a state that
destroying that object will be 'harmless'.

The moved-from object continues to 'exist', eventually will be destroyed and
the dtor will be run on that. Setting pointer members to nullptr makes
StrVec::free() in dtor do nothing. Otherwise, would delete the
memory(resource) we have moved. Also this is 'why' do not have const on s
since changes its state.

StrVec::StrVec( StrVec&& s ) noexcept
: elements(s.elements), first_free(s.first_free), cap(s.cap)
{
  // leave s(moved-from) in a state in which it is safe to run the dtor
  s.elements = s.first_free = s.cap = nullptr;
}

The move assign does the same work as the dtor and the move ctor. If move
assign won't throw any exceptions, should make it noexcept and must guard
against self-assignment.

StrVec &StrVec::operator=( StrVec &&rhs ) noexcept
{
  // direct test for self-assignment. note "&rhs" is address of rhs.
  if( this != &rhs )
  {
    // note: free existing string elements but this time it deletes memories for
    // characters as well this case since moved is not used.
    free();    

    // member initializers take over the resources from rhs. this is move as
    // with move ctor.
    elements = rhs.elements;
    first_free = rhs.first_free;
    cap = rhs.cap;

    // leave rhs(moved-from) in a destructible state
    rhs.elements = rhs.first_free = rhs.cap = nullptr;
  }

  return *this;
}


<destructible-state>
Be careful about meaning of move: The actual move happens on elements which is
string in this case and move is done by copying and setting pointer members in
StrVec POV and is not to free the memory moved. This is a meaning of taking
over the resources in s, StrVec.

Moving from an object does not destroy that object. Therefore, must ensure
that the moved-from object is `in a state in which the dtor can be run.` In
this example, if not set these pointer members null, there shall be a problem
when dtor runs and calls free().

In addition to that, move operations guarantee that the object remains 'valid'
meaning that can runs operations but no guarantees/assumptions about its
'value'. Can safely be given a new value or used in other ways that do not
depend on its current value. StrVec move leave the moved-from object in the
same state as a default initialized object and other classes may behave
differently.


{synthesized-move-operations}
If class do not define copy ctor and assign then compiler 'always' make these
operations; defined either as memberwise or deleted.

Move operations are different. The compiler make move operations 'only' if a
class does 'not' define any copy ctor and assign and 'only' if all nonstatic
members can be move constructed and assigned because if a class doesn't have a
move operation, the corresponding copy operation is used in place of move
through function matching. 

  "if class has own copy ctor and assign then move will 'not' be synthesized."

// the compiler will synthesize the move operations for X and hasX
struct X {
  int i;
  std::string s;
};

struct hasX {
  X mem;
};

X x, x2 = std::move(x);          // use the synthesized move ctor
hasX hx, hx2 = std::move(hx);

If class defines either move ctor and/or move assign but not defined copy
controls, the synthesized copy controls will de defined 'deleted'. 

  "class that define move operations 'must' also define own copy operations." 


{copy-or-move}
When class has both a move and copy ctor, how does the library know what to
use? Use function matching since copy ctor takes const StrVec& and move only
takes StrVec&&.

StrVec v1, v2;
v1 = v2;                    // use copy assign

StrVec getVec(istream &);   // assume getVec returns an rvalue
v2 = getVec(cin);           // use move assign
   
Like const, can bind lvalue to rvale but cannot bind rvalue to lvalue. So in
the second assign, both copy assign and move assign are viable but copy assign
requires conversion to const. Hence move is used since it is exact match.


{conditions-to-use-move}

1. noexcept on move

The library containers provide guarantees as to what they do if an exception
happens; vector guarantees that if an exception happens when call push_back, the
vector itself will be left unchanged.

Imagine that push_back in StrVec causes reallocation as vector, uses move ctor
but exceptions happens in the middle of moving. There would be a problem.
However, if used copy ctor, not a problem when exception happens since the
original copy still remains. Like, exception safe condition in using dynamic
resources.

To avoid this potential problem, vector must use a copy ctor instead move during
reallocation 'unless' it knows that 'element's type move ctor cannot throw an
exception. How to tell the library that move ctor is safe to use? Do so by using
explicitly noexcept keyword on move ctor and assign.

note: the question is how vector code knows if it has noexcept or not?

2. copy is bigger than move 

Using the copy controls in place of move controls is safe and will meet the
requirement of move controls since objects is moved by copying operations. In
other words, copy controls are more of necessary to work properly, move controls
are more of performance choice so if there are no move operations, copy controls
will be used instead.

note: If a class has no move operations, copy operations will be used 'even if'
attempt to use move by calling std::move().

// define copy but no move operations
class Foo {
  public:
    Foo() = default;
    Foo(const Foo&);
};

Foo x;
Foo y(x);                  // copy ctor
Foo z( std::move(x) );     // copy ctor

Here copy initialization happens but std::move returns rvalue, Foo&&, but no
move ctor. So can convert a Foo&& to const Foo&, copy ctor is viable and it is
called. "can bind rvalue to lreference".


<move-example>
The HasPtr copy-and-swap example shows that 'single' assignment operator acts
as both copy and move assign.

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

HasPtr& HasPtr::operator=(HasPtr rhs) // note not ref and it's a copy
{
  swap(*this, rhs);
  reutn *this;       // rhs is destroyed, which deletes the old ps.
}

If add move ctor to HasPtr class then `effectively add move assign as well.`
The assign operator is both the move and copy assign. 

note This code is from copy-and-swap-idiom which is for valuelike case. Hence
move is safe.

class HasPtr {
  public:
    // move ctor
    HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) { p.ps = 0; }

    // copy-assign or move-assign
    HasPtr& operator=(HasPtr rhs)
    { swap(*this, rhs); return *this; }
    ...
};

Since operator=() uses nonreference type, uses copy ctor to copy argument.
'depending' on the type of argument, it uses either the copy ctor or the move
ctor.

HasPtr hp, hp2;

hp = hp2;               // 1
hp = std::move(hp2);    // 2

The first assignment. hp2 is an lvalue, so the move ctor is not viable. copy
ctor is used to initialize `rhs`.

The second assignment. std::move return rvalue and both ctor are viable.
However, because the argument is an rvalue reference, the move ctor is an
exact match. 

Regardless of whether the copy or move ctor was used, the body of the
assignment operator `swaps` the state of the two operands.

note:
After all, save a copy ctor in using valuelike case than move ctor case. 


{move-iterator-adaptor}
The StrVec::reallocate can be rewritten using move iterator which would be
easier. 

The <uninitialized_copy> copy and costruct elements in uninitialized space but
there is no analogous to move objects into unconstruced memory. Instead, the new
library defines move iterator adaptor which changes the behavior of iterator's
dereference operator to 'fetch' elements.

Ordinarily, an iterator dereference operator returns an lvaue reference to the
element but move iterator yields an rvalue reference.

The make_move_iterator() 'transform' an ordinary iterator to a move iterator.

The <uninitialized_copy> uses the iterator dereference to fetch elements from
the input sequence. Becase passed move iterators, the dereference yields an
rvalue reference, which means `construct` will use the move (string) ctor to
construct the elements.

void StrVec::reallocate()
{
  auto newcapacity = size() ? 2 * size() : 1;

  auto newdata = alloc.allocate(newcapacity);   // first

  auto dest = newdata;      // start in the new array
  auto elem = elements;     // start in the old array

  // 'before'
  // for( size_t i = 0; i != size(); ++i )
  //  alloc.construct( dest++, std::move(*elem++) );

  // 'after'
  auto dest = uninitialized_copy(
      make_move_iterator( begin() ),
      make_move_iterator( end() ),
      first );

  free();   // member which destroy and deallocate

  elements = newdata;
  first_free = dest;
  cap = elements + newcapacity;
}


note:
STL makes no guarantees about which algorithms can be used with move iterators
or which cannot since move can destory the source. Should pass move iterators to
algorithms only when confident that algorithms does not access an element after
it has assigned to that element.


{move-can-be-dangerous}
Since moved-from object has 'indeterminate' state, std::move is a dangerous
operation. When we call std::move must be certain that there can be 'no' user
of the moved-from object. Judiciously used inside class code such as move
operations for significant performance benefit.


{move-or-copy-overload} *cpp-overload-move*
Member functions other than constructors and assignment can benefit from
providing both copy and move versions.

  note: *cpp-overload-const*
  class Screen {
    public:
      Screen& display()
      { cout << "dis: this is non-const member" << endl; return *this; }
  
      `const` Screen& display() `const`
      { cout << "dis: this is const member" << endl; return *this; }
  };

class StrVec {
  public:

    // copy version, lvalue reference to const
    void push_back( const std::string& );

    // move version, rvalue reference to nonconst
    void push_back( std::string&& );
    ...
};

void StrVec::push_back( const std::string& s )
{
  chk_n_alloc();
  alloc.construct( first_free++, s );
}

void StrVec::push_back( std::string&& s )
{
  chk_n_alloc();
  alloc.construct( first_free++, std::move(s) );   // use string move ctor
}

StrVec vec;
string s = "some string or another";

vec.push_back(s);         // calls push_back(const string&)
vec.push_back("done");    // calls push_back(string&&). temporary string.


note:
Move operations is about moving pointers and nothing special about that. The
std::move is to signal to compiler to pick up move operations via resolution.
The std::move() doesn't itself do any moving, but merely converts its argument
into a so-called rvalue reference.


<cxx-reference-quailifier> <reference-member-function> RCPR 546
Ordinarily, can call a member function on object, regardless of whether that
is an lvalue or rvalue. Sometimes such usage can be surprising. Here assign to
the "rvalue result" of concatentating these strings:

s1 + s2 = "wow!";

Still allow assignment to rvalues for backward compatability. The new standard
have a way to `prevent such usage` by forcing the left-hand operand, the
object to which `this` points, to be an lvalue.

The reference qualifier is either & or && and indicate the lvalue/rvalue
`property of this` in the same way that define const member function.

The refernece qualified and must follow the `const`.

class Foo {
  public:
    Foo someMem() & const;    // error
    Foo someMem() const &;    // ok
};


{cpp-overload-reference} *cpp-overload-move*
We can overload a function based on its reference quialifier. See
*cpp-ex-quote-example*


={============================================================================
*kt_dev_cxx_0000* cxx-ex-query-example cxx-interface cxx-grep

CPR 484. 12.3.2

Requirements are:
 * Search a given file for a word
 * Show the number of times the word occurs
 * Show a list of lines on which that word appears in ascending order
 * Show the line only once if a word occurs more than once on the same line
 * Repeat a search for any given word until user quit

The output for query word "element" is:

element occurs 112 times
	(line 36) A set element contains only a key;
	(line 158) operator creates a new element
	...

When reads the input,
 * must remember the line(s) in which each word appears.
 * need to read the input a line at a time and break up the lines into its
   separate words.

When makes output,
 * must be able to fetch the line numbers associated with a given word.
 * the line numbers must appear in ascending order with no duplicates.
 * must print the text in the input file at a given line number.


<ex-simple>
#include <set>
#include <map>
#include <vector>
#include <string>
#include <fstream>          // ifstream
#include <memory>           // shared_ptr
#include <iostream>
#include <sstream>

using namespace std;

// g++ -std=c++11 -g t_query_simple.cpp

// <DN> <cxx-design> 
// When design a class, can be helpful to write programs using the class before
// implementing the members. That way, can see whether the class has the
// `operation` we need. A good way to start the design of a program is to list
// the program's operations. Again, what operation we need helps us see what
// `data structure` we will need.
//
// int main()
// {
//     std::ifstream ifs("README", std::ifstream::in);
// 
//     TextQuery tq(ifs);
// 
//     while (true)
//     {
//         cout << "pls enter the word to search or q to quit: ";
// 
//         string word;
// 
//         // if see condition to quit
//         if (!(cin >> word) || s == "q") break;
// 
//         // run query and print the result
//         print(cout, tq.query(word)) << endl;
//     }
// 
//     ifs.close();
// }

// <DN> This ex is more than simple grep since simple grep is one-pass but this
// do mutiple-pass. So needs more structures.
//
// <DN> Search a given word whenever a user runs a query? If built a structure
// which has a word and where that word was shown then no need to search a whole
// file every time. So use a map<word, set<lines>>


// <DN> What if have to return the result from query()? Since the result is not
// simple due to more structures used, need to pack them to return. Like
// iterator, pack them as a class. So needs to make it sharable, not a member
// and use shared_ptr on file and set.
//
// The hard part in designing query function is deciding what the query function
// return. The easiest way to return "all" those data is to define a second
// class.

class QueryResult
{

    friend ostream &print(ostream &os, const QueryResult &result);

    using line_no = size_t;

    public:
        QueryResult(std::string word, 
            std::shared_ptr<std::vector<std::string>> file,
            std::shared_ptr<std::set<line_no>> lines)
            : sought(word), file_(file), lines_(lines) {}

    private:
        std::string sought;
        std::shared_ptr<std::vector<std::string>> file_;
        std::shared_ptr<std::set<line_no>> lines_;
};

class TextQuery
{
    // *cxx-size-t*
    // using line_no = std::vector<std::string>>::size_type;
    using line_no = size_t;

    public:
        TextQuery(std::ifstream &in);
        void query_and_print(const std::string &word) const;
        QueryResult query(const std::string &word) const;

    private:
        // std::vector<std::string> input_file_;
        std::shared_ptr<std::vector<std::string>> input_file_;

        // std::map<std::string, std::set<line_no>> word_map_;
        std::map<std::string, std::shared_ptr<std::set<line_no>>> word_map_;
};

TextQuery::TextQuery(std::ifstream &in) 
    : input_file_(make_shared<std::vector<std::string>>())
{
    std::string line;

    // read a file
    while (getline(in, line))
    {
        input_file_->push_back(line);

        // get a line number
        // <DN> can use variable to keep line counts
        // <DN> line count starts from 0
        line_no n = input_file_->size()-1;

        // parse up a line into words
        std::stringstream iss{line};
        std::string word;

        while (iss >> word)
        {
            // if a word isn't in the map, add a new entry but shared_ptr is
            // default initialized, nullptr. Have to create a empty set.
            auto &lines = word_map_[word];
            if (!lines)
                lines = make_shared<std::set<line_no>>();

            // insert a line into a set
            lines->insert(n);
        }
    }
}

// utility function
string make_plural(size_t size, const string &word, const string &ending)
{ return (size > 1) ? word+ending : word; }

void TextQuery::query_and_print(const std::string &word) const
{
    auto pos = word_map_.find(word);

    // if found
    if (pos != word_map_.end())
    {
        cout << word << " occurs " << pos->second->size() << " " 
            << make_plural(pos->second->size(), "time", "s") << endl;

        for (auto e : *(pos->second))
            cout << "(line " << e+1 << ") " << (*input_file_)[e] << endl;
    }
    else
        cout << word << " not found" << endl;
}

QueryResult TextQuery::query(const std::string &word) const
{
    // <DN> How to handle when not found? Use the empty set rather than nullptr
    //
    // return QueryResult(word, input_file_, nullptr);
    // 
    // since by doing that, print() do not have special handling. 

    static std::shared_ptr<std::set<line_no>> notfound{make_shared<std::set<line_no>>()};

    // <DN> should not use [] which can add new entry
    auto pos = word_map_.find(word);

    // if found
    if (pos != word_map_.end())
        return QueryResult(word, input_file_, pos->second);
    else
        return QueryResult(word, input_file_, notfound);
}

ostream &print(ostream &os, const QueryResult &result)
{
    // os << word << " occurs " << pos->second->size() << " " 
    //     << make_plural(pos->second->size(), "time", "s") << endl;
    os << result.sought << " occurs " << result.lines_->size() << " " 
        << make_plural(result.lines_->size(), "time", "s") << endl;

    // <DN> line number starts from 0 in the set but add +1 to print it from 1
    // for the user.
    //
    // <DN> Since uses vector, can use *cxx-iter-arithmetic* rather than []
    // for (auto e : *(pos->second))
    //     cout << "(line " << e + 1 << ") " << *(result_file_->begin()+e) << endl;

    for (auto e : *result.lines_)
        cout << "(line " << e + 1 << ") " << (*result.file_)[e] << endl;

    // <DN> if miss out this line, gets core and the trace is:
    //
    // Program terminated with signal SIGSEGV, Segmentation fault.
    // #0  0x00007f84dd7af05c in std::basic_ostream<char, std::char_traits<char> >& std::endl<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&) ()
    //    from /usr/lib/x86_64-linux-gnu/libstdc++.so.6

    return os;
}


// *cxx-simple-grep*
// = 01 ======
// pls enter the word to search or q to quit: GNU
// GNU occurs 10 times
// (line 1) This directory contains the sources of the GNU C Library.
// (line 4) The GNU C Library is the standard system C library for all GNU systems,
// (line 5) and is an important part of what makes up a GNU system.  It provides the
// (line 14) The GNU C Library implements much of the POSIX.1 functionality in the
// (line 17) incorporated into an official GNU C Library release.
// (line 19) When working with Linux kernels, this version of the GNU C Library
// (line 25) The GNU C Library supports these configurations for using Linux kernels:
// (line 53) the GNU C Library.  You might also consider reading the WWW pages for
// (line 56) The GNU C Library is (almost) completely documented by the Texinfo manual
// (line 69) The GNU C Library is free software.  See the file COPYING.LIB for copying

void t_query_01()
{
    std::ifstream ifs("README", std::ifstream::in);

    TextQuery tq(ifs);

    cout << "pls enter the word to search or q to quit: ";

    string word;

    // if see condition to quit
    if (!(cin >> word)) return;

    // run query and print the result
    tq.query_and_print(word);
}


// = 02 ======
// pls enter the word to search or q to quit: GNU
// GNU occurs 10 times
// (line 1) This directory contains the sources of the GNU C Library.
// (line 4) The GNU C Library is the standard system C library for all GNU systems,
// (line 5) and is an important part of what makes up a GNU system.  It provides the
// (line 14) The GNU C Library implements much of the POSIX.1 functionality in the
// (line 17) incorporated into an official GNU C Library release.
// (line 19) When working with Linux kernels, this version of the GNU C Library
// (line 25) The GNU C Library supports these configurations for using Linux kernels:
// (line 53) the GNU C Library.  You might also consider reading the WWW pages for
// (line 56) The GNU C Library is (almost) completely documented by the Texinfo manual
// (line 69) The GNU C Library is free software.  See the file COPYING.LIB for copying
// 
// pls enter the word to search or q to quit:

void t_query_02()
{
    std::ifstream ifs("README", std::ifstream::in);

    TextQuery tq(ifs);

    while (true)
    {
        cout << "pls enter the word to search or q to quit: ";

        string word;

        // if see condition to quit
        if (!(cin >> word) || word == "q") break;

        // run query and print the result
        print(cout, tq.query(word)) << endl;
    }

    ifs.close();
}
 
int main()
{
    cout << "= 02 ======" << endl;
    t_query_02();

    // cout << "= 01 ======" << endl;
    // t_query_01();
}


{extented}
To support more complicated queries:
  * word queries:
    Executing Query for: Daddy

  * not queries:
    Executing Query for: ~(Alice)

  * or queries:
    Executing Query for: (hair | Alice)

  * and queries:
    Executing Query for: (hair & Alice)

  * compound queries which uses normal C++ precedence rule:
    Executing Query for: (fiery & bird | wind)


<can-use-textquery-class>
Can use TextQuery? No. To see why, consider a Not query and we would have to
able to find the word for which the Not query was searching. There is no such
word. Instead a Not query has a query whose value it negates. Similarly, And
and Or query have two queries whose results it combines. 

This `observation` suggests that we model our different kinds of queries as
independent classes that share a common base class. The solution is to have
four classes which has the same interface and use ABC.

WordQuery, NotQuery, OrQuery, AndQuery


<why-abc>
These four query types are not related to one another by inheritance; they are
`conceptually siblings and shares the same interface.` This suggest that will
need to define ABC to represent that interface.

Two abc:

  * QueryBase, abc for single operand
   
  * BinaryQuery, abc for two operands. The AndQuery and OrQuery share one
    property that the other classes do not. Each has two operands. To model
    this, define another ABC to represent queries with two operands.


<build-object-to-represent-query>
Need to create queries. The simplest way is to write C++ expressions to create
the compounded queries:

   Query q = Query("fiery") & Query("bird") | Query("wind");

`This problem description` suggests that user code won't use the inherited
class directly. Instead, will define an `interface class` named Query which hide
the hierarchy and has the same operations as Query_base. It will have three
overloaded operators and ctor.

  * & operator will [create] a Query bound to a new AndQuery.
  * | operator will [create] a Query bound to a new OrQuery.
  * ~ operator will [create] a Query bound to a new NotQuery.
  * Query ctor that takes a string will create a Query bound to a new WordQuery.
    WordQuery is a base unit in building a query.

Users will create and manipulate Query_base objects only `indirectly`
through operations on Query object: overloaded operators

<ex>
#include <iostream>
#include <set>
#include <map>
#include <vector>
#include <memory>
#include <fstream>
#include <sstream>
#include <algorithm>

// g++ -g -std=c++0x -c a.c

using namespace std;

// CPR 484. 12.3.2
//
// Requirements are:
//  * Search a given file for a word
//  * Show the number of times the word occurs
//  * Show a list of lines on which that word appears in ascending order
//  * Show the line only once if a word occurs more than once on the same line
//  * Repeat a search for any given word until user quit
//
// The output for query word "element" is:
//
// element occurs 112 times
// 	(line 36) A set element contains only a key;
// 	(line 158) operator creates a new element
// 	...
//
//
// When reads the input,
//  * must remember the line(s) in which each word appears.
//  * need to read the input a line at a time and break up the lines into its
//    separate words.
//
// When makes output,
//  * must be able to fetch the line numbers associated with a given word.
//  * the line numbers must appear in ascending order with no duplicates.
//  * must print the text in the input file at a given line number.
//
//
// *cpp-remember*
// When design a class, can be helpful to write programs using the class before
// implementing the members. That way, can see whether the class has the
// `operation` we need. A good way to start the design of a program is to list
// the program's operations. Again, what operation we need helps us see what
// `data structure` we will need.
//
// The hard part in designing query function is deciding what the query function
// return.
//
// "need to know how often it occured, the line numbers, and the corresponding
// text."
//
// The easiest way to return "all" those data is to define a second class.
//
//
// * Use `vector<string>` to store the entire input file. Can fetch the line using
//   its line number as the index.
// * Use `istringstream` to break up each line into words.
// * Use `set` to hold line numbers on which each word appears. Appears only once
//   in ascending order.
// * Use `map` to associate each word with the set

class QueryResult {

    friend ostream &print(ostream &os, const QueryResult &qr);

    public:
        // to support extended query ex
        typedef std::set<size_t>::const_iterator line_it;

        line_it begin() { lines->cbegin(); }
        line_it end() { lines->cend(); }

        std::shared_ptr<std::vector<std::string>> get_file() { return file; }

        // *cpp-size-t* use size_t instead typedef
        // using line_no = std::vector<std::string>::size_type;

        QueryResult(std::string s, 
                std::shared_ptr<std::set<size_t>> p,
                std::shared_ptr<std::vector<std::string>> f) :
            sought(s), lines(p), file(f) {}

    private:
        std::string sought;
        // std::shared_ptr<std::set<line_no>> lines;
        std::shared_ptr<std::set<size_t>> lines;
        std::shared_ptr<std::vector<std::string>> file;
};

class TextQuery {
    public:
        // using line_no = std::vector<std::string>::size_type;

        // ok
        // TextQuery(std::ifstream &in) : file(make_shared<std::vector<std::string>>())
        TextQuery(std::ifstream &in) : file(new std::vector<std::string>())
        {
            std::string line;

            while (getline(in, line))
            {
                // save the line
                file->push_back(line);

                // get line number
                size_t n = file->size() - 1;

                // break up the line into words
                std::istringstream iss(line);
                std::string word;

                // conversion-to-bool is explicit. okay?
                while (iss >> word)
                {
                    // not covered in the book -- cleanup_str removes
                    // punctuation and converts all text to lowercase so that
                    // the queries operate in a case insensitive manner
                    word = cleanup_str(word);

                    // if word isn't already in the map, subscripting adds a new
                    // entry which has default init shared_ptr(null). Need to
                    // create empty set. 
                    auto &lines = word_map[word];
                    if (!lines)
                        // lines.reset( new set< line_no > );   // new set
                        lines = make_shared<std::set<size_t>>();

                    lines->insert(n);
                }

            }
        }

        QueryResult query(const std::string &s) const
        {
            // 1. see it returns QueryResult but not printing the result here.

            // 2. should not use [] since it creats an entry when it's not found
            // auto &lines = word_map[s];

            // 3. can use map.count() in place of map.find().
            
            // 4. handle when the given string is not found.
            // why not use nullptr such as:
            //
            // static std::shared_ptr<std::set<line_no>> nodata;
            // QueryResult(s, nullptr, file);
            //
            // since print() do not need to have special handling for this case
            // such as size() and range for loop.

            static std::shared_ptr<std::set<size_t>> nodata(new std::set<size_t>);

            // *cpp-pair*
            // auto loc = word_map.find(cleanup_str(s));
            auto loc = word_map.find(s);
            if (word_map.end() == loc)
                return QueryResult(s, nodata, file);
            else
                return QueryResult(s, loc->second, file);
        }

        void print_file()
        {
            for (auto it = file->begin(); it != file->end(); ++it)
                cout << *it << endl;
        }

    private:
        std::string cleanup_str(const std::string &word)
        {
            std::string ret;
            for (auto it = word.begin(); it != word.end(); ++it)
            {
                // if (!ispunct(*it))
                //     ret += tolower(*it);

                // to keep the case
                if (!ispunct(*it))
                    ret += *it;
            }
            return ret;
        }

        std::shared_ptr<std::vector<std::string>> file;
        std::map<std::string, std::shared_ptr<std::set<size_t>>> word_map;
};

// utility function
string make_plural(size_t ctr, const string &word, const string &ending)
{
    // if (ctr > 1)
    //     return word + ending;
    // else
    //     return word;

    return (ctr > 1) ? word + ending : word;
}

ostream &print(ostream &os, const QueryResult &qr)
{
    os << qr.sought << " occurs " << qr.lines->size() << " "
        << make_plural(qr.lines->size(), "time", "s") << endl;

    // Although the number in the set are numbered from 0, most users think of
    // the first line as 1, so add 1 to the line number.

    // for (auto num : *qr.lines)
    //     os << "\t(line " << num + 1 << ") " 
    //         << *(qr.file->begin() + num) << endl;

    for (auto num : *qr.lines)
        os << "\t(line " << num + 1 << ") " 
            << (*qr.file)[num] << endl;

    return os;
}

int ex_query_01()
{
    std::ifstream ifs("README", std::ifstream::in);

    TextQuery tq(ifs);
 
    while (true) {
        cout << "enter the word to look for, or q to quit: ";
 
        string s;
 
        // eof or q?. *cpp-remember* not s == 'q'
        if (!(cin >> s) || s == "q") break;
 
        // run query and print the result
        print(cout, tq.query(s)) << endl;
    }

    ifs.close();
}

// CPR 634. 15.9
// 
// *input data*
//
// note: have to use cleanup_str() to see matches on "hair." or "hair,"
//
// Alice Emma has long flowing red hair. 
// Her Daddy says when the wind blows 
// through her hair, it looks almost alive, 
// like a fiery bird in flight. 
// A beautiful fiery bird, he tells her, 
// magical but untamed. 
// "Daddy, shush, there is no such thing," 
// she tells him, at the same time wanting 
// him to tell her more.
// Shyly, she asks, "I mean, Daddy, is there?"
//
//
// <build-objects>
// So objects created by the expression are:
// 
//    Query q = Query("fiery") & Query("bird") | Query("wind");
//              - new WQ         - new WQ                    
//                        - new ANDQ             - new WQ
//                                            - new ORQ
//                                            
//    q = Query      OrQuery        AndQuery          WordQuery
//          [ ] ->   [ ]      ->    [ ]      ->       [fiery] 
//                                                    WordQuery
//                                  [ ]      ->       [bird]
// 
//                   [ ]      ->    WordQuery
//                                  [wind]
// 
// 
// <class-hierarchy>
// Inheritance hierarchy is:                                    
// 
// User     Query class             Query Base
//          - interface class       - ABC
//          - hide QB from user        |           |           | 
//                                  WordQuery   NotQuery    BinaryQuery
//                                                          - ABC
//                                                             |           |
//                                                          AndQuery    ORQuery


// *error* since *cpp-incomplete-type* *cpp-layout*
// class Query_base;
//
// abc acts as a base class for concrete query types. Query_base hierarchy are
// not intended to be used by user code. *all-private*
class Query_base {
    friend class Query;

    protected:
        // why default? why protected?
        virtual ~Query_base() = default;

    private:
        virtual QueryResult eval(const TextQuery &) const = 0;
        virtual std::string rep() const = 0;
};

// *cpp-interface-class* *cpp-pimpl*
class Query {

    // to use private ctor
    friend Query operator~(const Query &);
    friend Query operator|(const Query &, const Query &);
    friend Query operator&(const Query &, const Query &);

    public:
        Query(const std::string &s);
        // *error* since *cpp-incomplete-type* *cpp-layout*
        // Query(const std::string &s) : q(new WordQuery(s)) {}

        QueryResult eval(const TextQuery &t) const { return q->eval(t); }
        std::string rep() const { return q->rep(); }

    private:
        // *cpp-private-ctor* since don't intend user code to define Query_base
        // object chain. The overloaded operators do.
        Query(std::shared_ptr<Query_base> query): q(query) {}
        std::shared_ptr<Query_base> q;
};


class WordQuery : public Query_base {

    friend class Query;

    WordQuery(const std::string &s) : query_word(s) 
    {
        // cout << "> WordQuery::WordQuery" << endl;
    }

    QueryResult eval(const TextQuery &t) const
    { return t.query(query_word); }

    std::string rep() const { return query_word; }

    std::string query_word;
};

class NotQuery : public Query_base {

    // *all-private*
    friend Query operator~(const Query &);

    NotQuery(const Query &q) : query(q) 
    {
        // cout << "> NotQuery::NotQuery" << endl;
    }

    // is *heart* of this system. calls eval() on its operand and then applies
    // its *own* logic.
    QueryResult eval(const TextQuery &t) const
    {
        auto ret_lines = make_shared<set<size_t>>();

        // calls underlying object's eval which ends with TextQuery.query. gets
        // a set which contains a word.
        auto result = query.eval(t);
        auto beg = result.begin(), end = result.end();

        // build a new set which do not contain the word
        auto sz = result.get_file()->size();
        for (size_t n = 0; n != sz; ++n)
        {
            if (beg == end || *beg != n)
                ret_lines->insert(n);
            else if (beg != end)
                ++beg;
        }
        return QueryResult(rep(), ret_lines, result.get_file());
    }

    // query.rep() is non-virtual call which ultimately makes a virtual call to
    // get the representation of the underlying Query.
    // *cpp-override-access-control*

    std::string rep() const 
    { return "~(" + query.rep() + ")"; }

    // *query-operand*
    //
    // the operand(s) can be an object of any of the concrete classes derived
    // from Query_base: A NotQuery can be applied to any, or another NotQuery,
    // or compound query. To allow this flexibility, the operands must be stored
    // as pointers to Query_base. That way we can bind the pointer to whichever
    // concrete class we need.
    //
    // However, rather than using simple pointer, will use Query object. Just as
    // user code is simplified by using the interface class, we can simplify our
    // own class by using the same class.
    //
    // Q: really simplified?

    Query query;
};

// abc since do not override eval() and is to add data needed by the query type
// that operate on two operand.
class BinaryQuery : public Query_base {
    protected:
        BinaryQuery(const Query &l, const Query &r, std::string s):
            lhs(l), rhs(r), opsym(s) {}

        std::string rep() const 
        { return "(" + lhs.rep() + " " + opsym + " " + rhs.rep() + ")"; }

        Query lhs, rhs;
        std::string opsym;
};

class AndQuery : public BinaryQuery {

    friend Query operator&(const Query &, const Query &);

    AndQuery(const Query &left, const Query &right):
        BinaryQuery(left, right, "&") {}

    QueryResult eval(const TextQuery &t) const
    {
        auto ret_lines = make_shared<set<size_t>>();

        auto left = lhs.eval(t), right = rhs.eval(t);

        // *algo-set-intersection*
        set_intersection(left.begin(), left.end(),
                right.begin(), right.end(),
                inserter(*ret_lines, ret_lines->begin()));

        return QueryResult(rep(), ret_lines, left.get_file());
    }
};

class OrQuery : public BinaryQuery {

    friend Query operator|(const Query &, const Query &);

    OrQuery(const Query &left, const Query &right):
        BinaryQuery(left, right, "|") {}

    QueryResult eval(const TextQuery &t) const
    {
        auto left = lhs.eval(t), right = rhs.eval(t);

        auto ret_lines = make_shared<set<size_t>>(left.begin(), left.end());
        
        ret_lines->insert(right.begin(), right.end());

        return QueryResult(rep(), ret_lines, left.get_file());
    }
};


// move to here since *cpp-incomplete-type* *cpp-layout*
inline Query::Query(const std::string &s) : q(new WordQuery(s)) {}


// *cpp-interface-class* *cpp-argument-dependant-lookup*
// The return implicitly uses private Query ctor that takes the shared_ptr and
// this is equivalent to:
//
// shared_ptr<Query_base> tmp(new NotQuery(expr));
// return Query(tmp);
//
inline Query operator~(const Query &operand)
{
    return std::shared_ptr<Query_base>(new NotQuery(operand));
}

inline Query operator&(const Query &l, const Query &r)
{
    return std::shared_ptr<Query_base>(new AndQuery(l, r));
}

inline Query operator|(const Query &l, const Query &r)
{
    return std::shared_ptr<Query_base>(new OrQuery(l, r));
}


// utility
std::ostream &operator<<(std::ostream &os, const Query &query)
{
    return os << query.rep();
}

int main()
{
    std::ifstream ifs("t_query.dat", std::ifstream::in);

    TextQuery tq(ifs);

    // tq.print_file();

    // Query q = Query("fiery") & Query("bird") | Query("wind");


    // Executing Query for: hair
    // hair occurs 2 times
    //         (line 1) Alice Emma has long flowing red hair.
    //         (line 3) through her hair, it looks almost alive,
    Query q0 = Query("hair");

    cout << "\nExecuting Query for: " << q0 << endl;

    // run query and print the result
    const auto results0 = q0.eval(tq);

    print(cout, results0) << endl;


    // Executing Query for: Alice
    // Alice occurs 1 time
    //         (line 1) Alice Emma has long flowing red hair.
    Query q1 = Query("Alice");
 
    cout << "\nExecuting Query for: " << q1 << endl;

    // run query and print the result
    const auto results1 = q1.eval(tq);

    print(cout, results1) << endl;


    // Executing Query for: ~(Alice)
    // ~(Alice) occurs 9 times
    //         (line 2) Her Daddy says when the wind blows
    //         (line 3) through her hair, it looks almost alive,
    //         (line 4) like a fiery bird in flight.
    //         (line 5) A beautiful fiery bird, he tells her,
    //         (line 6) magical but untamed.
    //         (line 7) "Daddy, shush, there is no such thing,"
    //         (line 8) she tells him, at the same time wanting
    //         (line 9) him to tell her more.
    //         (line 10) Shyly, she asks, "I mean, Daddy, is there?"
    Query q2 = ~Query("Alice");
 
    cout << "\nExecuting Query for: " << q2 << endl;

    // run query and print the result
    const auto results2 = q2.eval(tq);

    print(cout, results2) << endl;


    // Executing Query for: (hair | Alice)
    // (hair | Alice) occurs 2 times
    //         (line 1) Alice Emma has long flowing red hair.
    //         (line 3) through her hair, it looks almost alive,
    Query q3 = Query("hair") | Query("Alice");
 
    cout << "\nExecuting Query for: " << q3 << endl;

    // run query and print the result
    const auto results3 = q3.eval(tq);

    print(cout, results3) << endl;


    // Executing Query for: (hair & Alice)
    // (hair & Alice) occurs 1 time
    //         (line 1) Alice Emma has long flowing red hair.
    Query q4 = Query("hair") & Query("Alice");
 
    cout << "\nExecuting Query for: " << q4 << endl;

    // run query and print the result
    const auto results4 = q4.eval(tq);

    print(cout, results4) << endl;


    // Executing Query for: ((fiery & bird) | wind)
    // ((fiery & bird) | wind) occurs 3 times
    //         (line 2) Her Daddy says when the wind blows
    //         (line 4) like a fiery bird in flight.
    //         (line 5) A beautiful fiery bird, he tells her,
    Query q5 = Query("fiery") & Query("bird") | Query("wind");
 
    cout << "\nExecuting Query for: " << q5 << endl;

    // run query and print the result
    const auto results5 = q5.eval(tq);

    print(cout, results5) << endl;

    ifs.close();
}


{
  Query q = Query("fiery") & Query("bird") | Query("wind");
}

> WordQuery::WordQuery
> Query::Query
> WordQuery::WordQuery
> Query::Query
> WordQuery::WordQuery
> Query::Query

> Query::Query(const Query&): fiery
> Query::Query(const Query&): bird
> AndQuery::AndQuery
> Query::Query(shared_ptr)

> Query::Query(const Query&): (fiery & bird)
> Query::Query(const Query&): wind
> OrQuery::OrQuery
> Query::Query(shared_ptr)

Why Query copy-ctor gets called? Since BinaryQuery has two Query members which
copy constructed in ctor. However, Query only has shared_ptr member and not
really problem of having a copy-ctor.


={============================================================================
*kt_dev_cxx_0000* cxx-ex-strblob-example

<ex>
#include <iostream>             // for cout
#include <vector>
#include <string>
#include <memory>
#include <initializer_list>

// g++ -std=c++11 -g t_strblob.cpp

//////////////////////////////////////////////////////////////////////////////
// StrBlob without StrBlobPtr
//
// CPR 455
//
// * show how to implement a new collection type using library container.
// `is-implemented-in-terms-of-model`
//
// * This shows when shared_ptr is useful than own raii since this case don't
// need `copy-controls` and use syn versions but not a problem as it has only
// one member which is shared_ptr.

namespace SB1
{

using namespace std;

class StrBlob
{
    public:
        typedef vector<string>::size_type size_type;

        // interface
        StrBlob() : data_(make_shared<vector<string>>()) {}
        StrBlob(initializer_list<string> il) :
            data_(make_shared<vector<string>>(il)) {}

        size_type size() const { return data_->size(); }
        bool empty() const { return data_->empty(); }

        void push_back(const string &e);
        void pop_back();

        std::string &front();
        std::string &back();

    private:
        shared_ptr<vector<string>> data_;

        // *cpp-except*
        // see that return type has nothing to do with exception.
        void check(size_type index, const string &message) const
        {
            if (index >= data_->size())
                throw out_of_range(message);
        }
};

void StrBlob::push_back(const string &e)
{
    data_->push_back(e);
}

void StrBlob::pop_back()
{
    // check if we calls it on empty vector since calls on empty
    // vector is `undefined` behavior.
    check(0, "pop_back() on empty container");

    // std::vector.pop_back() removes the last but do not return.
    data_->pop_back();
}

std::string &StrBlob::front()
{
    check(0, "front() on empty container");
    return data_->front();
}

std::string &StrBlob::back()
{
    check(0, "back() on empty container");
    return data_->back();
}

} // namespace SB1


// = 01 ======
// size : 4
// front: one
// back : four
// size : 5
// front: one
// back : five
// size : 0
// terminate called after throwing an instance of 'std::out_of_range'
//   what():  front() on empty container
// Aborted

void t_strblob_01()
{
    using namespace std;

    SB1::StrBlob sb{"one", "two", "three", "four"};

    cout << "size : " << sb.size() << endl;
    cout << "front: " << sb.front() << endl;
    cout << "back : " << sb.back() << endl;

    sb.push_back("five");

    cout << "size : " << sb.size() << endl;
    cout << "front: " << sb.front() << endl;
    cout << "back : " << sb.back() << endl;

    SB1::StrBlob s2;

    cout << "size : " << s2.size() << endl;
    cout << "front: " << s2.front() << endl;
    cout << "back : " << s2.back() << endl;
}


// = 02 ======
// b1 size: 1
// b1 size: 4
// b2 size: 4
// b1 size: 4

void t_strblob_02()
{
    SB1::StrBlob b1{"b1"};
    {
        std::cout << "b1 size: " << b1.size() << std::endl;

        SB1::StrBlob b2{ "this", "is", "second blob" };
        b1 = b2;
        b2.push_back(". really?");

        std::cout << "b1 size: " << b1.size() << std::endl;
        std::cout << "b2 size: " << b2.size() << std::endl;
    }

    std::cout << "b1 size: " << b1.size() << std::endl;
}

//////////////////////////////////////////////////////////////////////////////
// StrBlob with StrBlobPtr

// namespace SB2
// {

using namespace std;

// forward declaration
// *cpp-incomplete-type* issue decide which class comes first.
class StrBlobPtr;

class StrBlob
{
    // friend declaration
    friend class StrBlobPtr;

    public:
        typedef vector<string>::size_type size_type;

        // interface
        StrBlob() : data_(make_shared<vector<string>>()) {}
        StrBlob(initializer_list<string> il) :
            data_(make_shared<vector<string>>(il)) {}

        size_type size() const { return data_->size(); }
        bool empty() const { return data_->empty(); }

        void push_back(const string &e);
        void pop_back();

        std::string &front();
        std::string &back();

        // iterator support
        // cause *cpp-incomplete-type* issue and can't be defined until
        // StrBlobPtr is defined.
        //
        // StrBlobPtr begin() { return StrBlobPtr(*this); }
        // StrBlobPtr end() { return StrBlobPtr(*this, data_->size()); }

        StrBlobPtr begin();
        StrBlobPtr end();

    private:
        shared_ptr<vector<string>> data_;

        void check(size_type index, const string &message) const
        {
            if (index >= data_->size())
                throw out_of_range(message);
        }
};

void StrBlob::push_back(const string &e)
{
    data_->push_back(e);
}

void StrBlob::pop_back()
{
    // check if we calls it on empty vector since calls on empty
    // vector is `undefined` behavior.
    check(0, "pop_back() on empty container");

    // std::vector.pop_back() removes the last but do not return.
    data_->pop_back();
}

std::string &StrBlob::front()
{
    check(0, "front() on empty container");
    return data_->front();
}

std::string &StrBlob::back()
{
    check(0, "back() on empty container");
    return data_->back();
}

// CPR 473, *cpp-iter*
//
// <- new container class ->  <- companion class like iterator ->
//    StrBlob                    StrBlobPtr
//    - shared_ptr               - weak_ptr
//
//                      vector[]
//                      - underlying container
class StrBlobPtr
{
    friend bool eq(const StrBlobPtr&, const StrBlobPtr&);

    public:
        StrBlobPtr() {}
        // cannot use on const StrBlob since ctor uses non-const.
        StrBlobPtr(StrBlob &blob, size_t size = 0) : blob_(blob.data_), curr_(size) {}

        StrBlobPtr &incr();     // prefix version, ++iter
        StrBlobPtr &decr();     // prefix version, --iter
        string &deref() const;  // *iter

        // CPR 566, *cpp-overload-operator-increment-decrement*
        //
        // * No language requirement but prefer to be a member since change the
        // state of the object.
        //
        // * As for built-in type, there are both prefix and postfix versions.
        
        // prefix versions
        //
        // note: 
        // To be consistent with the built-in operators, the prefix should
        // return a reference

        StrBlobPtr &operator++();
        StrBlobPtr &operator--();

        // postfix versions
        //
        // The postfix version takes an extra parameter which is unused and is
        // to distinguish it from the prefix.
        //
        // note:
        //
        // To be consistent with the built-in operators, the postfix should
        // return the old `value`, not a reference.

        StrBlobPtr operator++(int);
        StrBlobPtr operator--(int);

        // may use const to prevent like, a++++.
        // const StrBlobPtr operator++(int);
        // const StrBlobPtr operator--(int);
        

        // CPR 569, *cpp-overload-operator-member-access*
        //
        // * Used in iterator and smart pointer class
        //
        // * operator arrow must be a member and dereference usually be a member
        // as well.
        
        string &operator*() const;
        string *operator->() const;

    private:
        shared_ptr<vector<string>> check(size_t index, const string &message) const
        {
            // check member differs from the one of StrBlob.
            auto pblob = blob_.lock();
            if (!pblob)
                throw runtime_error("unbound StrBlobPtr");

            if (index >= pblob->size())
                throw out_of_range(message);

            return pblob;
        }

        // current index
        size_t curr_{0};
        weak_ptr<vector<string>> blob_;
};

inline string &StrBlobPtr::deref() const
{
    auto blob = check(curr_, "dereference nonexistent element");
    // [] is higher than *
    return (*blob)[curr_];
}

inline StrBlobPtr &StrBlobPtr::incr()
{
    // if curr_ already points past the end
    check(curr_, "increment past the end");
    ++curr_;
    return *this;
}

inline StrBlobPtr &StrBlobPtr::decr()
{
    // if curr_ is zero, decrementing it will yield an invalid index
    --curr_;
    // check(-1, "decrement before the begin");
    check(curr_, "decrement before the begin");
    return *this;
}

// same as incr()
inline StrBlobPtr &StrBlobPtr::operator++()
{
    // if curr_ already points past the end
    check(curr_, "increment past the end");
    ++curr_;
    return *this;
}

inline StrBlobPtr StrBlobPtr::operator++(int)
{
    StrBlobPtr ret = *this;     // saves the current value
    ++*this;                    // no checks since prefix ++ do.
    return ret;
}

// same as decr()
inline StrBlobPtr &StrBlobPtr::operator--()
{
    // if curr_ is zero, decrementing it will yield an invalid index
    --curr_;
    // check(-1, "decrement before the begin");
    check(curr_, "decrement before the begin");
    return *this;
}

inline StrBlobPtr StrBlobPtr::operator--(int)
{
    StrBlobPtr ret = *this;     // saves the current value
    --*this;                    // no checks since prefix -- do. R associative
    return ret;
}

// same as deref()
// note:
// Although it's const member function since do not change its state, returns a
// reference and client can change through it.

inline string &StrBlobPtr::operator*() const
{
    auto blob = check(curr_, "dereference nonexistent element");
    // [] is higher than *
    return (*blob)[curr_];
}

// note:
//
// StrBlob a1{"hi", "bye", "now"};
// StrBlobPtr p{a1};
//
// *p = "okay";     // can change. assigns ot the fist element in a1
//
// cout << p->size() << endl;       // prints 4, the size of the first element.
// cout << (*p).size() << endl;     // same
//
// The arrow operator never lose its meaning of member access. Depending on the
// type of point:
//
// (*point).mem;                // point is a built-in pointer type
// point.operator()->mem;       // point is an object of class type. iterator
// 
//
// <ex> when item is shared pointer itself
//
// multiset<std::shared_ptr<Quote>, comp> items;
//
// for (auto item = items.cbegin(); item != items.cend();
//  item = items.upper_bound(*item))
// {
//  os << (*item)->isbn() << " occurs, " << endl;
// }
//
// <ex> shared pointer is not built-in array type
//
// For array:
// 
// *(parray+1) is synomym for parray[1]
// 
// the same hold for shared_ptr? No. array is special and not vector.
// 
// shared_ptr<vector<string>> sp(new vector<string>{"one", "two", "three"});
// 
// // OK
// cout << "0: " << (*sp)[0] << endl;
//     
// // OK
// cout << "0: " << *(sp->begin()+0) << endl;
// 
// // ERROR
// cout << "0: " << *(*sp+0) << endl;


inline string *StrBlobPtr::operator->() const
{
    // take address of a string reference
    return & this->operator*();
}


// "casue *cpp-incomplete-type* issue and can't be defined until
// StrBlobPtr is defined." so defined here.
// return a temporary which points either begin or end.
StrBlobPtr StrBlob::begin()
{
    return StrBlobPtr(*this);
}

StrBlobPtr StrBlob::end()
{
    return StrBlobPtr(*this, data_->size());
}

// } // namespace SB2


// named equality operators for StrBlobPtr
inline bool eq(const StrBlobPtr &lhs, const StrBlobPtr &rhs)
{
    auto l = lhs.blob_.lock(), r = rhs.blob_.lock();

    // if the underlying vector is the same
    if (l == r)
        // then they're equal if they're both null, !r
        // or if they point to the same element.
        return (!r || lhs.curr_ == rhs.curr_);
    else
        return false;
}

inline bool neq(const StrBlobPtr &lhs, const StrBlobPtr &rhs)
{
    return !eq(lhs, rhs);
}


// = 03 ======
// b1 size: 1
// b2 size: 4
// b1 size: 4
// a
// an
// the
// about

void t_strblob_03()
{
    StrBlob b1{"b1"};
    {
        std::cout << "b1 size: " << b1.size() << std::endl;

        StrBlob b2{"a", "an", "the"};
        b1 = b2;
        b2.push_back("about");

        std::cout << "b2 size: " << b2.size() << std::endl;
    }

    std::cout << "b1 size: " << b1.size() << std::endl;

    for (auto it = b1.begin(); neq(it, b1.end()); it.incr())
        cout << it.deref() << endl;
}


// = 04 ======
// 10
// 10
// b1 size: 5
// super okay
// bye
// for
// now
// about

void t_strblob_04()
{
    StrBlob a1{"hi", "bye", "for", "now"};
    StrBlobPtr p{a1};
    
    *p = "super okay";     // can change. assigns ot the fist element in a1
    
    cout << p->size() << endl;       // prints 4, the size of the first element.
    cout << (*p).size() << endl;     // same

    a1.push_back("about");

    cout << "b1 size: " << a1.size() << endl;

    for (auto it = a1.begin(); neq(it, a1.end()); ++it)
        cout << *it << endl;
}

int main()
{
    using namespace std;

    cout << "= 04 ======" << endl;
    t_strblob_04();

    // cout << "= 03 ======" << endl;
    // t_strblob_03();

    // cout << "= 02 ======" << endl;
    // t_strblob_02();

    // cout << "= 01 ======" << endl;
    // t_strblob_01();
}

<ex>
// Blob template <cpp-ex-strblob-template>
// This is the template-version of the same. No longer specific to `string`.
//
template <typename T>
class Blob
{
    public:
        typedef T value_type;

        // *cpp-template-type-member*
        typedef typename std::vector<T>::size_type size_type;

        Blob();
        Blob(std::initializer_list<T> il);

        size_type size() const { return data->size(); }
        bool empty() const { return data->empty(); }

        void push_back(const T &t) { data->push_back(t); }
        void pop_back();

        T& front()
        {
            check(0, "front() on empty container");
            return data->front();
        }
        T& back();

        T& operator[](size_type i);

        // // const versions
        // T & back() const;
        // T & operator[](size_type i) const;

    private:
        std::shared_ptr<std::vector<T>> data;
        void check(size_type i, const std::string &message) const;
};

// ctors
template <typename T>
Blob<T>::Blob(): data(make_shared<std::vector<T>>()) {}

template <typename T>
Blob<T>::Blob(std::initializer_list<T> il) : data(make_shared<std::vector<T>>(il)) {}

// <cpp-template-member-function>
//
// To write a member function of class template 'outside' of definition,
// remember that the instantiated type is a new type and must say to which class
// the member belongs. see Blob`<T>`
//
// it is instantiated `only if` it is used and if not, it is not instantiated.

template <typename T>
void Blob<T>::check(size_type i, const std::string &message) const
{
    if (i >= data->size())
        throw std::out_of_range(message);
}

// as stl-vector back() returns the last element
template <typename T>
T & Blob<T>::back()
{
    check(0, "back on empty blob");
    return data->back();
}

template <typename T>
T & Blob<T>::operator[](size_type i)
{
    check(i, "subscript out of range");
    return (*data)[i];
}

template <typename T>
void Blob<T>::pop_back()
{
    check(0, "pop_back on empty blob");
    data->pop_back();
}


={============================================================================
*kt_dev_cxx_0000* cxx-abc cxx-ex-quote-example cxx-refactoring

* class hierarchy represents book purchase or transaction
* supports several discount strategy
* each book has isbn number. the same book has the same isbn. 


This is the previous approach to support several discounts:

class Quote {
  public:
    ...
    std::string isbn() const { return bookNo; }
    virtual double net_price( std::size_t n ) const
    { return n*price; }

  private:
    std::string bookNo;
  protected:
    double price = 0.0;
};

class Bulk_quote : public Quote {
  public:
    Bulk_quote() = default;

    // defines discount strategy
    double net_price( std::size_t ) const override;

  private:
    std::size_t min_qty = 0;
    double discount = 0.0;
};


<cxx-refactoring>
Imagine that want to support `several discount strategies` How? 

Define a class which represents each strategy derived from Bulk_quote or
Quote. Or move up members for discount strategy to Quote.


Quote -> Bulk_quote -> School_quote
                    -> Xmas_quote
                    ...

However, all do not represent the general concept.

So:

  Each of these discout strategies requires a quantity and a discount amount
  which are common to all discout strategies. Make it general and abstract.
  
  Each of the derived classes will implement its discount strategy by defining
  its own version of net_price.

This is refactoring example. Refactoring involves redesigning a class
hierarchy to move operations and/or data from one class to another. It is that
even though we changed the inheritance hierarchy code that uses Bulk_quote or
Quote would 'not' need to change but need to recompile.


So have seperate Disc_quote to represent the general concept, not a concreate
discount strategy, and make it abstract base class to prevent users creating a
object of this type.

class Disc_quote : public Quote {
  public:
    Disc_quote() = default;
    Disc_quote(const std::string& book, double price, std::size_t qty, double disc):
      Quote(book, price), quantity(qty), discount(disc) {}

    // *cxx-pure-virtual-function*
    double net_price(std::size_t) const = 0;

  protected:
    std::size_t quantity = 0;
    double discount = 0.0;
};

class Bulk_quote : public Disc_quote {
  ...
};


<error-when-create-abc>
This happens when tries to create an implementation class which is derived
from ABC class. This is because implementation class did not override some of
members.

/port/CPort.cpp: In static member function 'static CPort* CPort::getInstance()':
/port/CPort.cpp:36:27: error: cannot allocate an object of abstract type 'CPort'
/port/CPort.h:29:1: note:   because the following virtual functions are pure within 'CPort':
/interface/port/IPort.h:48:22: note: 	virtual IIframe* IPortingLayer::getIframe()
/interface/port/IPort.h:56:23: note: 	virtual ISession* IPortingLayer::getSession()
/port/CPort.cpp: In constructor 'CPort::CPort()':
/port/CPort.cpp:46:25: error: cannot allocate an object of abstract type 'CIframe'
/port/CIframe.h:27:1: note:   because the following virtual functions are pure within 'CIframe':
/interface/port/IIframe.h:73:18: note: 	virtual void IIframe::destory(uint32_t)
/interface/port/IIframe.h:80:18: note: 	virtual bool IIframe::isDisplayed()
/interface/port/IIframe.h:86:18: note: 	virtual bool IIframe::setDisplayFlag()
/interface/port/IIframe.h:94:18: note: 	virtual bool IIframe::isMHEG2(void*, uint32_t)
/interface/port/IIframe.h:102:18: note: 	virtual bool IIframe::isMHEG4(void*, uint32_t)

Why? When deriving a ABC class, if don't override a pure virtual func then the
derived also becomes ABC. Hence errors.

This may be a way to check whether overrides happens or not? Yes, when use ABC
and only one override. No when not use ABC and there are multiple overrides
down the inheritance.


<containers-and-inheritance>
In order to use objects of inheritance in containers, must use pointer or
reference due to sliced-off. For example, cannot use this approach.

vector<Quote> sales; or vector<Bulk_quote> sales;

One of the ironies of OOP in C++ is that we cannot use objects directly to
support it. Instead `must use pointers and references.` So often define
auxiliary class to help manage complexity that pointer use impose.


<code>
#include <iostream>
#include <set>
#include <memory>

// g++ -g -std=c++0x -c a.c

using namespace std;

// base class
class Quote 
{
    public:
        Quote(): bookNo(""), price(0.0) {}
        Quote(const string &book, double sales_price):
            bookNo(book), price(sales_price) {}

        virtual ~Quote() {}

        string isbn() const { return bookNo; }

        // defines discount strategy
        virtual double net_price(size_t n) const { return n*price; }

    private:
        std::string bookNo;
    protected:
        double price;
};

// abc class which has minimum quantity for a discount and discount rate
class Disc_quote : public Quote {
    public:
        // Why need to have constructors in abstract class although cannot
        // define objects of this type directly? Becuase ctors in classes
        // derived from Disc_quote will use the Disc_quote ctor to construct
        // the Disc_quote part of their objects. Default ctor default
        // initialize those members.
        Disc_quote(): quantity(0), discount(0.0) {}
        Disc_quote(const string &book, double price, size_t quantity, double discount):
            Quote(book, price), quantity(quantity), discount(discount) {}

        // *cpp-abc-dtor*
        // no need to declare virtual dtor since Quote have one and will be
        // made.

        // note: pure virtual function in the middle of inheritance. not a
        // problem.
        double net_price(size_t n) const = 0;

        pair<size_t, double> discount_policy() const 
        { return make_pair(quantity, discount); }

    protected:
        size_t quantity;
        double discount;
};

// derived class
class Bulk_quote: public Disc_quote {
    public:
        Bulk_quote(const string &book, double price, size_t quantity, double discount):
            Disc_quote(book, price, quantity, discount) {}

        // defines discount strategy:
        // apply discount percentage when sold more than minimum quantity
        double net_price(size_t n) const override
        {
            if (n >= quantity)
                return n*(1-discount)*price;
            else
                return n*price;
        }
};

// utility user function
double print_total(ostream &os, const Quote &item, size_t sold)
{
    // calls type specific version
    double net_price = item.net_price(sold);

    os << "isbn: " << item.isbn() << ", sold: " << sold << ", total due: " 
        << net_price << endl;
}

// *cpp-user-class*
class Basket {
    public:
        // when not use in-class-initializer
        Basket(): items(compare) {}

        void add_item(const std::shared_ptr<Quote> &sale)
        { items.insert(sale); }

        double total_receipt(std::ostream &os) const;
        void display(std::ostream &os) const;

    private:
        // there is no less-than(<) operator for shared_ptr and must provice one
        // to compare keys in multiset since set is sorted container.
        //
        // The basket is not in the hierarchy and has multiset to manage
        // 'multiple' purchase for the same book, isbn. The multiset has
        // shared_ptr key but equality is decided by compare function.
        // Therefore, the comparison uses the isbn but not shared_ptr itself.
        // That is shared_ptr is a key in multiset but the same 'key' is the
        // same isbn number since comparison function defines the meaning of
        // the same.

        static bool compare(const std::shared_ptr<Quote> &lhs, 
            const std::shared_ptr<Quote> &rhs)
        { return lhs->isbn() < rhs->isbn(); }

        // when uses in-class initializer:
        //
        // *gcc-error* when do not support *in-class-initializer*
        //
        // g++ (Debian 4.9.2-10) 4.9.2 do not support
        //
        // t_quote.cpp:88:55: error: could not convert ‘{Basket::compare}’ 
        // from ‘<brace-enclosed initializer list>’ to ‘std::multiset<std::shared_ptr<Quote> >’
        //
        // multiset<std::shared_ptr<Quote>> items{compare};
        
        // when not use in-class-initializer *cpp-using-typedef*
        // using comp = bool (const shared_ptr<Quote> lhs, const shared_ptr<Quote> rhs);
        using comp = bool (*)(const std::shared_ptr<Quote> &lhs, 
            const std::shared_ptr<Quote> &rhs);
        multiset<std::shared_ptr<Quote>, comp> items;
};

void Basket::display(std::ostream &os) const
{
    os << "=> basket size: " << items.size() << endl;

    // *cxx-multi-set*
    // print each distinct book(isbn) in the basket. the key is shared ptr.
    for (auto item = items.cbegin(); item != items.cend();
            item = items.upper_bound(*item))
    {
        os << (*item)->isbn() << " occurs, "
            << items.count(*item) << " times, "
            << "net price: " << (*item)->net_price(items.count(*item)) 
            << endl;
    }
}

double Basket::total_receipt(std::ostream &os) const
{
    double total_price = 0.0;

    for (auto item = items.cbegin(); item != items.cend();
            item = items.upper_bound(*item))
    {
        total_price += print_total(os, **item, items.count(*item));
    }

    os << "=> total sale price: " << total_price << endl;

    return total_price;
}


int main()
{
    Basket sale;

    // Quote sales which has no discount. 45*3 = 135
    sale.add_item(shared_ptr<Quote>(new Quote("123", 45)));
    sale.add_item(shared_ptr<Quote>(new Quote("123", 45)));
    sale.add_item(make_shared<Quote>("123", 45));

    // minimum 3 and 15% discount. no discount 45*2 = 90
    sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));
    sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));

    // Bulk_quote sales which has discount: minimum 3 and 15% discount
    // 35*4*(1-.15) = 119
    sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 35, 3, .15)));
    sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 35, 3, .15)));
    sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 35, 3, .15)));
    sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 35, 3, .15)));

    // Bulk_quote sales which has discount: minimum 5 and 25% discount
    // 35*6*(1-.25) = 157.5
    sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
    sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
    sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
    sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
    sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
    sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));

    sale.display(cout);
    sale.total_receipt(cout);

    // => basket size: 15
    // 123 occurs, 3 times, net price: 135
    // 345 occurs, 2 times, net price: 90
    // 678 occurs, 4 times, net price: 119
    // 912 occurs, 6 times, net price: 157.5
    // isbn: 123, sold: 3, total due: 135
    // isbn: 345, sold: 2, total due: 90
    // isbn: 678, sold: 4, total due: 119
    // isbn: 912, sold: 6, total due: 157.5
    // => total sale price: 2.11371e-314
}


{cxx-virtual-copy} {cxx-clone} // RCPR 633
The user have to deal with dynamic memory to add items:

void add_item(const std::shared_ptr<Quote> &sale);

sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 55, 5, .25)));
sale.add_item(make_shared<Quote>("def", 35));

Hiding the pointers. This new version will handle the memory allocation so
that users no longer need to do so:

sale.add_item(Quote("def", 35));
sale.add_item(Bulk_quote("678", 55, 5, .25));

void add_item(const Quote &sale);    // copy version
void add_item(Quote &&sale);         // move version

The problem is that add_item do not know what type to allocate:

void add_item( const Quote &sale )
{
  // somewhere
  new Quote(sale);
}

This won't do right thing. Only handles Quote even if passes Bulke_quote and
see sliced-off problem. How to solve? Use overloads? Use virtual copy to have
right version. 


<code>
#include <iostream>
#include <set>
#include <memory>

using namespace std;

// base class
class Quote {
    private:
        string s_book_no;

    protected:
        double price;

    public:
        Quote() : s_book_no(""), price(0.0) {}
        Quote(const string book, const double price) : s_book_no(book), price(price) {}

        // have to since it's intended to be inherited
        virtual ~Quote() {}

        string isbn() const { return s_book_no; }

        // get net price without discount
        virtual double net_price(size_t sales_count) const
        { return sales_count*price; }

        // virtual copy, copy version
        //  *cpp-const-this* if not use `const` on this, 
        //  see *cpp-const-to-nonconst-error* when use
        //
        // void add_item( const Quote& sale )
        // { items.insert( shared_ptr<Quote>( sale.clone())); }
        //
        // since sale is const object and error to call nonconst version on
        // const object. *cpp-remember* always makes a call on `object`
        //
        virtual Quote *clone() const &
        { 
            cout << "quote::clone::copy" << endl;
            return new Quote(*this); 
        }

        // virtual copy, move version
        //  uses *reference-qualifier* and *cpp-overload-move*
        //  if there is no move version, copy version is used when move version
        //  of add_item() is called.
        //
        virtual Quote *clone() const &&
        { 
            cout << "quote::clone::move" << endl;
            return new Quote(std::move(*this)); 
        }
};

class Disc_quote : public Quote
{
    protected:
        double d_quantity;
        double d_discount;

    public:
        Disc_quote(const string book, const double price, const double quantity, const double discount) :
            Quote(book, price), d_quantity(quantity), d_discount(discount) {}

        double net_price(size_t sales_count) const = 0;
};

class Bulk_quote : public Disc_quote
{
    public:
        Bulk_quote(const string book, const double price, const double quantity, const double discount) :
            Disc_quote(book, price, quantity, discount) {}

        // double net_price(size_t sales_count) const override
        double net_price(size_t sales_count) const 
        {
            if( sales_count >= d_quantity )
                return sales_count*(1-d_discount)*price;
            else
                return sales_count*price;
        };

        // virtual copy, copy version
        //  Unlike Quote::clone(), when there is no const, no compile error but
        //  gets always Quote version since no override. see
        //  *cpp-override-condition*
        virtual Bulk_quote *clone() const &
        { 
            cout << "bulk::clone::copy" << endl;
            return new Bulk_quote(*this); 
        }

        // virtual copy, move version
        virtual Bulk_quote *clone() const &&
        { 
            cout << "bulk::clone::move" << endl;
            return new Bulk_quote(std::move(*this)); 
        }
};

// user class
class Basket
{
    public:
        Basket() : items(compare) {}

        void add_item(const shared_ptr<Quote> &item);

        // virtual copy, copy version
        // which signals to use lvalue object, lvalue reference qualifier
        void add_item(const Quote &item)
        {
            cout << "basket::add_item::copy version" << endl;
            items.insert(shared_ptr<Quote>(item.clone()));
        }

        // virtual copy, move version
        // which signals to use rvalue object, rvalue reference qualifier
        void add_item(Quote &&item)
        {
            cout << "basket::add_item::move version" << endl;
            items.insert(shared_ptr<Quote>(std::move(item).clone()));
        }


        double total_receipt(ostream &os) const;

    private:
        static bool compare(const shared_ptr<Quote> lhs, const shared_ptr<Quote> rhs)
        { return lhs->isbn() < rhs->isbn(); }

        using comp = bool (const shared_ptr<Quote> lhs, const shared_ptr<Quote> rhs);
        multiset<shared_ptr<Quote>, comp*> items;
};

void Basket::add_item(const shared_ptr<Quote> &item)
{
    cout << "basket::add_item::copy version" << endl;
    items.insert(item);
}

double Basket::total_receipt(ostream &os) const
{
    for (auto iter = items.cbegin(); iter != items.cend();
            iter = items.upper_bound(*iter))
    {
        os << "isbn : " << (*iter)->isbn() 
            << ", sold : " << items.count(*iter)
            << ", total sales: " << (*iter)->net_price( items.count(*iter)) 
            << endl;
    }
}

int main()
{
    Basket sale;

    // to use copy version
    // // Quote sales which has no discount. 45*3 = 135
    // sale.add_item(shared_ptr<Quote>(new Quote("123", 45)));
    // sale.add_item(shared_ptr<Quote>(new Quote("123", 45)));
    // sale.add_item(make_shared<Quote>("123", 45));

    // // minimum 3 and 15% discount. no discount 45*2 = 90
    // sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));
    // sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));

    // // Bulk_quote sales which has discount: minimum 3 and 15% discount
    // // 35*4*(1-.15) = 119
    // sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 35, 3, .15)));
    // sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 35, 3, .15)));
    // sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 35, 3, .15)));
    // sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 35, 3, .15)));

    // // Bulk_quote sales which has discount: minimum 5 and 25% discount
    // // 35*6*(1-.25) = 157.5
    // sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
    // sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
    // sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
    // sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
    // sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
    // sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));

    // to use move version
    // Quote sales which has no discount. 45*3 = 135
    sale.add_item(Quote("123", 45));
    sale.add_item(Quote("123", 45));
    sale.add_item(Quote("123", 45));

    // minimum 3 and 15% discount. no discount 45*2 = 90
    sale.add_item(Bulk_quote("345", 45, 3, .15));
    sale.add_item(Bulk_quote("345", 45, 3, .15));

    // Bulk_quote sales which has discount: minimum 3 and 15% discount
    // 35*4*(1-.15) = 119
    sale.add_item(Bulk_quote("678", 35, 3, .15));
    sale.add_item(Bulk_quote("678", 35, 3, .15));
    sale.add_item(Bulk_quote("678", 35, 3, .15));
    sale.add_item(Bulk_quote("678", 35, 3, .15));

    // Bulk_quote sales which has discount: minimum 5 and 25% discount
    // 35*6*(1-.25) = 157.5
    sale.add_item(Bulk_quote("912", 35, 5, .25));
    sale.add_item(Bulk_quote("912", 35, 5, .25));
    sale.add_item(Bulk_quote("912", 35, 5, .25));
    sale.add_item(Bulk_quote("912", 35, 5, .25));
    sale.add_item(Bulk_quote("912", 35, 5, .25));
    sale.add_item(Bulk_quote("912", 35, 5, .25));
 
    sale.total_receipt(cout);
}

...
basket::add_item::move version
bulk::clone::move
isbn : 123, sold : 3, total sales: 135
isbn : 345, sold : 2, total sales: 90
isbn : 678, sold : 4, total sales: 119
isbn : 912, sold : 6, total sales: 157.5


={============================================================================
*kt_dev_cpp_200* cpp-abc-call-in-dtor

<cxa-pure-virtual>
// from mapfile
 .text.__cxa_pure_virtual
                0x00000000004027b0       0x1f /usr/lib/gcc/x86_64-linux-gnu/4.9/libstdc++.a(pure.o)
                0x00000000004027b0                __cxa_pure_virtual

// gcc/libsupc++/pure.cc

extern "C" void
__cxxabiv1::__cxa_pure_virtual (void)
{
  writestr ("pure virtual method called\n");
  std::terminate ();
}

<purpose>
https://stackoverflow.com/questions/920500/what-is-the-purpose-of-cxa-pure-virtual?noredirect=1&lq=1
If anywhere in the runtime of your program an object is created with a virtual
function pointer not filled in, and when the corresponding function is called,
you will be calling a 'pure virtual function'.

The handler you describe should be defined in the default libraries that come
with your development environment. If you happen to omit the default
libraries, you will find this handler undefined: the linker sees a
declaration, but no definition. That's when you need to provide your own
version.

The infinite loop is acceptable because it's a 'loud' error: users of your
software will immediately notice it. Any other 'loud' implementation is
acceptable, too.


https://stackoverflow.com/questions/99552/where-do-pure-virtual-function-call-crashes-come-from
They can result if you try to make a virtual function call from a constructor
or destructor. Since you can't make a virtual function call from a constructor
or destructor (the derived class object hasn't been constructed or has already
    been destroyed), it calls the base class version, which in the case of a
pure virtual function, doesn't exist.

class Base
{
public:
    Base() { doIt(); }  // DON'T DO THIS
    virtual void doIt() = 0;
};

void Base::doIt()
{
    std::cout<<"Is it fine to call pure virtual function from constructor?";
}

class Derived : public Base
{
    void doIt() {}
};

int main(void)
{
    Derived d;  // This will cause "pure virtual function call" error
}


When run on GCC 4.9.2, see Base::doIt() gets called rather than
__cxa_pure_virtual() called. Believe that __cxa_pure_virtual is default
setting for vtable.


<ex>
in this case, provides own __cxa_pure_virtual(). see this pointer, 0x2b02b4fc,
gets changed and item is getting freed?

Core was generated by `/NDS/bin/MW_Process MW_Process'.
Program terminated with signal 8, Arithmetic exception.
#0  0x008bee20 in __cxa_pure_virtual () at ms_utils.cpp:103
#0  0x008bee20 in __cxa_pure_virtual () at ms_utils.cpp:103
        _XDEBUG_TraceAssociationStr = 0x12f49a0 "< no-ctx >"
        _XDEBUG_FuncInfo = {funcName = 0x12f4710 "__cxa_pure_virtual", dummy = 0}
#1  0x00997a08 in MSCPP::ITEM::GetFilter (this=0x1, filter_type=MSCPP::E_MS_FILTER_TYPE_BUFFERPUMP) at item.cpp:6259
        p_filter = 0xff0000 <PANEL_ReceiveMessage+1072>
#2  0x0099b768 in MSCPP::ITEM::SetItemRunningJobs (`this=0x2b02b4fc`, p_item_running_jobs=0x2b02b4fc) at item.cpp:15740
No locals.
#3  0x0099b7c8 in MSCPP::ITEM::UndoGraph (this=0xff0000 <PANEL_ReceiveMessage+1072>, graph_index=1) at item.cpp:15688
No locals.
0x4, p_params = `0x2b02b4fc`, callback = 0x98fce8 <MSCPP::ITEM::ActionListFsm_SetState(MSCPP::ITEM_ACTION_LIST_FSM_STATE)+28>}, undo_event = {p_action_list = 0x4, callback = 0x2b02b4fc}, action_done_event = {action_id = 4, p_out_params = 0x2b02b4fc, result = 10026216}, action_undone_event = {action_id = 4, result = 721597692}}}
        _XDEBUG_FuncInfo = {funcName = 0x1333440 "ActionFsm_HandleUndoEvent", dummy = 0}

    class MS_FILTER : public TRACE_ASSOCIATION, private virtual NonCopyable
    {
        public:
            virtual MS_FILTER *GetSource(_in_ ITEM       *p_item) = 0;
            virtual MS_FILTER *GetDest(_in_ ITEM         *p_item) = 0;
    };

    class SHARED_FILTER : public MS_FILTER
    {
      // no override
    };

    class BUFFERPUMP_FILTER : public SHARED_FILTER, public MS_SRC_PUSH, public MS_DEST_PULL
    {
      public:
        virtual MS_FILTER *GetSource(_in_ ITEM       *p_item);
        virtual MS_FILTER *GetDest(_in_ ITEM         *p_item);
    };


MS_FILTER* ITEM::GetFilter(_in_ MS_FILTER_TYPE   filter_type)
{
    MS_FILTER *p_filter = m_p_source_filter;

    while (p_filter != XNULL)
    {
	if (p_filter->GetType() == filter_type)
	{
	    break;
	}
	p_filter = p_filter->GetDest(this);
    }

    return p_filter;
}

so what's the actual filter type? is it in the middle of free?


={============================================================================
*kt_dev_cpp_004* cxx-copy-preventing-copies cxx-delete

CPR 507 and EC++06. How can define a class to prevent copy or assign like
`iostream` class? Do not defining copy-controls? This do not work as syn version
will be made. Two ways: `delete-keyword` and `private-access-control`.

<cpp-delete> *C++11*
Signal to the compiler `not to define` these members and lead to compile error
when try to use it. Or syn version will be `deleted` when compiler cannot make
it.

struct NoCopy {
  NoCopy() = default;
  NoCopy(const NoCopy&) = delete;                 // NO copy-ctor 
  NoCopy& operator=(const NoCopy&) = delete;      // NO copy-assign
  ~NoCopy() = default;
  ...
};


<not-on-dtor>
If the dtor is deleted, then there is no way to destory objects of that type.
The compiler will not 'let' us define variables or create temporaries of that
type.


<before-CPP-11>
To prevent copies before C++11:

class PrivateCopy {
  private:
  // declare but not define 
    PrivateCopy(const PrivateCopy&);
    PrivateCopy &operator=(const PrivateCopy&);

  public:
    PrivateCopy() = default;
    ~PrivateCopy();
};

Since the dtor is public, users will be able to define object but not be able
to copy such objects.


<ex>
This is an example and see 'compile' errors when use `private-access-control`
to prevent copies and note that won't compile regardless of whether there is
copy control definition(implementation) in base class.

#include <iostream>

using std::cout; using std::endl;

class Base {
  public:
    Base() = default;
    ~Base() = default;
  private:
    int m_iDataABCAnimal;
    Base(const Base& base) { cout << "copy-ctor: base" << endl; }   // @11
    Base& operator=(const Base& base) { cout << "copy-assign: base" << endl; }
};

class D : public Base
{
  public:
    void getShout() { cout << "derived get shout" << endl; };
};

int main()
{
  std::cout << "--{ main " << std::endl;

  Base b1, b2;

  Base b3(b1);       // note: 01 @21

  D d1, d2;

  d1.getShout();

  d2 = d1;           // note: 02

  std::cout << "--} main " << std::endl;
}

note: 01
use-prevent-copy.cpp: In function ‘int main()’:
use-prevent-copy.cpp:11:4: error: ‘Base::Base(const Base&)’ is private
use-prevent-copy.cpp:21:12: error: within this context

note: 02
base.cpp: In function ‘int main()’:
base.cpp:33:8: error: use of deleted function ‘D& D::operator=(const D&)’
base.cpp:15:7: error: ‘D& D::operator=(const D&)’ is implicitly deleted 
    because the default definition would be ill-formed:
base.cpp:12:10: error: ‘Base& Base::operator=(const Base&)’ is private
base.cpp:15:7: error: within this context


<friend-can-access> 
However, friend and members still can access private. How to prevent this? Use
'link' error by not defining in addition to using private access.

using std::cout; using std::endl;

class Base {
  public:
    Base() = default;
    ~Base() = default;
  public:
    int m_iDataABCAnimal;
    Base(const Base& base);      // NO definition
    Base& operator=(const Base& base) { cout << "copy-assign: base" << endl; }
};

int main()
{
  Base b1, b2;

  Base b3(b1);
}

$ ./comp.sh use-prevent-copy.cpp 
/tmp/ccskAMRR.o: In function `main':
/home/kit/work/use-prevent-copy.cpp:22: undefined reference to 
  `Base::Base(Base const&)' collect2: ld returned 1 exit status


To prevent access from derived classes or user, make copy control private and
cause compile error.

To prevent access from friend or members, so declare copy controls but not
define. By doing this, can cause 'link' errors when there are attempts to use.
Because when used, compiler will try to link but no definition. The example is
ios_base, basic_ios, and sentry of STL implementation.


<boost-noncopyable>
EC++06. For a easy use of adding preventing copy features discussed above, use
uncopyable class as a base which is boost::noncopyable. This has couple of
consideration for inheritance.

#include <iostream>

class Uncopyable {
  protected:                                                   // note
    Uncopyable() {}
    ~Uncopyable() {}

  private:
    Uncopyable(const Uncopyable&);
    Uncopyable& operator=(const Uncopyable&);
};

// class Foo : public/protected Uncopyable {                  // note
class Foo : private Uncopyable {                              // 13
  public:
    void WhoAmI() { std::cout << "foo" << std::endl; }
};

int main()
{
  Foo f;
  f.WhoAmI();

  // errors only when add followings
  Foo o;
  o = f;                                                      // @26
}

: In function ‘int main()’:
:26:6: error: use of deleted function ‘Foo& Foo::operator=(const Foo&)’
:13:7: error: ‘Foo& Foo::operator=(const Foo&)’ is implicitly deleted 
   because the default definition would be ill-formed:
:10:17: error: ‘Uncopyable& Uncopyable::operator=(const Uncopyable&)’ is private
:13:7: error: within this context

note: Why protected on ctor and dtor? Only possible to create it via
inheritance. e.g. derived class.

note: Regardless of inheritance type, won't compile. Why shouldn't be public?
Since it is not is-a relationship and the case use is 'private'.

note: Why not virtual dtor in base? By using protected dtor, make it error to
use delete on base but able to run dtor via derived class. See
non-virtual-destruction-problem. 


*cpp-access-error*
<Q> Why this error on calling test_f()? Since use of reference parameter do not
cost copy constructor, what calls are involved here?

error: 'Uncopyable' is an inaccessible base of ‘Foo’

void test_f( Uncopyable &uc )
{
  uc.WhoAmI();
}

int main()
{
  Foo fo;
  test_f(fo);
}


={============================================================================
*kt_dev_cxx_0000* cxx-function-matching

Known as overload resolution. `The name has scope` and `object has lifetime.`
Three possible outcomes: best match, no match, and ambiguous call.


#01: <cxx-name-lookup> *cxx-argument-dependant-lookup*

For `name-lookup` inside a namespace, look in members in case class, and if
not found, continue looking in enclosing scope; which is a open scope having a
name to look up. This can be block, class, or `namespace`. So continue looking
in classes up the chain of inheritance or namespaces. This search goes upwards
that means declared before use and before in reading order. For example, int
A::C1::f3() in qualified name. 

In addition, use `argument-dependant-lookup` for reference and pointer of
class type. For non-class, enclosing scope that is before the point of use and
is still open. See Primers p797. `using-declaration` or directive add names to
the candidate set. 

  "If found the name, the compiler looks 'no' further"

Use the number of arguments, type match, and conversion to get viable
functions. `In C++, name lookup happens before type checking`


<scope-and-search>
The search looks 'outwards' or 'upwards' through the 'enclosing' scopes which
are declared 'before' the point of use and are still 'open'. The enclosing
scopdes are blocks, namespaces, and base classes and search goes upwards and
ends 'global' namespace. Hence 'hiding' name can happen.


#02: <build-candidate> use name and build candiate of overloads and
template instantiations

Use 'name' only hence called name-lookup. Build candidate functions which is
the set of overloaded functions and should be the same name and visible.
Include any function-template instantiation for which template argument
deduction succeeds.

// <overload-condition>
// Member functions differing only in their constness can be overloaded.
// Conditons for overloading
//
// * Shall be the same 'name'
// * Shall have different param list in the 'number' or the 'type'
// * Shall be in the same 'scope'
// 
// It is an error for two functions to differ only in terms of their return
// types.


#03: <build-viables>


#04: <find-best-match> prefer best and nontemplate

The exact match is better than a match that requires a conversion.
`nontemplate` function is selected if there's only one in the set. If not,
more specialized func template is called. otherwise, the call is ambiguous.


#05: <check-access>

See accessibilty in case of inheritance. From EC++40


#06: <virtual-or-not>

If it is a virtual call, generate a code for run-time binding. Otherwise,
generate a normal call.


{wider-candidate-set-op-overload}

a op b;

This says nothing about whether it would calls member or non-member. So the set
is wider to both member and non-member to be considered.  


<in-inheritance>
CPP 617. Hierarchical nesting of class scope; means that the derived is nested
in the base scope and names in the derived can hide names declared in the base.
See {override-keyword} *kt_dev_cpp_023* The point is that the name-lookup
happens at compile time and uses static-type. The below shows that point.

class Disc_quote : public Quote {
  public:
    // added in this class only
    std::pair<a,b> discount_policy() const {}
};

class Bulk_quote : public Disc_quote {
  ...
};

Bulk_quote bulk;

Bulk_quote* bulkP = &bulk;
Quote* itemP = &bulk;        // static and dynamic type differ

bulkP->discount_policy();
itemP->discount_policy();    // error

What if discount_policy is a virtual func? Doesn't matter in this case and it's
still error because this is not found in Quote class.

Tried with GCC and got an error:
.cpp:139:10: error: 'class Quote' has no member named 'discount_policy'


<cpp-hide-name>
EXC++34. Name Hiding

The code below may will compile or maybe not. GCC 4.7.2 builds fine. 

The std::accumulate uses operator+(int, N::C) and the problem is that the
compiler may or may not be able to see that function depending on the compiler
implementation since C++ does not specify which standard headers will include
each other.

The namespace N do not have oparator+() and continue to search it in std
namespace. If compiler finds one then no look further so don't see the one in
global scope. If compiler do not find one, then see one in global scope.

<ex>
namespace N { class C {}; }

int operator+(int i, N::C) { return i+1; }

#include <numeric>

int main()
{
  N::C a[10];
  std::accumulate(a, a+10, 0);
}


The solution is to make the operator+() the part of interface by putting it
into the same namespace. This will builds regardless of compiler
implementations.

namespace N { 
  class C {}; 
  int operator+(int i, N::C) { return i+1; }
}

#include <numeric>

int main()
{
  N::C a[10];
  std::accumulate(a, a+10, 0);
}


={============================================================================
*kt_dev_cpp_028* cpp-namespace

{cpp-namespace-case}
03/07/2014. At samsung. 
When moves application which was a process and uses static link to the shared
library application to be used by other processes. The codes which works well
before starts to fail since crash happens when try to create a thread using
custom thread library. 

Problem of linking? Problem of the thread library when used in shared library
application? Somehow linker picks up the wrong libaray since a debugger shows
odd address when thread creation call is made and causes a crash? 

Tried various directions and spent many days. Eventually, found out that
PCThread::Create() is a problem and works fine when changes parameter orders.
The problem was that the process loads a lot of shared library and one of
those has the same PCThread class in it but different signature. When our
library make a call, it picks it up from the other shared library in which has
different signature so crashes. Sovled when wraps PCThread class with a
namespace.

note: So this was a problem of symbols between shared libraries.

The typical example is to use third party library and name conflict happens
when other parties develops a libaray separately. In static link, conflict
happens in link stage. In dynamic loading, this happens at run time and called
dynamic binding. So more difficult to find out.

See *kt_linux_core_107* shared library: search and resove


{cpp-namespace}
To solve name pollution or collisions, namespace partitions the global
namespace and `a namespace is a scope` It provides a much more controlled
mechanism and any declaration can be put into a namespace.


<global-namespace>
Names defined at global scope are in the global-namespace which is implicitly
declared and exists in every program. The scope operator can be used. Use "::"
for global variables.

::member_name


<named-namespace>
*cpp-remember* Except for function and namespce definitions, a declaration is
terminated by a semicolon.

namespace Foo {
  ...
}


<ways-to-use-member-in-namespace>
Code outside the namespace must indicate the namespace in which the name is
defined.

cplusplus_primer::Query q = cplusplus_primer::Query("Hello");

Other ways of referring to members from outside their namespace are using
declaration, using directive, and argument-dependent lookup.


<use-marco>

#define NS_OPEN namespace XXX {
#define NS_CLOSE }

# header or source file

# include <xxx>

NS_OPEN
...
NS_CLOSE


{cpp-namespace-unnamed} *cpp-static* 
Unnamed namespace. variables in unnamed namespace has staic lifetime so has
file scope as with file static. If a header file has vars in unnamed
namespace, it create different static vars which are local to file that
includes that header file. This also means that unnamed-namespace never spans
multiple files and do 'not' recommend to have it in a header since the names
in that namespace define different entities local to each file that includes
the header.

C++PL 422
By default, const objects, constexpr objects, type aliases, and anything
declared static in a namespace scope have internal linkage.


namespace {
  ...
}

<ex>
#include <iostream>

int i;         // 3

namespace {
   int i;      // 6
}

int main()
{
   i = 10;     // 11. ambiguous: defined globally and in an 
               // unnested, unnamed namespace.

   return 0;
}

sam01.cpp: In function ‘int main()’:
sam01.cpp:11:2: error: reference to ‘i’ is ambiguous
sam01.cpp:3:5: error: candidates are: int i
sam01.cpp:6:6: error:                 int {anonymous}::i

<same-as-static>
For static variable, try to use extern keyword and fails to link in the end.
This is the same when use unnamed namespace. If not use extern then have
multiple definition error. 

<global-variables>
Can use namespace for global variables:

// file one
namespace NG {
  int gfs_count;
}

// file two
namespace NG {
  extern int gfs_count;
}


{cpp-using-declaration-and-directive} *cpp-using*
The `using-declaration` which brings one namespace member into the scope that
uses it.

using std::cin;

The `using-directive` which brings whole namespace into the the scope that
have both a namespace and a scope that uses directive. This is enclosing scope
that is outter scope than the one uses directive.

`using namespce` std;

<avoid-use-of-directive>
Why? Other than else, `late detection`; means that ambiguity errors are
detected only at the point of use when use directive. This late detection
means that conflicts can arise long after introducing a particular library. If
the program begins using a new part of the library, perviously undetected
collisions may arise.

// ex. blip namespace is injected into the global namespce but no compile
// error. Emit error when strat to use j. At a point of `use`.

#include <iostream>

namespace blip {
  int i=16, j=15;
}

int j = 0;

int main()
{
  using namespace blip;

  //++j;

  return 0;
}


// ex. immediate compile error regardless of using j. At a point of
// `declaration`. sam01.cpp:9:13: error: ‘j’ is already declared in this scope

#include <iostream>

namespace blip {
  int i=16, j=15;
}

int j = 0;

using blip::j; 

int main()
{
   return 0;
}


<avoid-use-in-header-file>
Why? A header that has a using directive or declaration at its top-level
injects names into every file that includes the header. 

<when-directive-useful>
One place where using directive are useful is in the implementation files of
the namespace itself.


{nested-namespace}
namespace X { 
  namespace App {
    class X : public XXX
    {
      ...
    };
  }
}


{rename-namespace}
namespace bt = boost::posix_time;


{cpp-argument-dependant-lookup} *cpp-adt* 

CPP 797. See this statements:

std::string s;
std::cin >> s;

this is equi to:

operator>>(std::cin, s); 

This operator>>() is defined in the string libaray as a `non-memeber` and in
std namespace. 

When func has class type argument which is class object, pointer or reference,
     the compiler searches `namespace` in which argument defined in addition
     to the normal scope to lookup. 

In this case, searches the namespace std, where cin and string is defined and
found this func from string. 

This saves the programmer a lot of typing. Otherwise, should use for every
use:

using std::operator>>; or std::operator>>(std::cin, s);

Either would make simple use of the IO library more complicated. This makes it
easy to use nonmember func which is conceptually part of class interface.


EXC++31 Koenig Lookup

In short, the meaning of code in namespace B is being affected by a function
declared in the completely separate namespace A, even though B has done
nothing but simply mention a type found in A.

namespace aren't quite as independent as people originally thought, but they
are still pretty independent and fit their intendted purpose.


EXC++ 120. say that member is more strongly related to the class than a
nonmember.

namespace A
{
  class X {};
  void f(X);
}

namespace B
{
  void f(A::X);
  void g(A::X parm)
  {
    // use A::f or B::f()?. ambiguous
    f(parm);
  }
};


namespace A
{
  class X {};
  void f(X);
}

class B
{
  void f(A::X);
  void g(A::X parm)
  {
    // use B::f(), not ambiguous
    f(parm);
  }
};


<what-makes-up-the-interface-of-class>
EXC++32. Interface Principle.

the class definition:

"A class describes a set of data, along with the functions that operate on
that data"

Here, function means all function. For class X, all functions, including
`free-functions` (non-member function), that both:

* Mention X
* Are supplied wth X 
  means that `come in the same header file and/or namespace`

are logically part of X, because they form part of the interface of X.
see *cpp-ex-query-example*


*cpp-pattern-handle*
`handle-technique` for writing OO code in a language that doesn't have
classes. After all, "a sef of data, along with the functions that operate on
that data"

struct _iobuf { /* data goes here */ };

typedef struct _iobuf FILE;

FILE* fopen(const char* filename, const char* mode);
int fclose(FILE* stream);

long ftell(FILE* stream);
/* etc */


class FILE
{
  public:
    FILE(const char* filename, const char* mode);
    ~FILE();

    int fseek(long offset, int origin);
    long ftell();
    /* etc */

  private:
    /* data goes here */
};


{namespace-express-logical-structure}
The namespace is open and it shall express logical structure; interface
separated from implementation.  

The declaration and definition should be in the same namespace and this means
that shall use namespace block in 'both' header and source file as well.

// Sales_data.h
#include <string>

namespace cplusplus_primer {
  class Sales_data { ... };
  Sales_data operator+( const Sales_data&, const Sales_data&);
  // declarations for the remaining functions in the Sales_data interface
}

// Sales_data.cpp
#include "Sales_data.h"

namespace cplusplus_primer {
  // definitions for the Sales_data members and overloaded operators
}

// user.cpp
#include "Sales_data.h"

int main()
{
  using c_plusplus_primer::Sales_data;
  Sales_data trans;
  ...
}


<cpp-ood> *cpp-encapsulation*
EC++23 About considering encapsulation in design:

OOD principle dictates that data and functions that operates on them should be
bundled together. Does it suggest that member function is a better choice? No
since OOD is about encapsulation. The non-member and non-friend provides more
encapsulation, packaging flexibility, and extensibility.

The greater something is encapsulated, then the greater our ability to change
it later without breaking user codes. Roughly, when there are 'more' funcs to
access data, it's less encapsulated. Assumes that it follows the rule in
EC++22 that member data must be private and therefore provide only funtional
interfaces to access data.

If use private member data, then only member function and friend can use it.
If member function and non-member non-friend function provides the same
functionality, which is better? non-member non-friend function 

since it doesn't increase the number of functions that can access the private
part of the class or dependant on memeber data. 

class WebBrowser
{
  public:
    ...
    void clearCache();
    void clearHistory();
    void removeCookies();
    ...
};


o. Add more interface?

class WebBrowser
{
  public:
    ...
    void clearCache();
    void clearHistory();
    void removeCookies();
    void clearEverything();
    ...
};


o. Or, add non-member non-friend function?

void clearBrowser( Webbrowser& wb )
{
  wb.clearCache();
  wb.clearHistory();
  wb.removeCookies();
}

Use namespace due to *cpp-adt* 

namespace WebBrowserStuff {
  class WebBrowser { ... };
  void clearBrowser(WebBrowser& wb);
  ...
}


o. partitioning on convenience functions

The convenience function can't offer any functionality a WebBrowser client
couldn't already get in some other way. However, can make client to be
compliation dependent on only what they uses.

// `<webbrowser.h>` for class WebBrowser and core functionality.
namespace WebBrowserStuff {
  class WebBrowser { ... };
  void clearBrowser(WebBrowser& wb);
  ...
}

// `<webbrowserbookmarks.h>` for bookmark related convenience functions.
namespace WebBrowserStuff {
  ...
}

// `<webbrowsercookies.h>` for cookies related convenience functions.
namespace WebBrowserStuff {
  ...
}


o. partitioning on functionality

Use the same approach but on separated functionality. Like STL, vector, list
and etc are in each header but in the same namespce. Cannot do the same with
class member since a class cannot be split into pieces.


o. functional extensibility

When necessary, can extend functionality in the existing namespace by adding
more. This is 'horizental' extension compared with 'vertical', i.e., class
inheritence. 

After all, it's all about encapsulation and seperation. The class is closed or
tightly coupled approach since if it changes, the client will be broken. By
having non-member non-friend in the middle, can have seperation between
classes and client. This is like indirect access or interface class approach.


<namespace-as-module> C++PL 14.3.3
Could give the user's interface and the implementer's interface different
names but (because namespace are open) we don't have to.

    Parser (user interface)
         ^             ^
        /|\           /|\ 
         |        Parser_impl (implementation interface)
         |                 ^
  Driver code             /|\
                        Parser code

// user interface
namespace Parser
{
  double expr(bool);
}

// implementer interface
namespace Parser_impl
{
  using namespace Parser;

  double prim(bool);
  double term(bool);

  using namespace Lexer;
  using Error::error;
  using Table::table;
}


={============================================================================
*kt_dev_cpp_021* cpp-overload-operator

CPR 552

Operator overloading defines the meaning of an operator applied to operand(s)
of a 'class' type.

  * Overloaded operators are 'functions' with special names
  
  * Overloaded operators has the same number of parameters as the operator has
    operands. unary and binary.

  * Except for overloaded function call operator, overloaded operator must not
    have default arguments.

  * Member operator function has `this` bound to lhs operand. 
  
  * Operator function must either be a member of a class or have at least one
    parameter of class type. Since cannot change operators of built-in types
    and argument dependant lookup for nonmember case.

  * Operator function has the same precedence and associativity as built-in
    operator.

  * Be consitent with use of the built-in types.

  * Four symbols(+, -, *, &) serve as both unary and binary operators. 
  * note: +, - for unary?
  

{member-or-nonmember}
Decide whether to implement operator function as either a member or nonmember?

// nonmember case
data1 + data2;
operator+(data1, data2);

// member case
data1 += data2;
data1.operator+=(data2);

  * For member, the first(lhs) operand is bound to implict `this` 

  * For member, the `lhs` operand must be an object of the class of which that
    operator is a member. 
  
  * 'symmetric' operators - those that might convert either oparand, such as
    arithmetic, equiality, relational, and bitwise operators - usually should
    be nonmember.

    Since use symetric operators with mixed types. For example, can add `int`
    and `double` which can use either type as lhs or rhs operand. To provide
    similar mixed-type expressing involving class object, must be nonmember to
    allow 'conversion' since member fixes ths lhs type.


{assignment-version} {compound-op}
The standalone version of op 'must' be `nonmember` since the literal, "hi!",
    do not have member operations.

string u = "hi" + s; 

a = b + 1.0;
a = 1.0 + b;

However, the assignment version, operator+=(), is 'not' symmetric and
commutative. they are different and must be `member`.

data1 += data2;   // data1.operator+=(data2);
data2 += data1;   // data2.operator+=(data1);


note: 
CPR 564. Compound assignment operators are 'not' required to be members. So
"assignment operators 'must', and ordinarily compound assignment operators
'should', be defined as members.


*cpp-remember*
EXPC++20. The operator+= is more efficient since it operates on the `lhs`
directly and returns only a reference, not a temporary object. The standalone
version should be implemented in terms of assignment version.

T& T::operator+=(const T& other)
{
  ...;
  return *this;
}

This must return `const return` and see *const-return* to prevent this:

const Number operator+( const Number& lhs, const Number& rhs );
Number a, b, c;
a + b = c;

// How to eliminate this cost? Not always possible to shun this. Can use
// operator+= and see MEC++22 for more. Or can use compiler's
// <return-value-optimisation> in MEC++20.

const T operator+(const T& a, const T& b)
{
  T temp(a);
  temp += b;                // `implemented in terms of` +=
  return temp;
}


<ex> case that is based on syntax and library requirement.

If IO-op for Sales_data was member, then:

Sales_data data;

data << cout;     // since against to usual syntax of built-in type
cout << data;     // since cannot change the library


{assign-op}
The assign("="), member access arrow("->"), and call("()") 'must' be a member.

The copy and move assign that assign one object to another object of the 'same'
thye. The assign operator that assign 'other' types as the `rhs`.

<ex>
vector defines the third assign operator that takes a linitializer-list.

vector<string> v;
v = {"a", "an", "the"};

class StrVec {
  public:
    // return referece to its lhs to be consistent with built-in type
    StrVec &operator=(std::initializer_list<std::string>);
};


{input-output}

  * the first parameter of an output operator is reference to `nonconst` since
    writing to the stream changes its state.

  * the second parameter should be a reference to `const` since avoids copying
    and printing does not change that object.

  * return its stream parameters for chaining
  
  * implemented in terms of member or virtual member function which do actual
    work.

<<, >> operators 'must' be `nonmember` and usually a 'friend' since uses
private members. 

istream &operator>>(istream &is, Sales_data &item);

ostream &operator<<(ostream& os, const Sales_data& item)
{
  os << item.isbn() << " " << item.revenue() << ...;
  return os;
}


{equal-and-relational} operator-less
There is a subtle difference between equal and relational(operator <) as to
define 'ordering'.

<equal>
  * Classes for which there is a logical meaning for equality should define
    operator== to use with the library algorithms.

  * If defines operator==, should also define operator!=.

bool operator==( const Sales_data *lhs, const Sales_data *rhs )
{
  return lhs.isbn() == rhs.isbn() &&
    lhs.units_sold == rhs.units_sold &&
    lhs.revenue == rhs.revenue;
}

bool operator!=( const Sales_data *lhs, const Sales_data *rhs )
{
  return !(lhs == rhs);
}


{relation}
As with equal, classes for which the equality operator is defined also often
have relational since associative containers as a key and some algorithms use
the less-than operator.

<consistent-with-equaluty>
Should Sales_data support relational operator when supports euality?

The relational should be consistent in both "strict weak ordering" and "equal".

Suppose there are two Sales_data object which has the same ISBN but different
other members. 

Then operator== treats them 'unequal' but compareIsbn() which is operator< and
is used in ordered container, treats them 'equal' since neither of which is
"less than" the other.

So the ordering depends on how plan to use the class. For Sales_data class there
is no single logical defintion of < so better not to define < at all.


{subscript}
* must be member.
* return a reference to the element that is fetched.
* can be used on either side of an assignment. So it is a good idea to define
  with `const` and `nonconst` version.

class StrVec {
  public:
    std::string& operator[](std::size_t n)
    { return elements[n]; }

    const std::string& operator[](std::size_t n) const
    { return elements[n]; }

  private:
    std::string *elements;
};


See cpp-sp-ex-strblob-example for more.


={============================================================================
*kt_dev_cpp_005* cpp-builtin-conversion

{common-type}
When an operator has operands of 'different' types, they are converted to a
widest `common-type` to preserve precision.

CPR p159. Happens in expression, func call and func matching

int ival = 3.541 + 3;

Here, two conversion.

* 3 becomes `double` since double is common-type.
* The result of addition becomes `int` since in assignment, the left type
  dominates.

cases:

* integral promotion. promote smaller types to int. when mixed, promote to a
  bigger type.

* In conditions, nonbool are converted to bool. However, not always possible.
  see below.

* In assignment or initialization, converted to the left or the type of
  variable. Can be 'truncated'.

* common-type for mixed types.

* convert between signed and unsigned.


{truncated-and-undefined}
If the conversion is from a floating-point type to an integer type, the value is
truncated; the fractional part is removed.

signed char sc = 256;   // `out-of-range`. -128...127. `undefined value`
int ival = 3.541 + 3;


{integral-promotion} known as standard conversion
The `integral-promotion` converts the small types(bool, char, short, unsigned
    short) to a larger type(`int`) if all possible values of that type fit in an
int. Otherwise, to unsigned int. 


{when-type-and-signess-different}
Depends on the relative size of the 'integral' type on the machine. When signess
is the same, converted to the bigger type. When signess differ, two cases:

* unsigned >= signed then, the signed is converted to unsigned.

* unsigned < signed then, If all values of unsigned fits in the larger type,
  unsigned operand is conveted to signed. If the values don't fit, the signed
  operand is converted to unsigned. 


{when-same-type-and-signess-different}
unsigned char uc = -1;  // `out-of-range`. 255. See `wrap-around`

Recommends that don't mix between them:

//
unsigned ui = 10; int i = -42;
cout << ui + i << endl;

unsigned int u1 = 42, u2 = 10;
cout << u2 - u1 << endl;

These two cases shows the same result. 4294967264. why? because converted to
`unsigned`.


// infinite loop because u = -1 and means Uxxx_MAX

for( unsigned u = 10; u >= 0; --u )
   cout << n << endl;


// infinite loop due to implicit conversion

unsigned int begi;

for( int i = endi-1; i >= begi; --i )
   cout << line[i];

When begi is 0 and "i >= begi" cause implicit conversion to `unsigned` since it
is comparison between signed and unsigned. note: this is a problem of
string-npos.


<ex> *ex-atoi* ansic, p43.

check points:

  * input type? digits only? no space?
  * input size?
  * what base? 10 or 2?
  * sign support? 

int atoi(char s[])
{
  int n, i;

  for(n = 0, i = 0; s[i] >= '0' && s[i] <= '9'; i++)
    n = n*10 + (s[i]-'0');

  return n;
}


<ex> *ex-lower*

ASCII only since uses "offset = a-A" based on that upper case comes first and
lower case comes later in the table. 

int lower(int c)
{
  if( c => 'A' && c <= 'Z' )
    return 'a' + (c - 'A');   // clearer?
    return c + 'a' - 'A';     // c -'A' + 'a' or c + 'A' - 'a' ?
  else
    return c;
}


<ex> *ex-interview*

Amazon phone interview. Explain a problem to print money value to string such as
ONE HUNDRED AND FOURTY FIVE PENCE for $100.45. This simplifies handling of
fractional part and can get it by x100. The rest is string process.

int main()
{
  float fval = 100.45;
  int decimal = fval;
  int fraction = (fval - decimal)*100;

  cout << "float   : " << fval << endl;
  cout << "decimal : " << decimal << endl;
  cout << "fraction: " << fraction << endl;
}

float   : 100.45
decimal : 100
fraction: 44


={============================================================================
*kt_dev_cpp_005* cpp-integer-division

From ansic 1.2., this is a program to implement a formula "C = (5/9)(F-32)" to
print a table of Fahrenheit and Celsius.

<1> print Fahrenheit-Celsius table
int main(int argc, char* argv[])
{
  int fahr, celsius;
  int lower, upper, step;

  lower = 0;
  upper = 300;
  step = 20;

  fahr = lower;
  while( fahr <= upper ) 
  {
    celsius = 5 * (fahr-32) / 9;
    printf("%d\t%d\n", fahr, celsius );
    fahr = fahr + step;
  }
}

celsius = 5 * (fahr-32) / 9;      // okay
celsius = 5/9 * (fahr-32);        // not okay

Since `integer-division` truncates; any fractional part is discarded so 5/9
would be trancated to zero.

0     -17
20    -6
40    4
...
260   126
280   137
300   148

0     0
20    0
...
280   0
300   0


<2> floating-point version to be accurate

int main(int argc, char* argv[])
{
  float fahr, celsius;
  int lower, upper, step;

  lower = 0;
  upper = 300;
  step = 20;

  fahr = lower;
  while( fahr <= upper ) 
  {
    celsius = 5/9 * (fahr-32);        // not okay
    celsius = 5/9 * (fahr-32.0);      // not okay
    celsius = 5/9.0 * (fahr-32);      // okay
    celsius = 5.0/9.0 * (fahr-32.0);  // okay
    printf("%3.0f %6.1f\n", fahr, celsius );
    fahr = fahr + step;
  }
}

"5/9" is still integer division.

If an arithmetic operator has integer operands, an integer operation is
performed. If an arithmetic operator has one floating-point operand and one
integer operand, howerver, the integer will be converted to floating point
before the operation is done. 

"while(fhar <= upper)" and "fahr-32" would be converted to floating point.
Nevertheless, writing floating-point constants with explicit decimal point
'emphasizes' their floating-point nature for human readers.


<3> *cpp-modulus*
The division truncate the remainder and modulus(%) operator.

// plus to grade ending in 8 or 9 and minus to grade ending in 0, 1, or 2.
const vector<string> scores = { "F", "D", "C", "B", "A", "A++" };

string lettergrade;

if( grade < 60 )
  lettergrade = score[0];
else
{
  lettergrade = score[ (grade-50)/10 ];

  if( grade % 10 > 7 )
    lettergrade += '+';
  else if( grade % 10 < 3 )
    lettergrade += '-';
}


={============================================================================
*kt_dev_cpp_005* cpp-type-conversion cpp-explicit

converting-ctor and conversion-op define `class-type conversions.`

<ex>
EXC++39 says that avoid converison operators and non-explicit ctors.

string s1, s2, s3;
s1 = s2 - s3;           // oops, probably menat "+"


{converting-ctor} *cpp-single-ctor*
The converting-ctor is every ctor with `single` argument and do `implicit`
conversion from arg type to that class type and conversion-op is opposite.

class T {       <- from other type to T. converting-ctor
   ...          -> from T to other types. conversion-op
};


class Sale_data {

   combine(const Sales_data&);
   Sales_data(const std::string &s);
   Sales_data(std::istream &);

};

string null_book;

item.combine(null_book);

The combine() expect Sales_date type but it is given a string. How can make it
work? The compiler do implicit conversion to make a call succeed and creates a
`temporary` Sales_data object. So this equates to:

item.combine(Sales_data(str));

<ex>
Since the second parameter has a default value, this can be used as a single
parameter ctor and, hence, as an implicit conversion. make it explicit.

Complex (double real, double imaginary = 0)
  : real_(real), imaginary_(imaginary)
{}


<only-one-conversion-allowed>
The compiler will do only 'one' implicit conversion and the following is error.

item.combine("9-999-99999-9");

Since this requires two conversion to make it succeed.

item.combine(string("9-999-99999-9"));
item.combine(Sales_data("9-999-99999-9"));


{cpp-explicit-keyword}
Whether the conversion is desiable depends on "how users wil use the
conversion." More problematic is the conversion from istream to Sales_data.
When combine() finishes, temporary is gone and lost input. 

item.combine(cin);

To avoid this, can use explicit-keyword:

class Sales_data {

  `explicit` Sales_data(const std::string &s): bookNo(s) {};
  `explicit` Sales_data(std::istream &s);
  combine(const Sales_data&);

};

Have to use explicit ctor 'explicitly':

item.combine(null_book);                      // error
item.combine(cin);                            // error

item.combine(Sales_data(null_book));          // T(x)
item.combine(static_cast<Sales_data>(cin));


{implicit-conversion-problems}
Avoid implicit conversion. From MEC++05. Recommend to use a member func to do
the same.

<ex>
template< typename T>
class Array {
  public:
    Array(int lowBound, int highBound);
    Array(int size);
    ...
};

bool operator==(const Array<int> &lhs, const Array<int> &rhs);

Array<int> a(10); Array<int> b(10);

for( int i=0; i < 10; ++i )
  if( a == b[i] ) {                 // meant to be a[i] == b[i]
    ...
  }
  else {
    ...
  }

There is no match candidate, operator==( Array<int>, int ), and compiler do
convert the second arg to Array because there is converting-ctor. This is the
same as:

if( a == static_cast< Array<int>> (b[i]) )

This causes a creation and deletion of unknowm number of Array objects for
each iteration. How to prevent this?

  *cpp-remember*
  `The implicit conversion is not always useful since temporary is made.` More
  expensive, lost state(input), or making changes on temporary. So the point
  is about making it explicit in code and
  `forcing-user-to-know-what-they-are-doing`.


// Q: CPR 297
// the string ctor that takes a single parameter of type const char * is not
// explicit.
//
// <ex>
// EXPC++39. The std-string has no implicit conversion to a const char*. Should it?
// If it had that conversion, this code would compile cleanly because the compiler
// would silently convert both strings to const char* and then substract those
// pointers.
//
// string s1, s2, s3;
// s1 = s2 - s3;           // oops, probably meant "+"


<ex-of-explicit>
The vector<T> v(number) is explicit so the following is in error.

explicit container::container (size_type num)
- Creates a container with num elements.
- The elements are created by their default constructor.
- Provided by vector, deque, list, forward list.

// x.member(vector<string>& vec);
x.member(10);  // error


<cpp-copy-init>
`copy-init` only uses `converting-ctor` which uses `implicit-conversion` to make a
call succeed but not `copy-ctor`. So if use `explicit` converting-ctor then
cannot use `copy-init` and must use `direct-init`

*cpp-remember* prefer direct-init to copy-init.


explicit Sales_data(const std::string &s): bookNo(s) {};

Sales_data item(null_book);     // okay, `direct-init`
Sales_data item = null_book;    // error, `copy-init`

note:
* The explicit-keyword supress conversion or use of constructor in a context
  that requires an implicit conversion.

  *why-direct-init* CPR 296
* The explicit ctor can be used `only with direct-init`
  
  Because direct-init explicitly say to initialize so that's why it is okay
  for use explicit ctor
    
* The explicit-keyword is meaningful 'only' on constructors that can be called
  with a `single-arguments` since constructors with more arguments are not
  used to perform an implicit conversion.
  
  note:
  EXPC++42. Prefer using `direct-form-init` to `copy-form-init` since works
  wherever the latter works and can take multiple parameters.

* The explicit-keyword is used only in constructor declaration inside a
  class.

* The `copy-ctor` cannot be 'explicit' since used implicitly in cases as pass by
  value. 

<ex>

class Base {
  public:
    explicit Base(const string &s) : mesg(s) {}
    // Base(const string &s) : mesg(s) {}

    void message( const Base & b ) 
    { 
      cout << "base: " << b.mesg << endl;
      cout << "base: " << mesg << endl; 
    }

  private:
    string mesg;
};

int main()
{
  std::cout << "--{ main " << std::endl;

  Base ba(string("iam base"));
  Base baa = string("iam base two");            // 1

  ba.message(string("this is mesg for base"));  // 2

  std::cout << "--} main " << std::endl;
}

When use `explicit-keyword`, two errors:

: error: conversion from ‘std::string {aka std::basic_string<char>}’ to
non-scalar type ‘Base’ requested

: error: no matching function for call to ‘Base::message(std::string)’
: note: candidate is:
: note: void Base::message(const Base&)
: note:   no known conversion for argument 1 from ‘std::string {aka
  std::basic_string<char>}’ to ‘const Base&’

  *cpp-remember*
  After all, explicit-keyword surpress implicit-converson and side-effect is
  that cannot use copy-init.


{cpp-converting-op}
The conversion-op is a conversion from class type `to other type.` Have no
explicitly stated return type and no parameters. Must be member.

operator T() const;     where T represents `type`

class SamallInt {
  public:
    operator int() const { return val;}

  private:
    std::size_t val;
};

SmallInt si;

si = 4;   // implicitly converts 4 to SmallInt then calls operator=
si + 3;   // implicitly converts si to int then do integer addition


note:
Although the compiler will apply only one user-defined conversion at a time,
         implicit user-defined conversion can be preceded or followed by a
         standard(built-in) conversion.

// the `double` converted to `int` and calls SmallInt(int) ctor.

SmallInt si = 3.14;

<use-exlicit>
To avoid following problem, use explicit keyword:

class SamallInt {
  public:
    'explicit' operator int() const { return val;}
};

int i = 42;
cin << 42;

There is no operator<< in cin but could use conversion-to-bool to convert `cin`
to bool. So 0 or 1 depending on the cin state, promote to int and used as the
lhs to the left shift operator.

0 or 1 << 42;


={============================================================================
*kt_dev_cpp_010* cpp-temp-object

EXC++06, 07

string FindAddr( list<Employee> emps, string name )
{
  for( list<Employee>::iterator i = emps.begin();
      i != emps.end();
      i++ )
  {
    // *cpp-type-conversion*
    if( *i == name )
    {
      return i->addr;
    }
  }
  return "";
}

string FindAddr( const list<Employee> &emps, const string &name )
{
  list<Employee>::const_iterator end( emps.end() );
  for( list<Employee>::const_iterator i = emps.begin();
      i != end;
      ++i )
  {
    if( i->name == name )
    {
      return i->addr;
    }
  }
  return "";
}

// have to provide operator==(const Employee&, const string &)
string FindAddr( const list<Employee> &emps, const string &name )
{
  list<Employee>::const_iterator i(
      find( emps.begin(), emps.end(), name));

  if( i != emps.end() )
  {
    return i->addr;
  }
  return "";
}



{temp-object} MEC++19 *cpp-type-conversion*
The temp-object is used in implicit type conversion, nonconst-to-const, func
call, casting and return. Can have an impact on the performance in
construction and destruction.

<ex> <temp-object-in-return>
Return the plural version of the word if the counter is greater than 1.

string make_plural( size_t ctr, const string& word, const string& ending)
{
  return (ctr>1) ? word + ending : word;
}

The word is copied to the call(ing) site or unnamed string temp-object is
copied to the call site for 'word + ending' case.

<ex>
Here explicitly constructed return pair 'temporary'. 'pair<string, int>' is T.
That is T() and so is default constructed and value-init.

See {return-reference-vs-copy} for interesting case. So whether or not there
is a temp object created in called site, there is a copy to call site when a
func is defined to return a copy.

pair<string, int> process( vector< string > v )
{
  if( !v.empty())
   return {v.back(), v.back().size() };
   // or return pair<string, int>( v.back(), v.back().size() );
  else
    return pair<string, int>();
}

<ex>
const char* PersonInfo::theName() const;

virtual std::string name() const
{ return PersonInfo::theName(); }


<temp-object-in-converison> cost-of-temp-object

<ex> *cpp-type-conversion*
size_t countChar( const string& str, char ch );    // see const here

char buffer[MAX_STRING_LEN];

countChar( buffer, c ); // string str = string temp-object(buffer);

When it is called, there is a type mismatch so string temp object will be
created, buffer is copied, and 'binding' to argument happens. Destruction
happens when return. If buffer size is big, then it is costly. It is for
compiler to make a func call succeed.

if remove const from the above:

size_t countChar( string& str, char ch );    // see no const here

Then gets *cpp-const-to-nonconst-error*

: error: invalid initialisation of non-const reference of type ‘std::string&
{aka std::basic_string<char>&}’ from an rvalue of type ‘char*’

since basic_string(const char*) is not explicit and cause implicit conversion
which creats temp-object. temp-object is const and rvalue and
const-to-nonconst is not allowed.


<temp-object-is-const>
WHY? In any case, compiler will create temporary due to type mismatch and if
temporary was not const (means mutable or can change this) then make a changes
to temporary. Not expected result.

reference-to-const parameters don't suffer from this problem, because such
parameters, by virtue of being const, can't be changed.

How to eliminate this?

1. No implicit conversion
make *cpp-converting-ctor* explit or do not provide them. 

2. MEC++21


<in-casting> from ansic, p45.
The cast produces the 'value' of n in the proper type; n itself is not altered. 

squrt( (double)n );

item.combine( static_cast<Sales_data>(str) );


={============================================================================
*kt_dev_cpp_010* cpp-return cpp-rvo

https://shaharmike.com/cpp/rvo/

#include <iostream>
#include <memory>
#include <vector>

// g++ -g -std=c++11 -fno-elide-constructors t_evo.cpp

using namespace std;

/////////////////////////////////////////////////////////////////////////
struct Snitch {   // Note: All methods have side effects
  Snitch() { cout << "c'tor" << endl; }
  ~Snitch() { cout << "d'tor" << endl; }

  Snitch(const Snitch&) { cout << "copy c'tor" << endl; }
  Snitch(Snitch&&) { cout << "move c'tor" << endl; }

  Snitch& operator=(const Snitch&) {
    cout << "copy assignment" << endl;
    return *this;
  }

  Snitch& operator=(Snitch&&) {
    cout << "move assignment" << endl;
    return *this;
  }
};

Snitch ExampleRVO() {
  return Snitch();
}

void t_evo_1()
{
  Snitch snitch = ExampleRVO();
} 

/////////////////////////////////////////////////////////////////////////
vector<int> ReturnVector() {
  return vector<int>(1, 1);
}

void t_evo_2() {
  for (int i = 0; i < 1000000000; ++i) {
    ReturnVector();
  }
}


/////////////////////////////////////////////////////////////////////////
Snitch CreateSnitch(bool runtime_condition) {
  Snitch a, b;
  if (runtime_condition) {
    return a;
  } else {
    return b;
  }
}

void t_evo_3() {
  Snitch snitch = CreateSnitch(true);
}

int main()
{
    t_evo_1();
    // t_evo_2();
    t_evo_3();
    cout << "end of main" << endl;
}


Return Value Optimization (RVO), Named RVO (NRVO) and Copy-Elision are in C++
since C++98. In this post I will explain what these concepts mean and how they
help improve runtime performance.


Return Value Optimization

RVO basically means the compiler is allowed to avoid creating temporary
objects for return values, even if they have side effects.

Here’s a simple example:

Snitch ExampleRVO() {
  return Snitch();
}

int main() {
  Snitch snitch = ExampleRVO();
}


$ clang++ -std=c++11 main.cpp && ./a.out
c'tor
d'tor

// same as gcc
$ clang++ -std=c++11 -fno-elide-constructors main.cpp && ./a.out
c'tor
move c'tor
d'tor
move c'tor
d'tor
d'tor

In the first run (without -fno-elide-constructors) the compiler refrained from
calling user code despite it having a clear side effect (being printing to
    console). 


<rvo-is-default>
This is also the default behavior, meaning practically all C++ programs
utilize RVO.


// https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html#index-fno-elide-constructors
// 
// 3.5 Options Controlling C++ Dialect
// 
// -fno-elide-constructors
//
// The C++ standard allows an implementation to omit creating a temporary that
// is only used to initialize another object of the same type. Specifying this
// option disables that optimization, and forces G++ to call the copy
// constructor in all cases. This option also causes G++ to call trivial
// member functions which otherwise would be expanded inline.
// 
// In C++17, the compiler is required to omit these temporaries, but this
// option still affects trivial member functions.


Without RVO the compiler creates 3 Snitch objects instead of 1:

* A temporary object inside ExampleRVO() (when printing c'tor);

* A temporary object for the returned object inside main() (when printing the
  first move c'tor);

* The named object snitch (when printing the second move c'tor).


Performance

The neat thing about RVO is that it makes returning objects free. It works via
allocating memory for the to-be-returned object in the caller’s stack frame.
The returning function then uses that memory as if it was in its own frame
without the programmer knowing / caring.

In C++98 days this was significant:

#include <vector>
using namespace std;

vector<int> ReturnVector() {
  return vector<int>(1, 1);
}

int main() {
  for (int i = 0; i < 1000000000; ++i) {
    ReturnVector();
  }
}


$ clang++ -fno-elide-constructors -std=c++98 -stdlib=libc++ -O3 main.cpp && time ./a.out
real	0m37.235s
user	0m37.168s
sys	0m0.024s

$ clang++ -std=c++98 -stdlib=libc++ -O3 main.cpp && time ./a.out
real	0m17.681s
user	0m17.668s
sys	0m0.000s
217% difference on my machine by simply avoiding the copy of the vector. In C++11 (or newer) environments it is even marginally faster to disable RVO:

$ clang++ -fno-elide-constructors -std=c++11 -stdlib=libc++ -O3 main.cpp && time ./a.out
real	0m18.195s
user	0m18.188s
sys	0m0.000s

$ clang++ -std=c++11 -stdlib=libc++ -O3 main.cpp && time ./a.out
real	0m18.356s
user	0m18.340s
sys	0m0.000s

This is due to Move Semantics, which is the subject of the next post.

<ex>
kyoupark@kit-debian64:~/works$ uname -a
Linux kit-debian64 3.16.0-4-amd64 #1 SMP Debian 3.16.36-1+deb8u1 (2016-09-03) x86_64 GNU/Linux
kyoupark@kit-debian64:~/works$ gcc --version
gcc (Debian 4.9.2-10) 4.9.2

kyoupark@kit-debian64:~/works$ time ./on-evo.out
c'tor
d'tor
end of main

real    2m46.195s
user    2m42.556s
sys     0m0.292s

kyoupark@kit-debian64:~/works$ time ./no-evo.out
c'tor
move c'tor
d'tor
move c'tor
d'tor
d'tor
end of main

real    4m27.133s
user    4m24.960s
sys     0m0.368s


In trying to come up with an example where RVO is faster on modern C++ using
STL containers I hit a wall, mostly because of move-semantics but also because
on x86_84 RVO is in the ABI so disabling it is harder. Please post such
examples if you have any!


Named Return Value Optimization (NRVO)

Named RVO is when an object with a name is returned but is nevertheless not
copied. A simple example is:

Snitch ExampleNRVO() {
  Snitch snitch;
  return snitch;
}

int main() {
  ExampleNRVO();
}

Which has a similar output to ExampleRVO() above:

$ clang++ -std=c++11 main.cpp && ./a.out
c'tor
d'tor

While RVO is almost always going to happen, NRVO is more restricted, as we
will see below. I personally don’t think NRVO deserves its own acronym.


Copy Elision

RVO is part of a larger group of optimizations called copy-elision. Essentials
are the same, except copy-elision is not required to happen as part of return
statements, for example:

void foo(Snitch s) {
}

int main() {
  foo(Snitch());
}

c'tor
d'tor

In my experience, RVO is more frequent (and thus useful) than other
copy-elision practices, but your mileage may vary.


<when-rvo-do-not-on>
When RVO doesn’t / can’t happen

RVO is an optimization the compiler is allowed to apply (starting C++17 it is
    in fact required to in certain cases). However, even in C++17 it is not
always guaranteed. Let’s look at a few examples.

The following examples are cases where, on my environment, RVO doesn’t happen.
Some of them may change with other compiler / versions.


Deciding on Instance at Runtime

When the compiler can’t know from within the function which instance will be
returned it must disable RVO:

Snitch CreateSnitch(bool runtime_condition) {
  Snitch a, b;
  if (runtime_condition) {
    return a;
  } else {
    return b;
  }
}

int main() {
  Snitch snitch = CreateSnitch(true);
}

$ clang++ -std=c++11 -stdlib=libc++ main.cpp && ./a.out
c'tor
c'tor
move c'tor
d'tor
d'tor
d'tor


Returning a Parameter / Global

When returning an object that is not created in the scope of the function
there is no way to do RVO:

Snitch global_snitch;

Snitch ReturnParameter(Snitch snitch) {
  return snitch;
}

Snitch ReturnGlobal() {
  return global_snitch;
}

int main() {
  Snitch snitch = ReturnParameter(global_snitch);
  Snitch snitch2 = ReturnGlobal();
}

$ clang++ -std=c++11 -stdlib=libc++ main.cpp && ./a.out
c'tor
copy c'tor
move c'tor
d'tor
copy c'tor
d'tor
d'tor
d'tor


Returning by std::move()

Returning by calling std::move() on the return value is an anti-pattern. It is
wrong most of the times. It will indeed attempt to force move-constructor, but
in doing so it will disable RVO. It is also redundant, as move will happen if
it can even without explicitly calling std::move() (see here).

Snitch CreateSnitch() {
  Snitch snitch;
  return std::move(snitch);
}

int main() {
  Snitch snitch = CreateSnitch();
}
Output:

$ clang++ -std=c++11 -stdlib=libc++ main.cpp && ./a.out
c'tor
move c'tor
d'tor
d'tor


Assignment

RVO can only happen when an object is created from a returned value. Using
operator= on an existing object rather than copy/move constructor might be
mistakenly thought of as RVO, but it isn’t:

Snitch CreateSnitch() {
  return Snitch();
}

int main() {
  Snitch s = CreateSnitch();
  s = CreateSnitch();
}

$ clang++ -std=c++11 -stdlib=libc++ main.cpp && ./a.out
c'tor
c'tor
move assignment
d'tor
d'tor


Returning Member

In some cases even an unnamed variable can’t RVO:

struct Wrapper {
  Snitch snitch;
};

Snitch foo() {
  return Wrapper().snitch;
}

int main() {
  Snitch s = foo();
}

$ clang++ -std=c++11 -stdlib=libc++ main.cpp && ./a.out
c'tor
move c'tor
d'tor
d'tor


Conclusion

While we can’t count on RVO to always take place, it will in most cases. For
`those cases where it doesn’t we always have Move Semantics,` which is the
topic of the next post. As always, optimize for readability rather than
performance when writing code, unless you have a quantifiable reason.


TODO: *C++17*
https://jonasdevlieghere.com/guaranteed-copy-elision/


={============================================================================
*kt_dev_cpp_009* cpp-return cpp-undefined

<no-return-when-expected>

#include <iostream>
#include <string>

using namespace std;

bool str_subrange( const string& str1, const string& str2 )
{
  if( str1.size() == str2.size() )
    return str1 == str2;

  auto small_size = ( str1.size() < str2.size() ) ? str1.size() : str2.size();

  for( decltype(small_size) i = 0; i != small_size; ++i )
    if( str1[i] != str2[i] )
      ;                          // NO ERROR in this case
      return;                    // ERROR-01
                                 // ERROR-02
}

int main()
{
  string str1 = "KYOUNG";
  //string str2 = "YOU";
  string str2 = "KYO";

  bool ret = false;

  ret = str_subrange(str1, str2);
  if( ret )
    cout << "return true" << endl;
  else
    cout << "return false" << endl;

  return 0;
}

<ERROR-01>
VC and GCC picks up this error. This is GCC case:

.cpp: In function bool str_subrange(const std::string&, const std::string&)
.cpp:16: error: return-statement with no value, in function returning bool

<ERROR-02> *cpp-undefined*
CPR 6.3.2 says that some picks up this error and some do not. Both VC adn GCC
do not picks up this error.

Also says that its result at runtime is 'undefined'. When running for VC and
GCC showed different result: VC returns true and GCC do false. Hence
'undefined'. 


<ex>
Have spent a day to find out why a program crashes. Two lessons:

  * It is better to have a core dump rather then narrowing down where a crash
    happens. Since looked like there are other places to be suspicious while
    doing gdb session until reachs to the real cause such as constructors, map
    insertions, and so on.

  * From the *C89* standard as quoted in the new testament: Flowing off the
    end of a function is equivalent to a return with no expression. In either
    case, the return value is undefined.

This is a debug trace routines and defines enums, strings for enums. It is
easy to make a mismatch between enum and strings when add more enums. So
better to have strings from enums using macro stringfication. However, in that
case, enum should be sequential.

typedef enum MHEGComponent_
{
    eMHEGNull       = 0x00000001,
    eMHEGeng        = 0x00000002,
    eMHEGengRuntime = 0x00000004,
    ...
} MHEGComponent;

const char* s_names[] =
{
    "Null",
    "MHEGEng",
    "MHEGEngRun",
    ...
};

const uint32_t getIndex(MHEGComponent comp)
{
  switch (comp)
  {
    case 0x00000001: return 0; break;
    case 0x00000002: return 1; break;
    case 0x00000004: return 2; break;
    case 0x00000008: return 3; break;
    case 0x00000010: return 4; break;
    ...
    case 0x00000040: return 6; break;
    case 0x00000080: return 7; break;
    case 0x00000100: return 8; break;
    case 0x00000200: return 9; break;
    case 0x00000400: return 10; break;
  }
}

This didn't have default case and when there is a enum which don't have a
matching case, no return statement but this function returns int. Which value
will you get? Quick test shows undefined return value.

case: 3000
val: 134520896


<when-return-local>
const string& foo()
{
  string ret;

  if
    return ret;
  else
    return "Empty";
}

Both return cause undefined result at the call site(caller) because it returns
reference to local to function foo().


={============================================================================
*kt_dev_cpp_005* type-conversion-to-bool

{cpp-type-bool}
Do not have a minimum size. In VC, is the same as `int` type. 

<gcc-case> on ubuntu linux
#include <iostream>
#include <bitset>

using std::cout;
using std::endl;

int main () {

  bool* parr = new bool(20);

  cout << "size: " << sizeof(parr) << endl;
  cout << "size: " << sizeof(*parr) << endl;
  cout << "valu: " << *parr << endl;

  return 0;
}

size: 4
size: 1
valu: 1


{nonbool-to-bool}
When assign non-bool to bool type, `type-conversion` happens and got 0 or 1
depending on the value of nonbool. That is false for 0 and 'true' for 'any'
other values other than 0.

bool b = 42;    // b is true


{true-and-false} {bool-to-nonbool}
The 'true' and 'false' are literals-of-type-bool. true is any `nonzero` but not
only 1. 

if( val == true ) { ... }

If val is nonbool type, conversion to <non-bool> which is bigger type happens
and this becomes 

if( val == 1 ) { ... }

This may not be what intented if meant for cases of nonzero because it runs only
when val is 1. Therefore, want the case of when val is 1 then do it directly.

The direct form is:

if(val) or if(!val) 

It is usually bad idea to use the boolean literals true and false as operands in
a comparison. These literals should be used 'only' to compare to an object of
type 'bool'.

<case>
In the mips gcc++, have bool variables but shows value in some cores rather then
ture/false literals. So true is `nonzero`

bool errorState;
bool stopped;

errorState = false, stopped = true
errorState = 103, stopped = 101
errorState = 101, stopped = 110

http://stackoverflow.com/questions/4276207/is-c-c-bool-type-always-guaranteed-to-be-0-or-1-when-typecasted-to-int
In C++ (§4.5/4):
    An rvalue of type bool can be converted to an rvalue of type int, with false
    becoming zero and true becoming one.

In C, when a value is converted to _Bool, it becomes 0 or 1 (§6.3.1.2/1):
    When any scalar value is converted to _Bool, the result is 0 if the value
    compares equal to 0; otherwise, the result is 1.


{not-use-in-computation}
Do not use bool and char for computation since there is conversion. For example:

bool b1 = true;
bool b2 = -b1;

b2 is true since b1 promoted to 1, negates to -1, and convert back to bool but
it is nonzero hence true. <Q> why promoted? due to negate operator?


{bool-conversion} equal-misspell

<1>
The fact that we can use assignment in a condition can have surprising effects:

if (i = j)

<true-nonzero>
The condition like this which assigns the value of j to i and then tests the
result of the assignment. If j is nonzero, the condition will be true in
conditons. 'true' means `nonzero` (all other value than zero). 

The author of this code almost surely intended to test whether i and j have the
same value:

if (i == j)

Bugs of this sort are notoriously difficult to find.


<2> 
auto loc = wordmap.find( sought );

if( loc = wordmap.end() )  // meant if( loc == wordmap.end() )

GCC error is:

tquery.cpp:63: error: could not convert '(loc <unknown operator> ((const
        std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char,
        std::char_traits<char>, std::allocator<char> >,
        std::shared_ptr<std::set<long unsigned int, std::less<long unsigned
        int>, std::allocator<long unsigned int> > > > >&)((const
            std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char,
            std::char_traits<char>, std::allocator<char> >,
            std::shared_ptr<std::set<long unsigned int, std::less<long unsigned
            int>, std::allocator<long unsigned int> > > > >*)(&((const
                  TextQuery*)this)->TextQuery::wordmap.std::map<_Key, _Tp,
              _Compare, _Alloc>::end [with _Key = std::basic_string<char,
              std::char_traits<char>, std::allocator<char> >, _Tp =
              std::shared_ptr<std::set<long unsigned int, std::less<long
              unsigned int>, std::allocator<long unsigned int> > >, _Compare =
              std::less<std::basic_string<char, std::char_traits<char>,
              std::allocator<char> > >, _Alloc = std::allocator<std::pair<const
              std::basic_string<char, std::char_traits<char>,
              std::allocator<char> >, std::shared_ptr<std::set<long unsigned
              int, std::less<long unsigned int>, std::allocator<long unsigned
              int> > > > >]()))))' 
to 'bool'

This happens when tries to covert loc iterator to bool. If it were ==, then
operator== would return bool type.

<3>
Meant to be == and this if is always true.

bool QueueFull(Queue* queue)
{
   if( queue->count = MAXSIZE )
   {
      std::cout << "full(" << queue->count << ")" << std::endl;
      return true;
   }

   return false;
}


{conversion-to-bool}
The classes 'rarely' provide conversion operator but one important exception is
convertion to bool.

In earlier version of the library, the IO types defined a `conversion-to-void`
to avoid the kind of problems above. Under the new standard, instead defines an
`explicit-conversiton-to-bool`.

However, even if uses explicit, this explicit has no effect when use stream in
condition such as:

if, while, for and do statements. logical operators. conditional operators.
 
Why? `conversion-to-bool` is 'intended' for use in conditions and hence ordinarily
  should be defined as explicit to avoid problems in other uses:

while(std::cin >> value)

Reads input into value, 'return' cin, and  cin converted to bool depending on
cin state. This bool conversion is the typical use of conversion-op.

note: 
Like cin, seems useful to have bool conversion when class has 'state'.


={============================================================================
*kt_dev_cpp_005* cpp-conversion-to-bool-stream

Two stream functions are defined for the use of streams in Boolean expressions

operator bool ()
Returns whether the stream has not run into an error (corresponds to !fail())

operator ! ()
Returns whether the stream has run into an error (corresponds to fail())

note: 
Before C++11, the `operator-bool()` was declared as `operator-void*()`, which
could cause problems such as those described in Section 15.10.1, page 805.

note: fail() is stream member function:
Returns true if an error has occurred (failbit or badbit is set)


<conversion-to-bool>
The conversion to bool is often used to read objects and test for success in
the same expression. Because cin is being used in the context of a condition,
operator void* is called, which returns whether the stream has run into an
  error.

A typical application of this technique is a loop that reads and processes
objects:

// as long as obj can be read
while (std::cin >> obj) {
  // process obj (in this case, simply output it)
  std::cout << obj << std::endl;
}

This is C's classic filter framework for C++ objects. The loop is terminated
if the failbit or badbit is set.

With operator !, the inverse test can be performed. The operator is defined to
return whether a stream has run into an error; that is, the operator returns
true if failbit or badbit is set. 

Like the implicit conversion to a Boolean value, this operator is often used
to test for success in the same expression in which an object was read:

if (! (std::cin >> x)) {
  // the read failed
  ...
}


<ex>
Use implicit conversion operator which is traditional. This is the way
iostream uses so it is possible:

ifstream inputFile("datafile.dat");
if(ifstream) ...

template< class T>
class SmartPtr {
  public:
    operator void*(); // return 0 if smart pointer is null, nonzero otherwise.
    ...
};

This approach has a problem since it allows following: 

SmartPtr<Apple> pa; SmartPtr<Orange> po;

if( pa == po ) ...

This compiles even if there is no operator== taking a SmartPtr<Apple> and a
SmartPtr<Orange>:

Since both smart pointers can be implicitly converted into void* pointers, and
there is a built-in comparison function for built-in pointers.

So the below fails although they points to the same.

SmartPtr<Apple> pa; SmartPtr<Orange> po;

pa = po;

if( pa == po ) ...


<ex>
Before C++11, a typical programming error when dealing with stringstreams was
to forget to extract the string with the function str() and to write to the
stream directly instead. This was, from a compiler's point of view, a possible
and reasonable thing to do because there was an implicit conversion to void*. 

ostringstream os;
cout << os.str() << endl;       // right

As a result, the issue is that instead of its value the state of the stream
was written in the form of an address. 

Section 15.3.3, page 756

Type void*

Operators << and >> also provide the possibility of printing a pointer and
reading it back in again. An address is printed in an implementation-dependent
format if a parameter of type void* is passed to the output operator. For
example, the following statement prints the contents of a C-string and its
address:

char* cstring = "hello";

std::cout << "string \"" << cstring << "\" is located at address: "
<< static_cast<void*>(cstring) << std::endl;

The result of this statement might appear as follows:

string "hello" is located at address: 0x10000018

It is even possible to read an address again with the input operator. However,
   note that addresses are normally transient. The same object can get a
   different address in a newly started program. A possible application of
   printing and reading addresses may be programs that exchange addresses for
   object identification or programs that share memory.

*cpp-remember*
With C++11, this conversion was replaced by an explicit conversion to bool, so
passing a stringstream to the output operator << 'without' calling str() is no
longer possible.


<case>
The issue is tht the code below starts to fail to build suddenly when upgrages
gcc.

: error: cannot convert ‘std::istream {aka std::basic_istream<char>}’ to ‘bool’
in initialization"

This is because operator bool() is defined 'explicit'. This issue was shadowed
by the fact that gcc-4.9 (and below) still had operator void*() const.

stringstream s;

// operator>> returns stream. Although bool do not have converting ctor,
// stream is implicitly converted to bool since copy-init is used. This means
// copy-init not only mean converting ctor but also any conversion to make it
// succeed.

-    bool read_ok = s >> st;
-    ASSERT_THAT(read_ok, Eq(true));
-
+    s >> st;
+    ASSERT_THAT(s.good(), Eq(true));


<problem>
This member function prints "1" then the address. What happended?

class printer {

  void wtf()
  {
    std::cout << "what: " << &printer::print << std::endl;
  }
};


*code-ios*

// bits/basic_ios.h

  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
  {
    public:
      //@{
      /**
       *  @brief  The quick-and-easy status check.
       *
       *  This allows you to write constructs such as
       *  "if (!a_stream) ..." and "while (a_stream) ..."
      */
      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }
  }

// iosfwd
// ostream

  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
  {
  }

  /// Base class for @c char output streams.
  typedef basic_ostream<char> 		ostream;


// bits/shared_ptr_base.h

  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
    {
      ...

      explicit operator bool() const // never throws
      { return _M_ptr == 0 ? false : true; }
    }


={============================================================================
*kt_dev_cpp_008* cpp-const 

<must-be-initialized>
Because we can't change the value of a const object after we create it, `must`
be initialized.


<constant-expression>
A constant expression is an expression that involves only constants:

#define MAXLINE 100
char line[MAXLINE+1];


{const-file-scope} *cpp-static* *cpp-internal-linkage* CPR p60

o. constant expression

const int bufSize = 512;

The compiler will repace uses of the variable with its corresponding value
during compilation. That is, the compiler will generate code using the value
512 in the places that our code uses bufSize. To do this, the compiler has to
see the initializer. 

When split a program into multiple files, every file must have access to its
initializer. In order to see initializer, the variable must be defined in
every file. 

To support this, `yet avoid multiple definitions` of the same variable, const
variable are defined as local to file. When define a const with the same name
in multiple files, it is `as if` had written definitions for separate
variables in each file. 

// this is main.c
//
// $ g++ -g -std=c++0x -c a.c
// $ g++ -g -std=c++0x -c b.c
// $ g++ -g -std=c++0x a.o b.o main.c
//
#include <cstdio>
#include "def.h"

int main()
{
    printf("this is main\n");
    printf("this is main: the const is %d\n", ci_max_value );

    print_const_from_a();
    print_const_from_a();

    return 0;
}

// this is a.c
//
#include <cstdio>
#include "def.h"

void print_const_from_a()
{
    printf("this is a.c and the const is %d\n", ci_max_value );
}

// this is b.c
//
#include <cstdio>
#include "def.h"

void print_const_from_b()
{
    printf("this is b.c and the const is %d\n", ci_max_value );
}

// this is def.h
//
const int ci_max_value = 500;

extern void print_const_from_a();
extern void print_const_from_b();

// output
//
$ nm a.o
0000000000000000 T _Z18print_const_from_av
0000000000000024 r _ZL12ci_max_value

$ nm b.o
0000000000000000 T _Z18print_const_from_bv
0000000000000024 r _ZL12ci_max_value

$ nm a.out
...
000000000040071c r _ZL12ci_max_value
0000000000400744 r _ZL12ci_max_value
0000000000400778 r _ZL12ci_max_value

The nm result is the same when defines ci_max_value in each c file and even
when uses different initializers.

Again as said, although use `the same name`, 
  "it is `as if` had written definitions for separate variables in each file."
  by `generating` a separate variable in each file.


2. for not a constant expression

When initialzer is not a constant expression, not generate a separate variable
in each file and want const object behave like other variable. Must use
`extern` on 'both' definition and declaration.

// file one
extern const int bufSize = fcn();

// file two
extern const int bufSize;


3. extern works for constant expression as well.

$ nm a.o
                 U ci_max_value
$ nm b.o
                 U ci_max_value
$ nm a.out
0000000000400758 R ci_max_value


<ex>
Suppose that a header has const definition like below and is included in
multiple files. Is it a problem?

const char *const MESSAGE_TYPE_URL_LIST = "text/uri-list";

Interesting, I was using gcc. It seems this is legal in C++ but not in C. Causes
link error, duplicated.

The reason:

the C++ Standard, Annex C
3.5 [also 7.1.6]
Change: A name of file scope that is explicitly declared const, and not
explicitly declared extern, has `internal-linkage`, while in C it would have
`external-linkage`

Rationale: Because const objects can be used as compile-time values in C++, this
feature urges programmers to provide explicit initializer values for each const.
This feature allows the user to put constobjects in header files that are
included in many compilation units.


4. tried 1 with gcc

$ nm a.o
0000000000000000 R ci_max_value
$ nm b.o
0000000000000000 R ci_max_value

$ gcc -g a.o b.o main.c
b.o:(.rodata+0x0): multiple definition of `ci_max_value'
a.o:(.rodata+0x0): first defined here
/tmp/ccfme3ln.o:(.rodata+0x0): multiple definition of `ci_max_value'
a.o:/home/kyoupark/works/t_const/a.c:11: first defined here
collect2: error: ld returned 1 exit status


All in all, 1 is C++ feature which makes const file-scope.


{top-and-low-level-const} *cpp-base-type*
This is only for pointer which has 'indirect' access so makes two level in
terms of constness. This matters when copy an object.

  const int *const <variable-name>
  <-- 1 --> <- 2 ->

  const int * <variable-name>            // pointer to const
  const int *const <variable-name>       // const pointer to const
  int const *const <variable-name>       // const pointer to const
  const int & <variable-name>            // reference to const

1. `base-type` part which is for underlying object and for low-level. That is a
object that point or reference to.

2. `declarator-type` part which is for compound type, reference or pointer, and
for top-level. That is pointer or reference itself.

Do not think about top low-level. The point is that low-level, underlying
object, 'never' be ignored but top-level can be since it's not about
underlying object. The main thing is if it's break constness of underlying
object.

In other words, top-level restrics only what we can do 'through' that reference
or pointer and says nothing about whether the underlying object itself. 

<ex>
this is a reference of pointer:

Binary_node<Record> *&sub_root; 


Unlike pointer, there is only `reference-to-const` since reference is not object. 

int &ri = i;
const int &r2 = i;

r1 = 0;
r2 = 0;              // error since r2 is reference-to-const


{no-const-to-nonconst-conversion}
This is an error because `no-const-to-nonconst` conversion is allowed.

int main()
{
  const int ci = 100;

  // ERROR: invalid initialisation of reference of type ‘int&’ from expression
  // of type ‘const int’

  int &ri = ci;
  // int &ri = (int&) ci;     // no error since uses cast

  int ival = 100;

  const int *pci = &ival;
  cout << "ival: " << ival << ", " << *pci << endl;

  // ERROR: invalid conversion from 'const int*' to 'int*' [-fpermissive]
  int *pi = pci;
}


{const-return} equal-misspell
EC++03. When use `pass-by-value` for user type as a return, use const to raise
error when mistake happens:

const Rational operator*( const Rational& lhs, const Rational& rhs );

if( a * b = c )       // typo. was meant if( a*b == c )

If these are built-in type, this is flat-out error but don't for class type. 

* The returned `built-in` type is an `rvalue` and can't be modified. EXPC++43.
* Even if it were legal, the fact that it returns object by value would mean
  that a copy would be modified and that's not the behavior you want. 

So better to be prepared for this kind of mistakes. Also this is an example of
returning a copy than reference.


{const-on-base-type}
When use const with type alias, it can be surprising. For example,

typedef char *pstring;

const pstring cstr = 0;    // a "const pointer to char"
const pstring *ps;         // a "pointer to "const pointer to char*"

The important thing is that type alias `is not replacing string` but it a type
and const applies on `base-type`.

// wrong interpretation. base type is char and * is part of declarator. cstr is
// pointer to "const char" 
const char* cstr = 0;      

// base type is "pstring" so const is on pstring type is a const pointer to char
const pstring cstr = 0;    


{const-on-iterators}
The `iterator-begin` has overloads: const and nonconst version because if it has
only const version, *this is const and any data member is also const. 

note: see how it has overloads 'depending' on object called upon and how to use
const iterator.

/**
*  Returns a read/write iterator that points to the first
*  element in the %vector.  Iteration is done in ordinary
*  element order.
*/
iterator
begin() _GLIBCXX_NOEXCEPT
{ return iterator(this->_M_impl._M_start); }

/**
*  Returns a read-only (constant) iterator that points to the
*  first element in the %vector.  Iteration is done in ordinary
*  element order.
*/
const_iterator
begin() const _GLIBCXX_NOEXCEPT
{ return const_iterator(this->_M_impl._M_start); }

// like 'T* const' and iter itself is const
const std::vector<T>::iterator iter = vec.begin();

// like 'const T*' and *iter is const
std::vector<T>::const_iterator iter = vec.begin();


={============================================================================
*kt_dev_cpp_008* cpp-const-temporary

{use-reference-const-argument} {reference-to-const}
Use `reference-to-const` argument when possible since two implications over
plain reference param in func:
 
  * clerer interface. A func that don't change a reference param, mislead its
  * user to think it does change.
 
  * can be used both const-param and nonconst-param version. 
 
  * for better performance

The `const` only matters when user reference.
 
void fcn( const int i ); 
fcn(j);     // const int i = j; 
fcn(cj);    // const int i = cj;
 
void fcn( int i ); 
fcn(j);     // int i = j; 
fcn(cj);    // int i = cj; NO ERROR
 
 
<ex> 
const GstCaps *caps = gst_caps_from_string(); 
gst_caps_unref(GetCaps *caps);
 
:44: error: invalid conversion from 'const GstCaps*' to 'GstCaps*' :44: error:
initializing argument 1 of 'void gst_caps_unref(GstCaps*)'
 
<ex> *cpp-temporary* 
// ok, reference-to-const can match to literal, temporary

find_char(const string& s, char c); 
find_char("Hello", 'o');   

// ERROR,  literal is temporary
 
find_char(string& s, char c); 
find_char("Hello", 'o');   

<ex> *cpp-temporary*
void add_item(shared_ptr<Quote> &item);

sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));

t_quote_two.cpp:94:58: error: no matching function for call to ‘Basket::add_item(std::shared_ptr<Quote>)’
     sale.add_item(shared_ptr<Quote>(new Quote("123", 45)));
                                                          ^
t_quote_two.cpp:94:58: note: candidate is:
t_quote_two.cpp:72:6: note: void Basket::add_item(std::shared_ptr<Quote>&)
 void Basket::add_item(shared_ptr<Quote> &item)
      ^
t_quote_two.cpp:72:6: note:   no known conversion for argument 1 
  from ‘std::shared_ptr<Quote>’ to ‘std::shared_ptr<Quote>&’



{nonconst-to-const-conversion} type-match-exceptions. CPR p61
As long as maintain constness, allow conversion and so two exceptions to type
match rule. 

These exception are 'implicit' `non-const-to-const` and derived-to-base-reference
conversion. Can bind reference-to-const to non-const, a literal, a temp, or
other expression that evaluate to an type.

int i;
const int &j = i;       // type match exception. `non-const to const`
const int *p = &i;      // type match exception. non-const to const
int &r = j, *q = p;     // ERROR since `no const to nonconst`


<const-reference-to-literal>
compiler make a 'temporary' to allow conversion and maintain constness.

const int &ri = 42;     // ok since temporay from 42
int &ri = 10;           // ERROR

double dval = 3.14;     // ok, not a reference
int ival = dval;        // ok, truncation
const int &ri = dval;   // ok, will bind to temporary

int &ri = dval;         // ERROR
// error: invalid initialization of reference of type 
// ‘int&’ from expression of type ‘double’

The reference is alias for something exist and also need to maintain
constness. The compiler transforms this:

const int temp = dval;  // see const and tempoary is const object.
cont int &di = temp;

This also shows an example of creating a temporary through const conversion.

int main()
{
  int i{100};
  const int &ri = i;

  i = 200;

  std::cout << "i: " << i << std::endl;
  std::cout << "ri: " << ri << std::endl;

  double dval{3.14};
  const int &di = dval;

  dval = 6.28;

  std::cout << "d: " << dval << std::endl;
  std::cout << "rd: " << di << std::endl;
}

i: 200
ri: 200
d: 6.28
rd: 3                   // not changed, temporary


<const-reference-to-return> *cpp-return*
// std::string YVCloudAuth::getAuthToken() const;

try
{
  const std::string& token = cloudAuth->getAuthToken();
  Header.replace("<add-youview-token>", token.c_str());
}

You're taking a reference to a temporary object

That's allowed.

exactly, this const reference binds to this rvalue, extending it's lifetime for
the lifetime of the reference itself. But in practice it's like giving a temp an
alias. see below for a nice explanation


http://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/

GotW #88: A Candidate For the "Most Important const"

Q1: Is the following code legal C++?

    // Example 1

    string f() { return "abc"; }

    void g() {
      const string& s = f();
      cout << s << endl;    // can we still use the "temporary" object?
    }


A1: Yes.

This is a C++ feature. the code is valid and does exactly what it appears to do.

Normally, a temporary object lasts only until the end of the full expression in
which it appears. However, C++ deliberately specifies that binding a temporary
object to a reference to const on the stack 'lengthens' the lifetime of the
temporary to the 'lifetime' of the reference itself, and thus avoids what would
otherwise be a common dangling-reference error. In the example above, the
temporary returned by f() lives until the closing curly brace. (Note this only
    applies to stack-based references. It doesn't work for references that are
    members of objects.)


Q2: What if we take out the const. is Example 2 still legal C++?

    // Example 2

    string f() { return "abc"; }

    void g() {
      string& s = f();       // still legal?
      cout << s << endl;
    }

A2: No.

The "const" is important. The first line is an error and the code won't compile
portably with this reference to non-const, because f() returns a temporary
object (i.e., `rvalue`) and only lvalues can be bound to references to non-const.

Note: Visual C++ does allow Example 2 but emits a "nonstandard extension used"
warning by default. A conforming C++ compiler can always allow otherwise-illegal
C++ code to compile and give it some meaning — hey, it could choose to allow
inline COBOL if some kooky compiler writer was willing to implement that
extension, maybe after a few too many Tequilas. For some kinds of extensions the
C++ standard requires that the compiler at least emit some diagnostic to say
that the code isn’t valid ISO C++, as this compiler does.

Note: gcc 4.7.2 and see 'rvalue'.

<cpp-const-to-nonconst-error>
:19:21: error: invalid initialization of non-const reference of type 
  ‘std::string& {aka std::basic_string<char>&}’ 
  from an `rvalue` of type ‘std::string {aka std::basic_string<char>}’

note: TODO: virtual dispatch?

I once heard Andrei Alexandrescu give a talk on ScopeGuard (invented by Petru
    Marginean) where he used this C++ feature and called it "the most important
const I ever wrote." And this brings us to the Guru Question, which highlights
the additional subtlety that Andrei's code deftly leveraged.

Guru Question

Q3: When the reference goes out of scope, which destructor gets called?
A3: The same destructor that would be called for the temporary object. It's just
being delayed.

Corollary: You can take a const Base& to a Derived temporary and it will be
destroyed without virtual dispatch on the destructor call.

This is nifty. Consider the following code:

    // Example 3

    Derived factory(); // construct a Derived object

    void g() {
      const Base& b = factory(); // calls Derived::Derived here
      // use b
    } // calls Derived::~Derived directly here - not Base::~Base + virtual dispatch!

Does this work in practice on real compilers? Yes: Every compiler I have access
to calls the correct Derived destructor, including even ancient Borland 5.5 and
Visual C++ 6.0 (and Digital Mars, though DM calls the destructor at the wrong
    time, as noted above).

Andrei leverages this subtlety (of course) in his ScopeGuard implementation to
avoid making the implementation classes' destructors virtual at all, which is
okay in that case because those classes otherwise have no need for one. 


={============================================================================
*kt_dev_cpp_008* cpp-const-member-function cpp-this

{cpp-overload-condition}
Member functions differing only in their constness can be overloaded. Conditons
for overloading

* Shall be the `same-name`
* Shall have different param list in the `number-or-type` 
* Shall be in the `same-scope`

It is an error for two functions to differ only in their return types since
don't see return type. See {virtual-copy-constructor} for override case.

<const-overload>
The reason that the compiler can use the constness of the argument to
distinguish which funtion to call is that there is `no-const-to-nonconst`
conversion.

void fcn( const int i );          // support both const and nonconst
void fcn( int i );                // *error* redefines and *cpp-pass-by-value*

Record lookup(account *);         // pointer
Record lookup(account *const);    // const pointer.*error* redefines

Record lookup(account &);         // nonconst version
Record lookup(const account &);   // const version

Record lookup(account *);         // nonconst version
Record lookup(const account *);   // const version


{cpp-const-member-func}
EC++03. Two points:

* Clearer interface to show which member func can change state; read or write.
* Make it possible to work with const objects. 


{cpp-const-this}
Member function access the object through an extra, implicit parameter named
`this`. The compiler passes the address of `total` to the implicit `this`
parameter as if rewrites this call as:

total.isbn();

Sales_data::isbn(&total);  // where Sales_data::isbn(Sales_data *const this);

Since `this` is intended to always refer to "this" object, `this` is const
pointer. When defines const member function:

string isbn `const` { return bookNo; }

The `const` changes the type of the implicit `this` pointer.

Without const, `this` is a const pointer to nonconst by default and means that
can use(bind) only nonconst objects since there's no const-to-nonconst
conversion which cause *cpp-const-to-nonconst-error*

 T *const this -> const T *const this

So:
  Cannot change object via const member func.
  Can be used on 'both' const and nonconst class object.
  Cannot call non-const member function on const object.


<ex> this force to have const and nonconst version.

class Screen {
  public:
    string getMesg() const { return mesg; }     // OK
    string getMesg() { return mesg; }           // ERROR
};

void print_screen( const Screen &s )
{
  cout << s.getMesg() << endl;
}

<ex>

void print( const TextBlock& cbt )
{
  std::cout << cbt[0];                    // operator[] shall be const version
}


{const-nonconst-member} *cpp-overload-const*
If there is only a const version of display() then following is a compile
error. Assume display() is const member func and set() is nonconst member
func.

screen myscreen;
myscreen.display().set(10);

Since display() returns const T& and cannot call nonconst, set() on const
object. Solution?

<1> Have const and nonconst version

class Screen {
  public:
    Screen& display()
    { cout << "dis: this is non-const member" << endl; return *this; }

    `const` Screen& display() `const`
    { cout << "dis: this is const member" << endl; return *this; }

    void set()
    { cout << "set: this is non-const member" << endl; }

    void set() const
    { cout << "set: this is const member" << endl; }
};


int main(int argc, char** argv)
{
  Screen screen;

  screen.display();
  screen.display().set();

  const Screen cscreen;

  cscreen.display();
  cscreen.display().set();    // error for note-02
}

dis: this is non-const member
dis: this is non-const member
set: this is non-const member
dis: this is const member
dis: this is const member
set: this is const member


  *cpp-remember* 
  A const member function 'must' have a form

    const T& () const;
    
  If it were written

  Screen& display() const
  { cout << "dis: this is const member" << endl; return *this; }

  then cause *cpp-const-to-nonconst-error*


<2> Have one implementation for both const and nonconst `const_cast`

From EC++03. Why need? If member function is big, code duplication. So implement
once and use it twice. Have one const implementation and nonconst version simply
calls const one.

Why this direction? If you were to call a nonconst from a const, would run the
risk that that object you'd promised not to modify would be changed. 

class TextBlock {
  const char& operator[]( std::szie_t position ) const 
  {
    ...
    return text[position];
  }

  char& operator[]( std::size_t position )
  {
    // Use static_cast to set const and const_cast to remove const

    return const_cast<char&> ( static_cast<const TextBlock&>(*this)[position] );
  }
};

From CPR 233, const_cast is most useful in the conext of overloaded functions.

const string &shorterString( const string &s1, const string &s2 )
{
  return s1.size() <= s2.size() ? s1 : s2;
}

string &shorterString( string &s1, string &s2 )
{
  auto &r = shorterString(const_cast<`const` string&>(s1), 
                          const_cast<`const` string&>(s2));

  return const_cast< string& >(r);
}

This is safe to cast the const string back to a plain string and return it
because it is one of original nonconst arguments.


<3> Change the order

myscreen.set_set(10).display();
const_screen.display();


{cpp-const-to-nonconst-error}

<1>
// `const` Screen& display() `const`
Screen& display() `const`

test.cpp: In member function 'Screen& Screen::display() const':
test.cpp:14:58: error: invalid initialisation of reference of type 'Screen&'
from expression of type 'const Screen'

This is an ERROR on "return *this" since there is `no-const-to-nonconst`
conversion". So const member 'must' have this form since const applies to this
pointer: 


when do not have const set(), then causes an error since set is nonconst
version

    void set() const
    { cout << "set: this is const member" << endl; }

cscreen.display().set();

test.cpp: In function 'int main(int, char**)':
test.cpp:32:24: error: passing 'const Screen' as 'this' argument of 'void
Screen::set()' discards qualifiers [-fpermissive]


when remove const return and function do not return *this.  The const
display() returns nonconst as 'declared' since no comiple error and works. 

Screen& display() const                           // not "const Screen& () const"
{ cout << "dis: this is const member" << endl; }  // do not return *this

dis: this is non-const member
dis: this is non-const member
set: this is non-const member
dis: this is const member
dis: this is const member
set: this is non-const member           // see

*cpp-remember*
The point is that the const member func has always this form when use return.
Why? see bitwise-const for more. This matters only when returns reference but
not a copy.

const T func( ... ) const // OK
T func( ... ) const       // NO 


<2>

NS_ZINC::Future<Position> Gst::getPosition() const
{
    return returnDefault(
                Position(0,
                    int32_t(GST_TIME_AS_MSECONDS(cachedCurrent)),
                    int32_t(GST_TIME_AS_MSECONDS(cachedCurrent))));
}

template<typename T>
NS_ZINC::Future<T> Gst::returnDefault(const T& val)
{
    return NS_ZINC::asyncInvoke(getDispatcher(), *getDispatcher(),
            boost::bind(&GstMediaRouter::getPosition_async, this));
}

This emits an error:

: error: passing 'const nickel::system::GstMediaRouter' as 'this'
argument of 'zinc::Future<T>
nickel::system::GstMediaRouter::returnDefaultIfStopped(const T&) [with T =
Zinc::Media::Position]' discards qualifiers

Because returnDefault() is called in getPosition which is const member function
and to make returnDefault() succeeds, needs to `const-to-nonconst` so fails.


{const-in-func-definition}
Must use 'const' for both.

: error: prototype for 'bool Stack::empty()' does not match any in class 'Stack'
: error: candidate is: bool Stack::empty() const

class Stack {
  ...
  bool empty() `const`;
  ...
};

bool Stack::empty() `const` 
{
  ...
}


={============================================================================
*kt_dev_cpp_008* cpp-const-bitwise

{bitwise-const} physical constness
From EC++03. bitwise-const(physical const) is C++'s definition and compiler
only catches assignment to member data which is read-only. 

note: these are compiler errors at build time even if a user not use a member
function which causes an error.

<ex>

Error_code Stack::top(Stack_entry &item) const
{
  else
    item = entry[count--];   // ERROR since count is member

  return outcome;
}

:53:21: error: decrement of member 'Stack::count' in read-only 'object'


<ex>

int cube(const int& num)
{
  num = num * num;   // ERROR
  return num;
}

:22:14: error: assignment of read-only reference 'num'


<ex>

#include <iostream>

using namespace std;

class Sample {
  public:
    Sample(const char* str) : text(str) {}

    // read-only assignment error
    // : In function ‘int main(int, char**)’:
    // :25:11: error: assignment of read-only 'location' ‘sam.Sample::operator[](1u)’

    const char& operator[] (std::size_t pos) const
    { return text[pos]; }

    // *cpp-const-to-nonconst* error
    // 11:22: error: invalid initialization of reference of type ‘char&’ 
    //   from expression of type ‘const char’

    char& operator[] (std::size_t pos) const
    { return text[pos]; }

  private:
    std::string text;
};

int main(int argc, char** argv)
{
  Sample sam("CONSTMEMEBER");

  std::cout << sam[1] << endl;

  sam[1] = 'X';                  // error
}


<ex> when changed to use pointer instead

#include <iostream>

using namespace std;

class Sample {
  public:
    Sample(const char* str) : ptext(new std::string(str)) {}

    // As with the above, emits read-only assignment error.
    const char& operator[] (std::size_t pos) const
    { return (*ptext)[pos]; }

    // NO error and can change the value
    char& operator[] (std::size_t pos) const
    { return (*ptext)[pos]; }

    ~Sample() { delete ptext; }

  private:
    std::string* ptext;
};

int main(int argc, char** argv)
{
  Sample sam("CONSTMEMEBER");

  std::cout << sam[1] << endl;
  sam[1] = 'X';                  // no error and can chage the value
  std::cout << sam[1] << endl;
}

No compile errors because 'indirect' use of an object (outside of an object)
can avoid C++'s const check called bitwise-const. Since do not make changes to
*this, member, pointer in this case, so compiler do not complain. This means
const member func can change object state. Break encapsulation.


<solution-one>
From EC++28. this form fix this problem as below since not able to modify via
this call. However, 'dangling' handles problem still remains since it returns
reference to internal member such as reading it which is already gone.

Therefore, recommend to use const T(...) const form as a 'default'.

const char& operator[] (std::size_t pos) const


<solution-two>
Use *cpp-const-logical*


={============================================================================
*kt_dev_cpp_008* cpp-const-logical

<ex>
EC++03. Hence logical-const. This is an example to cache the length whenever
it is requested. cache textLength. Although it changes its member, it
maintains logical constness as it updates length to cache purpose. 

class CTextBlock {
  public:
    std::size_t length() const;

  private:
    char* pText;
    mutable std::size_t textLength;    // mutable
    mutable bool lengthIsValid;        // mutable
};

Last calculated length of textblock

std::size_t CTextBlock::length() const
{
  if( !lengthIsValid )
  {
    textLength = std::strlen( pText );
    lengthIsValid = true;
  }

  return textLength;
}


<ex> cpp-lazy-initialization

// from Singleton discussion

class Singleton {
  public:
    // single point of access
    // <lazy-initialisation> means that do not create instance 
    // until its first access.
    static Singleton* Instance()
    {
      if(_instance==0) {
        _instance = new Singleton;
      }
      return _instance;
    }

    // <no-user-creation>
    // shall be an implementation since gets created in Instance() anyway.
    // <Q> why not private?
  protected:
    Singleton() {};

    // can have different concrete classes in different hierachy
  private:
    'static' Singleton* _instance;
};


={============================================================================
*kt_dev_cpp_008* cpp-const-mutable cpp-mutable

To make member data writable from a const member func. A mutable data member is
never const even when it is a member of a const object.

class T {
  public:
    void some_member() const;

  private:
    'mutable' size_t access_ctr;
};

<usecase>
* in debug, to count the number of calls for a member func.
* to use logical constness
* to use lock as a mutable member. seems useful.
* see {lazy-fetching} in *kt_dev_mecpp_002* 

All these cases are about 'logical' constness and the snippet from online:

A mutable variable could be used for example for tracking lifetime of an
object and regularly prints a log of its internal state. In this case, nothing
changes for the object from the external point of view, but some thing in its
internal state changes. This does not contradict to promise to not modify the
object, because in this case, const can be seen as "I promise to my user that
this operation will not modify any visible state / information he could
access". 

Why logical? Since do it in ways that clients cannot detect or that maintain
constness in terms of logic. 


<ex>
When use the mix of C and C++, face an build error when builds C++ source.

SessionResolveName(const char *in, char *out, int maxLen, int *calculated)
{
...
  source = _determineSource(in, &sourcelen, &inIndex, &usePath);
}

const char* _determineSource(const char*in, int* sourceLen, int *readPos, bool* usePath)
{
  idx = strchr(in, '/');      // C++ version
  ...
}


Session.cpp:876:23: error: invalid conversion from 'const char*' to 'char*'

Looked at the strchr man page and it says:

NAME
       strchr, strrchr, strchrnul - locate character in string

SYNOPSIS
       #include <string.h>

       char *strchr(const char *s, int c);
       

What? What's going on here?! Found that from glibc string.h


/* Find the first occurrence of C in S.  */
#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO            // IF
extern "C++"
{
extern char *strchr (char *__s, int __c)
     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));
extern __const char *strchr (__const char *__s, int __c)
     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));

# ifdef __OPTIMIZE__
__extern_always_inline char *
strchr (char *__s, int __c) __THROW
{
  return __builtin_strchr (__s, __c);
}

__extern_always_inline __const char *
strchr (__const char *__s, int __c) __THROW
{
  return __builtin_strchr (__s, __c);
}
# endif
}
#else                                              // ELSE for C
extern char *strchr (__const char *__s, int __c)
     __THROW __attribute_pure__ __nonnull ((1));
#endif

That says that will use non-const version for C++ build and const version for C.
So:

SessionResolveName(const char *in, char *out, int maxLen, int *calculated)
{
  ...
  source = _determineSource((char*)in, &sourcelen, &inIndex, &usePath);    <DN>
}

const char* _determineSource(char*in, int* sourceLen, int *readPos, bool* usePath)
{
  idx = strchr(in, '/');
  ...
}


={============================================================================
*kt_dev_cpp_008* read: logical and physical state

https://isocpp.org/wiki/faq/const-correctness#logical-vs-physical-state

How can it help me design better classes if I distinguish logical state from
physical state?  

Because that encourages you to design your classes from the outside-in rather
than from the inside-out, which in turn makes your classes and objects easier to
understand and use, more intuitive, less error prone, and faster. (Okay, that’s
    a slight over-simplification. To understand all the if’s and’s and but’s,
    you’ll just have to read the rest of this answer!)

Let’s understand this from the inside-out — you will (should) design your
classes from the outside-in, but if you’re new to this concept, it’s easier to
understand from the inside-out.

On the inside, your objects have physical (or concrete or bitwise) state. This
is the state that’s easy for programmers to see and understand; it’s the state
that would be there if the class were just a C-style struct.

On the outside, your objects have users of your class, and these users are
restricted to using only public member functions and friends. These external
users also perceive the object as having state, for example, if the object is of
class Rectangle with methods width(), height() and area(), your users would say
that those three are all part of the object’s logical (or abstract or
    meaningwise) state. To an external user, the Rectangle object actually has
an area, even if that area is computed on the fly (e.g., if the area() method
    returns the product of the object’s width and height). In fact, and this is
the important point, your users don’t know and don’t care how you implement any
of these methods; your users still perceive, from their perspective, that your
object logically has a meaningwise state of width, height, and area.

note:
Even if there is no 'area' member data in a class, user assumes that and this is
logical state.

The area() example shows a case where the logical state can contain elements
that are not directly realized in the physical state. The opposite is also true:
classes sometimes intentionally hide part of their objects’ physical (concrete,
    bitwise) state from users — they intentionally do not provide any public
member functions or friends that would allow users to read or write or even know
about this hidden state. That means there are bits in the object’s physical
state that have no corresponding elements in the object’s logical state.

As an example of this latter case, a collection-object might 'cache' its last
lookup in hopes of improving the performance of its next lookup. This cache is
certainly part of the object’s physical state, but there it is an internal
implementation detail that will probably not be exposed to users - it will
probably 'not' be part of the object’s logical state. Telling what’s what is
easy if you think from the outside-in: if the collection-object’s users have no
way to check the state of the cache itself, then the cache is transparent, and
is not part of the object’s logical state.


={============================================================================
*kt_dev_cpp_008* read: constness on logical state

https://isocpp.org/wiki/faq/const-correctness#logical-vs-physical-state

Should the constness of my public member functions be based on what the method
does to the object’s logical state, or physical state?  

Logical.

There’s no way to make this next part easy. It is going to hurt. Best
recommendation is to sit down. And please, for your safety, make sure there are
no sharp implements nearby.

Let’s go back to the collection-object example. Remember: there’s a lookup
method that caches the last lookup in hopes to speed up future lookups.

Let’s state what is probably obvious: assume that the lookup method makes no
changes to any of the collection-object’s logical state.

So... the time has come to hurt you. Are you ready?

Here comes: if the lookup method does not make any change to any of the
collection-object’s logical state, but it does change the collection-object’s
physical state (it makes a very real change to the very real cache), should the
lookup method be const?

The answer is a resounding Yes. (There are exceptions to every rule, so “Yes”
    should really have an asterisk next to it, but the vast majority of the
    time, the answer is Yes.)

This is all about “logical const” over “physical const.” It means the decision
about whether to decorate a method with const should hinge primarily on whether
that method leaves the logical state unchanged, irrespective (are you sitting
    down?) (you might want to sit down) irrespective of whether the method
happens to make very real changes to the object’s very real physical state.

In case that didn’t sink in, or in case you are not yet in pain, let’s tease it
apart into two cases:

    If a method changes any part of the object’s logical state, it logically is
    a mutator; it should not be const even if (as actually happens!) the method
    doesn’t change any physical bits of the object’s concrete state.

    Conversely, a method is logically an inspector and should be const if it
    never changes any part of the object’s logical state, even if (as actually
        happens!) the method changes physical bits of the object’s concrete
    state.

If you’re confused, read it again.

If you’re not confused but are angry, good: you may not like it yet, but at
least you understand it. Take a deep breath and repeat after me: “The constness
of a method should makes sense from outside the object.”

If you’re still angry, repeat this three times: “The constness of a method must
make sense to the object’s users, and those users can see only the object’s
logical state.”

If you’re still angry, sorry, it is what it is. Suck it up and live with it.
Yes, there will be exceptions; every rule has them. But as a rule, in the main,
this logical const notion is good for you and good for your software.

One more thing. This is going to get inane, but let’s be precise about whether a
method changes the object’s logical state. If you are outside the class - you
are a normal user, every experiment you could perform (every method or sequence
    of methods you call) would have the same results (same return values, same
      exceptions or lack of exceptions) irrespective of whether you first called
    that lookup method. If the lookup function changed any future behavior of
    any future method (not just making it faster but changed the outcome,
        changed the return value, changed the exception), then the lookup method
    changed the object’s logical state - it is a mutuator. But if the lookup
    method changed nothing other than perhaps making some things faster, then it
    is an inspector.


={============================================================================
*kt_dev_cpp_008* const-read-const-correctness, part 1

http://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/

1. What is a "shared variable"?

A "shared variable" is one that could be accessed from more than one thread at
the same time.

This concept is important in the C++ memory model. For example, the C++ memory
model (the core of which is described in ISO C++ §1.10) prohibits the invention
of a write to a "potentially shared memory location" that would not have been
written to in a sequentially consistent execution of the program, and the C++
standard library refers to this section when it prohibits "modify[ing] objects
accessible by [other] threads" 'through' a const function, as we will see in #2.


2. What do const and mutable mean on shared variables?

Starting with C++11, const on a variable that is possibly shared means
"read-only or as good as read-only" for the purposes of concurrency. Concurrent
const operations on the same object are required to be safe without the calling
code doing external synchronization.

If you are implementing a type, unless you know objects of the type can never be
shared (which is generally impossible), this means that each of your
`const-member-functions` must be either:

    truly physically/bitwise const with respect to this object, meaning that
    they perform no writes to the object's data; or else

    internally synchronized so that if it does perform any actual writes to the
    object's data, that data is correctly protected with a mutex or equivalent
    (or if appropriate are atomic<>) so that any possible concurrent const
    accesses by multiple callers can't tell the difference.

Types that do not respect this cannot be used with the standard library, which
requires that:

    "... to prevent data races (1.10). ... [a] C++ standard library function
    shall not directly or indirectly modify objects (1.10) accessible by threads
    other than the current thread unless the objects are accessed directly or
    indirectly via the function's *non-const* arguments, including this."-ISO C++
    §17.6.5.9

    note: that is, shall not modify if the objects are accessed via const


Similarly, writing `mutable` on a member variable means what it has always
meant: The variable is "writable but `logically-const`." Note what this implies:

    The "logically const" part now means "can be used safely by multiple
    concurrent const operations." The "mutable" and "writable" part further
    means that some const operations may actually be writers of the shared
    variable, which means it's inherently got to be correct to read and write
    concurrently, so it should be protected with a mutex or similar, or made
    atomic<>.

In general, remember:

    Guideline: Remember the "M&M rule": For a member variable, mutable and mutex
    (or atomic) `go-together`.

This applies in both directions, to wit:

    (1) For a member variable, mutable implies mutex (or equivalent): 

    A mutable member variable is presumed to be a mutable shared variable and so
    must be synchronized internally-protected with a mutex, made atomic, or
    similar.

    (2) For a member variable, mutex (or similar synchronization type) implies
    mutable: 

    A member variable that is itself of a synchronization type, such as a mutex
    or a condition variable, naturally wants to be mutable, because you will
    want to use it in a non-const way (e.g., take a std::lock_guard<mutex>)
    inside concurrent const member functions.

We'll see an example of (2) in Part 2, GotW #6b.


3. How are const and mutable different in C++98 and C++11?

First, let's be clear: C++98 single-threaded code still works. 

C++11 has excellent C++98 compatibility, and even though the meaning of const
has evolved, C++98 single-threaded code that uses the old "logically const"
meaning of const is still valid.

With C++98, we taught a generation of C++ developers that "const means logically
const, not physically/bitwise const." That is, in C++98 we taught that const
meant only that the observable state of the object (say, via its non-private
    member functions) should not change as far as the caller could tell, but its
internal bits might change in order to update counters and instrumentation and
other data not accessible via the type's public or protected interface.

That definition is 'not' sufficient for concurrency. With C++11 and onward, which
now includes a concurrency memory model and thread safety specification for the
standard library, this is now much simpler: 

const now really does mean "read-only, or safe to read concurrently"-either
truly physically/bitwise const, or internally synchronized so that any actual
writes are synchronized with any possible concurrent const accesses so the
callers can't tell the difference.

Although existing C++98-era types still work just fine in C++98-era
single-threaded code for compatibility, those types and any new ones you write
today should obey the new stricter requirement if they could be used on multiple
threads. 

The good news is that most existing types already followed that rule, and code
that relies on casting away const and/or using mutable data members in
single-threaded code has already been generally questionable and relatively
rare.  
        
Summary

Don't shoot yourself (or your fellow programmers) in the foot. Write
const-correct code.

Using const consistently is simply necessary for correctly-synchronized code.
That by itself is ample reason to be consistently const-correct, but there's
more: 

It lets you document interfaces and invariants far more effectively than any
mere /* I promise not to change this */ comment can accomplish. It's a powerful
part of `design-by-contract` 

It helps the compiler to stop you from accidentally writing bad code. It can
even help the compiler generate tighter, faster, smaller code. That being the
case, there's no reason why you shouldn't use it as much as possible, and every
reason why you should.

Remember that the correct use of mutable is a key part of const-correctness. If
your class contains a member that could change even for const objects and
operations, make that member mutable and protect it with a mutex or make it
atomic. That way, you will be able to write your class' const member functions
easily and correctly, and users of your class will be able to correctly create
and use const and non-const objects of your class' type.

It's true that not all commercial libraries' interfaces are const-correct. That
isn't an excuse for you to write const-incorrect code, though. 

It is, however, one of the few good excuses to write const_cast, plus a detailed
comment nearby grumbling about the library vendor's laziness and how you're
looking for a replacement product.


={============================================================================
*kt_dev_cpp_008* cpp-const-read-correctness

EXPC++ 43

Problem: In the following code, `add or remove const` (including minor
    variants and related keywords) wherever appropriate. Note: Don't comment
on or change the structure of this program. It's contrived and condensed for
illustration only.

For bonus points: In what places are the program's results undefined or
uncompilable due to const errors?

class polygon {
public:
    polygon() : area{-1} {}

    void add_point( const point pt ) { area = -1;
                                       points.push_back(pt); }

    point get_point( const int i ) { return points[i]; }

    int get_num_points() { return points.size(); }

    double get_area() {
        if( area < 0 )   // if not yet calculated and cached
            calc_area();     // calculate now
        return area;
    }

private:
    void calc_area() {
        area = 0;
        vector<point>::iterator i;
        for( i = begin(points); i != end(points); ++i )
            area += /* some work using *i */;
    }

    vector<point> points;
    double        area;
};

polygon operator+( polygon& lhs, polygon& rhs ) {
    auto ret = lhs;
    auto last = rhs.get_num_points();
    for( auto i = 0; i < last; ++i ) // concatenate
        ret.add_point( rhs.get_point(i) );
    return ret;
}

void f( const polygon& poly ) {
    const_cast<polygon&>(poly).add_point( {0,0} );
}

void g( polygon& const poly ) { poly.add_point( {1,1} ); }

void h( polygon* const poly ) { poly->add_point( {2,2} ); }

int main() {
    polygon poly;
    const polygon cpoly;

    f(poly);
    f(cpoly);
    g(poly);
    h(&poly);
}


<solution>

When I pose this kind of problem, I find that most people think the problem is
on the easy side and address only the more-usual const issues. There are,
   however, subtleties that are worth knowing, and hence this Item.

1. The point object is passed by value, so there is little benefit to
declaring it const.

    void  add_point( const point pt )

In this particular case, because the function is `defined-inline`, the const
value parameter can make sense. This is because for inline functions the
declaration and definition are the same. Otherwise, const value parameters
should appear only on the definition, not on the declaration. Let's see why.

Putting the const on a 'value' parameter in a function declaration is
irrelevant outside the function; it makes no difference to the caller and can
only confuse readers. 

To the compiler, the function signature is the 'same' whether you include this
const in front of a value parameter or not. For example:

// `value-parameter`: `top-level-const` is not part of function signature
int f( int );
int f( const int );    // redeclares f(int): this is the same function

// `nonvalue-parameter`: `top-level-const` is part of function signature
int g( int& );
int g( const int& );   // overloads g(int&): these are two functions

But putting the const on the value parameter does make a difference to how it
can be used 'inside' the function's actual definition. Remember that, inside a
function, the parameters are just the 'first' set of local variables, so
putting a const on a value parameter simply means that the function can't
modify its local variable, which only happens to be a parameter. Here's an
example that declares and then defines the same function f:

int f( int );          // declaration: no const

int f( const int i ) { // definition: use const to express "read-only"

    vector<int> v;
    v.push_back(i);    // ok, only reads from i

    i = 42;            // error, attempts to modify i

}

  Guideline: Consider not writing const on `pass-by-value` function parameters
  when only forward-declaring a function. You can always add it on the
  `definition` to express a read-only parameter.


2. get_point and get_num_points should be `const-member-function`

    point get_point( const int i ) { return points[i]; }

    int   get_num_points() { return points.size(); }

These functions should be marked const, because they don't change the state of
the object.


3. get_area should be `const-member-function`

    double get_area() {
        if( area < 0 )        // if not yet calculated and cached
            calc_area();      // calculate now
        return area;
    }

Even though this function modifies the object's internal state, we should
consider making it const. Why? Because this function does not modify the
object's `observable-state`; we are doing some caching here, but that's an
internal implementation detail and the object is *cpp-const-logical* even if
it isn't physically const.


4. Therefore calc_area should also be `const-member-function`

    void calc_area() {
        area = 0;
        vector<point>::iterator i;
        for( i = begin(points); i != end(points); ++i )
            area += /* some work using *i */;
    }

Once we make get_area be const, this private helper function 'ought' also to
be const.

In turn, once you make this function const, the compiler will tell you that
you also need to do something about the member variable area, which should be:

    mutable, so that it's writable in a const member function; and

    synchronized using a mutex or made atomic<>, so that it's
    concurrency-safe, as discussed in GotW #6a.


5. Also, calc_area should use a const_iterator.

The iterator should not change the state of the points collection, and so it
ought to be a const_iterator. We're now 'forced' to make this change anyway if
we're making calc_area be a const member function, but 

note that if we had said auto for the iterator's type we wouldn't have had to
make any change at all.

While we're at it, the for loop inside calc_area: It should prefer to use the
range-based for loop, as well as auto.

Combining all that, we get this simpler and const-correct code:

      for( auto& pt : points )
          area += /* some work using pt */;

    Guideline: Prefer declaring variables using auto.

    Guideline: Prefer range-based for loops to naked iterator-incrementing for
    loops when visiting the elements of the range in order.


6. area should be `mutable` and synchronized.

    double        area;

As noted already, in conjunction with the other changes the internal cache
variable will area now want to be mutable so that it can be used correctly and
safely inside const member functions, and because it is now a shared variable
potentially used by multiple concurrent const operations it must also be
synchronized—protected with a mutex or made atomic.

Bonus Question: Before reading on, which should it be: Protected by a mutex? or
made atomic<double>?

Have you thought about it? All right, let's continue

Both work, but a mutex is usually 'overkill' for a single variable.

Option 1 is to use a mutex in the perhaps-soon-to-be-canonical "mutable mutex
mutables" pattern:

// Option 1: Use a mutex  *cpp-mutable*

    double get_area() const {
        auto lock = unique_lock<mutex>{mutables};
        if( area < 0 )    // if not yet calculated and cached
            calc_area();  // calculate now
        return area;
    }

private:
    // ...
    mutable mutex  mutables;      // canonical pattern: mutex that
    mutable double area;          // covers all mutable members

Option 1 generalizes well if you add more data members in the future. However,
       it's also more invasive and generalizes less well if you add more const
       member functions in the future that use area, because they will all
       have to remember to acquire a lock on the mutex before using area.

Option 2 is to just change double to mutable atomic<double>. 

    mutable atomic<double> area; 

This is attractive because the "mutable part" of polygon is just a single
variable. That can work, but you have to be careful because that's not the
only necessary change, for two reasons:

    The minor reason is that atomic<double> doesn't support +=, so if we only
    change area's 'type' then calc_area will no longer compile. That can be
    worked around, but leads us to the major reason...

    The major reason is that, because calc_area is a `compound-operation` and
    must be safe to run on multiple threads concurrently, we must restructure
    calc_area to be safe to run concurrently. In particular it should not
    perform intermediate updates to area, and should ensure that multiple
    competing concurrent updates to area don't cause overwrites that lose
    written values.

There are several ways to do it, but the simplest is probably to allow benign
redundant recalculations in the case of concurrent calls to calc_area, on the
grounds that it's probably no worse than blocking the concurrent calls which
would have to wait anyway.

// Option 2: Use an atomic

    // void calc_area() {
    //     area = 0;
    //     vector<point>::iterator i;
    //     for( i = begin(points); i != end(points); ++i )
    //         area += /* some work using *i */;
    // }

    void calc_area() const {
        auto tmp = 0.0;              // do all the work off to the side
        for( auto& pt : points )
            tmp += /* some work using pt */;
        area = tmp;                  // then commit with a `single-write`
    }

private:
    // ...
    mutable atomic<double> area;

Notice that concurrent const operations that call to calc_area can still
overlap and overwrite each other's results, but that's benign because they're
concurrent const operations so they will all calculate the 'same' value. 

Also, concurrent calc_area calls use the shared points variable in a loop
which should make us mentally check that it doesn't cause cache contention,
      but because they're all readers it won't and so this too is fine.

note: "tmp" is local to a thread in thread stack


7. operator+'s rhs parameter should be a `reference-to-const`.

polygon operator+( polygon& lhs, polygon& rhs ) {

The rhs parameter should be passed by reference to const, of course.

    Guideline: Prefer passing a read-only parameter by const& if you are only
    going `to read from it (not make a copy of it).`

"But wait!" I can just hear some of you saying, "you forgot about lhs! Shouldn't
it be const& too?" Actually, not so much:


8. operator+'s lhs parameter should be `passed-by-value`.

The key point is that we're going to copy from it anyway, in this case
immediately:

    auto ret = lhs;

When you're in the `special` case of "read-only parameter that you're going to
  take copy of anyway," there are several ways to accept the parameter, which
  I'll cover in detail in another GotW. For now, suffice it to say that
  usually you shouldn't overthink these options, and just use pass-by-value as
  the simplest method, which offers some advantages that we also touched on in
  GotW #4:

    If the caller passes a named polygon object (an lvalue), there's no
    difference. Both pass-by-const& followed by an explicit copy and
    pass-by-value will perform 'one' copy.

    If the caller passes a temporary polygon object (an rvalue), the compiler
    automatically move-constructs lhs from that, which probably makes no
    difference for a small type like polygon but can be considerably cheaper for
    many types.

    Guideline: Prefer passing a read-only parameter by value if you're going to
    make a copy of the parameter anyway, because it enables move from rvalue
    arguments.

note: needs more follow-ups for reasons?


9. Also in operator+, last should be const.

    auto last = rhs.get_num_points();
    for( auto i = 0; i < last; ++i ) // concatenate
        ret.add_point( rhs.get_point(i) );
    return ret;
}

Since last should never change, prefer to say so by making it const.

    Guideline: Prefer to make variables, including locals, const if they
    should not change.

Incidentally, notice that once we make rhs a reference-to-const parameter as
noted above, we see another reason why get_point should be a const member
function.


10. f's const_cast may give `undefined` behavior, and is morally wrong anyway.

void f( const polygon& poly ) {
    const_cast<polygon&>(poly).add_point( {0,0} );
}

Bonus: The result of the const_cast is undefined if the referenced object was
declared as const-the case of f(cpoly) below. *cpp-const-undefined*

The parameter isn't really const, so don't declare it as const and then try to
modify it anyway. Lying to the compiler, never mind to the caller, is a bad
idea, never mind morally reprehensible in most value systems.


11. g's const is illegal and useless.

void g( polygon& const poly ) { poly.add_point( {1,1} ); }

This const is illegal; you can't apply const directly to the reference itself,
     besides which references are already const inasmuch as they cannot be
     reseated to refer to a different object.

note:     
void g( polygon& const poly ) { poly.add_point( {1,1} ); }

cause:
:51:24: error: ‘const’ qualifiers cannot be applied to ‘polygon&’

void g( const polygon& poly ) { poly.add_point( {1,1} ); }

cause:
:53:56: error: passing ‘const polygon’ as ‘this’ argument of ‘void
  polygon::add_point(point)’ discards qualifiers [-fpermissive]


void h( polygon* const poly ) { poly->add_point( {2,2} ); }

h's const merely ensures that h's body won't modify the pointer value.  This
is the same as the const value parameters in add_point and get_point, and
perfectly fine on the definition.


12. Examining the mainline.

int main() {
    polygon poly;
    const polygon cpoly;

    f(poly);

This is fine.

    f(cpoly);

As already noted, this causes undefined results when f tries to cast away the
  const-ness of its parameter and then modify it. *cpp-const-undefined*

    g(poly);

This is fine.

    h(&poly);
}

This is fine.


Summary

Here is a revised version of the code that corrects the const issues noted
above, but does not attempt to correct any other poor style. Note that because
of the atomic member, which is not copyable, we now provide polygon's copy and
move operations explicitly.

class polygon {
public:
    polygon() : area{-1} {}

    polygon( const polygon& other ) : points{other.points}, area{-1} { }

    polygon( polygon&& other ) 
        : points{move(other.points)}, area{other.area.load()}
        { other.area = -1; }

    polygon& operator=( const polygon& other )
        { points = other.points; area = -1; return *this; }

    polygon& operator=( polygon&& other ) {
        points = move(other.points);
        area = other.area.load();
        other.area = -1;
        return *this;
    }

    void add_point( point pt ) 
        { area = -1; points.push_back(pt); }

    point get_point( int i ) const { return points[i]; }

    int get_num_points() const { return points.size(); }

    double get_area() const {
        if( area < 0 )   // if not yet calculated and cached
            calc_area();     // calculate now
        return area;
    }

private:
    void calc_area() const {
        auto tmp = 0.0;
        for( auto& pt : points )
            tmp += /* some work using pt */;
        area = tmp;
    }

    vector<point>          points;
    mutable atomic<double> area;              // *cpp-mutable*
};

polygon operator+( polygon lhs, const polygon& rhs ) {
    const auto last = rhs.get_num_points();
    for( auto i = 0; i < last; ++i ) // concatenate
        lhs.add_point( rhs.get_point(i) );
    return lhs;
}

void f( polygon& poly ) { poly.add_point( {0,0} ); }

void g( polygon& poly ) { poly.add_point( {1,1} ); }

void h( polygon* poly ) { poly->add_point( {2,2} ); }

int main() {
    auto poly = polygon{};

    f(poly);
    g(poly);
    h(&poly);
}


={============================================================================
*kt_dev_cpp_011* cpp-inline

EC++30 recommends to minimize use of inline.

good:

* Can avoid function call overhead

* Request to the compiler but not a command since the compiler may choose to
  ignore this request.

* EC++30 says that can have compiler optimisation on inlined code area.

bad: as with macro, inline has cost:

* bigger size and performance penalty which can cause additional paging and
  reduced instruction cache hit.

* impossible to provide binary upgrades. Force client to compile than to
  relink. Think when changes inline func. All clients should be recompiled.

* problem with debugger.

* A compiler refuse to inline function that has calls to 'virtual' funcs
  because cannot know it at compile time.


<empty-ctor-represenstaion>
ctor and dtor may be 'worse' candiate for inline. Why? There are codes written
by compilers and inserted into program during compilation for construction,
destruction, exception handling during those, new and delete, and so forth.

These are up to compiler implementation. So empty ctor can have followings:

class Derived: public Base {
  public:
    Derived() {}              // is it really empty?
    ...
  private:
    std::string dm1, dm2, dm3;
};

Derived::Derived()
{
  Base::Base();

  try{ dm1.std::string::string(); }
  catch(...) {
    Base::~Base();
    throw;
  }

  try{ dm2.std::string::string(); }
  catch(...) {
    dm1.std::string::~string();
    Base::~Base();
    throw;
  }

  try{ dm3.std::string::string(); }
  catch(...) {
    dm1.std::string::~string();
    dm2.std::string::~string();
    Base::~Base();
    throw;
  }
}

This is unrepresentative of what real compiler emit but do what ctor must
offer. When think ctors of base class, class members, not attractive for
inlining. 

Initially don't inline anything, or at least limit your inlining to those
functions that must be inline. Employ inlines cautiously including templates
functions. Think about 80-20 rule and may use profiler to find out 20% as a
candidate for inlining.


={============================================================================
*kt_dev_cpp_014* cpp-auto

{auto-specifier}
When initialize it from a expression, have to know the type of that expression
and can be difficult.

Under new standard, let the compiler figure out the type by using auto type
specifier and by deducing the type from the initializer. so must have
initializer.

note: GCC 4.4.5 supports.

auto item = val1 + val2;

double salePrice = applyDiscout( price, discount );


{auto-and-const}

const int ci = i, &cr = ci;

auto b = ci;      // b is int
auto c = cr;      // c is int
auto d = &i;      // d is int*
auto e = &ci;     // e is const int*

auto figures out type and also initialize. So copy initialize do not affect
constness but the last does affect so have const in its deduced type.

<ex> to use reference
  for(const auto& e: vint)
  {
    ...
  }


={============================================================================
*kt_dev_cpp_014* cpp-decltype cpp-typedef cpp-struct {class-vs-struct} 

{cpp-decltype-specifier}
Want to have a type deduced `without defining an initialized variable.` Return
the type of expression but do not 'evaluate' it, that is, do not call
expression.

string s("...");
decltype( s.size() ) count = 0;

<when-decltype-return-reference-type> to get reference type of expression
The decltype return reference type when expression yields objects that is
lvalue, that can stand on the left hand side of assignment.

int i = 42, *p = &i, &r = i;

decltype( r + 0 ) b;          // int b
decltype( *p ) c;             // int& c; error.

The decltype of a parenthesized variable is always a reference.

decltype((i)) d;              // int& d; error.
decltype(i) e;                // int e;

The side effect when decltype returns a reference is that variable must be
initialized as usual reference variable does.


<typeof-and-decltype>
The 'typeof' is gcc one and decltype is C++.

The problem is:

std::vector<typeof(k)> myVec;
    
C++0x standard introduces an alternative called 'decltype', which can be used
to replace uses of typeof. Unfortunately, in some more complex use cases when
deduced types are used as parameters for templates resolving into types
declared as 'constexpr', use of typeof() triggers a compile-error.

note: decltype usage. decltype is used to get type for template. solution was
to have #define to use decltype only for C++0x but typeof for before C++0x.


{cpp-struct-and-typedef}
The structure is declared like this. No space allocated since it is
declaration.

struct point {
  int x;
  int y;
};

note: As with class, see terminating ";".

Here point is that `structure tag` defines a `type`. So defining structure
objects is analogous to defining objects of any type.

"struct { ... } x, y, z;" is analogus to "int x, y, z;"

Why 'tag'? The tag can be used 'later' in definition of instances of the
structure since cannot use the above later. Given the declaration above:

struct point pt = { 320, 200 };

The only 'legal' operation on structure are copy and assign as a unit but not
compare.

<why-typedef> From ansic, p146.
The typedef creates a new data `type name` and does not create a `new type` in
any sense; merely adds a new name for some 'existing' type. In effect, typedef
is like #define, except that it is interpreted by the compiler.

point top;          // using typedef is convenient
struct point top;


{initialization}

typedef struct {
  int a;
  int b;
  int arr[2];
} NODE;

int main()
{
  // note: this warning happens due to -Wextra
  // : warning: missing initializer [-Wmissing-field-initializers]
  // : warning: (near initialization for 'node.arr') [-Wmissing-field-initializers]
  // NODE node = {0,0};

  NODE node = {0,0,{0,0}};

  return 0;
}

To avoid warning, may have {0} for a single element array

typedef struct {
  int a;
  int b;
  int arr[1];
  int c;
} NODE;

NODE node = {0,0,{0},0};


<designated-initializers> note: about the initialzation order but not layout.
https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html

Standard C90 requires the elements of an initializer to appear in a fixed
order, the same as the order of the elements in the array or structure being
initialized.

In ISO C99 you can give the elements in 'any' order, specifying the array
indices or structure field names they apply to, and GNU C allows this as an
extension in C90 mode as well. This extension is not implemented in GNU C++.

struct view_class {
  const char *title;
  const char *style;
  Evas_Object *(*create)(struct viewmgr *vmgr);
  void (*update)(Evas_Object *base, Elm_Object_Item *it);
  void (*show)(Evas_Object *base, Elm_Object_Item *it);
  void (*hide)(Evas_Object *base, Elm_Object_Item *it);
  void (*resume)(Evas_Object *base, Elm_Object_Item *it);
  void (*pause)(Evas_Object *base, Elm_Object_Item *it);
  void (*terminate)(Evas_Object *base);
  int show_bg;
};                                                          

This is struct declaration and not a typedef. So need to use struct keyword to
create a object. All three examples below creates objects.

note: see use of comma for below examples to create a object.

static struct view_class _vclass = {   static struct view_class _vclass = {
  .title = NULL,                         NULL,                             
  .style = "homepanel/apps/1",           "homepanel/apps/1",               
  .create = _create,                     _create,                          
  .update = _update,                     _update,                          
  .show = _show,                         _show,                            
  .hide = _hide,                         _hide,                            
  .resume = _resume,                     _resume,                          
  .pause = _pause,                       _pause,                           
  .terminate = _terminate,               _terminate,                       
  .show_bg = 0,                          0,                                
};                                     };                                  

or

struct view_class {
  const char *title;
  const char *style;
  Evas_Object *(*create)(struct viewmgr *vmgr);
  void (*update)(Evas_Object *base, Elm_Object_Item *it);
  void (*show)(Evas_Object *base, Elm_Object_Item *it);
  void (*hide)(Evas_Object *base, Elm_Object_Item *it);
  void (*resume)(Evas_Object *base, Elm_Object_Item *it);
  void (*pause)(Evas_Object *base, Elm_Object_Item *it);
  void (*terminate)(Evas_Object *base);
  int show_bg;
} x = {
  NULL,
  "homepanel/apps/1",
  _create,
  _update,
  _show,
  _hide,
  _resume,
  _pause,
  _terminate,
  0,
};

If it was a typedef then would use like:

static view_class _vclass = {
  .title = NULL,
  .style = "homepanel/apps/1",
  .create = _create,
  .update = _update,
  .show = _show,
  .hide = _hide,
  .resume = _resume,
  .pause = _pause,
  .terminate = _terminate,
  .show_bg = 0,
};

<ex> creates a type name but not object. 
typedef struct tnode {
  char *word;
  int count;
  struct tnode* left;
  struct tnode* right;

  // note: <diff-between-c-and-cpp> error for C but okay for CPP since it is a
  // pointer and okay as long as not define object. To define object, compiler
  // may see whole definition.
  //
  // msort-list.c:7:3: error: unknown type name 'tnode' when use C.

  tnode* left;
  tnode* right;

} Treenode;

<ex> both creates a type name.
typedef struct tnode *Treeptr;

typedef struct tnode {
  char *word;
  int count;
  Treeptr left;
  Treeptr right;
} Treenode;


<ex>
typedef struct treenode TreeNode;

typedef struct treenode {
  TreeEntry entry;
  TreeNode  *left;
  TreeNode  *right;
} TreeNode;

or

typedef struct treenode {
  TreeEntry entry; 
  treenode  *left;
  treenode  *right;
} TreeNode;

<example>
<error>
struct List;         // 7

typedef struct node
{
  EntryType entry;
  node*     pnext;         // okay for CPP
  List*     plist;
} Node;

typedef struct {
   int   count;
   Node* header;
} List;              // 19

gen-list-linked.cpp:19:3: error: conflicting declaration ‘typedef struct List List’
gen-list-linked.cpp:7:8: error: ‘struct List’ has a previous declaration as ‘struct List’

<okay>
struct list;

typedef struct node
{
  EntryType entry;
  node*     pnext;
  list*     plist;
} Node;

typedef struct list {
  int    count;
  Node*  header;
} List;

OR

typedef struct list List;

typedef struct node
{
  EntryType entry;
  node*     pnext;
  List*     plist; or list* plist;
} Node;

typedef struct list {
  int    count;
  Node*  header;
} List;

<example> this is to create a pointer type name but not object.
typedef struct _fsm
{
  VRM_FSM_INIT  init;
  ...

} *FSM_T;

FSM_T new_fsm = 0;


{cpp-type-alias} cpp-using
typedef double wages;
using wages = double;         // C++11

note: can be suprising result when use alias with compound type and const

typedef char *pstring;
const pstring cstr = 0;       // do not interpret as "const char *pstring cstr"
const pstring *ps;

The cstr is "const pointer to char" but not "pointer to const char" since base
type is "char *" and const applies on base type.

<typedef-in-class>
Effectively, make alias to classA. Useful when class name changes. Seen in
Tizen code. typedef is just a 'synonym' for some type (from ESTL)

typedef classA classB;


<define-new-type>
The aliasing mechanism can be used to define a new template by binding some or
all template arguments.

template<typename Key, typename Value>
class Map
{
  // ...
};

template<typename Value>
using String_map = Map<string, Value>;

// Map<string, int>
String_map<int> m; 


To simplify the declaration of containers, define a type alias:

using SD_multiset = unordered_multiset< Sales_data, decltype(hasher)*, decltype(eqOp)*>;
SD_multiset bookstore(42, hasher, eqOp);

This is not supported in GCC 4.6 and use typedef instead.

typedef unordered_multiset< Sales_data, decltype(hasher)*, decltype(eqOp)*> SD_multiset;
SD_multiset bookstore(42, hasher, eqOp);
SD_multiset::iterator it;


<typedef-multiple>
Is it error to have multiple typedefs? No. See *kt_dev_gcc_001* and the error
is to have conflicting typedefs.

<two-reasons-to-use-typedef>
1. To parameterize a program against portability problems. If typedef are used
for data types that may be machine-dependent, only the typedef need change
when the program is moved.

2. To provide better documentation for a program. A type Treeprt may be easier
to understand.


{class-vs-struct}
The only difference between struct and class is the default access specifier
for members and derivation; struct is 'public' and class is private by
default. p616 in ref-CPR.


{layout-order-and-size}
From C++BS 8.2.1.

An object of a struct holds its members in the order they are declared.

struct Readout {
  char hour;
  int value;
  char seq;
};

A more realistic layout of a Readout on a machine with 4-byte int would be:

hour :   [*      ]
value:   [* * * *]
seq  :   [*      ]

In this case, as on many machines, sizeof(Readout) is 12, and not 6 as one
would naively expect from simply adding the sizes of the individual members.

You can minimize wasted space by simply ordering members by size (largest
    member first).

struct Readout {
  int value;
  char hour;
  char seq;
};

This would give us:

value:      [* * * *]
hour: seq : [* *    ]

It is usually best to order members for readability and sort them by size only
if there is a demonstrated need to optimize.


={============================================================================
*kt_dev_cpp_016* cpp-pointer-array

{array-vs-struct}
1. From C++BS 8.2. Objects of structure types can be assigned, passed as
function arguments, and returned as the result from a function. For example:

Address current;
Address set_current(Address next)
{
  address prev = current;
  current = next;
  return prev;
}

Other plausible operations, such as comparison (== and !=), are not available
by default. However, the user can define such operators.

2. An array is an aggregate of elements of the same type. In its simplest
form, a struct is an aggregate of elements of arbitrary types.


{array-as-an-object}
Placing a built-in array in a struct allows us to treat that array as an
'object': we can copy the struct containing it in initialization (including
    argument passing and function return) and assignment. For example:

struct Point {
  int x,y
};

struct Array {
  Point elem[3];
};

Array shift(Array a, Point p)
{
  for (int i=0; i!=3; ++i) {
    a.elem[i].x += p.x;
    a.elem[i].y += p.y;
  }
  return a;
}

Array points2 {{1,2},{3,4},{5,6}};

Array ax = shift(points2,{10,20});

The notation for Array is a bit primitive: Why i!=3? Why keep repeating
.elem[i]? Why just elements of type Point? The standard library provides
std::array as a more complete and elegant development of the idea of a
fixed-size array as a struct:

This array is a template to allow arbitrary numbers of elements of arbitrary
types. It also deals directly with the possibility of exceptions and const
objects.

struct Point {
   int x,y
};

using Array = array<Point,3>; // array of 3 Points

Array points {{1,2},{3,4},{5,6}};

int x2 = points[2].x;
int y2 = points[2].y;

Array shift(Array a, Point p)
{
  for (int i=0; i!=a.size(); ++i) {
    a[i].x += p.x;
    a[i].y += p.y;
  }
  return a;
}

Array ax = shift(points,{10,20});

<pros-and-cons>
The main advantages of std::array over a built-in array are that it is a
'proper' object type (has assignment, etc.) and does not implicitly convert to
a pointer to an individual element:

The disadvantage of std::array compared to a built-in array is that we can't
'deduce' the number of elements from the length of the 'initializer':

// 3 elements
Point point1[] = {{1,2},{3,4},{5,6}}; 

// 3 elements
array<Point,3> point2 = {{1,2},{3,4},{5,6}}; 

// error : number of elements not given
array<Point> point3 = {{1,2},{3,4},{5,6}}; 


={============================================================================
*kt_dev_cpp_016* cpp-static

// file A
class FileSystem {
  public:
    ...
      std::size_t numDisk() const;
    ...
};

extern FileSystem tfs;            // global tfs

// file B
class Directory {
  Directory()
  {
    std::size_t = tfs.numDisk();  // here uses tfs
    ...
  }
  ..
};

Directory tempDir( params );      // global dir


How can you make sure that the global object tfs will be initialised before
tempDir which uses that? 


<cxx-init-order-problem> *cpp-undefined*
This is called the intialization order fiasco, where global variables can be
accessed, pre-initialization value 0 for bulit-in types, before they are
initialised since the order of initialization for global variables(including
class statics) between translation units is undefined. This is the
race-condition on global variables. 

How to solve? By replacing the global variable with a function that returns a
reference to a local static variable, this guarantee that it is initialised
before anything accesses it. This is only true for single-threaded. 

Only true for single thread? <static-and-race-condition>

From C++ concurrency in action, p62, the initialization of function static is
defined to occur the first time control passes through its declaration; for
multiple threads calling the function, this means there's the potential for a
race condition to define first. 

On many pre-C++11 compilers this race condition is problematic in practice
because multiple threads may believe they're first and try to initialize the
variable, or threads may try to use it after initialization has started on
another thread but before it's finished. 

In C++11 this problem is solved: the initialization is defined to happen on
exactly one thread.


{cpp-static-type} function-static, file-static
Global vars has a program scope. The static vars are still global object but
has a limited scope.

The `function-static` is only accessible within the function, and has no
linkage.(?) It is initialised the first time execution reaches the definition,
  not necessarily during the program's initialization phases.

From ansic, p83. So static is to 'limit' the scope of the object whether is
to file or function.  

The `file-static` is private to a file and will not conflict with the same
names in other files of the same program. The `file-static` can be used on
both variables and functions.

`internal-linkage` refers to everything only in scope of a translation unit.

`global-static` `file-static` should use *cpp-namespace-unnamed* in C++.
global(file) static has a file scope.

`local-static` `function-static` 
local(function) static has a function scope. 


void foo () {   
  static int x = 0;
  ++x;
  cout << x << endl;
}

int main (int argc, char const *argv[]) {
  foo();  // 1
  foo();  // 2
  foo();  // 3
  return 0;
}


<limit-scope-meaning>
This applies to a function so if define static function, it has file-scope. 

// file one
#include <iostream>

static int gfs_count;
// extern static int gfs_count; 
// causes an compile error: conflicting specifiers in declaration of 'gfs_count'

void print_gfs()
{
  std::cout << "{ "; 

  for(int idx = 0; idx < 5; idx++)
    gfs_count++;

  std::cout << gfs_count << std::endl;

  std::cout << "}" << std::endl; 
}

// file two
#include <iostream>

extern int gfs_count;
extern void print_gfs();

int main()
{
  std::cout << "{ "; 

  std::cout << gfs_count << std::endl;    // if remove this, no link error
  print_gfs();

  std::cout << "}" << std::endl; 
}

No error in building and in using a function in file-one but failed to use
static variable in file two in link stage.

$ make
echo '>> build use-main.cpp'
g++ -std=c++0x -o main.o -c use-main.cpp
echo '>> build file-static.cpp'
g++ -std=c++0x -o file.o -c file-static.cpp
echo '>> bulid main'
g++ -std=c++0x -o out main.o file.o
main.o: In function `main':
use-main.cpp:(.text+0x1e): undefined reference to `gfs_count'
collect2: ld returned 1 exit status
make: *** [main] Error 1


{solution}
To the initial problem, use `function-static`. EC++04 said it is common
implementation of `singleton-pattern`

// file A
class FileSystem {
   ...
};

// extern FileSystem tfs;
FileSystem& tfs()
{ >
  static FileSystem fs; return fs;
}

// file B
class Directory {
   // use tfs
};

# Directory tempDir( params );
Directory& tempDir()
{ >
  static Directory td(tempDir); return td;
}


={============================================================================
*kt_dev_cpp_017* cpp-static-members and class const

The staic members are associated with the class rather than objects. So can
call static member function as `class method` or class operation as in
smalltalk and static member variable as `class variable` or class static. 

See *class-variable-case* for class variable example.

note: static members 'obey' normal access control.


<static-member-func-and-this>
The static-member-func do not bound to any object; do not have a this pointer.
Aa a result static-member-func `may not be declared as const` and not refer to
this in the body. 

The static member func, class-method, do not have `this-pointer` because no
need to distinguish objects and this means class-methond can only use class
variable.


Use directly through the scope operator:

double r;
r = Account::rate();

Even though static are not part of the object, can use object to
access a static member.

Account ac1;
Account *ac2 = &ac1;

r = ac1.rate();
r = ac2->rate();

Member function can use it directly without the scope operator.


<init-class-variable>
The objects do 'not' contain data associated with class variable. When
initialized? The default constructor 'implicitly' default initialize
static-member-variable. The class-static <must-be-defined-and-inited> outside
of class because it's global objects.

// xxx.h
class Foo {
  private:
    static double interest;         // declare
};

// xxx.cpp
double Foo::interest = initRate();  // define and init


{class-const} EC++02
If it's const, it `limit the scope of a constant to a class` Ordinarily, class
static members may not be initialized in the class body. However, can be used
in-class-initializer. Hence it's called class-const and be static. Otherwise
got error:

usecomma.cpp:8:13: error: invalid use of non-static data member ‘Foo::MAX’

<in-h>
class Foo {
  private:
    static const double interest = 30;    // declaration. in-class-init. 
    double table[ interest ];             // can be used.
};

<in-cpp>
As with this example, if the only use is the context where the compiler can
substitute the member's value, then no need to define class-const. However,
           used in other context such as passing it to func arg, must define.

// definition and 'must' not init since an initializer is provided inside a
// class.

double Foo::interest;                     


After all, class-method and class-variable is to limit a scope of golbal
objects as with file or function static. The bottom line is that static is
global but we can limit its scope to file, class, or function.

1. SCOPE. easy access as global, no need to create an object to use, but in
the class scope.

2. created only when it is used. It is true for <function-static> in
{limit-the-number-of-object}.

3. to solve init-order-problem


={============================================================================
*kt_dev_cpp_0000* cpp-except

The exception are run-time anomalies that prevent the program from continuing
normally. Exception handling supports the cooperation between the detecting
and handling parts of a program. 

MEC++09: What's different to the approach of returning error code? 

  * Exception 'cannot' be 'ignored' and if do, it is terminated. 
  
  * From MEC++12. The execution return to call site for func call but never
    for exception when think that throw is a function call.

Exception handling involves:

  * throw expression
  * try blocks and catch clauses or exception handlers
  * exception classes


{form}

try {
  program-statements
} catch (exception-declaration) {
      handler-statments
} catch (exception-declaration) {
      handler-statments
}


{standard-exception}
Exception classes are defined in four headers.

  * exception header
    The C++ Standard library provides a 'base' class specifically designed to
    declare objects to be thrown as exceptions. It is called std::exception
    and is defined in the exception header. This class has a virtual member
    function called what() that returns a null-terminated character sequence
    and that can be overwritten in derived classes to contain some sort of
    description of the exception. 

  * stdexcept header
    The 'stdexcept' header defines several general purpose exception classes
    which are derived from std::exception.

  * new header
    Defines bad_alloc exception type.

  * typeinfo header
    Defines the bad_cast exception type. 

  <exception>
  /**
   *  @brief Base class for all library exceptions.
   *
   *  This is the base class for all exceptions thrown by the standard
   *  library, and by certain language expressions.  You are free to derive
   *  your own %exception classes, or use a different hierarchy, or to
   *  throw non-class data (e.g., fundamental types).
   */
  class exception
  {
  public:
    exception() _GLIBCXX_USE_NOEXCEPT { }
    virtual ~exception() _GLIBCXX_USE_NOEXCEPT;

    /** Returns a C-style character string describing the general cause
     *  of the current error.  */
    virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
  };
  
    note:
    what() returns "std::exception" when use "throw exception()"


  <stdexcept>

  // note:
  // exception takes message in ctor
 
  class logic_error : public exception;

  /** This represents an argument whose value is not within the expected
   *  range (e.g., boundary checks in basic_string).  */
  class out_of_range : public logic_error 
  {
  public:
    explicit out_of_range(const string& __arg);
    virtual ~out_of_range() _GLIBCXX_USE_NOEXCEPT;
  };

  class runtime_error : public exception 
  {
    string _M_msg;

  public:
    /** Takes a character string describing the error.  */
    explicit 
    runtime_error(const string& __arg);

    // note: see noexcept on dtor
    virtual ~runtime_error() _GLIBCXX_USE_NOEXCEPT;

    /** Returns a C-style character string describing the general cause of
     *  the current error (the same string passed to the ctor).  */
    virtual const char* 
    what() const _GLIBCXX_USE_NOEXCEPT;
  };


<ex>
#include <iostream>
#include <exception>

using namespace std;

class myexception: public exception
{
  virtual const char* what() const throw()
  {
    return "My exception happened";
  }
} myex;

int main () {
  try
  {
    throw myex;      // or throw myexception();
  }
  catch (exception& e)
  {
    cout << e.what() << '\n';
  }
  return 0;
}

My exception happened


All exceptions thrown by components of the C++ Standard library derived from
this exception class.  These are:

bad_alloc            thrown by new on allocation failure
bad_cast             thrown by dynamic_cast when it fails in a dynamic cast
bad_exception        thrown by certain dynamic exception specifiers
bad_typeid           thrown by typeid
bad_function_call    thrown by empty function objects
bad_weak_ptr         thrown by shared_ptr when passed a bad weak_ptr

Also deriving from exception, exception header defines two generic exception
types that can be inherited by custom exceptions to report errors:

logic_error          error related to the internal logic of the program
runtime_error        error detected during runtime


{stack-unwinding}
A `throw` acts like a return; statements following a throw are not executed.
If no 'matching' catch found, current/calling function is exited until found
one in the call tree.

If not found a matching catch and call 'terminate'. If found, run catch and
coutinue running from the the end of the try block catched but not the point
where throw is called.

When no try-catch block in the chain, 1,2, and 3 runs only.  

func3()              func2()                func1()
{                    {                      {
   (1)                   (2)                    (3)
   func2();              func1();               throw...;
   (6)                   (5)                    (4)
}                    }                      }


During stack-unwinding, function exits 'prematurely' and means local objects
are dstroyed and dtor is called.


={============================================================================
*kt_dev_cpp_019* except-dtor-ctor

{exception-in-ctor}
Partially constructed. Even if it's partially constructed, guaranteed that the
constructed members will be properly destroyed. From EC++30 p137 and see
{empty-ctor-represenstaion}

But from MEC++10, it shows many ways to handle exceptions in ctor so not sure
that it is properly destroyed. Seems EC++ is the latest.


{problem-of-exception-in-dtor} *stack-unwinding*
Why exception in dtor is the problem? Since stack-unwinding starts to find
matching catch and local objects are destroyed. If dtor of object being
destroyed can raise an execption, then would have two running exceptions and it
is not allowed in C++. EC++08 says that terminate is called or undefined.

The main problem is 'permature' termination which means 'no' chance to do useful
things as resource clean-up and making a log entry in handling exception or
before terminating or swallowing.  So premature termination means the undefined
state of an application or system.

So no exception in dtor and if necessary, should handle in the same dtor. This
is the base assumption STL has and STL guarantee that any class's dtor will not
raise an execption.


{exception-and-raii}
To handle exception, shall use resource-managing-class, RAII, since destruction
will be handled when do stack unwinding.


{how-to-handle-exeception-in-dtor}
See {raii-for-resource-using-own-interface} for other examples. From EC++08.
General recommendation is not to raise exception in dtor. If interface to use
comes from external source then it could raise an exception. What to do? These
are how to handle when exception happens in dtor.

// think this external source
class DBConnection {
  public:
    ...
    static DBConnection create();    // fatctory-func
    void close();                    // can throw exception
};

// resource managing class
class DBConn {
  public:
    ~DBConn() { db.close(); }

  private:
    DBConnection db;
};

// client use
{
  DBConn dbc( DBConnection::create() );
  ...
}

Two approach to address exception in dtor:

<1> terminate the program
By doing this, make a log entry to see and prevent undefined behavior.

DBConn::~DBConn()
{
  try{ db.close() }
  catch(...) {
    // make log entry
    std::abort();
  }
}

Can use {noexcept} at below? Seems not as it has the same effect when not
handling exaction from a dtor: no chance to do useful thing such as making a log
entry.

<2> swallow the exception
Can be used when the program must be able to continue execution even after
exception is happened.

DBConn::~DBConn()
{
  try{ db.close() }
  catch(...) {
    // make log entry
  }
}

<3> However, said that the better way is:

class DBConn {
  public:
    void close()
    {
      db.close();             // can exception happen
      closed = true;
    }

    ~DBConn() 
    { 
      if(!closed)
      {
        try { db.close(); }
        catch(...) {
          // make log enrtry
          // terminate or swallow
        }
      }
    }

  private:
      DBConnection db;
      bool closed;
};


The client have an opportunity to handle the exception and if the client choose
not to handle it then fall back to default action: terminating or swallowing. It
appears that it make raii less useful and pass the burden on to the client but
it is not since it gives them opportunity to handle.  it. See
{raii-and-exception-in-dtor} for the point to consider when use raii.

// client use
{
  DBConn dbc( DBConnection::create() );

  try{ dbc.close() }
  catch(...)
  {
    // try to address exception and if successful, set closed to true.
  }
}


{function-try-block}
CPR 773, 18.1.3 shows function-try to handle exception in construction or
destruction phase.

Since constructor initializers executes 'before' ctor body, exception handling
in ctor body cannot catch that.

* The members are initialised in the order of defined in class. covered by
  function-try-block.
* The parameters are copied using copy-ctor and if exception happens, covered in
  caller site.
* Runs constructor-initializers if there are. covered by function-try-block.
* Runs ctor-body. covered by function-try-block.

template< typename T>
Blob<T>::Blob( std::initialzer_list<T>il) : 
  data( std::make_shared< std::vector<T>> (il)) {}

template< typename T>
Blob<T>::Blob( std::initialzer_list<T>il) try : 
  data( std::make_shared< std::vector<T>> (il)) { /* empty body */ }
catch ( const std::bad_alloc& e) { handle_out_of_memory(e); }


{exception-object} user-defined-exception-object
The `throw` and `catch` expression use special-object, exception object. If it's
a class type, must be 'complete' type and have dtor and copy or move op. If it's
array or func type, it's converted to its pointer type. 

Because there's a stack-unwinding, must not to throw a pointer to a local
object. Hence exception object is 'copied' in space that is manintained by
compiler and remains vaild 'until' catched.

} catch (exception-declaration) {

Exception is like a functin call and exception declaration is like a function
  with one param. Like function call, catch 'parameter' can be non-refernce or
  reference. If it's class type from inheritance and non-reference then
  `sliced-off` can happen in `throw` and `catch` 

How can use reference in catch? Since there is separation between throw and
catch site. That is the exception object is held in 'global' space by a
compiler.

throw expr -> (copy init) -> exception object -> (copy init) -> catch (expr)

<ex>
#include <iostream>
using namespace std;

class B 
{
  public:
  B() { cout << "B ctor" << endl; }
  B(const B& b) { cout << "B copy ctor" << endl; }
  ~B() { cout << "B dtor" << endl; }
  virtual string what() { return "i'm B"; }
};

class CD : public B
{
  public:
  CD() { cout << "CD ctor" << endl; }
  CD(const CD& b) { cout << "CD copy ctor" << endl; }
  ~CD() { cout << "CD dtor" << endl; }
  string what() { return "i'm CD"; }
};

int main () {
  try
  {
    B b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (B e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

B ctor            // {
going to throw
B copy ctor                            // {  exception object
B dtor            // }
B copy ctor                // {
An exception occurred. Exception Nr. i'm B
B dtor                     // }
B dtor                                 // }
end

<exception-catch-by-reference>
The catch by referecne is recommendation.

* Catch by pointer, do not know if should call delete on it because do not know
  if it is created by new or not.
* Catch by value, sliced-off can happen.
* Catch by reference, okay for both problems above.

<ex> to show sliced-off.

int main () {
  try
  {
    CD b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (B e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

B ctor
CD ctor
going to throw
B ctor               // {  copy init for derived
CD copy ctor         // }
CD dtor
B dtor
B copy ctor
An exception occurred. Exception Nr. i'm B
B dtor
CD dtor              // { dtor for exception object
B dtor               // } 
end


<ex> to see when catch reference

int main () {
  try
  {
    CD b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (B& e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

B ctor
CD ctor
going to throw
B ctor
CD copy ctor
CD dtor
B dtor               // note to see there is no copy init for catch argument
An exception occurred. Exception Nr. i'm CD
CD dtor              // { dtor for exception object
B dtor               // } 
end


<ex> when throw base and catch derived

int main () {
  try
  {
    B b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (CD& e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

B ctor
going to throw
terminate called after throwing an instance of 'B'
Aborted (core dumped) 
  
note: the exception spec mismatches hence terminated.


<type-conversion-and-first-fit>
Restricted type conversion for exception. 

  * conversions from nonconst to const
  * conversions from derived to base type

No others are allowrd such as class type conversion.

Since catch uses the order of appearance in code, this is called first-fit
strategy compared to best-fit in function-matching. If use exceptions from an
inheritance, 'must' order from derived type to least derived.

  class logic_error : public exception;
  class invalid_argument : public logic_error;

try {
  ...
} catch ( logic_error& ex ) {
  ...
} catch ( invalid_argument& ex ) {
  ...
}

must be:

try {
  ...
} catch ( invalid_argument& ex ) {
  ...
} catch ( logic_error& ex ) {
  ...
}


<rethrow>
Partially handle the exception and may decide that the exception must be handled
by a function further up the call chain.

  * Do not specify an expression; the current exception object is passed up
  * Changes will be passed up only if catch uses a reference

catch (myerror& eobj) {
  eobj.status = errCodes::severeErr;
  throw;
}


<catch-all>
To catch all exceptions regardless of type. If used with other handlers, must be
the last one. Often used with rethrow.

catch (...)
{
  // work to partially handle the exception
  throw;
}


<exception-object-always-copied>
The execution returns to call site for func call but never for exception. This
means that whenever throw happens, a copy is 'always' made regardless of catch
type whether it is value or reference because throw leaves a call site. This is
natural since there should be execption object anyway.

// example-one
catch( Widget& w )
{
  ...
  throw;
}

Use 'current' exception and throw it again, rethrow. So there is no addtional
copy made and w can be a derived class in Widget inheritance.

// example-two
catch( Widget& w )
{
  ...
  throw w;        // see
}

This create a new Widget type exception and cost copy ctor and dtor even if
catch reference. Checked with code. Therefore, 'rethrow' recommended if
possible.


={============================================================================
*kt_dev_cpp_019* except-noexcept

{noexcept-specification}
A function can specify that it does not `throw` exception by providing a
noexcept specificaton.

void recoup(int) noexcept;    // won't `throw`
void alloc(int);              // might `throw`


Earlier C++ allowed us to specify the types of exception that a function might
throw and has been 'deprecated'. There is one use of the old scheme.

void recoup(int) noexcept;
void recoup(int) throw();     // equivalent declaration in earlier C++

note:
If the compiler knows that no exceptions will be thrown, can (sometimes) perform
'oprimizations' that must be supressed if code might throw.


{broke-exception-spec}
The compiler does 'not' check the `noexcept` specification at compile time and
as a result, possible that a function that claims it will not `throw` will in
fact throw. In that case, `terminate()` is called, thereby 'enforcing' the
promise not to `throw` at run time.

MEC++14. If there is a mismatch of 'spec' between throw and catch, permature
program-termination happens and This means no clean-up so should be avoided.

extern void f1();       // may throw anything
void f2() throw (int);  // says it will throw only int type exception

void f2() throw (int)
{
  ...
  f1();
  ...
}

By this, can wrap old code with new code that handles exception. But if f1()
  raise exception other than int type, 'violate' f2's exception specification.


<avoid-spec-mismatch>

* Do not mix template and exception spec because do not know T type so not able
  to write spec.

* Change default handler, unexpected(), to handle those. For example, if we use
  a library that raise unexpected exception:


<when-use-noexcpt>

* When absolutly sure that there's no exception.

* When don't know what to do or not possible to handle an exception. Exit the
  program.


<why-deprecated-and-dynamic>
From stl reference, p24. noexcept targets a lot of problems (empty) exception
specifications, throw(), have. (also lot of problems of specifying the spec)

1. Runtime checking: C++ exception specifications are checked at runtime rather
than at compile time, so they offer no programmer guarantees that all exceptions
have been handled. The runtime failure mode (calling std::unexpected()) does not
lend itself to recovery.

2. Runtime overhead: Runtime checking requires the compiler to produce
additional code that also hampers optimizations.

3. Unusable in generic code: Within generic code, it is not generally possible
to know what types of exceptions may be thrown from operations on template
arguments, so a precise exception specification cannot be written.

In practice, only two forms of exception-throwing guarantees are useful: 

An operation might throw an exception (any exception) or an operation will never
throw any exception. The former is expressed by omitting the
exception-specification entirely, while the latter can be expressed as throw()
  but rarely is, due to performance considerations.

Especially because noexcept does not require stack unwinding, programmers can
now express the nothrow guarantee 'without' additional overhead. As a result, the
use of exception specifications is 'deprecated' since C++11. 

note: additional overhead?


={============================================================================
*kt_dev_cpp_019* cpp-except-safety

C++PL 13.2

The library provides one of following guarantees for every library operation:

o. basic
For all operations. The basic invariants of all objects are maintained, and no
resources are leaked. 

o. strong
For key operations. In addition to providing the basic guarantee, either the
operation succeeds, or it has no effect. 

o. nothrow
For some operatins. In addition to providing the basic guarantee, some
operations are guaranteed not to throw an exception. 


{self-assign-exception-safe}
EC++29. Two requirements for exception safety when exception happens:

See *self-assign* for reasons why need to handle self-assign. Also if not, then
it's not exception safe as well. If this is exception safe, then lhs state
shouldn't change when new raise exception, but the below don't and the below
isn't exception safe.

// NO self-assign and exception-safe in valuelike case
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  delete ps;
  auto newp = new string(*rhs.ps);
  ps = newp;
  return *this;
}

// combine dtor and copy. handle self-assign and exception-safe by moving delete
// after new. careful-statement-ordering

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

EC++11. Making operator=() exception-safe typically renders it self-assign-safe
too. So think about exception-safe only. Alternatively, can use
*copy-and-swap-idiom* 

<ex>
// from the bad example
void PrettyMenu::changeBackGround( std::istream& imgSrc )
{
  Lock ml(&mutex);

  delete bgImage;
  ++imageChanges;
  bgImage = new Image(imgSrc);
};

// offer strong

class PrettyMenu {
  ...
  std::shared_ptr<Image> bgImage;
  ...
};

void PrettyMenu::changeBackGround( std::istream& imgSrc )
{
  Lock ml(&mutex);

  bgImage.reset( new Image(imgSrc) );  // bad_alloc or ctor exception
  ++imageChanges;
};

The deletion of old image takes place 'only' if the new image is successfully created because reset
will be called only if the parameter is successfully created.

note: This offers 'almost' strong guarantee and offers the basic exception since if the parameter
imgSrc constructor throws an exception, possible that the read marker for the input stream has been
moved and such movement would be a change in state visible to the rest of the program.

General design to lead to the strong guarantee: use {copy-and-swap-idiom} and {pimpl-idiom} in
*kt_dev_cpp_006* 

<copy-and-swap-idiom-case>
Make a copy and all changes to the copy. If any of the modifying operation throws an exception, the
original remains 'unchanged'. After all changes have been successfully completed, swap the modified
with the original in non-throwing swap operation.

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

HasPtr& HasPtr::operator=(const HasPtr rhs)  // note. not ref and it's copy
{
  ...                // operations to change the copy if there are more to do
  swap(*this, rhs);
  reutn *this;       // rhs is destroyed, which deletes the old ps.
}

<pimpl-idiom-case>
This is the same as copy-and-swap and is different from usual pimpl-idiom. The object has a pointer
to the implementation that has all object data. This can be rewritten as general design although
offer no better gurarantee than the previous for this particular example.

struct PMImpl {
  std::shared_ptr<Image> bgImage;
  int imageChanges;
};

class PrettyMenu {
  private:
    std::shared_ptr<PMImpl> pImpl;
};

void PrettyMenu::changeBackGround( std::istream& imgSrc )
{
  using std::swap;

  std::shared_ptr<PMImpl> pNew( new PMImpl(*pImpl) );

  pNew->bgImage.reset( new Image(imgSrc) );  // bad_alloc or ctor exception
  ++pNew->imageChanges;

  swap(pImpl, pNew);
};

<exception-safety-is-difficult>
Although copy-and-swap-idiom is a good way for strong but doesn't guarentee that the overall
function is strongly exception safe.

void someFunc()   // uses copy-and-swap
{
  ...
  f1();
  f2();
  ...
}

Although f1 and f2 provide strong exception, difficult to have strong for someFunc to guarantee
since the state of the program is not the same as it was when someFunc was called, even though f2
didn't change anything. f1 has strong exception but may change state.

Two reasons for difficulty:

1. side effect
As long as functions operate only on local state, relatively easy to offer the strong guarantee but
when on non-local data, it's much harder such as database.

2. efficiency
Copy and swap idiom requires more space and time.

<recommendation>
The strong guarantee is desiable but not always practical. Especially, when use third party or
legacy code which do not provide exception safety. In other words, can offer no stronger than the
weakest guarantee of the functions it uses.

Aim to provide basic guarantee which is resonable for many functions and think carefully about
strong safety: if it's practical in terms of efforts, cost in efficiency and complexity, how many
functions should have strong safety. 80-20 rule?


={============================================================================
*kt_dev_cpp_019* except-disable

<default-exception-handler>

class UnexpectedException { };

void convertUnexpected()
{ throw UnexpectedException(); }

set_unexpected( convertUnexpected );

This convert <all-unhandled-exception> to UnexpectedException and there should be catch for that
type. This means to set default exception handler.

OR

void convertUnexpected()
{ throw; }

set_unexpected( convertUnexpected );

This convert all to <bad_exception> but no detail about why. Q: why bad_exec?


{exception-cost}
MEC++15. Exception has cost:

1. If not use exception, can save speed and space penalty. There is compiler option to disable it.

2. the cost of try and exception spec in space varies from compiler to compiler. As a rough
estimate, expect your overall code size to increase by 5-10% and your runtime to go up by a similar
amount if you use try blocks. So try to 'minimise' the use.

<80-20-rule>
But think 80-20 rule and that exception is rare. The recommendation is that think if it is feasible
not to use exception, if can minimise, if can use other compiler showing better exception
implementation, and if use profiler to find out 20% to use exception.


<exception-to-disable>
From stackoverflow and said G++ specific.

Option #1: Simply never catch exceptions. {QQ} really?

Exceptions don't have much overhead when they're not thrown or caught; if you're throwing and not
prepared to catch, well, you're doing to die anyway, so the performance impact at that point is
trivial. Note also that stack unwinding will not be performed if an exception is not handled; the
program will simply terminate without performing stack unwinding.

It's important to note that, in G++, exceptions have almost no overhead when not actually thrown.
G++ generates extra information sufficient to trace back the execution of the program through the
stack, and some extra code to invoke destructors, etc - however none of this extra code or data is
ever used until an exception is actually thrown. So you should not see a performance difference
between code with exceptions enabled but not used and code with exceptions disabled (through
whatever mechanism).

Q: not sure it means never throw or never catch.

Option #2: Pass -fno-exceptions.

This flag instructs G++ to do two things:
http://gcc.gnu.org/onlinedocs/libstdc++/manual/using_exceptions.html

All exception handling in STL libraries are removed; throws are replaced with abort() calls Stack
unwind data and code is removed. This saves some code space, and may make register allocation
marginally easier for the compiler (but I doubt it'll have much performance impact).  Notably,
however, if an exception is thrown, and the library tries to unwind through
-fno-exceptions code, it will abort at that point, as there is no unwind data.

This will, effectively, turn all exceptions into abort()s, as you would like. Note, however, that
you will not be allowed to throw - any actual throws or catchs in your code will result in a
compile-time error.

Option #3: (Nonportable and not recommended!) Hook __cxa_allocate_exception.

C++ exceptions are implemented using (among others) the __cxa_allocate_exception and __cxa_throw
internal library functions. You can implement a LD_PRELOAD library that hooks these functions to
abort():

void __cxa_allocate_exception() { abort(); }
void __cxa_throw() { abort(); }

WARNING: This is a horrible hack. It should work on x86 and x86-64, but I strongly recommend against
this. Notably, it won't actually improve performance or save code space, as -fno-exceptions might.
However, it will allow the throw syntax, while turning throws into abort()s.


={============================================================================
*kt_dev_cpp_019* except-terminate-call-tree

#0  0x745911f4 in raise () from /lib/libc.so.0
#1  0x7458a884 in abort () from /lib/libc.so.0
#2  0x77d3a300 in __gnu_cxx::__verbose_terminate_handler() () from /lib/libstdc++.so.6
#3  0x77d37cc0 in ?? () from /lib/libstdc++.so.6
#4  0x77d37d14 in std::terminate() () from /lib/libstdc++.so.6
#5  0x77d37edc in __cxa_throw () from /lib/libstdc++.so.6
#6  0x7702ff5c in void zinc::detail::throwExceptionUsingTraits<DBus::ErrorNoReply>
    (char const*, std::map<std::string, std::string, std::less<std::string>, 
     std::allocator<std::pair<std::string const, std::string> > > const&) () 
    from /opt/zinc-trunk/lib/libZincDbusBindingRuntime.so.0


={============================================================================
*kt_dev_cpp_019* except-case

class BrokerException: public std::runtime_error
{
  public:
    BrokerException() : std::runtime_error("Error in MetadataBroker."){}

    BrokerException(std::string msg) : 
      std::runtime_error(msg)
  {}

    /** Explicit virtual destructor to control RTTI generation. */
    virtual ~BrokerException() throw();
};

class NetworkProblemException : public BrokerException
{
  public:
    /**  */
    NetworkProblemException (const std::string& mesg = "")
      : BrokerException(mesg)
      {}

    /** Explicit virtual destructor to control RTTI generation. */
    virtual ~NetworkProblemException() throw();
};

{
    try
    {
        throw NetworkProblemException("Error in somewhere");
    }
    catch(const ServiceNotFoundException& e)
    {
        URANIUM_ERROR("Caught ServiceNotFoundException. What = "<<e.what());
        //This is seriously wrong. We got events which don't belong to a known service.
        //Stop creating this window now.
        failEventWindowCreation(*command);
    }
    catch(const InvalidNullEventException& e)
    {
        URANIUM_ERROR("Caught InvalidNullEventException while retrieving \
                IP events. What = "<<e.what());
    }
    catch(const NS_COBALT_SYSTEM::InvalidResponseException& e )
    {
        URANIUM_ERROR("Caught NS_COBALT_SYSTEM::InvalidResponseException \
                while retrieving IP events. What = "<<e.what());
    }
    catch(const NS_COBALT_SYSTEM::TransientServerProblemException& e )
    {
        URANIUM_ERROR("Caught NS_COBALT_SYSTEM::TransientServerProblemException \
                while retrieving IP events. What = "<<e.what());
    }
    catch(const NS_COBALT_SYSTEM::InternalProblemException& e )
    {
        URANIUM_ERROR("Caught NS_COBALT_SYSTEM::InternalProblem while \
                retrieving IP events. What = "<<e.what());
    }
    catch(const NS_COBALT_SYSTEM::InvalidRequestException& e )
    {
        URANIUM_ERROR("Caught NS_COBALT_SYSTEM::InvalidRequestException \
                while retrieving IP events. What = "<<e.what());
    }
    catch(const NS_COBALT_SYSTEM::NetworkProblemException& e )
    {
        URANIUM_ERROR("Caught NS_COBALT_SYSTEM::NetworkProblemException \
                while retrieving IP events. What = "<<e.what());
    }
    catch(const std::exception& e )
    {
        URANIUM_ERROR("Caught std::exception. What = "<<e.what());
    }
    catch(...)
    {
        URANIUM_ERROR("Caught an exception while receiving IP events.");
    }
}


={============================================================================
*kt_dev_cpp_019* except-blanket catch and hidden exception

catch(ZINC_UNUSED const std::exception& e)
{
  ...
}

This seems like a rather blanket catch and could potentially catch some serious
exceptions that you don't intend on catching given the below comments. You
should be more specific in which exceptions you catch IMO.

There's a whole list of exceptions that could be thrown. Just because you're not
expecting it right now doesn't mean it won't happen in the future. I don't think
std::exception should be caught anywhere but say in a main message loop. It's
much harder to debug exceptions being 'hidden' like that, as what() is not
always likely to include a useful what().


={============================================================================
*kt_dev_cpp_019* except-and-finally

Q: There is no finally keyword in C++. What should you use instead? 
A: Allocate local objects whose destructors perform cleanup 


={============================================================================
*kt_dev_cpp_0000* cpp-code-check

... [0               (size-1)] size ...
    <------------------------>

Use the fact that the valid index is always < container.size(). When i equals
to size() is either empty or past end.

// to check if it is empty

void StrBlob::check(size_type i, const string &msg) const
{
  if( i >= data->size() )
    throw out_of_range(msg);
}

string& StrBlob::front()
{
  check( 0, "front on empty StrBlob" );
  return data->front();
};


// to check if it's beyond [0, size)

std::string &StrBlobPtr::deref() const
{
  // StrBlobPtr::check()
  auto p = check( curr, "dereference past end");
  return (*p)[curr];    // () is necessary since [] is higher than *
}


// to check if it's beyond the begin

The trick is that decrement curr 'before' calling check() and that way, if
curr is already 0, the value that we pass to check() will be a large positive
value representing an 'invalid' subscript since size_t is 'unsigned' number.

StrBlobPtr &StrBlobPtr::operator--()
{
  --curr;
  check(curr, "decrement past begin of StrBlobPtr");
  return *this;
}


={============================================================================
*kt_dev_cpp_022* cpp-inheri

The inheritance provides `overriding` and `polymorphism`.

{cpp-polymorphism}
Polymorphism is derived from a Greek words meaning "many forms".

Oppose to compile-time static binding, the compiler generates 'code' to decide
at run-time which function to call. This dynamic binding or virtual mechanism
based on the fact that the static and dynamic types of reference and pointers
can differ is how C++ supports polymorphism.

Polymorphism in general is when a piece of a program is designed to allow
multiple different types to be used in it.

`static-polymorphism` is a use of polymorphism that is determined when the
program is constructed (such as the Template system in C++). Once the program
is constructed, the choice is made and the type used is known.

`dynamic-polymorphism` is determined at run-time. (Such as a pointer to a base
    class that allows for descendant class pointers to be passed in. The base
    class provides the interface and the descendants implement that interface
    in different ways that are suitable to the specifics of the class.)
Decisions are made during run time that choose which type to pass.

The important distinction is deciding at construction (compile) or run-time.

Generally, a well designed static polymorphism performs better than dynamic,
so it is to be preferred when the design makes it possible. If the information
  to make a choice is not available until run-time, dynamic is the choice.

<from-python>
the meaning of an operation depends on the type of the objects being operated
on.

How? overloading and overiding


{static-dynamic-type}
The `dynamic-binding` at run-time so called `run-time-binding` because
`static-type` is different from `dynamic-type` 

pointer or reference of base class = derived class objects;
`static-type`                          `dynamic-type`

* This is an exception to normal type-match as this is a conversion between
  different types. See {type-match-exceptions}

* Do not know which object to bind until run-time. 

  "The `subobject` is key to how inheritance and dynamic-binding works. MEC++:
  inheritance give rise to pointer and reference with two different types:
  static and dynamic type."


{conceptual-structure-of-deirved-object}

| ----------- |
|  base part  |
| ----------- |
| drived part |   // non-static members
| ----------- |

Quote item; Bulk_quote bulk;

// implicit derived-to-base-conversion for ref and pointer.

Quote* p = &item;
p = &bulk;

Quote& r = bulk;

See followings when use p or r:

* Calls non-virtual funcs of base then get base version. `static-type`
* Calls virtual funcs of base then get derived version. `dynamic-type`
* Calls any func of derived then compile error. `static-type`
* Deference and copy then `sliced-off`. `static-type`

class Bulk_quote : public Quote {
  public:
    double net_price( std::size_t ) const override;
};

double print_total( ostream& os, const Quote& item, size_t n ) // Quote-reference
{
  double ret = item.net_price(n);                              // virtual-call
  os << ... ;
  return ret;
}

Quote item;
Bulk_quote bulk_item;

print_total( item );          // Quote version
print_total( bulk_item );     // Bulk version. dynamic-binding.


{sliced-off}
The `staic-binding` is done at compile-time. copy-ctor and copy-assign are
func calls and derived-to-base-conversion happens when base's copy-ctor and
copy-assign is called.

class Foo {
  Foo(const Foo&);
  Foo& operator=(const Foo&);
};

Quote item(bulk);         // sliced-off
item = bulk;              // sliced-off


<ex>
From MEC++33. When there are concrete classes like this:

base <- derived1
     <- derived2

The problem case is:

obj = obj;               // the same class. fine
baseobj = derivedobj;    // sliced-off
derivedobj = baseobj;    // compile error

// GCC
: error: no match for 'operator=' in 'lo = bo'
: note: candidate is:
: note: Derived& Derived::operator=(const Left&)
: note:   no known conversion for argument 1 from 'Base' to 'const Derived&'
note: this is a syn coy-ctor that a compiler created.

*baseptr = *baseptr;     // the same class. fine
*baseptr = *baseptr;     // diff. base = derived. sliced-off. 1)
*baseptr = *baseptr;     // diff. derived = base. 2) no-compile-error

Why different results, no comile error? Because a compiler use `static-type`
and only base part will be copied for 1) and 2).

So two problems here:

* The sliced-off with no comiple error can happen when use pointer
* Real programmers write code like this.

How can make it compile error to flag up two cases, 1) and 2), in compile
time?  That is to make it difficult to use incorrectly. 

TODO: So what's the solution? need to summarise the followings again.

<approach-one> 
Make operator= virtual. May thought it can use virtual mechanism. MEC++ said
that derived's version will be called and shall have the same params for virual
funcs. But the return can be different.

class Base {
private:
	Animal& operator=(const Base& rhs); 
	...
};

class Derived: public Base {
public:
	Derived& operator=(const Base& rhs);
	...
};

However, in GCC 4.6.3, the params of virtual function can be different and
derived's version is not called. Note: Q: Changed in C++11?

Note: MEC++ seems to be wrong as a compiler use static-type and base version
gets called. So don't need to consider.

Note: see {override-keyword} and need to sum up if needed.

<approach-two-and-three>
Make operator= private and protected. Do not work when *pbase1 = *base2;

sam_slice.cpp:16:8: error: 'Base& Base::operator=(const Base&)' is private
sam_slice.cpp:92:13: error: within this context

sam_slice.cpp:16:8: error: 'Base& Base::operator=(const Base&)' is protected
sam_slice.cpp:92:13: error: within this context

So not a solution.


<approach-to-make-abstract-class>
To remove sliced-off cases, make the base abstract and all derived on the same
level. MEC++ says it as make non-leaf classes abstract.

This only enables copys between objects in the same class whether it is via
object or pointer.

But MEC++ says it is more about uncovering the design need to have abstract
class out of derived classes.


{virtual-and-definition}
Ordinarily if we do not use a function, do not need to supply a definition for
that function. However `must define every virtual function` regardless of
whether it is used because do not know which version of a function is called
until run time. 

note: To make a vtable in compile time.


{virtual-and-resolution}
The compiler generates code to decide at run time which function to call when
a virtual function is called through a reference or pointer. This is run-time
binding and polymorphism in C++.


{preventing-inheritance}

* Use C++11 final keyward
class Last 'final' : Base { ... };

* Use private ctor. See {control-the-number-of-object}


={============================================================================
*kt_dev_cpp_022* cpp-inheri-virtual

MI and SI (single inheritance)

The problem is that a class inherit from the same base class more than once
and this means there are more than one subobject. Then what is the real
problem or consequence out of having more than one subobject?

From C++ Primer, p810, took this example from IO library:

basic_ios (ABC) <- istream <- iostream
                <- ostream <- iostream

basic_ios holds stream's buffer and state but iostream wants to use "the same
buffer and condition state for both reading and writing". If an iostream
object has two copies of its basic_ios, this 'sharing' is not possible.

That is, in iostream, cause ambiguity and can use both data using scope
specifier like istream::x and ostream::x. so real issue is 'sharing'

To solve this, use `virtual-inheritance` and this shared base class is called
a virtual-base-class. How? makes only 'one' shared subobject for that virtual
base class.


class istream : 'virtual' public basic_ios {};
class istream : virtual public basic_ios {};
class iostream : public istream, public ostream {}; 

From EC++40, p193,

This problem is called "deadly-MI-diamond" Problems? 'ambiguity' and
  'replication' in the derived. C++ takes 'no' position on virtual inheritance
  problem. (checked with VC and no errors when there's a deadly MI diamond)
  and its default is to perform the replication. 

However, VI 'costs' in size, speed and initialization problem. So
recommendation is don't use VI unless you need to.

<syntax>
Which one is right to have public inheritance from Y and Z?

class X : public Y, Z {
  ...
};

class X : public Y, public Z {
  ...
};


see *cpp-incomplete-type* on why every virtual functio shall be defined.


={============================================================================
*kt_dev_cpp_022* cpp-inheri-ctor-init

{cpp-init-order-class}
nonvirtual base classes are initialized in `left-to-right` order as they are
declared.

// EXC++47
class Array : private ArrayBase, public Container
{
  Array (size_t startingSize = 10)
    : Container (startingSize),
    ArrayBase (Container::GetSize()) {}       // *cpp-error*
};

That means it's trying to use a member of the not-yet-initialized Container
base subobject.


<1>
Unless we say otherwise, the base part of a derived is 'default' initialized.

The usual way is:

class Disc_quote : public Quote {
  public:
    Disc_quote(const std::string& book, double price, std::size_t qty, double disc):
      Quote(book, price), quantity(qty), discount(disc) {}

};

If omit base ctor, then base part, Quote, is default-init.

class Disc_quote : public Quote {
  public:
    Disc_quote(const std::string& book, double price, std::size_t qty, double disc):
      quantity(qty), discount(disc) {}

};


<2> when there are class member data

class ZINC_LOCAL DispatchingEventProducer : virtual public EventProducer 
{
  public:

    // note: "impl(dispatcher_)" shows that calls ctor on member data
    //
    explicit DispatchingEventProducer(boost::shared_ptr<EventDispatcher>
        dispatcher_) : impl(dispatcher_) {}

  private:
    mutable detail::DispatchingEventProducerHoisted impl;
};

class DispatchingEventProducerHoisted : boost::noncopyable 
{
public:

	explicit DispatchingEventProducerHoisted
       (boost::shared_ptr<EventDispatcher> dispatcher_);
   ...
};


<3>
As for ctor, 'copy' controls must explicitly call base part and otherwise has
'oddly configured' object such as the derived part copied as expected but the
base part 'default'-init. note: dtor is the only exception that do only for its
own part.

class Base {
  public:
    Base(int val) { ... }
};

class Left: public Base {
  public:
    Left(int val) {}
    ...
};

sam_slice.cpp: In constructor 'Left::Left(int)':
sam_slice.cpp:27:32: error: no matching function for call to 'Base::Base()'

Because Base has another ctor so default-ctor will not be made and shows this
error.


{call-base-in-virtual-of-derived}
Use scope operator. This is called circumventing the virtual mechanism; base version do work common
to all types and the derived version do whatever additional work.

class Window {
  public:
    virtual void onResize() { ... }
    ...
};

class SpecialWindow: public Window {
  public:
    virtual void onResize()
    {
      Window::onResize();
      ...
    }
};


{base-class-pointer-container} {RTTI} <problem-one>
MEC++03: In inheritance, base pointer can point to derived class and when passes
a array of derived instead of base, <undefined-result> can happen.

class BalancedBST: public BST { };

void printBSTArray(ostream& s, const BST array[], int numElements)
{
  for (int i = 0; i < numElements; ++i) {
    s << array[i]; // this assumes an operator<< is defined
  } 
} // for BST objects

Because array[i] is *(array+i) and means can end up with wrong place. This warning applies to
deleting arrays like: delete [] array;

{Q} what is the real problem here? how does it relate to base class pointer? 

<problem-two> when use dynamic_cast
EC++27. Use smart-pointers to base to access 'any' possible derived class. Only SpecialWindow
support blinking. Means that need to have to check its type at rumtime.

class Window { ... }
class SpecialWindow: public Window {
  public:
    void blink( ... );
    ...
};

typedef std::vector<std::shared_ptr<Window>> VPW;
                                    ^^^^^^
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{
  if( SpecialWindow* psw = dynamic_cast<SepecialWindow*>( iter->get() ) )
  {                        ^^^^^^^^^^^^
    psw->blink();
  }
}

Undesirable because dynamic_cast is slow and also need to know to which type the object should be
cast since dynamic_case 'must' refer 'complete' object. Means already you know what it is.


<problem-three>
From MEC++33: when showing virtual operator= to support mixed type assign in inheritance.

Derived& Derived::operator=(const Base& rhs)      # virtual member op
{
	 const Derived& rhs_derived = dynamic_cast<const Derived&>(rhs);

	 // proceed with a normal assignment of rhs_derived to left *this
}


<solution-one> type-safe container

typedef std::vector<std::shared_ptr<SpecialWindow>> VPW;
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{ >
  (*iter)->blink();
}

Remove dynamic_cast BUT limited to SpecialWindow only. Not other possible derived class.


<solution-two> use virtual func in the hierarchy

class Window { 
  public: >
   virtual void blink {}      // def-impl. do-nothing
};

class SpecialWindow: public Window {
  public: >
   virtual void blink( ... ); // do real work
};

typedef std::vector<std::shared_ptr<Window>> VPW;
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{ >
   (*iter)->blink();
}


={============================================================================
*kt_dev_cpp_022* cpp-access-control

<member-access-specifier>
Members after a `private` specifier are accessible to the member functions of
the class but are not accessible to code that uses the class. The `private`
section encapsulate the implementation.

A derived class 'may' access the `public` and `protected` members of its base
class. `cannot access private of its base class.`


<derivation-access-specifier>
Access to a member that a class inherits is controlled by a combination of the
`member-access-specifier` in the base class and the
`derivation-access-specifier` in the derivation list.

The derivation-access-specifier `do not affect access of base class` in the
derived class. The purpose of `derivation-access-specifier` is to control the
access that "`users-of-derived-class` including other classes derived from the
derived class" have to the members inherited from base class.

This has `no effect on the single inheritance` which is between direct base and
the derived. If omits this, it will be private by default. 

class Base {
  public:
    void pub_mem();
  protected:
    int prot_mem;
  private:
    char priv_mem;
};

struct Pub_Derv : public Base {
  // can access pub_mem, prot_mem but cannot access priv_mem.
};

struct Priv_Derv : private Base {
  // can access pub_mem, prot_mem but cannot access priv_mem.
  // regardless of derivation, cannot access priv_mem. derivation doesn't affect
  // in the derived class.
};


However, that affects `users-of-derived-class`

Pub_Derv d1;
Priv_Derv d2;

d1.pub_mem();
d2.pub_mem();     // error, pub_mem is `private` in the derived class

struct Derived_from_Private : public Priv_Derv {
  // error, prot_mem is `private` in Priv_Derv
  int use_base() { return prot_mem; }
};


<on-derived-base-conversion>
As with this, this remains the same when derived to base conversion happens.
That is: 

User code may use the derived to base conversion only if inherits publicly
from base and may not for other derivations.


<cpp-access-error>

class Base { virtual void dummy() {} };
class DerivedPub: public Base { int a; };
class DerivedPri: private Base { int a; };

// okay
Base * pdd1 = new DerivedPub;

// error
Base * pdd2 = new DerivedPri;

t_cast.cpp: In function ‘void t_cast_01()’:
t_cast.cpp:17:23: error: ‘Base’ is an inaccessible base of ‘DerivedPri’
     Base * pdd2 = new DerivedPri;
                       ^

={============================================================================
*kt_dev_cpp_022* cpp-cast cpp-named-cast
  
EC++27 minimize casting, MEC++02 

These casts are called named cast and these provides:

o. Easier-to-recognise style in code both for humans and for tools.

o. The more narrowly specified purpose and precision of meaning. 
   Better for a comipler to diagnose usuage errors.


{careful-about-cast}

<ex>
Uses function style cse. The both do exactly the same although doesn't feel
like a cast.

doSomething(Widget(15));
doSomething(static_cast<Widget>(15));


<do-not-assume-how-things-are-laid-out>
C++ can have an object that might have more than one address; that is when
pointed by a Base* pointer and when pointed by Derived*. This cannot happen in
C and other lanauages.

Derived d;
Base *pb = &d;

Sometimes, a base class pointer and derived class pointer values will not be
the same. When that's the case, an offset is applied at runtime to the
Derived* pointer to get the correct Base* pointer value. DO not use "I know
how things are laid out" casts.


<cast-means-more-code>
The cast do nothing but tell compilers to treat one type as another? Mistaken
since type conversion often lead to 'additional' code that is executed at
runtime. 

int x, y;
...
double d = static_cast<double>(x)/y;

Use division but use floating point division.


<cast-create-a-temp-object> 
Assume that a virtual function in derived class call their base class
counterparts first.

class Window 
{
  virtual void onResize() {...}
};

class SpecialWindow : public Window 
{
  public:
    virtual void onResize()
    {
      static_cast<Window>(*this).onResize();
      ...
    }
    ...
};

It does call onResize but on the temp object. WHY? The solution is:

class SpecialWindow : public Window 
{
  public:
    virtual void onResize()
    {
      Window.onResize();
      ...
    }
    ...
};


<cast-is-expensive>
The dymamic_cast is expensive and slow since often is implemented using string
comparison in the hierarchy. The compier supports 'upcast' that is implicit
derived-to-base conversion so a base pointer can point either base object and
derived object. How to know which? 

The need for dynamic cast arises when want to use derived class ops on what
you believe to be a derived class objects 

"via base pointer or reference." ??? 

This example is repeated in *kt_dev_cpp_022* inheritance

class Window { ... };
class SpecialWindow: public Window {
  public:
    void blink();
};

typedef std::vector< std::shared_ptr<Window>> VPW;
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{
  if( SpecialWindow *psw = dynamic_cast<SpecialWindow*> (iter->get()))
    psw->blink();
}

Here used dymamic_cast to meet the condition which only derived class supports
blink(). To avoid this dymamic_cast, two approaches:


<solution-one>
typedef std::vector< std::shared_ptr<SpecialWindow>> VPW;

But, do not support all possible window derivatives.

<solution-two>
Use virtual mechanism. 

class Window {
  public:
    virtual void blink() {}     
    // default impl is no-op. see *kt_dev_ecpp_010* for why it can be a bad idea
};

class SpecialWindow : public Window {
  public:
    virtual void blink() { ... }
};

<other-things-to-remember>
Avoid cascading dynamic cast and try to hide cast inside a function.

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{
  if( SpecialWindow1 *psw = dynamic_cast<SpecialWindow1*> (iter->get()))
    psw->blink();
  else if( SpecialWindow2 *psw = dynamic_cast<SpecialWindow2*> (iter->get()))
    psw->blink();
  ...
}


{cpp-cast-read}
http://www.cplusplus.com/doc/tutorial/typecasting/

<implicit-conversions-with-classes>
In the world of classes, 'implicit' conversions can be controlled by means of
three member functions:

  Single-argument constructors *cpp-single-ctor* allow implicit conversion
  from a particular type to initialize an object.  

  Assignment operator: allow implicit conversion from a particular type on
  assignments.  

  Type-cast operator: allow implicit conversion to a particular type.
  *cpp-converting-op*


#include <iostream>
using namespace std;

class A {};

class B {
  public:
    // conversion from A (constructor):
    B (const A& x) {}

    // conversion from A (assignment):
    B& operator= (const A& x) {return *this;}

    // conversion to A (type-cast operator)
    operator A() {return A();}
};

int main ()
{
  A foo;
  B bar = foo;    // calls constructor
  bar = foo;      // calls assignment
  foo = bar;      // calls type-cast operator
  return 0;
}

The type-cast operator uses a particular syntax: it uses the operator keyword
followed by the destination type and an empty set of parentheses. Notice that
the return type is the destination type and thus is not specified before the
operator keyword.


<type-casting>
C++ is a strong-typed language. Many conversions, specially those that imply a
different interpretation of the value, require an 'explicit' conversion, known
in C++ as type-casting. There exist two main syntaxes for generic
type-casting: functional and c-like:

double x = 10.3;
int y;

y = int (x);    // functional notation
y = (int) x;    // c-like cast notation

The functionality of these generic forms of type-casting is enough for most
needs with fundamental data types. 

However, these operators can be applied indiscriminately on classes and
pointers to classes, which can lead to code that - while being syntactically
correct - can cause runtime errors. For example, the following code compiles
'without' errors: 

// class type-casting
#include <iostream>
using namespace std;

class Dummy {
  double i,j;
};

class Addition {
    int x,y;

  public:
    Addition (int a, int b) { x=a; y=b; }
    int result() { return x+y;}
};

int main () {
  Dummy d;
  Addition * padd;
  padd = (Addition*) &d;
  cout << padd->result();
  return 0;
}

The program declares a pointer to Addition, but then it assigns to it a
reference to an object of another 'unrelated' type using explicit
type-casting:

`unrestricted explicit` type-casting allows to convert any pointer into any
other pointer type, independently of the types they point to. The subsequent
call to member result will produce either a run-time error or some other
unexpected results.

In order to control these types of conversions 'between' classes, we have four
specific casting operators: dynamic_cast, reinterpret_cast, static_cast and
const_cast. Their format is to follow the new type enclosed between
angle-brackets (<>) and immediately after, the expression to be converted
between parentheses.

dynamic_cast <new_type> (expression)
reinterpret_cast <new_type> (expression)
static_cast <new_type> (expression)
const_cast <new_type> (expression)

The traditional type-casting equivalents to these expressions would be:

(new_type) expression
new_type (expression)

but each one with its own special characteristics:


<cpp-cast-dynamic-cast> 
dynamic_cast can only be used `with pointers and references to classes` (or
    with void*). Its purpose is to ensure that the result of the type
conversion points `to a valid complete object` of the destination pointer
type.

This naturally includes pointer 'upcast' (converting from pointer-to-derived
    to pointer-to-base), in the same way as allowed as an implicit conversion.
DONE BY COMPILER.

But dynamic_cast can also 'downcast' (convert from pointer-to-base to
    pointer-to-derived) `polymorphic classes (those with virtual members)`
`if-and only if` the pointed object is a valid 'complete' object of the target
type. For example:

#include <iostream>
#include <exception>

// g++ -g -std=c++0x t_sp.cpp

using namespace std;

class Base { virtual void dummy() {} };
class DerivedPub: public Base { int a; };
class DerivedPri: private Base { int a; };

void t_cast_01 () {
  try {
    DerivedPub dp1;

    // upcast
    Base * pba = new DerivedPub;

    Base * pbb = new Base;

    Base * pb;
    DerivedPub * pd;

    // derived to derived, okay.
    pd = dynamic_cast<DerivedPub*>(pba);
    if (pd==0) cout << "Null pointer on first type-cast.\n";

    // downcast, base to derived, fails.
    pd = dynamic_cast<DerivedPub*>(pbb);
    if (pd==0) cout << "Null pointer on second type-cast.\n";

    // upcast, derived to base, fails. WHY??
    // see EXC++44 for more examples which do not match up with what see here.

    pb = dynamic_cast<Base*>(pba);
    if (pd==0) cout << "Null pointer on third type-cast.\n";
    pb = dynamic_cast<Base*>(&dp1);
    if (pd==0) cout << "Null pointer on forth type-cast.\n";

  } catch (exception& e) {cout << "Exception: " << e.what();}
}

Null pointer on second type-cast.
Null pointer on third type-cast.
Null pointer on forth type-cast.
=== end of main

Compatibility note: This type of dynamic_cast requires RTTI to keep track of
dynamic types. Some compilers support this feature as an option which is
disabled by default. This needs to be enabled for runtime type checking using
dynamic_cast to work properly with these types.

The code above tries to perform two dynamic casts from pointer objects of type
Base* (pba and pbb) to a pointer object of type Derived*, but only the first
one is successful. Notice their respective initializations:

Even though both are pointers of type Base*, pba actually points to an object
of type Derived, while pbb points to an object of type Base. Therefore, when
their respective type-casts are performed using dynamic_cast, pba is pointing
to a full object of class Derived, whereas pbb is pointing to an object of
class Base, which is an incomplete object of class Derived.


<for-pointer>
When dynamic_cast cannot cast a pointer because it is not a complete object of
the required class, it 'returns' a null pointer to indicate the failure. 

<for-reference>
If dynamic_cast is used to convert to a reference type and the conversion is
not possible, an exception of type `bad_cast` is thrown instead.

dynamic_cast can also perform the other implicit casts allowed on pointers:
casting null pointers between pointers types (even between unrelated classes),
        and casting any pointer of any type to a void* pointer.


<cpp-cast-static-cast>
static_cast converts 
  o. between `related types` such as one pointer type to another in the same
     class hierarchy,
        
  o. an integral type to an enumeration, or a floating-point type to an
     integral type

  o. conversions defined by constructors and conversion operators.

  o. from void* to any pointer type. In this case, it guarantees that if the
  void* value was obtained by converting from that same pointer type, the
  resulting pointer value is the same.


<cpp-cast-reinterpret-cast>
reinterpret_cast converts 
  o. between `unrelated types` such as integer to a pointer or a pointer to an
  unrelated pointer type.
  
The conversions that can be performed by reinterpret_cast but not by
static_cast are low-level operations based on reinterpreting the binary
representations of the types, which on most cases results in code which is
system-specific, and thus non-portable. For example:

class A { /* ... */ };
class B { /* ... */ };
A * a = new A;
B * b = reinterpret_cast<B*>(a);

This code compiles, although it does not make much sense, since now b points
to an object of a totally unrelated and likely incompatible class.
Dereferencing b is unsafe.

The other example is that it peforms a low-level reinterpretation of the bit
pattern of its operands.

int *p;
char *pc = reinterpret_cast<char*>(ip);


{cpp-cast-const-cast}
This manipulates the constness of the object pointed by a pointer, either to
'set' or to 'remove'. For example, in order to pass a const pointer to a
function that expects a non-const argument:

<remove-const-cast>

#include <iostream>
using namespace std;

void print (char * str)
{
  cout << str << '\n';
}

int main () {
  const char * c = "sample text";
  print ( const_cast<char *> (c) );
  return 0;
}

The example above is safe because function print does not write to the pointed
object. 


<cpp-const-undefined> *cpp-undefined*
After removing the constness of a pointed object, writing to it causes
'undefined' behavior since compiler store it in read-only memory as an
optimisation.


<set-const-cast>
From CPR 233, const_cast is most useful in the conext of overloaded functions.

const string &shorterString( const string &s1, const string &s2 )
{
  return s1.size() <= s2.size() ? s1 : s2;
}

string &shorterString( string &s1, string &s2 )
{
  auto &r = shorterString(const_cast<const string&>(s1), 
                          const_cast<const string&>(s2));

  return const_cast< string& >(r);
}

This is safe to cast the const string back to a plain string and return it
because it is one of original nonconst arguments.


{cpp-cast-error}

sanitizer_symbolizer_posix_libcdep.cc:78:77: 
error: ISO C++ forbids casting between pointer-to-function and pointer-to-object [-Werror]
   swift_demangle_f = (swift_demangle_ft)dlsym(RTLD_DEFAULT, "swift_demangle");
                                                                             ^
cc1plus: all warnings being treated as errors


// As of now, there are no headers for the Swift runtime. Once they are
// present, we will weakly link since we do not require Swift runtime to be
// linked.
typedef char *(*swift_demangle_ft)(const char *mangledName,
                                   size_t mangledNameLength, char *outputBuffer,
                                   size_t *outputBufferSize, uint32_t flags);
static swift_demangle_ft swift_demangle_f;

// This must not happen lazily at symbolication time, because dlsym uses
// malloc and thread-local storage, which is not a good thing to do during
// symbolication.
static void InitializeSwiftDemangler() {
  swift_demangle_f = (swift_demangle_ft)dlsym(RTLD_DEFAULT, "swift_demangle");
}


// to get around this
static char *(*`swift_demangle_f`)(const char *mangledName,
                                   size_t mangledNameLength, char *outputBuffer,
                                   size_t *outputBufferSize, uint32_t flags);

From C99 spec, section 6.2.5, paragraph 27:

    A pointer to void shall have the same representation and alignment
    requirements as a pointer to a character type. Similarly, pointers to
    qualiﬁed or unqualiﬁed versions of compatible types shall have the same
    representation and alignment requirements. All pointers to structure types
    shall have the same representation and alignment requirements as each
    other. All pointers to union types shall have the same representation and
    alignment requirements as each other. `pointers to other` types need not
    have the same representation or alignment requirements.

So no; no guarantee that a void * can hold a function pointer(pointers to
    other).

And section 6.3.2.3, paragraph 8:

    A pointer to a function of one type may be converted to a pointer to a
    function of another type and back again; the result shall compare equal to
    the original pointer.

implying that one function pointer type can hold any other function pointer
value. Technically, that's not the same as guaranteeing that function-pointer
types can't vary in size, merely that their values occupy the same range as
each other.


={============================================================================
*kt_dev_cpp_022* cpp-rtti

{rtti} CPR 19.2 825
The RTTI(run-time type identification) is provided through two operators:

* `typeid` operator, which returns the type of a given expression
* `dynamic_cast` operator, which 'safely' coverts base type pointer or reference
  into ones to a derived type

These operators are useful when we have a derived operation that we want to
perform through a pointer or reference to a base type and it is not possible to
make that operation a virtual function since when the operation is virtual, the
compiler automatically selects the right function.

note:
Ordinarily, 'should' use virtual 'functions' if we can since RTTI is more
error-prone and the programmer must know to which type the object should be cast
and must check that the cast was successful.


{dynamic-cast}
Has following forms:

dynamic_cast<type*>(e);
dynamic_cast<type&>(e);
dynamic_cast<type&&>(e);

The type e must be either a class type that has at least one 'virtual'
functions, is publicly derived from the target type, a public base class of the
target type, or the same as the target type.

note:
This means to support dynamic type since if the type has 'no' virtuals, then it
is static type and compiler knows that at compile time, also to support upcast
and downcast in the inheritance hirachacy.


If e has one of these types, the the call will succeed. Otherwise, the cast
fails and the result is 0. If the cast to a reference type fails, throws an
`bad_cast` exception.


if (Derived *dp = dynamic_cast<Derived*>(bp))
{
  //
} else {
  //
}

note:
By defining the variable in a condition, do the cast and check as a single
operation. Moreover, dp is not accessible outside the if. If the cast fails,
  then the unbound pointer is not available.


{cpp-typeid}
The `typeid` allows to check the type of an expression or type name.

typeid (e);

This operator returns a reference to a constant object of type `type_info` that is
defined in the standard header typeinfo. A value returned by typeid can be
compared with another value returned by typeid using operators == and != or can
serve to obtain a null-terminated character sequence representing the data type
or class name by using its name() member.

<ex>
Derived *dp = new Derived;
Base *bp = dp;

// compare the type of two objects at run-time
if (typeid(*bp) == typeid(*dp)) {
  //
}

// test whether the run-time type is a specific type
if (typeid(*bp) == typeid(Derived)) {
  //
}

// typeid(bp) retuns static type and this check always fails
if (typeid(bp) == typeid(Derived)) {
  //
}


{using-rtti}
An example when RTTI might be useful. Consider a class hierarchy for which
implements the equality operator. Equals if they have the same type an same
value for data members. Each derived type may add its own data members.

Use virtual equality operator that operates on reference to the base type?

This strategy doesn't quite work since virtual function must have the same
parameter type in hierarchy and which is a reference to the base type. This
means that equal function could use 'only' members from the base type.

class Base {
  friend bool operator==(const Base&, const Base&);

  public:
    //
  protected:
    virtual bool equal(const Base&) const;
};

class Derived : public Base {
  protected:
    virtual bool equal(const Base&) const;
};


// return false if typeids are different; otherwise makes a virtual call to
// equal.

bool operator==(const Base &lhs, const Base &rhs)
{
  return typeid(lhs) == typeid(rhs) && lhs.equal(rhs);
}

// the cast always succeed since type check is done already. Why do dynamic cast
// then? Because needs to access the members of rhs but not funtions.

bool Derived::equal(const Base& rhs) const
{
  auto r = dynamic_cast<const Derived&>(rhs);

  // do whatever is required to compare two objects.
}

bool Base::equal(const Base& rhs) const
{
  // do whatever is required to compare two objects.
}


{typeinfo}
The exact definition of the type_info varies by compiler but the standard
gurantees that the class will provide at least the operations:

t1 == t2
t1 != t2
t.name();
t1.before(t2);

The string returned by member name of type_info depends on the specific
implementation of your compiler and library. The only guarantee is that it
returns a unique string for each type.

<ex>
#include <iostream>
#include <typeinfo>

using namespace std;

int main () {
  int *a, b;
  a=0; b=0;
  if (typeid(a) != typeid(b))
  {
    cout << "a and b are of different types:\n";
    cout << "a is: " << typeid(a).name() << '\n';
    cout << "b is: " << typeid(b).name() << '\n';
  }
  return 0;
}

// on GCC 4.6.3, VM.
a and b are of different types:
a is: Pi
b is: i

// on the text.
a and b are of different types:
a is: int *
b is: int  


<ex>
// typeid, polymorphic class
#include <iostream>
#include <typeinfo>
#include <exception>
using namespace std;

class Base { virtual void f(){} };
class Derived : public Base {};

int main () {
  try {
    Base* a = new Base;
    Base* b = new Derived;
    cout << "a is: " << typeid(a).name() << '\n';
    cout << "b is: " << typeid(b).name() << '\n';
    cout << "*a is: " << typeid(*a).name() << '\n';
    cout << "*b is: " << typeid(*b).name() << '\n';
  } catch (exception& e) { cout << "Exception: " << e.what() << '\n'; }
  return 0;
}

// on GCC 4.6.3, VM.
a is: P4Base
b is: P4Base
*a is: 4Base
*b is: 7Derived

// on the text.
a is: class Base *
b is: class Base *
*a is: class Base
*b is: class Derived

Notice how the type that typeid considers for pointers is the pointer type
itself, static type. However, when typeid is applied to objects typeid yields
their dynamic type.

If the type that typeid evaluates is a pointer preceded by the dereference
operator (*), and this pointer has a null value, typeid throws a bad_typeid
exception.


={============================================================================
*kt_dev_cxx_0000* cxx-override

{problem-when-override-do-not-work}
Believe that made an override and expect that derived version gets called. no
compile error and why? Two things:

#include <iostream>

// g++ -g -std=c++0x t_override.cpp

using namespace std;

class B0 {
  public:
    virtual int foo() { cout << "B0::foo" << endl; }
};

class D1 : public B0 {
  public:
    int foo(int) { cout << "D1::foo(int) " << endl; }
};

// = 01 ======
// B0::foo

// No override since it do not meet *cxx-override-condition* Hence no vtable
// update and base version called.

void t_override_01()
{
    D1 dobj;
    B0* p = &dobj;
    p->foo();
}

// t_override.cpp: In function ‘void t_override_02()’:
// t_override.cpp:92:12: error: no matching function for call to ‘D1::foo()’
//      p->foo();
//             ^
// t_override.cpp:92:12: note: candidate is:
// t_override.cpp:14:9: note: int D1::foo(int)
//      int foo(int) { cout << "D1::foo(int) " << endl; }
//          ^
// t_override.cpp:14:9: note:   candidate expects 1 argument, 0 provided
//
// Effectively defines a new function in the derived, inner scope, name found
// and stops lookup. so hide the name in the base in *cxx-name-lookup* 
//
// Q: ?? As EC++33 said, since not use some overloads in the derived class due
// to hide, it also break "is-a" relationship.

void t_override_02()
{
    D1 dobj;
    D1* p = &dobj;
    p->foo();
}
 
int main()
{
    cout << "= 02 ======" << endl;
    t_override_02();

    cout << "= 01 ======" << endl;
    t_override_01();
}


{cpp-override-condition}
To override:

  name, parameter type, `const`, and return type should be the 'same'. 

An exception to this when return type is a pointer or reference.
See *cpp-overload-condition*

However, tried pointer return type, no errors so return type in overrides can
be different only that is pointer. See p606 in ref-CPR.


#include <iostream>

// g++ -g -std=c++0x t_override.cpp

namespace OR2 {

using namespace std;

class B0 {
  public:
    virtual int foo() { cout << "int B0::foo()" << endl; }
};

class D1 : public B0 {
  public:
    bool foo() { cout << "bool D1::foo() " << endl; }
};

class D2 : public D1 {
  public:
    int foo() { cout << "bool D2::foo() " << endl; }
};

}


// t_override.cpp:33:10: error: conflicting return type specified for ‘virtual bool OR2::D1::foo()’
//      bool foo() { cout << "bool D1::foo() " << endl; }
//           ^
// t_override.cpp:28:17: error:   overriding ‘virtual int OR2::B0::foo()’
//      virtual int foo() { cout << "int B0::foo()" << endl; }
//                  ^
// t_override.cpp:38:9: error: conflicting return type specified for ‘virtual int OR2::D2::foo()’
//      int foo() { cout << "bool D2::foo() " << endl; }
//          ^
// t_override.cpp:33:10: error:   overriding ‘virtual bool OR2::D1::foo()’
//      bool foo() { cout << "bool D1::foo() " << endl; }
          ^
void t_override_03()
{
    using namespace OR2;

    D2 dobj;
    D2* p = &dobj;
    p->foo();
}


{override-keyword} {final-keyword}
*problem-when-override-do-not-work* is surprisingly hard(really?) to find
because there is no compile error. To avoid this, use override keyword from
*C++11* and cause compile error when it's not overrided:

using namespace std;

class Base {
  public:
    virtual int fcn() { cout << "base: fcn" << endl; }
};

class D1 : public Base {
  public:
    int fcn(int) override { cout << "d1  : fcn(int) " << endl; }
};

class D2 : public D1 {
  public:
    int fcn() { cout << "d2  : fcn" << endl; }
};

int main()
{
  D1 d1obj;
  Base* bp = &d1obj;
  bp->fcn();
}

:12:9: error: ‘int D1::fcn(int)’ marked override, but does not override
     int fcn(int) override { cout << "d1  : fcn(int) " << endl; }
         ^

The final-keyword is used to end override as with final-keyword in inheritance.


{cxx-override-access-control} *cpp-access-control*
override do not respect access-control in derived class.

namespace OR3 {

using namespace std;

class B0 {
  public:
    virtual int calls_public() { cout << "B0::calls_public" << endl; }
    virtual int calls_private() { cout << "B0::calls_private" << endl; }
    virtual int calls_protected() { cout << "B0::calls_protected" << endl; }
};

class D1 : public B0 {
  public:
    int calls_public() { cout << "D1::calls_public" << endl; }
  protected:
    int calls_private() { cout << "D1::calls_private" << endl; }
  private:
    int calls_protected() { cout << "D1::calls_protected" << endl; }
};

}

// = 04 ======
// D1::calls_public
// D1::calls_protected
// D1::calls_private

void t_override_04()
{
    using namespace OR3;

    D1 dobj;
    B0* p = &dobj;
    p->calls_public();
    p->calls_protected();
    p->calls_private();
}


{further-references}
EC++33. do not find any useful or practical.
EC++36. If you redefine nonvirtual, as you seen, it hides names. The other
problem is to exhibit 'inconsistent' behavior depending on type of pointer
used.

class D: public B {
  public:
    void mf();
};

D x;
B* pB = &x; D* pD = &x;

pB->mf();      // same object but B::mf
pD->mf();      // same object but D::mf


{which-virtuals}
EC++34 

When design classes, should think 'three', pure virtual, virtual, and
non-virtual, separately to specify with precision what you want derived
classes to inherit.

* Pure virtual (abstract). To have 'only' interface inherited. interface
  inheritence. 

* (Simple) virtual (overridable). To have interface and 'default'
  implementation.


{no-separation-between-interface-and-default-implementation}
When use simple virtual, shall be careful since 'default' implementation is
inherited without 'request' from the derived. This can be a problem when the
derived not to redefine it.

class Airplane {
  public:
    virtual void fly( const Airport& destination ) 
    { // code for usual plane type. default; }
    ...
};

class ModelA : public Airplane { ... };
class ModelB : public Airplane { ... };
class ModelC : public Airplane { ... };

Although this is classic OOD, has a problem. This is okay for model A and B but
not C because C is different type of plane that has different way to fly and
should have defined own fly(). 

*cpp-remember* pure-virtual-can-force
If C has forgot to redefine own, it will use the default. The solution is to
'force' the derived explicitly request implementation if they need.


<1> use ABC
Has separation between interface and default implementation.

class Airplane {
  public: >
    virtual void fly( const Airport& destination ) = 0;  // pure and interface
    ...
  protected:
    void defaultFly( ... );                              // implementation
};

void Airplane::defaultFly( ... )
{
   // code for usual plane type. default;
}

class ModelA : public Airplane {
  public:
    virtual void fly( ... ) { defaultFly( ... ); }    // explicit request
};

class ModelC : public Airplane {
  public:
    virtual void fly( ... ) { specific code for model C type }
};

If forget to redefine ModelC::fly then will get errors in compile time because
cannot create ModelC objects. That's because ModelC is ABC.


<2> <pure-virtual-can-have-implementation> 
Use the fact that pure virtual can have its implementation.

class Airplane {
  public: >
    virtual void fly( const Airport& destination ) = 0; // make a pure
};

// pure virtual implementation
void Airplane::fly( ... )
{
   code for usual plane type. default.
}

class ModelA : public Airplane {
  public:
    virtual void fly( ... )  { Airplance::fly( ... ); }  // explicit
};

class ModelC : public Airplane {
  public:
    virtual void fly( ... ) { specific code for model C type }
};

The both approaches are the essentially same in that force the derived to
override, to request default implementation and if not override, emits errors.


<3>
nonvirtual (non-overridable). invariant `over specialization.` To have
interface and 'mandatory' implementation that is default implementation but
not overridable. 


={============================================================================
*kt_dev_cxx_0000* cxx-override-ref: C++ under the hood, Scott Meyers

http://www.han-ese.nl/~ewout/ESE/INF2/CPP_onder_de_motorkap.pdf

Overview

This talk offers a detailed look at how C++ compilers typically implement
language features, focusing on the cost of those features - or, more
typically, the lack thereof - compared to equivalent functionality in C. It
begins with an extremely detailed examination of the implementation of virtual
functions under both single and multiple inheritance, explaining how
performance considerations have influenced both the design and implementation
of this language feature. It then moves to an overview of the implementation
of all other features of C++, dividing them into "no-cost" and "low-cost"
categories. The information in this paper is an overview of more detailed
information covered in the conference presentation.

Implementing Virtual Functions

Given a class such as this,

class B {
  public:
    B();
    virtual ~B();                            // 0
    virtual void f1();                       // 1
    virtual int f2(char c) const;            // 2
    virtual void f3(const std::string& s);   // 3
    void f4() const;
};

Compilers number the virtual functions in the order in which they are
encountered. Different compilers may start the numbering with different
values, but it's common to start counting at 0. Assuming 0 is the initial
value, the virtuals in B would be numbered as indicated by the comments. Note
that neither B's constructor nor its member function f4 receive numbers.
That's because they're not virtual functions, hence are implemented
differently - like non-member functions, which themselves are implemented like
functions in C.

`For each class with at least one virtual function`, compilers generate a
virtual function table, `vtbl`. A vtbl is an array of function pointers such
that the n th entry of the table points to the implementations of the virtual
function numbered n. B's vtbl would look like this:

B's vtbl []    -> impl of B::~B
         []    -> impl of B::f1
         []    -> impl of B::f2
         []    -> impl of B::f3

In the case of pure virtual functions, there is typically no implementation to
point to. In that case, the vtbl slot for the function generally points to a
compiler-generated function that, when called, issues a runtime error message
(e.g., "Pure virtual function called") and exits the program. 

Consider now a derived class D :

class D: public B {
  public:
    D();                          // nonvirtual  - no number
    virtual ~D();                 // redefined   - number 0 (as in base class)
    virtual void f1();            // redefined   - number 1 (as in base class)
    virtual void f5(char *str);   // new virtual - number 4
};

Compilers set up a vtbl for D in the same way they do for B, except that when
D redefines a virtual function it inherits, that function gets the same number
in D as in B. D's vtbl thus looks like this:

D's vtbl []    -> impl of D::~D
         []    -> impl of D::f1
         []    -> impl of B::f2
         []    -> impl of B::f3
         []    -> impl of D::f5

Note that in cases where D inherits its virtual function implementations from
B, D's vtbl points to functions implemented in B. This reveals that the cost
of a virtual function call is independent of the depth of the hierarchy. At
runtime, when a virtual is to be called, there is no need to search the
hierarchy for the "right" implementation, because the hierarchy was flattened
during construction of the vtbls.  

Every object of a class with at least one virtual function contains a virtual
table pointer, `vptr`. This pointer is added by the compiler, and its location
may vary from compiler to compiler. An object's vptr points to the vtbl
appropriate for the type of the object; compilers automatically insert code to
achieve this into constructors and destructors. note: to set vptr. At runtime
we could have the following situation where all B objects have a vptr pointing
to B's vtbl and all D objects have a vptr pointing to D's vtbl:

For the following C++ source code,

void makeACall(B *pB)
{
  // call the implementation of f1 appropriate for whatever type of object pB
  // points to

  pB->f1(); 
} 

Compilers emit code equivalent to this:

(*pB->vptr[1])(pB); 

Call the function pointed to by vtbl entry 1 (f1's number/index) in the vtbl
pointed to by pB->vptr; pass pB as the "this" pointer

// this means that the code to select 1 entry in the vtbl is done at compile
// time but still need to decide what pB actually points at runtime.
// "pass pB as the "this" pointer"


Virtual Functions Under Multiple Inheritance

Under multiple inheritance (MI), a new issues arises: a single object has
multiple addresses, and different addresses need to be passed to different
functions. For example, suppose D has two base classes

class B1 { ... };
class B2 { ... };
class D: public B1, public B2 { ... };

A D object can be pointed to by pointers of any of three different types
(excluding void*): B1*, B2*, or D*. 

At runtime, such an object is likely to be laid out in memory like this, where
the diagram shows where pointers of each of these different types point:

B1*, D* ->  B1 data
B2*     ->  B2 data
            D data

Given these functions,

void f(B1 *pb1);  // expects pb1 to point to the top of a B1
void g(B2 *pb2);  // expects pb2 to point to the top of a B2

consider:

D *pd = new D;    // pD points to top of object

// fine, f expects a pointer to top of object
f(pd);            

// pointer adjustment required : g expects a pointer to B2 part of object
g(pd);            

In fact, offset adjustments may be necessary even for something as simple as a
pointer initialization:

B2 *pb2 = pd;     // pb2 should point to B2 part of object, not to top


Unfortunately, the need for an offset adjustment may not be determinable
during compilation. For example, given this hierarchy

class B1 {
  public:
    virtual void mf();     // may be overridden in derived classes
};

class B2 {
  public:
    virtual void mf();     // may be overridden in derived classes
};

and this implementation of g,

void g(B2 *pb2)
{
  pb2->mf();               // offset adjustment required?
}

The this pointer passed to mf may or may not require an offset adjustment. If
the mf called is implemented in B2, no adjustment is needed, but if the mf
called is implemented in B1 or D, an adjustment typically is required. During
compilation, however, there is no way to know the type of object pb2 points
to, hence no way to know which implementation of mf is being called.

<key> Compilers 'solve' this problem by creating 'extra' vptrs and vtbls in MI
hierarchies. In particular a class with n 'base' classes can be expected to
give rise to objects with n vptrs and n vtbls, e.g.:

note: this means extra vptr and vtbl entry(trunk) for each additional 'base' class
note: Here again, single inheritance means one level of inheritance so single inheritance is
different from single hierachy of inheritance.

B1*, D* ->  B1/D vptr   -> D vtbl [] impls of virtuals declared in B1 or D (and maybe B2)
            B1 data
B2*     ->  B2 vptr     -> D as B2 vtbl [] impls of virtuals declared in B2
            B2 data
            D data

When compilers generate code for a call to a virtual function, they 'know'
which vptr they are using hence where the object pointer currently points and
they know which vtbl they are using hence the this pointer expected by the
function pointed to by each vtbl entry, so they can determine whether an
offset adjustment is required for the call.


The code for the offset adjustment itself is typically placed in a thunk 
- a small piece of code not part of any function. Vtbl entries 'requiring'
offset adjustments then point to thunks, and thunks forward calls to the
target function implementation after performing the offset:

<key> 
In the above example, called g(B2*) with D and D's version should be called.
However, B2's vtable entry has B2's version and so update that entry with
trunk which adjust this to D and call D's version. See <understand-trunk> for
more. Thunks themselves are often implemented as alternative vtbl function
entry points:

This treatment of the implementation of virtual functions under MI is still
incomplete, because it fails to take into account the possibility of virtual
base classes, but, as Stan Lippman comments in Inside the C++ Object Model ,
     "Virtual base class support wanders off into the Byzantine...The material
     is simply too esoteric to warrant discussion...." 

However, one thing should be clear: virtual functions are implemented very
efficiently. In fact, their implementation is both smaller and faster than
most C approximations (e.g., anything based on cascading if/then/else type
    tests).

note: this article has lots of references to refer to when necessary.


={============================================================================
*kt_dev_cpp_023* cpp-class-model

EC++32, 38, 39

{is-a-model} `public-inheritance` EC++32
The base represent a more 'general' concept than the derived since the derived
represent a more `specialised concept.` Means that can use the derived where
the base can be used and means anything that is true of the base is also true
of the derived.

Think this example and is it right 'relationship' in C++?

class Square : public Rectangle;
class Bird : public Penguin;

No. English is different from C++


<implementation-inheritance-interface-inheritance>

EXPC++22

Never use public inheritance except to model ture `is-a-model` or
`works-like-a-model`. All overridden member functions must require no more and
promise no less. same semantic.


note:
CodeComplete p144. LSP (Liskov Substitution Principle) All the routines
defined in the base class should mean the same thing when they are used in
each of derived classes. Semantic meaning. Reduce complexity. 


{has-a-model} EC++38
The composition has other synonyms such as containment, aggregation, or
membership. `is-implemented-in-terms-of-model` is spelled either private
inheritance or membership.

<ex> `has-a-model` composition
This is a composition in application domain and says that Person 'has' a name. 

class Person {
  public:
    ...
  private: >
   std::string name;             // composition
   Address address;
   PhoneNumber voiceNumber;
   PhoneNumber faxNumber;
};


<ex> `is-implemented-in-terms-of-model`
Suppose that need to implement template class that supports no duplicates and
std::set is an option. However, set is fast but has space overhead per element
but space is more important for your applicaion. Then can we use std::list
instead? 

template<typename T>
class Set: 'public' std::list<T>;

We 'cannot' use `public-inheritance` since it is not `is-a-model` and
std::list can have duplicates. The right way is to implement by using it and
this is a composition in implementation domain.

template<class T>
class Set {
  public:
    bool member( ... ) const;
    void insert( ... );
    void remove( ... );
    std::size_t size() const;

  private: >
    std::list<T> rep;
};

template<typename T>
bool Set<T>::member( const T& item ) const
{
  // is there find member function in list? no.
  return std::find( rep.begin(), rep.end(), item ) != rep.end() );
}

template<typename T>
void Set<T>::remove( const T& item )
{
  typename std::list<T>::iterator it = std::find( rep.begin(), rep.end(), item );
  
  if( it != rep.end() ) rep.erase(it);
}

template<typename T>
void Set<T>::insert( const T& item )
{
   if( !member(item) ) rep.push_back(item);
}

template<typename T>
std::size_t Set<T>::size() const
{
  return rep.size();
}


{private-inheritance} EC++39
The private inheritance is implementation inheritance; inherits
impelementation only but not interface which means
`is-implemented-in-terms-of-model` 

The composition is also is-implemented-in-terms-of so which do we need to use
between them? 'prefer' composition whenever possible. 

Assume Widget class needs to keep track of how many times each member func is
called and periodically examine the information. Can redefine that virtual
function so that it examines the current state of the Widget.

class Timer {

  public:
    explicit Timer( int tickFrequency );
    virtual void onTick() const;
};

class Widget : 'public' Timer { ... };

No as Widget is not a timer and is not `is-a-model`.

class Widget : 'private' Timer {

  private:
    virtual void onTick() const;
    ...
};


Instead, can use composition approach.

class Widget {

  private:

    class WidgetTimer: public Timer {
      public:
        virtual void onTick() const;
        ...
    };

    WidgetTimer timer;
    ...
};


<cpp-prevent-derivation>
When derives a class from Widget but want that class do not redefine onTick?
Not possible using private inheritance. So the composition is an approach
before C++11 to prevent derivation and final keyword in C++11.


{compositions-over-private}

* If use composition approach, takes out WidgetTimer out of Widget, and use
  pointer instead, then can minimize compilation dependency since otherwise
  inheritance must see base class definition. Timer's definition. No need to
  include Timer header in Widget user.
 
* The composition is eaiser to understand.

Use `private-inheritance` only when is absolutely necessary; when need to
access protected area of the base and to redefine virtual functions of base
but no conceptual relationship. 

CodeComplete(p143) PI violates encapsulation and tends to point to design
errors that should be resolved.


={============================================================================
*kt_dev_cpp_023* cpp-class-model avoid-public

EXC++23. How to avoid public-inheritance using template-pattern 
See *cpp-pattern-nvi* and *cpp-ex-query-example*

class GenericTableAlgorithm
{
  public:
    GenericTableAlgorithm(const string& table);
    virtual ~GenericTableAlgorithm();

    // it does all the work:
    //
    // a) physically reads the table's records, calling Filter() on each to
    // determine whether it should be included in the rows to be processed 
    //
    // b) when the list of rows to operate upon is complete, call ProcessRow()
    // for each row.

    bool Process();

  private:
    virtual bool Filter(const Record&);
    virtual bool ProcessRow(const PrimaryKey&) = 0;

    struct GenericTableAlgorithmImpl* pimpl_;
};

// client or other developer's code to extend worker class

class MyAlgorithm : 'public' GenericTableAlgorithm
{
  // override Filter() and ProcessRow() to implement a specific operation
};

class YourAlgorithm : 'public' GenericTableAlgorithm
{
  // override Filter() and ProcessRow() to implement a specific operation
};


// client code

int main()
{
  MyAlgorithm a("Customer");
  a.Process();

  or

  YourAlgorithm a("Customer");
  a.Process();
}

Uses two pattern:

  * The `cpp-pattern-pimpl` hides the implementation behind an opaque pointer
    so that any changes to them will not require client code to compile.
    Called `compiler-firewall-idiom` and `opaque-pointer` is a pointer to a
    declared but undefined class.

    struct XxxxImpl; XxxxImpl* pimpl_;

  * *cpp-pattern-template-func*


<no-inheritance>

This holds two responsibilities, two users, to support different audiences.

  "Always give each piece of code-module, class, function - a single,
  well-defined responsibility."

* Client code uses the algorithm. `interface`

* Code to extend GenericTableAlgorithm for specialized specific case or usage.
  `implementation`


// one: `public interface for user` and use *cpp-pattern-pimpl* to remove
// compile dependancy. 

class GTAClient;

class GenericTableAlgorithm
{
  public:
    GenericTableAlgorithm(const string& table
                          `GTAClient& worker`);

    // Have separated away the inheritance relationship so the dtor doesn't need
    // to be virtual.
    ~GenericTableAlgorithm();

    // Does all the work; calling Filter() and ProcessRow()
    bool Process();

    struct GenericTableAlgorithmImpl* pimpl_;
};


// two: concrete implementation detail class for writers to extend

class GTAClient
{
  public:
    virtual ~GTAClient() = 0;
    virtual bool Filter(const Record&);
    virtual bool ProcessRow(const PrimaryKey&) = 0;
};

class MyWorker : public GTAClient
{
  // override Filter() and ProcessRow() to implement a specific operation
}

class YourWorker : public GTAClient
{
  // override Filter() and ProcessRow() to implement a specific operation
}

int main()
{
  GenericTableAlgorithm a("Customer", MyWorker());
  a.Process();
}

The good things are:

* Any interface changes to GenericTableAlgorithm does 'not' affect the concrete
  worker class at all since not in the inheritance.

* Any protocal changes to GenericTableAlgorithm such as additional arguments
  to Filter() or ProcessRow()? Not affect external users.
 
* Any concrete worker class can be used with any other algorithm using
  Filter()/ProcessRow() interface.

*cpp-remember*
Remember the computer science motto:
  "Most problems can be solved by adding a level of indirection."


<to-further>
As GenericTableAlgorithm do not have member data, it does not need to keep
'state' across invocations. So could replace it with function.

bool GenericTableAlgorithm(const string& table, GTAClient& worker)
{
  // contents of Process()
}

int main()
{
  GenericTableAlgorithm("Customer", MyWorker());
}


Further, if worker object never need to store state, all instances are
functionally equivalent and provide only virtual functions, then:

template<typename GTACworker>
bool GenericTableAlgorithm(const string& table)
{
  // contents of Process()
}

int main()
{
  // `cpp-template-explicit-argument`
  GenericTableAlgorithm<MyWorker>("Customer");
}


={============================================================================
*kt_dev_cpp_023* cpp-class-model not-abuse-inheritance

EXC++24.

Always minimise "coupling". The inheritance is strongest and tightly coupling.
Second to friendship. Should use `containment` to avoid needless coupling and
dependencies if can express a class relationship using it.

<when-abuse-inheritance>
template <class T>
class MyList
{
  public:
    bool    Insert( const T&, size_t index );
    T       Access( size_t index ) const;
    size_t  Size() const;

  private:
    T*      buf_;
    size_t  bufSize_;
};

Two ways to write a MySet `is-implemented-in-terms-of` MyList;
`nonpublic-inheritance` and `containment`.

nonpublic-inheritance make using class depend on public and protected area and
containment make is on only public.


template <class T>
class MySet1 : private MyList<T>
{
  public:
    bool    Add( const T& );            // calls Insert()
    T       Get( size_t index ) const;  // calls Access()

    // to make Size() public
    using MyList<T>::Size;

    // ...
};

template <class T>
class MySet2
{
  public:
    bool    Add( const T& );            // calls impl_.Insert()
    T       Get( size_t index ) const;  // calls impl_.Access()
    size_t  Size() const;               // calls impl_.Size()
    // ...

  private:
    MyList<T> impl_;
};


The containment is `has-a`, `composition`, `delagation`, and the inheritance is
a superset of single containment since it has a subobject.


<when-inheritance-appropriate>
When use nonpublic inheritance? To use override. Even when it is the case, can
avoid this.


class Base
{
  public:
    virtual int Func1();
  protected:
    bool Func2();
  private:
    bool Func3();   // uses Func1
};


To get the right behavior, need to override Func1. Allows Derived to override
Func1 but grants access to Func2 to all members of Derived. Needless made all
Derived's members depend upon Base's protected interface.

class Derived : private Base
{
  public:
    int Func1();
    // some of functions use Base::Func2 and some of which don't
};


Introduce as much couling as really need; "require no more and promise no less"

class DerivedImpl : private Base
{
  public:
    int Func1();
    // functions that use Func2
};

class Derived
{
  // functions that don't use Func2
  private:
    DerivedImpl impl_;
};


this is much better since:

* Separates and encapsulates the dependencies on Base.

* Follows `one-class-one-resposibility` guideline; coustomizing Base and
  implementaimplementing itself in-terms-of Base.

* Allows multiple copiles of helper(like DerivedImpl) class.

note:
This is similar to `cpp-pattern-pimpl` but not to reduce compiler dependancy.


<containment-in-generic-way>
Again, back to MySet example. It is `implentable-in-terms-of any class` that
supports the required functions that we need than MyList only.

Different user code may choose to instantiate MySet using implementations with
different performance characteristics. Write code that does many more inserts
than searches and want to use an implementation that optimizes inserts.

Difficult to have this flexibility with inheritance since it fix an
implementation decision at design time.

template <class T, class Impl = MyList<T>> 
class MySet3
{
  public:
    bool    Add( const T& );            // calls impl_.Insert()
    T       Get( size_t index ) const;  // calls impl_.Access()
    size_t  Size() const;               // calls impl_.Size()
    // ...

  private:
    Impl impl_;
};


note:
*cpp-queue* *cpp-stack* uses this technique which are implemented of in terms
of deque.


={============================================================================
*kt_dev_cxx_0000* cxx-pattern-template-method

EC++35

The design pattern [REF003] called it `template-method` and define skeleton of
an algorithm in an operation.

Deferring 'some' steps to subclass without default implementation of some
steps. Must be overridden.

<ex>
Application framework where application subclass application and document to
suit speficif needs. For example, a drawing application defines
DrawApplication and DrawDocument subclass.

Document                Application
+Save()                 +AddDocument()
+Open()                 +OpenDocument()
+Close()                +DoCreateDocument()*        // virtuals
+DoRead()*              +CanOpenDocument()*
                        +AboutToOpenDocument()*

MyDocument              MyApplication
+DoRead()               +DoCreateDocument()         // return new MyDocument
                        +CanOpenDocument()
                        +AboutToOpenDocument()

// this is template method which is non-virtual
void Application::OpenDocument( const char* name ) {
  if( !CanOpenDocument(name)) {
    // cannot handle this document
    return;
  }

  // *cxx-pattern-factory-func* to create application specific document
  Document* doc = DoCreateDocument();  

  // steps
  if(doc) {
    _docs->AddDocument(doc);
    AboutToOpenDocument(doc);
    doc->Open();
    doc->DoRead();
  }
}


* Without chaning the algorithm's structure, the template-method defines steps
  in terms of abstract operations that subclass override to provide concrete
  behavior. `define invariant parts once` and `leave variant part to subclass.`

* Refactoring. To avoid code duplication, identify the differences among
  existing subclasses and then separate the differences into new operations,
  replace the differing code with a template method(in base) that calls one of
  these new operations. This is also about code resuse but difference is
  steps, that is template method(function).

* Hook operations.


<cpp-pattern-nvi>
EC++35. In the following example, different character may calculate their
health in different ways. Use virtual? This is alternatives to usual virtual
design. Called NVI(non-virtual interface) idiom as a public non-virtual in the
base call a 'private' virtual func that can be redefined but it's little more
than window dressing as still use virtuals. 

  "HOW and WHEN: template-method means that base controls when and derived
  control how."

note: EC++ limits template method when it uses private virtual and EXPC++ p84
also says "avoid public virtial functions; prefer using the template method
pattern instead."


class GameCharacter {
  public:
    int healthValue() const
    {
      // do before stuff 
      int retVal = doHealthValue();
      // do after stuff
    }

  private:     // note: see this is private and {text-query-example}
    virtual int doHealthValue() const
    {
      // default calc code
    }
};

class XGameCharacter : public GameCharacter;

The base defines before and after stuff and when to call the derived part that
is the derived dependent. The before and after can be lock/unlock, logging,
   pre/post condition.

note:
For primitive operation which should be overridden, often prefix names with
Do: DoRead as DoCreateDocument shown above.


<hook-operation>
To 'extend' parent class operation. But it is esay to forget to call the
inherited function so can use template-method to give the parent class a
control over how subclasses extend it. This is called hook-operation. 

virtual void DerivedClass::Operation() {
  ParentClass::Operation();
  // additional
}

void ParentClass::Operation() {
  // parent class behavior
  HookOperation();
}

virtual void ParentClass::HookOperation() { }

virtual void DerivedClass::HookOperation() {
  // derived class extension
}


<private-or-protected>
As *cxx-override-access-control* override do not respect access control.
However as with hook to call base function, access control do matter when call
base version.

class Window {
  private:
    virtual void onResize() { ... }
    ...
};

class SpecialWindow : public Window {
  public:
    virtual void onResize() {
      Window::onResize();
      // additional to the derived
    }
    ...
};

: In member function 'virtual void Derived::doMorePri()':
:26:16: error: 'virtual void Base::doMorePri()' is private
:51:20: error: within this context


={============================================================================
*kt_dev_cxx_0000* cxx-pattern-pimpl cpp-minimise-compile-time

*cpp-encapsulation*

CPR 270. The benefits of encapsulation.

* The implementation of an encapsulated class can change over time without
  requiring changes in user code. User code needs to change only when the
  interface changes.

* The data are protected from mistakes that users might introduce. If there is
  a bug that corrupts an object's state, the place to look for the bug are
  localized and limited.


EC++31: minimize compilation dependencies 

Two cases can cause complilation dependency problem:

* Class interface changes which means header file changes.
* No separation between interface and implementation in class definition which
  means header file changes.

The `implementation separation` can be achieved when use function tables which
has a set of fixed interfaces and this is often done via registration. Such as
OS abstraction or driver abstraction which happens when porting.
 
But, how to handle when interface changes? For example, when replace graphic
library which has different interfaces. Usually talk about how to design
interfaces for user but if user uses it everywhere and replace library, need
to find every place using it. If there is a single point or file to use
interfaces then better to cope with changes? More about C. 

This item is to reduce compliation dependancy by separating interface from
implementation and this happens because C++ isn't very good at separating
interface from implementation.


{problem}

// person.h
class Person {
  public:
    Preson( const Date& birthDay, const Address& addr );
    std::string name() const;
    ...

  private:
    std::string theName;
    Date theBirthDate;
    Address theAddress;
};

`member data is implementaion` details and need class definition such as Date
to compile. Hence headers of these class are needed:

// person.cpp
#include <string>
#include "date.h"
#include "address.h"

This cause `cascading-compilation-dependencies`. Suppose if this Date or
Address class changes then classes using one of these should be compiled all
over again.

date.h    -- persoh.h -- xxx.cpp that use person class. 
address.h --          -- xxx.cpp
                      -- ...

* Any files using Person class as well even if not use member functions using
  Date or Address.

* No interface change. If only change implementation like adding or removing
  memeber data, will cause to compile every cpp files that includes person.h. 

Can use `forward-declaration` to avoid this? NO because cannot create an object
since the compiler cannot know the size of p and how big a Person object is. 


class Date;
class Address;

class Person {
  private:
      std::string theName;
      Date theBirthDate;
      Address theAddress;
};

Person p(params);    // define a person object

sam01.cpp:10:10: error: field ‘theBirthDate’ has incomplete type
sam01.cpp:11:13: error: field ‘theAddress’ has incomplete type


<solution>
* Decouple interface from implementation 
 
* Use dependencies on declaration than definition. This moves from
  dependencies-on-definition to dependencies-on-declaration


<ex>
STL uses this approach: Two header files.

<iosfwd> has declaration only
<sstream> <streambuf> <fstream> <iostream> are all implementation files


{cxx-pattern-pimpl} AKA `cpp-handle-class`. 

// See {exception-safe} in *kt_dev_cpp_019* Have two classes. One is what client
// use and has a pointer to implementation. 
>
Use the fact that compiler has no problem to get size of built-in types like
pointer. No definition needed.

* Use built-in types such as reference and pointer.
 
* Need only 'declaration' for member function which uses a class as argument or
  return by value because the definition is needed only when 'call' a func or
  'define' a func. So if Date class changes then only need to recompile clients
  that actually uses them but not all clients. See *cpp-forward-declaration* 
 
Date today(); void func(Date d);

No Date definition is needed to declare these function. This removes
dependency on definition and client should include necessary headers to
'actually' call these.


// person.h, interface class
class PersonImpl; // forward-declaration
class Date;
class Address;

class Person {
  ...
  private:
    std::shared_ptr<PersonImpl> pImpl;    // set pimpl
};


// personimpl.h, implementation class
Both class must have the same interface. If add or remove member data; changes
implementation, no need to compile clients.


// person.cpp, interface class
#include "person.h"
#include "personimpl.h"    // for Impl class

Person::Person(...) : pImpl( new PersonImpl (...) ) {}   // create-and-set-impl

std::string Person::name() const                         // forwarding
{ return pImpl->name(); }


<summary>
(client)    (interface class)                (impl. class)
use         interface: no virtuals           interface
            set impl in ctor.                has real impl. and can use other
            ptr to impl                      classes as Date and Address 
                                             in this example.

                                             (subclassing)

note:
* If impl class changes, need to change only cpp file of interface class but
  not clients.

* How about subclassing impl class to have other impls? okay.


EXC++27-31

The *cpp-pattern-pimpl* has advantages:

* Breaks compile-time dependencies.

has costs in performace:

* Each construction/destruction must allocate/deallocate memory.
* At least one extra indirection and size overhead.
 

EXC++29

What should go into Impl class from interface or visual class?

1. Put all private data (but not functions) into Impl.
2. Put all nonvirtual private members into Impl.
3. Put all private and protected members into Impl.

`Put all nonvirtual private members and private data` into Impl class since
client code shouldn't and doesn't care about these parts and protected and
virtuals to be seen and used by derived class.


={============================================================================
*kt_dev_cxx_0000* cxx-pattern-interface

Similar to JAVA's interface but C++ one can have data or func implementation.
Use ABC and interface class can have only interfaces or interface and default
implementation.

class Person {                      // class IPerson(ABC)
  public:
    virtual ~Person();              // see 'virtual'
    virtual std::string name() const = 0; 
    virtual std::string birthDate() const = 0; 
    virtual std::string address() const = 0; 
    ...
    // *cxx-pattern-factory-func*
    'static' std::shared_ptr<Person> create(
        const std::string& name, const Date& birthday, const Address& address);
};


std::shared_ptr<Person> Person::create(...)
{    
  // create "RealPerson" <create-and-set-impl>
  return std::shared_ptr<Person> ( new RealPerson (...) );
}


// implementation
//
class RealPerson: public Person {         // public IPerson
  private:
    std::string theName;                  // has-implementation-details
    Date theBirthDate;

  public:
    RealPerson(...): ... {}
    virtual ~RealPerson() {}
    virtual std::string name() const;

    ... same interface
};


Then client use:

std::shared_ptr<Person> pp ( Person::create(...) );

<summary>
(client) (interface class)   
(client)    interface: virtuals
...         factory-function 
            ptr to impl      

         (subclassing) 
            real implementation : use other classes

* Like `pimpl-pattern`, no interface change and can force class interface to
  derived class.
 
* Used subclassing.
 
* Like pimpl idiom, separated implementation. When implementation, derived
  class, changes, no need to compile clients. But re-link.

* No singleton class style but effectively singleton since cannot create ABC
  class and only ABC has a interface to create. note: not a singleton.

IPerson::create(...)
 |
 |-return new RealPersonX or
 |-return new RealPersonY
 |-...
 +-return new RealPersonZ


={============================================================================
*kt_dev_cxx_0000* cxx-pattern-singleton

Using global, static objects have two problems:

* Do not keep you from instantiating 'multiple' objects of the same type(class).
  Not about the name.

class X one_instance; class X two_instance.

* No control of access. *cxx-init-order-problem*

Good things over global by making a class itself 'responsible' for keeping track
of its sole instance:

* `instance-control`
 
* `controlled-access` 
  Sicne Singleton encapsulates its sole instance, have strict control over how
  client access it

* `lazy-initialization` 
  `no-creation` if it is not called. In the following example, no creation
  unless a user call instance() but global do not.


<code> RDP 129
For C++, use singleton class, pattern. Put simply, sigleton can be called
`class-static` in the same sense as function static.


class Singleton {

  public:
    // `controlled-access` single point of access
    // `lazy-initialisation` means that do not create instance until its first
    // access.

    'static' Singleton* Instance()
    {
      if(_instance==0) {
        _instance = new Singleton;
      }
      return _instance;
    }

  protected:                         
    // `no direct user creation`
    // gets created only via Instance()
    Singleton() {};                  

  // can have different concrete classes in different hierachy
  private:
    'static' Singleton* _instance;
};

Singleton* Singleton::_Instance = 0;

note:
Have to use shared_ptr to copy and dtor context? No. This is static function
and there is no Singleton object created. Hence no copy controls.

No need to delete _instance? Yes, will be reclaimed when an application
terminates.


{singleton-plus-factory}
The singleton is similar to `factory-function` in that both has a single point
to create hence static func. However, the aim is different. The singleton is
about `when-or-how-to-create` and the factory is about `what-to-create`. 


Like to have singleton and flexibility to choose what to create as well? Here
are ways:

<2> RDP 132

* Make a usual factory class a singleton to ensure there is only one instance
  by making globally accessible without resorting to global variable.

* Allow subclass on factory but not on singleton.
 
* Use env to select what to create at run-time.

// RDP 92
class MazeFactory {
  public:
    // ... public interfaces ...
    MazeFactory();
    virtual Maze* MakeMaze() const;
    virtual Wall* MakeWall() const;
    virtual Room* MakeRoom(int n) const;
    virtual Door* MakeDoor(Room *r1, Room *r2) const;
};


// Add a singleton
class MazeFactory {
  public:
    static MazeFactory* Instance();

    // ... public interfaces ...
    virtual Maze* MakeMaze() const;
    virtual Wall* MakeWall() const;
    virtual Room* MakeRoom(int n) const;
    virtual Door* MakeDoor(Room *r1, Room *r2) const;

  // no more than one instance
  protected:
    MazeFactory();

  private:
    static MazeFactory* _instance;
};

MazeFactory* MazeFactory::_instance = 0;

MazeFactory* MazeFactory::Instance () {
  if( _instance == 0 ) {
    _instance = new MazeFactory;
  }

  return _instance;
}


// Support subclass or other instances
MazeFactory* MazeFactory::Instance () {
  if( _instance == 0 ) {
    const char* mazeStyle = getenv("MAZESTYLE");

    if( strcmp( mazeStyle, "bombed" ) == 0 ) {
      _instance = new BombedMazeFactory;
    }
    else if( strcmp( mazeStyle, "ehchanted" ) == 0 ) {

      // note: subclass ctor should be public which means can create directly.
      _instance = new EnchantedMazeFactory;

      // other possible subclasses
      // should modify Instance() whenever there are new subclasses

    } else { 
      // default. okay since can access protected ctor
      _instance = new MazeFactory;
    }
  }

  return _instance;
}

How about overriding Instance() in class hierachy? No since there must be an
instance to call Instance() but constructor is protected. So no way to create
object. 

So MUST use
`class-method`, `staic-member-function`, for singleton-pattern.

class MazeFactory {
  public:
    'virtual' MazeFactory* Instance(); 
    ... public interfaces ...

  protected:
      MazeFactory();

  private:
      static MazeFactory* _instance;
};

MazeFactory* MazeFactory::_instance = 0;

BombedMazeFactory* BombedMazeFactory::Instance () {
  if( _instance == 0 ) {
    _instance = new BombedMazeFactory;
  }

  return _instance;
}


<1> RDP 130

* Another approach to support "subclassing singleton class"

* Use 'registry' to find a class to use and this is more flexible because
  there is no code change necessary, e.g., Instance(), when there are new
  sigleton class to add.

  The downside is that 'all' possible singleton classes must be created before
  register since must build a list to look up beforehand. 

* No protected ctor so can create static global instance

class Singleton {
  public:
    'static' void Register( char* name, Singleton* );
    'static' Singleton* Instance();

  protected:
    'static' Singleton* Lookup( const char* name );

  private:
    'static' Singleton* _instance;
    'static' List<NameSingletonPair>* _registry;
};

Singleton* Singleton::Instance() 
{
  if(_instance==0) {

    const char* singletonName = getenv("SINGLETON");
    _instance = Lookup(singletonName);
  }
  return _instance;
}

// to register in ctor
MySingleton::MySingleton() 
{
  ...
  Singleton::Register( "MYSINGLETON", this );
}

// create and used file static since no protected ctor
static MySingleton mySingleton;
static YourSingleton yourSingleton;

mySingleton.Instance();


note:
MEC++26 shows more such as how limit the number of objects.


={============================================================================
*kt_dev_cxx_0000* cxx-pattern-factory

{creational-pattern}
The factory-function plays the role of the ctor for the derived classes that
are actually created. Hence called virtual constructor

This is about a method but not a class. Two points:

* Encapsulation. No code to create in the client and move it into factory-func. 
 
* Defer decision on what to create: creation in the base such as parameterized
  factory-func or to defer creation to subclass, so any product class in the
  tree. This subclassing often used in framework since no need to make changes
  in framework.

<static-vs-virtual-factory-func>
The static-factory-func has efficient code because no virtual cost and has
single point to access but hard-wired to choose classes to create. Have to
change it when the choice to create changes. 

The virtual-factory-func has bigger code but subclassing can change class to
create. So useful for framework that cannot be changed. When factory-func is
on the creator tree and uses virtual func: pure virtual or virtual which as
default implementation. Let client decide which class to create using
subclassing, application specific document, to create(manufacture) and defer
instantiation to subclass which is out of framework.

(client)           (creator class, Application)           (product class, Document) 
-----------------  ------------------------------------   ------------------------- 
Creator.NewDoc();  // factory-func.
                   // set impl in factory func.
                   'virtual' CreateDoc() = 0;
                   'virtual' CreateDoc();

                   NewDoc()                                Open();
                   { pDoc = CreateDoc(); pDoc->Open(); }

                   (subclass)                              (subclass)
                   -------------------------------------   -------------------------
                   WordApplication, DrawApplicaion, ...    WordDoc, DrawDoc, ...
                   'virtual' CreateDoc()
                   { return new WordDoc; }
                   { return new DrawDoc; }

This can be used in parallel class implementation. See design pattern book for
more.

This looks like factory + pimpl and create object in the different tree.


<virtual-factory-func> sample-code-from-design-pattern
The previous has hard-codes for classes to create:

Maze* MazeGame::CreateMaze() {         // As with NewDoc()
  Maze* aMaze = new Maze;
  Room* r1 = new Room(1);
  Room* r2 = new Room(2);
  Door* theDoor = new Door(r1, r2);

  aMaze->AddRoom(r1);
  ...
  return aMaze;
}

This is revised to use factory which shows how framework works. The frameworks
has all logics and user implements interfaces as framework defines and creats
instance.

class MazeGame {
  public:
    // *cxx-pattern-template*
    Maze* CreateMaze();

    // factory functions
    virtual Maze* MakeMaze() const { return new Maze; }
    virtual Room* MakeRoom( int n ) const { return new Room(n); }
    virtual Wall* MakeWall(...);
    virtual Door* MakeDoor(...);
};

Maze* MazeGame::CreateMaze() {
  Maze* aMaze = MakeMaze();

  Room* r1 = MakeRoom(1); Room* r2 = MakeRoom(2);
  Door* theDoor = MakeDoor( r1, r2 );

  aMaze->AddRoom(r1); aMaze->AddRoom(r2);
  ...
  return aMaze;
};

class BombedMazeGame : public MazeGame {
  public:
    virtual Wall* MakeWall() const { return new BombedWall; }
    virtual Room* MakeRoom(int n) const { return new RoomWithABomb(n); }
};

class EnchantedMazeGame : public MazeGame {
  public:
    virtual Wall* MakeDoor() const { return new DoorNeedingSpell; }
    virtual Room* MakeRoom(int n) const { return new EnchantedRoom(n); }
};

BombedMazeGame bombMaze;               // BombedMazeGame
Maze* pMaze = bombMaze.CreateMaze();   // client know what to create
pMaze->func();

When CreateMaze is called, will use redefined factory-funcs to create
application specific class.


{parameterized-factory-func}
The realistic examples may support different derived class to create using
additional params, file, DB or env var. 


<ex> non-member-factory-func
From EC++40. Use id to select different concrete class and non-member
factory function and conditional switch in it.

std::shared_ptr<IPerson> makePerson( DatabaseID personID );

DatabaseID id(askUserForDatabaseID());
std::shared_ptr<IPerson> pp ( makePerson(id) );

pp->name();
pp->birthDate();


<ex> RDP
class Creator {
  public:
    virtual Product* Create( ProductId );
};

Product* Creator::Create( ProductId id )
{
  if( id == MINE ) return new MyProduct;
  if( id == YOURS ) return new YourProduct;

  return 0;
};

Product* MyCreator::Create( ProductId id )
{
  if( id == YOURS ) return new MyProduct;          // changed ids
    if( id == MINE ) return new YourProduct;

  if( id == THEIRS ) return new TheirProduct;      // extented

  return Creator::Create(id);                      // fall back on base class for others.
};


<ex> on-disk-representation-factory-func
From MEC++25. Creating objects from reading disk and there should be type to
create in disk.

class NLComponents {
  public:
    ...
};

class TextBook : public NLComponents {
  public:
    ...
};

class Graphic : public NLComponents {
  public:
    ...
};

class NewsLetter {
  public:
    ...
  private:
    list<NLComponents*> components;

    // static factory function
    static NLComponents* readComponent( istream& str );
};

NewsLetter::NewsLetter( istream& str )
{
  while( str ) {
    components.push_back( readComponent( str ) );
  }
}


{virtual-copy} cxx-clone

* return pointer type can be different of virtual function.

2. clone simply use real copy ctor and means it follows the same whether it is deep or shallow copy.

class NLComponent {
  public:
    virtual NLComponent* clone() const = 0;
    ...
};

class TextBlock : public NLComponent {
  public:
    virtual TextBlock* clone() const
    { return new TextBlock(*this); }
    ...
};

class Graphic : public NLComponent {
  public:
    virtual Graphic* clone() const
    { return new Graphic(*this); }
    ...
};

class NewsLetter {
  public:
    NewsLetter( const NewsLetter& rhs );
    ...

  private:
      list<NLComponents*> components;
};

NewsLetter::NewsLetter( const NewsLetter& rhs )
{
  for( list<NLComponent*>::const_iterator it = rhs.components.begin();
      it != rhs.components.end(); ++it )
  {
    components.push_back( (*it)->clone() );
  }
}

Why virtual copy ctor? This copies whatever the pointer really points to, that
is calls type dependent clone. If copying list is allowed this means copying
pointers, not real objects. So this is useful to implement deep copying.

Q: Can copy list?


{virtual-acting-non-member-func}
To have different output for different object? Can use virtual? That means member func.

class TextBlock : public NLComponent {
	 public:
	 	virtual ostream& operator<<( ostream& str ) const;
		...
};

TextBlock t; Graphic g;

t << cout; g << cout;

For usual syntax, must use non-member but then cannot use virtual. See kt_dev_cpp_021 for why it
must be non-member. How to solve?

class NLComponent {
	 public:
	 virtual ostream& print( ostream& os ) const = 0;
	 ...
};

class TextBlock : public NLComponent {
	 public:
	 	virtual ostream& print( ostream& os ) const;
};

inline ostream& operator<<( ostream& os, const NLComponent& c )
{ return c.print(os); }

Used virtual mecanism on the second arg since it is reference.


{more-things-from-design-pattern}
o In C++, always use virtual. [KT] How about static func?
o Not to call factory-func which is virtual in the creator's ctor. see *kt_dev_ecpp_003* 

Create the product on demand and use <lazy-initialization>. note: factory + singleton 

class Creator {
  public:
    Product* GetProduct();             // accessor

  protected:
    virtual Product* CreateProduct();  // factory-func

  private:
    Product* _product;
};

Product* Creator::GetProduct() {
  if(_product == 0) {
    _product = CreateProduct();
  }
  return _product;
}

o Can use template instead of subclassing. For example,

class Creator {
  public:
    virtual Product* CreateProcut() = 0;
};

template <class T>
class StandardCreator : public Creator {
  public:
    virtual Product* CreateProduct();
};

template <class T>
Product* StandardCreator<T>::CreateProduct() {
   return new T;
};

o Use naming convention for factory-funcs.
For MacApp framework example, class* DoMakeClass() where Class is the product class. 


={============================================================================
*kt_dev_cpp_023* cpp-inheri-strategy-pattern

{strategy-pattern} TODO: more clearer
As with the same example as template pattern, calculate a health for a different game character.
This design use no virtual and that calculating a health is independent of the character's type. So
take a calculation out of the class.

<key> The idea is to use function pointer for a calculation. This is simple application of strategy
pattern.

class GameCharacter;

// default calculation
int defaultHealthCalc( const GameCharacter& gc );

class GameCharacter {
  public:
    typedef int(*HealthCalcFunc)(const GameCharacter&);

    explicit GameCharacter( HealthCalcFunc hcf = defaultHealthCalc ) : healthFunc(hcf) {}

    int healthValue() const
    { return healthFunc(*this); }
    ...

  private:
      HealthCalcFunc healthFunc;
};

<comparison>
Interesting flexibilities than virtual approach, template pattern:

1. Each 'instance'(object) of the same type can have different calculation since use constructor to
set calculation function.

2. Can change the calculation function at runtime.

The possible downside is that calculation function is not member function so could weaken
encapsulation if need access to non-public part of class to calculation. For example, make it a
friend or offer more public funcs that are private otherwise.

<when-use-function-type>
Can use function type to support different callables. See {function-type} for more.

class GameCharacter {
  public:

    typedef std::tr1::function<int(const GameCharacter&)>HealthCalcFunc;
    ...
};

The stl function type is 'generalized' function pointer and allow us to use any compatible callable
entities such as function object, member funcs, and funcs with different return type.

<classic-strategy-pattern>
Use two hierarchy. One for characters and the other for calculations. Make calculation function a
virtual member function of the calculation hierarchy.

GameCharacter <--- CharacterX
               |- CharacterY
               |- ...
    <*>
    |
    | composition aggregation
   1|
HealCalcFunc  <--- SlowHealthLoser
               |- FastHealthLoser
               |- ...

class GameCharacter;

class HealthCalcFunc {
  public:
    virtual int calc( const GameCharacter& gc ) const { ... }
    ...
};

HealthCalcFunc defaultHealthCalc;

class GameCharacter {
  public:
    explicit GameCharacter( HealthCalcFunc* phcf = &defaultHealthCalc )
      : pHealthCalc( phcf ) {}

    int healthValue() const
    { return pHealthCalc->calc(*this); }     // see
    ...

  private:
      HealthCalcFunc* pHealthCalc;           // see
};

Can add/change calc func later because can have the drived classes in separate hierarchy.


={============================================================================
*kt_dev_cxx_0000* cxx-pattern-observer

RDP 293

The observer pattern describes how to establish these relationship. The key
object in this pattern are `subject` and `observer` A subject may have any
number of dependent observers. All observers are notified whenever the subject
undergoes a change in state. In response, each observer will query the subject
to synchronise its state with the subject's state.

This kind of interaction is also known as publish-subscribe. The subject is
the publisher of notifications. It sends out these notifications without
having to know who its observers are. Any number of observers can subscribe to
receive notifications.


={============================================================================
*kt_dev_cpp_024* cpp-incomplete-type cpp-forward-declaration cpp-layout

struct Sales_data { /* ... */ };
Sales_data accum, trans, *salesptr;

The semicolon marks the end of the (usually empty) list of declarators. It is
  a common mistake among new programmers to forget the semicolon at the end of
  a class definition.


CPR 278.

Just as can 'declare' a function apart from its 'definition', can also declare
a class without defining it.

class Screen;

This declaration, sometimes referred to as a `forward-declaration`, introduces
the name Screen into the program and indicates that Screen refers to a class
type. After a declaration and 'before' a definition is seen, the type Screen
is an `incomplete-type`; it is known that Screen is a class type but not known
what members that type contains.


<limited-use>
We can use an incomplete type in only limited ways: We can define pointers or
references to such types, and we can declare (but 'not' define) functions that
'use' an incomplete type `as a parameter or return type.`

EXPC++26 *cpp-minimise-compile-time*
Parameter and return types need only to be forward declared, so instead of the
full definiton, really only need its forward declaration. e.g., iosfwd


<object-function-member>
A class must be defined-not just declared-before we can write code that
creates objects of that type or use virtual function of it. Otherwise, the
compiler does not know how much storage such objects need. Similarly, the
class must be defined before a reference or pointer is used to access a member
of the type.` 

After all, if the class has not been defined, the compiler cannot know what
members the class has and don't know the class(type) layout:

* Cannot create object of that type.
* Cannot defines funcs using return or params of incomplete type.
* Cannot use that type to define data member of the other class.

see *cpp-ex-strblob-example*


<cpp-declaration>
A declaration tells compilers about the name and type of something and a
definition provides compilers with the details a a declartation omits. For an
object, the definition is where compilers set aside memory for the object. For
a function or function template, it provides the code body. For a class or
class template, it list the members of the class or template.

{compilation}
From p656. Ordinarily, when call a function, the compiler needs to see only a
declaration. Similarly, when use objects of class type, the class definition
must be available but the definition of the member functions need not be
present. As a result, put class definition and function declaration in header
file and definition of ordinary and class member function is source files.


From ansic, p80. A declaration announces the properties of a
variable(primarily its type) and a definition 'also' cuases storage to be set
aside.

int sp;
double val[MAXVAL];

this 'define' the external variables and cause storage to be set aside and
'also' serve as the declaration for the rest of that source file.


extern int sp;
extern double val[];

this 'declare' for the rest of the source file that sp is an int and val is a
double array.


{virtual-and-definition}
Ordinarily if we do not use a function, do not need to supply a definition for
that function. This is true. The code below works fine with no errors.

#include <iostream>

class AA {
  public:
  void member_defined() { std::cout << "has definition" << std::endl; }
  void member_nodefined();
};

int main()
{
  AA aa;

  aa.member_defined();

  return 0;
}

However 'must' define every virtual function regardless of whether it is used
because do not know which version of a function is called until run time.

extern int i;     // declare
int i;            // declare and define

void func(..);    // declare
void func(..)     // declare and define
{
   ...
}


={============================================================================
*kt_dev_cpp_024* cpp-empty-base-class-optimization

The class has no data members at all and there can be space advantage. Compilers
are allowrd to let an empty base subobject occupy zero space; whereas an empty
member object must occupy nonzero space.

class B { // functions only, no data };

class D
{
  // b_ must occupy at least one byte even though B is an empty class.
  B b_;
};

class D : private B
{
  // the B base subobject need not occupy any space at all
};


={============================================================================
*kt_dev_cpp_0000* cpp-design-defines-problem

In order to define what the problem is:

* to translate vague goals
* to clarfy contradictory requests
* to translate perhaps unstated desires into a precisely formulated project
  that can be programmed.


<80-20-rule> 80 and 20

EC++ p139.

Typical program spends 80% of its time excuting only 20% of its code. Your
goal as a software developer is to identify the 20% of your code that can
increase your program's overall performance.

From MEC++16:

The 80-20 Rule states that 80 percent of a program's resources are used by
about 20 percent of the code: 80 percent of the runtime is spent in
approximately 20 percent of the code; 80 percent of the memory is used by some
20 percent of the code; 80 percent of the disk accesses are performed for
about 20 percent of the code; 80 percent of the maintenance effort is devoted
to around 20 percent of the code. 

The rule has been repeatedly verified through examinations of countless
machines, operating systems, and applications. The 80-20 rule is more than
just a catchy phrase; it's a guideline about system performance that has both
wide applicability and a solid empirical basis.


={============================================================================
*kt_dev_cpp_0000* cpp-design-by-contract 
  
EC++18, Make it hard to use incorrectly 

1. Make compile error for incorrect uses (interface usage errors):

class Date {
  public:
    Date(int month, int day, int year);
    ...
};

// client use

Date d(30, 3, 1995);    // wrong order
Date d(3, 40, 1995);    // invalid

How to make compile errros? Use C++ type system.

struct Day {
  explicit Day(int day) : val(day) {}
  int val;
};

struct Month {
  explicit Month(int month) : val(month) {}
  int val;
};

struct Year {
  explicit Year(int year) : val(year) {}
  int val;
};

class Date {
  public:
    Date( const Month& month, const Day& day, const Year& year);
    ...
};


// wrong type. wrong order
Date d(30, 3, 1995);                      

// wrong type. invalid
Date d( Day(3), Month(40), Year(1995) );

// correct type. invalid value but easy to 'see'!
Date d( Month(40), Day(3), Year(1995) );  


2. Make compile error for invalid values: 

Consider enum? NO since not type-safe. Safer solution is to predefine all
vaild months. note: C++11 enum supports type checks. 

class Month {
  public:
    static Month Jan() { return Month(1); }
    ...
    static Month Dec() { return Month(12); }

  private:
    // prevent creation of new values
    explicit Month(int m); 
};

Date d( Month::Mar(), Day(30), Year(1995) );

Used functions to represent months. How about {class-const} in
*kt_dev_cpp_017* instead of using function?


3. Force client to follow interface rule

Investment* createInvestment();

This means that client remember to use raii to prevent resource leaks. The
better interface decision is:

std::shated_ptr<Investment> createInvestment();

The same is {factory-func} in *kt_dev_stl_018* which force client to use
smart_ptr.


={============================================================================
*kt_dev_cpp_0000* cpp-design-define-variable

EC++26, postpone variable definitions

Avoid unused varaibles but see that there are variables which aren't
completely unused so to postpone variable definitions as long as possible
until is needed and have init value. Increases clarity and efficiency.

std::string encryptPassword( const std::string& password )
{
  using namespace std;

  string encrypted;

  if( password.length() < MinimumPasswordLength )
  {
    throw logic_error("Password is too short");
  }

  ...

  return encrypted;
}

The real meaning of 'as long as possible': postpone a variable's definition
until right before you have to use the variable, also try to postpone the
definition until you have initialsation arguments for it. Avoid cost of
construction, destruction and default construction.


{what-about-loop}
# approach A                           # approach B
Widget w;
for( int i=0; i < n; i++ )             for( int i = 0; i < n; i++ )
{                                      {
  w = some value;                         Widget w(some value);
  ...                                     ...
}                                      }

1 ctor, 1 dtor, n assign.              n ctor and dtor.

Choose depending on whether ctor/dtor is expensive than assign.

The approach B makes that the name w is only visible in the loop. This is good
for comprehensibility and maintainability. So approach B is 'recommended'
unless performance analysis shows approach A is better.


{make-variable-available-only-for-some}
By defining the variable in a condition, the pointer dp is not accessible
outside the if. If the cast fails, then the unbound pointer is not available
for use in subsequent code where we might forget to check whether the cast
succeeded.

if (Derived *dp = dynamic_cast<Derived*>(bp))
{
    // use the Derived object to which dp points
   
} else {  // bp points at a Base object

    // use the Base object to which bp points
}


={============================================================================
*kt_dev_cpp_0000* cpp-design-no-reference-to-internals

EC++28, avoid returning handles to object internals

Here internals means everything except public interface and includes private
and protected member function. If returns handles (iterator, pointer and
    reference) to internals, causes three problems: breaks encapsulatation,
constness, and dangling-handles.

{compromising-encapsulation-and-constness}
The pass by reference is more efficient than pass by value and the interface
offer client a way to learn what rectangle's points are:

class Rectangle {
  public:
    Point& upperLeft() const { return pData->ulhc; }

  private:
    std::shared_ptr<RectData> pData;
};

Is it okay? NO because client can change its value:

// use
const Rectangle rec( ... );
rec.upperLeft().setX(50);

The problem is that makes memeber data effectively public as returns reference
to it from a public member function since this is *cpp-const-bitwise*


The solution is that it offers read-only access:

class Rectangle {
  public: >
   const Point& upperLeft() const { return pData->ulhc; }

  private:
   std::shared_ptr<RectData> pData;
};

Similar to the example of {const-member-func}

<ex>

using namespace std;

class Sample {
  private:
    int val;

  public:
    Sample() : val(10) {}
    int& getx() { return val;}
    void printx() { cout << val << endl; }
};

int _tmain(int argc, _TCHAR* argv[])
{
  Sample sam;
  cout << "------" << endl;
  sam.printx();
  sam.getx() = 20;
  cout << "------" << endl;
  sam.printx();

  return 0;
}

This changes private member val to 20.


{dangling-handles}
class GUIObject { ... }
const Rectangle boundingBox( const GUIObject& obj );

// use
GUIObject* pgo;
...
const Point* pUpperLeft = &( boundingBox(*pgo).upperLeft() );

This returns a temporary Rectangle and returns its upper member. The problem
is this temporary is destroyed when this statement ends and pUpperLeft will
dangle even if const use.

vector and string's [] operator returns reference but these are exceptions to
this rule, but not a general rule. Better not use [] operator.


={============================================================================
*kt_dev_cpp_0000* cpp-design-interface-first

see *cpp-sp-ex-strblob-example* as well.

https://isocpp.org/wiki/faq/operator-overloading#design-interfaces-first

Should I design my classes from the outside (interfaces first) or from the
inside (data first)?

From the outside!

A good interface provides a simplified view that is expressed in the vocabulary
of a user. In the case of OO software, the interface is normally the set of
public methods of either a single class or a tight group of classes.

First think about what the object logically represents, 'not' how you intend to
physically build it. For example, suppose you have a Stack class that will be
built by containing a LinkedList:

class Stack {
  public:
    // ...
  private:
    LinkedList list_;
};

Should the Stack have a get() method that returns the LinkedList? Or a set()
  method that takes a LinkedList? Or a constructor that takes a LinkedList?
  Obviously the answer is No, since you should design your interfaces from the
  outside-in. i.e., 
  
  "users of Stack objects don’t care about LinkedLists; they care about
  pushing and popping."

Now for another example that is a bit more subtle. Suppose class LinkedList is
built using a linked list of Node objects, where each Node object has a
pointer to the next Node:

class Node { /*...*/ };

class LinkedList {
  public:
    // ...
  private:
    Node* first_;
};

Should the LinkedList class have a get() method that will let users access the
first Node? Should the Node object have a get() method that will let users
follow that Node to the next Node in the chain? In other words, what should a
LinkedList look like from the outside? Is a LinkedList really a chain of Node
objects? Or is that just an implementation detail? And if it is just an
implementation detail, how will the LinkedList let users(Stack class) access
each of the elements in the LinkedList one at a time?

The key insight is the realization that a LinkedList is not a chain of Nodes.
That may be how it is built, `but that is not what it is.` What it is is a
sequence of elements. 

Therefore the LinkedList 'abstraction' should provide a LinkedListIterator
class as well, and that LinkedListIterator might have an operator++ to go to
the next element, and it might have a get()/set() pair to access its value
stored in the Node (the value in the Node element is solely the responsibility
    of the LinkedList user, which is why there is a get()/set() pair that
    allows the user to freely manipulate that value).

Starting from the user’s perspective, we might want our LinkedList class to
support operations that look similar to accessing an array using pointer
arithmetic:

    void userCode(LinkedList& a)
    {
      for (LinkedListIterator p = a.begin(); p != a.end(); ++p)
        std::cout << *p << '\n';
    }

To implement this interface, LinkedList will need a begin() method and an
end() method. These return a LinkedListIterator object. The LinkedListIterator
will need a method to go forward, ++p; a method to access the current element,
     *p; and a comparison operator, p != a.end().

The code follows. 

The important thing to notice is that LinkedList does not have any methods
that let users access Nodes. 

Nodes are an implementation technique that is completely buried. This makes:

  the LinkedList class safer (no chance a user will mess up the invariants and
      linkages between the various nodes), 
  
  easier to use (users don’t need to expend extra effort keeping the node-count
      equal to the actual number of nodes, or any other infrastructure stuff),

  and more flexible (by changing a single typedef, users could change their code
      from using LinkedList to some other list-like class and the bulk of their
      code would compile cleanly and hopefully with improved performance
      characteristics).


#include <cassert>    // Poor man's exception handling

class LinkedListIterator;
class LinkedList;

class Node {
  // No public members; this is a "private class"
  friend class LinkedListIterator;   // A friend class
  friend class LinkedList;
  Node* next_;
  int elem_;
};

class LinkedListIterator {
  public:
    bool operator== (LinkedListIterator i) const;
    bool operator!= (LinkedListIterator i) const;
    void operator++ ();   // Go to the next element

    // note: get/set to access element(value)
    int& operator*  ();   // Access the current element

  private:
    LinkedListIterator(Node* p);
    Node* p_;
    friend class LinkedList;  // so LinkedList can construct a LinkedListIterator
};

class LinkedList {
  public:
    void append(int elem);    // Adds elem after the end
    void prepend(int elem);   // Adds elem before the beginning

    // ...
    LinkedListIterator begin();
    LinkedListIterator end();

    // ...
  private:
    Node* first_;
};

Here are the methods that are obviously inlinable 

inline bool LinkedListIterator::operator== (LinkedListIterator i) const
{
  return p_ == i.p_;
}
inline bool LinkedListIterator::operator!= (LinkedListIterator i) const
{
  return p_ != i.p_;
}
inline void LinkedListIterator::operator++()
{
  assert(p_ != NULL);  // or if (p_==NULL) throw ...
  p_ = p_->next_;
}
inline int& LinkedListIterator::operator*()
{
  assert(p_ != NULL);  // or if (p_==NULL) throw ...
  return p_->elem_;
}
inline LinkedListIterator::LinkedListIterator(Node* p)
  : p_(p)
{ }
inline LinkedListIterator LinkedList::begin()
{
  return first_;
}
inline LinkedListIterator LinkedList::end()
{
  return NULL;
}

Conclusion: 

The linked list had two different kinds of data. The values of the elements
stored in the linked list are the responsibility of the user of the linked
list (and only the user; the linked list itself makes no attempt to prohibit
    users from changing the third element to 5), and the linked list’s
infrastructure data (next pointers, etc.), whose values are the responsibility
of the linked list (and only the linked list; e.g., the linked list does not
    let users change (or even look at!) the various next pointers).

Thus the only get()/set() methods were to get and set the elements of the
linked list, but not the infrastructure of the linked list. Since the linked
list hides the infrastructure pointers/etc., it is able to make very strong
promises regarding that infrastructure (e.g., if it were a doubly linked list,
    it might guarantee that every forward pointer was matched by a backwards
    pointer from the next Node).

So, we see here an example of where the values of some of a class’s data is
the responsibility of users (in which case the class needs to have get()/set()
    methods for that data) but the data that the class wants to control does
  not necessarily have get()/set() methods.

Note: the purpose of this example is not to show you how to write a
linked-list class. In fact you should not “roll your own” linked-list class
since you should use one of the “container classes” provided with your
compiler. Ideally you’ll use one of the standard container classes such as the
std::list<T> template.


={============================================================================
*kt_dev_cpp_0000* cpp-new-delete

{default-value-initialize}

string* ps = new string;      // default-init
string* ps = new string();    // value-init. T()

int* pi = new int;            // default-init
int* pi = new int();          // value-init. T()

Only for built-in types, value-init makes difference and this means that
default-init for built-in types has 'uninitialized' values. For class types,
  both will use default ctors and so no difference. 
  
The `new operator` combines allocation and construction; creates 'unnamed' and
then 'default-init' objects e.g. calls ctor for class object.


{new-operator-and-operator-new}
MEC++08: This operator is built into the language and, like sizeof, you can't
change its meaning: it always does the same thing. What it does is twofold:
allocation and construction.

The new operator, use `operator new` (or operator new[]) to allocate raw
memory, runs ctor to construct, and returns pointer to constructed memory.
Raise 'bad_alloc' exception when there is  no memory.

For deletion, do opposite; runs dtor and operator delete( or delete[]) to free
memory.

note: C++ runtime gurantees that delete nullptr do nothing.


{do-not-mix-with-array-form}
EC++16. Use the same form in corresponding uses of new and delete since these
do two things but think what will happen when call destructor(s) less or more
than needed. Undefined in both ways. 

std::string *stringPtr1 = new std::string;
std::string *stringPtr2 = new std::string[100]; 

delete stringPtr1;
delete[] stringPtr2;

This can be not obvious when use typedef: 

typedef std::string AddressLines[4];
std::string *pal = new AddressLines;

delete pal;    // undefined
delete[] pal;

If do not know that there is a typedef, for example, it is in a file somewhere
in huge source tree then may be a problem.


{operator-new-and-delete}
This is the C++ equivalent of calling malloc and free. What you can change is
how the memory for an object is allocated. The name of the function that the
new operator calls to allocate memory is operator new. Can rewrite or overload
that function to change its behavior.

The operator new function is usually declared like this:

void * operator new(size_t size);

The return type is void*, because this function returns a pointer to raw,
    uninitialized memory.

void *rawMemory = operator new(sizeof(string));

Like malloc, operator new's only responsibility is to allocate memory.

note: Can define own operator new and delete but careful because it takes over
responsibility for 'all' dynamic memory allocation. Since it changes global
one so new operator will automatically invoke your custom version of operator
new.


{new-operator-with-zero-size}
What happens if get_size returns 0? The answer is that our code works fine.
Calling new[0] is legal even though we cannout create an array variable of
size 0.

char arr[0];              // error: cannot define a zero-length array
char *cp = new char[0];   // ok: but cp can't be dereferenced

// p acts as the off-the-end pointer
size_t n = get_size();
int *p = new int[n];
for (int* q = p; q != p + n; ++q)
  // process the array
  

{new-handler}
EC++49, new handler

Before operator new throws an exception in response to an unsatisfiable
request for memory, calls a error handling function called new handler. Can
set user's handler by calling set_new_handler for 'flexibility' of handling
allocation errors.

namespace std {
  typedef void (*new_handler)();
  new_handler set_new_handler( new_handler p ) throw();     // see noexcept
};

void outOfMem()
{
  std::cerr << "Unable to satisfy request for memory\n";
  std::abort();
}

int main()
{
  std::set_new_handler( outOfMem );
  int *pBigDataMemory = new int[10000000000L];
  ...
}

When operator new is unable to fulfill a memory request, calls new handler
'repeatedly' until it can find enough memory. So handler must do one of
followings:

1. Make more memory avaiable
For example, allocate a large block of memory at program start-up, then
release it for use the first time thw handler is invoked.

2. Install a different handler
If the current handler can't make any more memory available, perhaps it knows
of a different handler that can and next time operator new calls the new
handler. note: May have hierachy of handler.

3. Deinstall handler
Call set_new_handler(0). With no handler installed, operator new will throws
an exception when allocation is unsuccessful.

4. Throw an exception
Throw a type bad_alloc or derived from bad_alloc.

5. Not return
Typically calls abort or exit.


{class-specific-handler}
Instead of using 'global' handler, can use class specific handler.

// Widget

class Widget {
  public:
    static std::new_handler set_new_handler( std::new_handler p ) throw ();
    static void *operator new( std::size_t size ) throw ( std::bad_alloc );

  private:
    static std::new_handler currentHandler;
};

std::new_handler Widget::currentHandler = 0;

std::new_handler Widget::set_new_handler( std::new_handler p ) throw ()
{
  // note: this merely set currentHandler
  std::new_handler oldHandler = currentHandler;
  currentHandler = p;
  return oldHandler;
}

void* Widget::operator new( std::size_t size ) throw( std::bad_alloc )
{
  // note: save old global handler and set new one
  NewHandlerHolder h( std::set_new_handler(currentHandler));

  // note: call global operator new
  return ::operator new(size);
}

// HandlerHolder
// note: uses raii to restore global handler back when done

class NewHandlerHolder {
  public:
    explicit NewHandlerHolder( std::new_handler nh ) : handler(nh) {}
    ~NewHandlerHolder() { std::set_new_handler(handler); }

  private:
    std::new_handler handler;

    // preventing copies
    NewHandlerHolder( const NewHandlerHolder& );
    NewHandlerHolder& operator=( const NewHandlerHolder& );
};

// Use

void outOfMem();

Widget::set_new_handler( outOfMem );

// note: see how Widget's operator new is called due to arg-dependent lookup.
Widget* pw1 = new Widget;              // if allocation fails, call outOfMem

std::string* ps = new std::string;     // if allocation fails, call global one if there is

Widget::set_new_handler(0);            // set no handler for Widget

Widget* pw2 = new Widget;              // if allocation fails, throw exception immediately

<to-support-other-class>
This scheme is the same regardless of the class and then use template to
support other types.

template<typename T>
class NewHandlerSupport {
  public:
    static std::new_handler set_new_handler( std::new_handler p ) throw ();
    static void* operator new( std::size_t size ) throw (std::bad_alloc);

    // other versions of operator new.
  private:
    static std::new_handler currentHandler;
};

template<typename T>
std::new_handler NewHandlerSupport<T>::currentHandler = 0;

template<typename T>
std::new_handler NewHandlerSupport<T>::set_new_handler( std::new_handler p ) throw ()
{
  std::new_handler oldHandler = currentHandler;
  currentHandler = p;
  return oldHandler;
}

template<typename T>
void* NewHandlerSupport<T>::operator new( std::size_t size ) throw( std::bad_alloc )
{
  NewHandlerHolder h( std::set_new_handler(currentHandler));

  return ::operator new(size);
}

class Widget : public NewHandlerSupprt<Widget> {
  // as before but without set_new_handler and operator new
};

note: never use type parameter T. All need is a different copy of
NewHandlerSupport, in particular its static data member currentHandler.
Template mechanism do.

note: this is useful and called 'mixin' style inheritance. how about "is-a"
relationship?


{replace-new}
EC++50: when to replace new and delete

Three common reasons to replace complier provided operator new and delete.

1. To detect usage errors

1.1. Operator new keeps a list of allocated addresses and operator delete
removes addresses from the list, easy to detect usage errors.

1.2. Overrun and underrun. Have signature before and after the memory made
available to clients.  Operator delete can check if the signatures are still
intact, can log when overrun or underrun occurred along with the value of the
offending pointer.

2. To improve efficiency

2.1. The default operator new and delete is general purpose such as large
blocks, small blocks, and mixtures of the two. Have to worry about heap
fragmentation. If know allocation 'pattern' of an application, can use custom
operator new and delete to have performance improvements.

2.2. Custom version for objects of a particular type such as class-specific
allocators. Boot pool libaray for fixed-size allocators.

2.3. Reduce space overhead. The general version often incur some overhead for
each allocated block.  Allocators tuned for small objects such as boost pool
library essentially eliminate such overhead.

2.4. Cluster related objects. If know that particular data structures are used
together and like to minimize page 'fault', can create a separate 'heap' for
the data so they are clustered together as few pages as possible. Placement
version can make it possible to achieve such clustering. note: placement new
use case.

3. To collect usage statics

Before writing custom new and delete, gather information about how application
uses dynamic memory.  Distribution of allocated block size, their lifetime,
     allocation and deallocation order such as FIFO, LIFO, or random, usage
     pattern changes in different stages of execution, maximum amount of
     allocated memory in use at any one time (high water mark or peak value).
     Custom version make it easy to collect this kind of information.

4. To have unconventioal behavior

4.1. Allocate and deallocate blocks in shared memory which has a C API or
memory-mapped I/O. note: placement new use case.

4.2. Overwrite deallocated blocks with zeros in order to increase the security
of application data.


<example> to show how to replace global operator new and see EC++51 for details
static const int signature = 0xDEADBEEF;

typedef unsigned char Byte;

// this code has several flaws
void* operator new( std::size_t size ) throw( std::bad_alloc )
{
  using namespace std;

  size_t realSize = size + 2*sizeof(int);

  void *pMem = malloc( realSize );
  if( !pMem ) throw bad_alloc();

  *(static_cast<int*>(pMem)) = signature;
  *(reinterpret_cast<int*>(static_cast<Byte*>(pMem)+realSize-sizeof(int)) ) = signature;

  return static_cast<Byte*>(pMem)+sizeof(int);
}

<alignment-consideration>
Many computer architectures require that data of particular type be placed in
memory in particular kinds of address. Called alignments. If not, cause
hardware exception or slow performance. If simly uses malloc then no problem
since C++ guarantees malloc returns alligned pointer. However, the above code
is not returning a pointer we got from malloc. So this is consideration when
think of custom new and delete.

Two options: Compiler can have options for different memory managers or open
source memory managers such as boost pool library for allocation of a large
number of small objects, fixed-size allocator.


{cpp-new-placement}

Widget* pw = new Widget;

Two functions are called: operator new and constructor. What would happen when
operator new allocated memory but constructor raised exception? C++ runtime
system gurantees to undo operator new.

{normal-new-and-delete-form}
The normal global new and delete are:

void* operator new( std::size_t ) throw (std::bad_alloc);            // normal new
void* operator new( std::size_t, void* ) throw();                    // placement new
void* operator new( std::size_t, const std::nothrow_t& ) throw();    // nothrow new
void operator delete( void* rawMemory ) throw ();
void operator delete( void* rawMemory, std::size_t ) throw ();       // at class scope


{placement-new} interview question
Means operator new function that takes additional parameters other than the
size. To use this version of new, include 'new' header.

note: see how passes parameters to operator new
note: operator new and deletes use 'overloads' mechanism.

// placement version to log allocations to ostream
static void* operator new( std::size_t size, std::ostream& os ) throw (std::bad_alloc);

// particularly useful placement version
void* operator new( std::size_t size, void *pMemory) throw();

<ex>
One example is to tell not to raise exception. No exception and return 'nullptr'
instead. 

note: This is for older code which expect null pointer when allocation fails
since newer C++ raise an exception instead. This is called 'nothrow' new. This
only guarentees no exception in operator new but not whole expression since
constructor can still raise an exception. So will never have a need for nothrow
new.

note: The nothrow keyword is the same as noexcept but used in new operator
expression.

int* pi = new (std::nothrow) int;

<example>
The other example is that it is used inside vector<> to create objects in the vector's unused
capacity. note: not sure when looked at gcc code. 

<example>
new (place_address) type 
new (place_address) type (initializers)

Widget * constructWidgetInBuffer(void *buffer, int widgetSize)
{
  return new (buffer) Widget(widgetSize);
}

This function returns a pointer to a Widget object that's constructed within the buffer passed to
the function.

<must-provide-all>
C++ choose corresponding delete when undo operator new so must provide 'both' when customize new and
delete. If not found, no delete is called.

Suppose class specific new and delete that logs allocations to ostream.

class Widget {
  public:
    // non-normal from of new
    static void* operator new( std::size_t, std::ostream& os ) throw (std::bad_alloc);

    // normal class specific form of delete
    static void operator delete( void *p, std::size_t size ) throw();
};

Widget* pw = new (std::cerr) Widget;

As with nothrow version, the problem is that C++ cannot find the corresponding delete when
constructor raises exception. So must have placement 'delete' as well.

void operator delete(void*, std::ostream&) throw();

If not, no delete is called if constructor throws an exception.

However, consider what happens if no exception is thrown and get to delete in client code. This
calls the normal operator delete but not placement version. Placement delete is called 'only' if an
exception arises from a 'constructor' that's coupled to a call to a placement new.

delete pw;

Therefore, must provide all to forestall all memory leaks associated with placement versions of new.

class Widget {
  public:
    // non-normal from of new
    static void* operator new( std::size_t, std::ostream& os ) throw (std::bad_alloc);

    // placement version
    static void operator delete(void *p, std::ostream& os) throw();

    // normal delete
    static void operator delete(void *p) throw();
};

<consider-name-hide>
Since member function names hides functions in outer scopes, class specific new and delete hides
normal new and delete.

class Base {
  public:
    // non-normal from of new
    static void* operator new( std::size_t, std::ostream& os ) throw (std::bad_alloc);
};

Base* pb = new Base;                // error since normal new is hidden
Base* pb = new (std::cerr) Base;    // okay

Similarly, new in derived hides both global and inherited versions.

class Derived : public Base {
  static void* operator new( std::size_t size ) throw( std::bad_alloc );
};

Derived* pd = new (std::clog) Derived;    // error
Derived* pd = new Derived;                // okay

So unless mean to prevent class clients from using these forms, be sure to make them available in
addition to any custom versions you create.

<conclusion>
An easy way is to create base class containing all and client just use inheritance to get the
standard forms.

class StandardNewDeleteForms {
  public:
    // normal new/delete
    static void* operator new( std::size_t size ) throw (std::bad_alloc)
    { return ::operator new(size); }
    static void operator delete( void* rawMemory ) throw ()
    { ::operator delete(rawMemory); }

    // placement new/delete
    static void* operator new( std::size_t size, void* pMem ) throw()
    { return ::operator new(size, pMem); }
    static void operator delete( void* rawMemory, void* pMem) throw()
    { ::operator delete( rawMemory, pMem ); }

    // nothrow new/delete
    static void* operator new( std::size_t size, const std::nothrow_t& nt ) throw()
    { return ::operator new(size, nt); }
    static void operator delete( void* rawMemory, const std::nothrow_t&) throw()
    { ::operator delete( rawMemory ); }
};

class Widget : public StandardNewDeleteForms {
  public:
    // make those visible
    using StandardNewDeleteForms::operator new;
    using StandardNewDeleteForms::operator delete;

    static void* operator new( std::size_t size, std::ostream& os ) throw( std::bad_alloc );
    static void operator delete( void* rawMemory, std::ostream& os ) throw();
};




={============================================================================
*kt_dev_cpp_025* random

{rand-function}
NAME
       rand, rand_r, srand - pseudo-random number generator

SYNOPSIS
       #include <stdlib.h>

       int rand(void);
       int rand_r(unsigned int *seedp);
       void srand(unsigned int seed);

DESCRIPTION
       The  rand()  function returns a pseudo-random integer in the range 0 to
       RAND_MAX inclusive (i.e., the mathematical range [0, RAND_MAX]).

NOTES
       The versions of rand() and srand() in the Linux C Library use the  same
       random number generator as random(3) and srandom(3), so the lower-order
       bits should be as random as the higher-order bits.  However,  on  older
       rand()  implementations,  and  on  current implementations on different
       systems, the lower-order bits are much less  random  than  the  higher-
       order  bits.   Do  not use this function in applications intended to be
       portable when good randomness is needed.  (Use random(3) instead.)

<ex>
#include <stdlib.h>

void Randomize()
{
  srand( (unsigned int) (time(NULL)%10000));
}

time_t time(time_t *timeptr); 

The `time()` returns the number of seconds elapsed since the epoch, 00:00:00
GMT, Jan. 1, 1970. If that pointer is null, function just returns the time.

int PoissonRandom( double expectedvalue )
{
  int n = 0;
  double limit;
  double x;

  limit = exp(-expectedvalue);
  x = rand()/(double) INT_MAX;
  while( x > limit )
  {
    n++;
    x *= rand()/(double) INT_MAX;
  }

  return n;
}


{c++-random}
The rand() has several problems. Many programs need random numbers in a
different range and some require random floating-point numbers. Some needs
numbers that reflect a nonuniform distribution. 

* engine: types that generate a sequence of random unsigned integers
* distribution: types that use an engine to retuen numbers according to a
  particular probability distribution.

<ex>
The engines are function-object class that define a call operator and returns a
random unsigned number. The engine object is similar to the output of rand().

#include <iostream>
#include <random>

using namespace std;

int main(void)
{
  default_random_engine e;

  for (size_t i = 0; i < 10; i++)
    cout << e() << " ";

  cout << endl;

  return 0;
}

16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 \
1458777923 2007237709 


The library defines several random-number engines that differ in terms of
performance and quality of randomness. Each compiler designates one of these as
the default_random_engine type. This is intended to be the engine with the most
generally useful properties.


<ex> to get a number in a specified range
#include <iostream>
#include <random>

using namespace std;

int main(void)
{
  default_random_engine e;
  uniform_int_distribution<unsigned> u(0,9);

  for (size_t i = 0; i < 10; i++)
    cout << u(e) << " ";

  cout << endl;

  return 0;
}

0 1 7 4 5 2 0 6 6 9


note:
When refer to an random-number generator, mean the combination of a distribution
object with an engine.


{same-sequence}
Even though the numbers generated appear to be random, a given generator returns
the 'same' sequence of numbers each time it is run. This is very 'helpful'
during testing and on the other hand, programs have to take this fact into
account.

<ex>
#include <iostream>
#include <random>
#include <vector>

using namespace std;

vector<unsigned> bad_randVec(void)
{
  default_random_engine e;
  uniform_int_distribution<unsigned> u(0,9);
  vector<unsigned> ret;

  cout << "--------------" << endl;

  for (size_t i = 0; i < 20; i++)
  {
    unsigned rval = u(e);
    ret.push_back(rval);
    cout << rval << " ";
  }

  cout << endl;

  return ret;
}

int main(void)
{
  vector<unsigned> v1(bad_randVec());
  vector<unsigned> v2(bad_randVec());

  cout << ((v1 == v2) ? "equal" : "not equal") << endl;
}

--------------
0 1 7 4 5 2 0 6 6 9 3 5 8 0 0 5 6 0 3 0 
--------------
0 1 7 4 5 2 0 6 6 9 3 5 8 0 0 5 6 0 3 0 
equal


The right way is to make the engine and distribution objects `static` and they
will hold their state across calls.


<ex>
#include <iostream>
#include <random>
#include <vector>

using namespace std;

vector<unsigned> good_randVec(void)
{
  static default_random_engine e;
  static uniform_int_distribution<unsigned> u(0,9);
  vector<unsigned> ret;

  cout << "--------------" << endl;

  for (size_t i = 0; i < 20; i++)
  {
    unsigned rval = u(e);
    ret.push_back(rval);
    cout << rval << " ";
  }

  cout << endl;

  return ret;
}

int main(void)
{
  vector<unsigned> v1(good_randVec());
  vector<unsigned> v2(good_randVec());

  cout << ((v1 == v2) ? "equal" : "not equal") << endl;
}

--------------
0 1 7 4 5 2 0 6 6 9 3 5 8 0 0 5 6 0 3 0 
--------------
4 6 5 9 8 5 0 6 4 7 9 7 2 0 7 3 6 7 9 3 
not equal


{different-sequence}
The same sequence is helpful during debugging. However, once program is tested
we often want to cause each run to generate different random results.

<ex>
#include <iostream>
#include <random>

using namespace std;

int main(void)
{
  default_random_engine e1;
  default_random_engine e2(2147483646);

  default_random_engine e3;
  e3.seed(32767);
  default_random_engine e4(32767);

  for (size_t i = 0; i < 20; i++)
  {
    if (e1() == e2())
      cout << "unseeded match at iteration:" << i << endl;

    if (e3() != e4())
      cout << "seeded differ at iteration:" << i << endl;
  }
}

no output

note:
Picking a good seed, like most things about generating good random numbers, is
surprisingly hard. The most common approach is to call `time()` function. 

Since that retuns time as the number of seconds, this seed is 'only' useful for
applications that generate the seed at longer intervals. This usually doesn't
work if the program is run repeatedly as part of an automated process; it might
wind up with the same seed several times.


{other-distribution}
CPR 749. TBD.


={============================================================================
*kt_dev_cpp_026* cpp-enum

The enumerations group together sets of `integral constants` and defines new
'type'. From ansic, there are two advantages over #define:

o Provide a convenient way to associate constant value with symbolic names.

o A debugger may be able to print values of enumeration variables. confirmed on
  gcc.

Why scoped enum in C++11? Support scope and type checks.


{forms}
The enumerator is const and need 'not' be unique. By default, start at 0 and
increases by 1.

// `class enum` scoped, named
enum class open_modes { input, output, append };

// `plain enum` unscoped, named
enum color { red, yellow, green };

// unscoped, unnamed
enum { floatPrec = 6, doublePrec = 10, double_doublePrec = 10 };


{scoped-enum} *C++11*
CPR 19.3 832. note that `enum class` Defines an object of 'open_modes' type
and follows scoping rule means 'type' erorr can happen. Scope means that
enumerators are inaccessible outside the scope and user have to specify
explicitly when use it. 

// scoped, named
enum class open_modes { input, output, append };

open_modes x = open_modes::input;


The enumerator names in unscoped enum are placed into the same scope as the
enumeration. 

enum color { red, yellow, green };          // unscoped
enum stoplight { red, yellow, green };      
// error since redefines enumerators
// error: conflicting declaration "red" error: red has a previous declaration as
// main()::color red

enum class peppers { red, yellow, green };  // okay. enumerators are hidden
color eyes = green;                         // okay. enumerators are in scope

peppers p = green;
// error: enumerators from peppers are not in scope. color::green is in scope
// but has the wrong type. error: cannot convert "main()::color" to
// "main()::peppers" in initialisation

color hair = color::red;                    // okay
peppers pp = peppers::red;                  // okay


{enum-hack}
The 'unscoped' enumerators are implicitly converted to 'integral' type. So can
be used where an integral value is required. Called `enum-hack`. 

int i = color::red;                       // ok
int j = peppers::red;                     // error since it is scoped

open_modes readfile = open_modes::input;  // ok
open_modes readfile = 2;                  // error

enum color eyes = green;                  // ok
enum color eyes = 2;                      // ok

class GamePlayer {
  private:
    enum { NumTurns = 5; }

    int scopes[NumTurns];
    ...
};


{underlying-type}
Although each enum defines a unique type, it is represented by one of the
built-in integral type. If do not specify, then by default for scoped enum have
`int` as the underlying type.

There is no default for unscoped enums; all we know is that the underlying type
is large enough to hold the enumerator values.

Being able to specify the underlying type lets us control the type used across
different implementation.

note: real use case?


{func-with-enum-arg}
The enum is type and cannot pass the same integral value to an enum parameter. 

enum Tokens { INLINE = 128, VIRTUAL = 129 }

void ff(Tokens);
void ff(int);

Tokens curr = INLINE;

ff(128);       // ff(int)
ff(INLINE);    // ff(Tokens)
ff(curr);      // ff(Tokens)

But can pass an object or enumerator of unscoped enumaration to a parameter of
integral type; the enum promotes to int or to a larger integral type depending
on the underlying type of the implementaion.

void newf(unsigned char);
void newf(int);

unsigned char uc = VIRTUAL;

newf(VIRTUAL);    // newf(int);
newf(uc);         // newf(unsigned char);


={============================================================================
*kt_dev_cpp_029* cpp-nested-class

A class defined within another class, called nested class or nested type.

Most used to define implementation class. This defines `type-member` of
enclosing class. The nested class are:

* 'independent' classes in terms of object to their enclosing class.
* type members of enclosing class and are under access control.
* types which are scope.

<ex>
A companion class, QueryResult, which is 'tightly' coupled to TextQuery class.
It would make little sense to use QueryResult for any other purpose than to
represent the result of a query operation. To reflect this coupling, make
QueryResult a 'member' of TextQuery.

class TextQuery {
  public:

    // to be defined later but must be seen before use since it is a type
    // member.
    class QueryResult; 
    ...
};

To define a nested class outside of enclosing class:

class TextQuery::QueryResult {

  // no need to qualify the name of QueryResult
  friend std::ostream& print(std::ostream&, const QueryResult&);

  public:

    // no need to define line_no since a nested class can use a member of its
    // enclosing class without needing to qualify.
    QueryResult(std::string,
      std::shared_ptr<std::set<line_no>>,
      std::shared_ptr<std::vector<std::string>>);
  ...
};

TextQuery::QueryResult::QueryResult(string s,
      shared_ptr<set<line_no>> p,
      shared_ptr<vector<std::string>> f):
  sought(s), lines(p), file(f) {}


To define a nested-class static member:

int TextQuery::QueryResult::static_mem = 1024;


Since a nested class is a type member of its enclosing class, can use the name
of nested class the same way it uses any other member.

TextQuery::QueryResult
TextQuery::query(const string &sought) const
{
  static shared_ptr<set<line_no>> nodata(new set<line_no>);

  auto loc = wm.find(sought);
  if (loc == wm.end())
    return QueryResult(sought, nodata, file);
  else
    return QueryResult(sought, loc->second, file);
}

Since there is no connection between the object of an enclosing class and
objects of its nested class, have to use members of enclosing class to construct
the QueryResult object to return.


={============================================================================
*kt_dev_cpp_029* cpp-regex

7.3.2.1. Raw Character Strings

If need a lot of backslashes and quotes in the string literals, it becomes
difficult to use backslash escape mechnism:

string s = "\\w+\\\\\\w+";     // I hope I got that right

To turn off backslash esacpe mechnism:

string s = R"(\w+\\\w+)";

With examples like that, even experts easily become confused, and raw string
  literals provide a significant service.

"('(?:[^\\\\']|\\\\.)*'|\"(?:[^\\\\\"]|\\\\.)*\")|"     // Are the five backslashes correct or not?


In contrast to nonraw string literals, a raw string literal can contain a
newline. For example:

string counts {R"(1

22

333)"};

is equivalent to

string counts {"1\n22\n333"};


={============================================================================
*kt_dev_cpp_050* cpp-template-function

The types become known during complilation in generic programming whereas OOP
deals with types that are not known until run time.

When we write a generic program, write the code in a way that is independent
of any particular type and supply the type(s) or value(s) on which that
instance of the program will operate.

We can use that generic definition to define many different types of
`vectors`, each of which differs from the others as to the type of elements
the `vector` contains.


{template-syntax}
The requirement to put a space between two closing template expressions has
gone:

vector<list<int> >;  // OK in each C++ version
vector<list<int>>;   // OK since *C++11*

// Error case as should be 'typename U'

template <typename T, U> inline T calc( const T&, const U& );

// Can use typename or class but recommands typename

template <typename T, class U> inline T calc( const T&, const U& );


{function-template}
Rather than defining a new function for each type, define a function template
to generate function.

*template-parameter-list*
The template-parameter-list acts much like a function parameter list. At run
time, arguments are supplied that initialize parameters.

Analogously, template parameters represents types or values used in the
definition of a class or function. When use a template, specify template
arguments to bind to the template parameters.

*templete-decuction*
Which actual type T represents is determined at compile time based on how
template function is used. 'deduce' the argument type to determine what type
to bind to the parameter T.

*template-instantiation*
Use the deduced template parameters to instantiate a specific version of the
function. Creates a new 'instance' of the template.

// `function-argument` T is "int", instantiates "int compare(const int&, const int&)"
cout << compare( 1, 0 ) << endl;

// `template-parameter-list` is "<typename T>"
template <typename T>
int compare(const T& v1, const T& v2)
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

// `template-parameter-type` T is "int"
int compare(const int& v1, const int& v2)
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}


// T is "vector<int>", 
// instantiates "int compare(const vector<int>&, const vector<int>&)"

vector<int> vec1{1, 2, 3}, vec2{4, 5, 6};
cout << compare( vec1, vec2 ) << endl;


<principle-to-write-generic-code>
Here two important principles for writing generic codes from this example:

* The function parameters in the templeate are `reference to const`.

This makes the function runs faster and also it 'can' be uses on types that
cannot be copied such as IO types and unique_ptr.

* Used only < comparison. More genarally, reduce the requirement on element or
  argument type.

Instead of:

template <typename T>
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v1 > v2 ) return 1;
  return 0;
}


{instantiation}
Ordinarily, when call a function, the compiler needs to see only a
declaration.  Similarly, when use objects of class type, the class definition
must be available but the definition of the member functions need not be
present. As a result, put class definition and function declaration in header
file and definition of ordinary and class member function is source files. 

Templates are 'different' since the compiler generates code 'only' when use a
template; instantiate a specific instance of the template. So to generate an
instantiation, needs to have the code that defines a function and class
template member function. As a result, headers includes definitions as well as
declarations.

The fact that the compiler generates code 'only' when use a template affects
when generate compilation errors.

Sales_data data1, data2;
cout << compare(data1, data2) << endl;

Sales_data don't have operator<. Errors such as this cannot be detected until
the compiler instantiates the definition of compare on type Sales_data. No
errors when use with types which supports operator<.

The 'instantiation' is a process that create a concrete 'independent' function
or class from a template when compiling. Code generation and these compiler
generated function or class are an 'instantiation' of the template. Must be
defined in the same namespace that contains the original template. See p675
for C++ feature to control this. note: what does it mean?

<overloading-and-templates>
function templetes can be overloaded by other templates or by ordinary
nontemplate functions. The things to remember is:

As shown in function-matching, nontemplate and then the more speciailized
function are preferred.


={============================================================================
*kt_dev_cpp_050* cpp-template-class cpp-template-friend

Blueprint for generating classes. Unlike function template, compiler 'cannot'
deduce the type of parameter so user must provide extra 'additional'
information to instantiate it. Which is the list of template arguments. 

  It is up to the user to ensure that the template argument type support any
  operations that template uses, and that those operations behave correctly in
  the context in which the template uses them. Include headers for any type to
  instantiate that template.

see *cpp-ex-strblob-template*


<extra-information>
Unlike function template, must provide the element type which is extra
information and is template argument which binds to tempalte parameter. Use
these argument to instantiate a 'specific' and 'independent' class from the
template. 

note:
May say "instantiation" rather than "specialization" and think that
specialzation is a special case of instantiation.

Blob<int> ia;
Blob<int> ia2 = { 0, 1, 2, 3, 4 };
Blob<string> names;

From class template, compiler will generate a class:

template <> class Blob<int> {
  typedef typename std::vector<int>::size_type size_type;
  Blob();
  Blob(std::initializer_list<int> il);
  ...
  private:
    std::shared_ptr<std::vector<int>> data;
    ...
};


<instantiated-type>
The name of a class template is not the name of type. A class template is used
to instantiate a 'type' and an instantiated type always includes template
arguments.

shared_ptr<vector<string>>  // both are different type
shared_ptr<vector<int>>     


{cpp-template-friend}
When a class contains a friend declaration, the class and the friend can
independently be template or not.

<one-to-one>
The one-to-one friendship is the most common form of friendship from a class
template to `the specific instantiation` of class or function template.

// forward declaration needed for friend declaration in Blob

template <typename T> class BlobPtr;
template <typename T> class Blob;
template <typename T> bool operator==(const Blob<T> &, const Blob<T> &);

template <typename T> class Blob {

    // each intantiation of Blob grants limited access to the instantiation of
    // BlobPtr and the equality operator with the same type, T. 

    friend class BlobPtr<T>;

    // see notation
    friend bool operator==<T>(const Blob<T> &, const Blob<T> &);
};


<one-to-many>
Can also make every(all) instantiation(type) of another template its friend or
may limit friendship to a specific instantiation.

templcate <typename T> class C2 {

  // single instantiation
  friend claass Pal<T>;

  // all instances of Pal2 are friends. no forward declaration required.
  template <typename X> friend class Pal2;
};


{template-static}
As with a static in ordinary class, there must be exactly one definition of
each static member. Each instantiation has its 'own' instance of static
members.

template <typename T> class Foo {
  public:
    static std::size_t count() { return ctr; }
    ...

  private:
    static std::size_t ctr;
};

template <typename T>
size_t Foo<T>::ctr = 0;

Foo<int> fi;

auto ct = Foo<int>::count();  // via scope operator and instantiated only used
ct = fi.count();              // via an object


={============================================================================
*kt_dev_cpp_050* cpp-template-type-member

{template-type-members} <cpp-type-member> <cpp-typename>
Uses scope operator(::) to access both static member and type members. For
example, string::size_type. In nontemplate code, the compiler has access to
the class definition and knows whether a name accessed through the scope
operator is a type or static member.

`However, in template code,` when see code such as T::mem, won't know whether
name is a type or a static member until instantiation is done. 

The problem is: is defining a variable named p or multiplying a static data
member named size_type by p?

T::size_type *p;

By default, the language assumes that a name accessed through the scope
operator is 'not' a type. So if want to use type member of template must
'explicitly' tell using the keyword `typename`

template<typename T> 
typename T::value_type top( const T& c )
{
  if( !c.empty() )
    return c.book();
  else
    return `typename` T::value_type();      // "typename T::value_type" is a type
}

EC++42. This is called 'dependant' type names since it depends on the template
parameter. This causes 'parsing' difficulty and this is why must tell it to
compiler and use 'typename' but not class.

template<typename T>
void print2nd( const T& container )
{
  T::const_iterator iter( container.begin() );  // iter is dependant name
  ...
}

template<typename T>
void print2nd( const T& container )
{
  typename T::const_iterator iter( container.begin() );  // must use typename
  ...
}

The exception to this is when typename is used in base class type. Suppose
that if it have to use typename in this case, then how difficult it is to
parse. Suppose Nested is a type(class) in this example.

template<typename T>
class Derived: public Base<T>::Nested {               // not use typename here
  public:
    explicit Derived(int x) : Base<T>::Nested(x) {    // not use typename here
      typename Base<T>::Nested temp;                  // use as usual
      ...
    }
    ...
};


Use typedef alias for a dependant name. This example is to create a local
variable which is the type pointed by a iterator.

template<typename iterT>
void workWithIterator(iterT iter)
{
  typename std::iterator_traits<iterT>::value_type temp(*iter);
  ...
}

template<typename iterT>
void workWithIterator(iterT iter)
{
  typedef typename std::iterator_traits<iterT>::value_type value_type;
  value_type temp(*iter);
  ...
}

<ex>
In the StrBlob example, it uses: 

class StrBlob {
  public:
    typedef std::vector<std::string>::size_type size_type;
    ...
};

But,

class StrBlob {
  public:
    `typedef typename` std::vector<std::string>::size_type size_type;
    ...
};

Tried the both and the both compiles and works well.

  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
      typedef size_t					 size_type;
    };


={============================================================================
*kt_dev_cpp_050* cpp-template-default-argument

Under new standard, supports default argument for both function and class
template while the earlier version support only for class.

<ex> function template

The rewritten example of the previous example and see that F represent the
type of a callable objects.

template <typename T>
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

// `This shows how function-object is useful` *cpp-functor*
// default template argument, the 'type' of callable 
// default function argument, F()

template <typename T, typename F = less<T>>        
int compare( const T &v1, const T &v2, F f = F())  
{
  if (f(v1, v2)) return -1;
  if (f(v2, v1)) return 1;
  return 0;
}

{
  cout << "compare_f(1, 2): " << compare(1, 2) << endl;
  cout << "compare_f(1, 1): " << compare(1, 1) << endl;
  cout << "compare_f(2, 1): " << compare(2, 1) << endl;

  cout << "compare_f(1, 2): " << compare(1, 2, greater<int>()) << endl;
  cout << "compare_f(1, 1): " << compare(1, 1, greater<int>()) << endl;
  cout << "compare_f(2, 1): " << compare(2, 1, greater<int>()) << endl;
}

May supply their own comparison operation but are not required to do so since
T is `int`.

bool i = compare(0, 42);

However, this depends on the isbn in item1 and item2.

Sales_data item1(cin), item2(cin);

bool compareIsbn( const Sales_data &lhs, const Sales_data &rhs )
{
    return lhs.isbn() < rhs.isbn();
}

bool j = compare( item1, item2, compareIsbn );


<ex> class template

template <typename T, typename container = vector<T>>
class MyClass;

template <typename T = int>           // default type
class Numbers {
  public:
    Numbers(T v = 0): val(v) {}       // default value
  private:
    T val;
};

Numbers<long double> lots_of_precision;

<cpp-template-default-type>
The empty braket says we want the 'default' type to instantiate.

Numbers<> average_precision;


={============================================================================
*kt_dev_cpp_050* cpp-template-member

Either an ordinary class or class template may have a member function that is
itself a template; `member template.` See this word ordering since it
summarise that it is member function and function template.

  "member template may 'not' be virtual."

<with-nontemplate-class>
The member template of ordinary class from CPR 672. This example is similar to
the default deleter in unique_ptr since overloads operator(). Unlike default
deleter, support debug print and any type, use template.


#include <iostream>
#include <string>
#include <typeinfo>

using namespace std;

// *cpp-functor*
class DebugDelete
{
  private:
    // *cpp-reference-member*
    ostream &os;

  public:
    DebugDelete(ostream &s = cerr) : os(s) {}

    // as with any function template, the type of T is 'deduced'
    template<typename T>
      void operator() (T* p) const
      { 
        os << "deleting " << typeid(p).name() << ", p = " << p << endl; 
        delete p; 
      }
};

int main()
{
  double *pd = new double();
  int *pi = new int();
  DebugDelete d;

  cout << "in main" << endl;

  d(pd); // now instantiated, T is double *
  d(pi); // now instantiated, T is int *

  cout << "end main" << endl;
}

in main
deleting Pd, p = 0x9be7008
deleting Pi, p = 0x9be7018
end main

<ex>
Can be used with unique_ptr as a deleter:

unique_ptr<int, DebugDelete> p( new int, DebugDelete() );
unique_ptr<string, DebugDelete> p( new string, DebugDelete() );

How will DebugDelete be instanticated for these cases? These are equivalent
to:

void DebugDelete::operator() (int*) const { delete p; }
void DebugDelete::operator() (string*) const { delete p; }

Why? Whenever unique_ptr's dtor is instantiated, DebugDelete's call operator
will also be instantiated.

After all, whether it is for ordinary class or class template, member template
is function template so compiler 'deduce' the type of member template when
used(instantiated) so these will be instantiated to use the correct type when
deleter is called.


<with-template-class>
Both the class and member template have their 'independent' template
parameters. To support iterators into varying kinds of sequences.

template <typename T> class Blob {
  template <typename It> Blob(It b, It e);
  ...
};

template <typename T>
template <typename It>
   Blob<T>::Blob(It b, It e): data(std::make_shared<std::vector<T>>(b,e)) {}

To instantiate:

Blob<int> a1( begin(iarray), end(iarray));
Blob<int> a1( ivec.begin(), ivec.end());
Blob<string> a1( svec.begin(), svec.end());

As with "with-nontemplate-class", function parameter types are 'deduced' as it
is function template.


={============================================================================
*kt_dev_cpp_050* cpp-template-explicit-instantiation

{template-control-instantiation}
The fact that instantiations are generated when a template is used means that
the same instantiation may appear in multiple object files. This overhead can
become significant in large systems. 

Under new standard *C++11* , `can avoid this through explicit instantiation.`

extern template `declaration`     // instantiation `declaration`
template `declaration`            // instantiation `definition`

When the compiler sees an "extern template declaration", will not generate
code for that instantiation 'in' that file and it is to say there will be
nonextern use of that elsewhere in the program. 

Must be one definition for that particular instantiation and appear before any
code that use that.

// file1.cc

// "instantiation declaration"
extern template class Blob<string>;
extern template int compare( const int&, const int& );

// Blob<string> instantiation will appear elsewhere
Blob<string> sa1, sa2;

// Blob<int>, initializer_list ctor, and copy ctor instantiated in this file.
Blob<int> a1 = { 0, 1, 2, 3, 4 };
Blob<int> a2(a1);

// compare(const int&, const int&) instantiation will appear elsewhere
int i = compare( a1[0], a2[0] );


// file2.cc *cpp-template-instantiate-all*
// compiler generate `all members` including inline members when see
// "instantiation definition" and must link file1.o with file2.o.

template class Blob<string>;
template int compare( const int&, const int& );


<instantiation-definition>
The instantiation definition generates 'all' the members of that template
including inline member function even if do not use a member since the
compiler cannot know which member the program uses.

Can be used only for types that can be used with every member function of a
class template.


*cpp-interview*

How to instantiate all members from a template? When it is useful? from
youview interview. How to before C++11?

http://stackoverflow.com/questions/2351148/explicit-instantiation-when-is-it-used

For instance, libstdc++ contains the explicit instantiation of

  // std::basic_string<char,char_traits<char>,allocator<char> >
  typedef basic_string<char> string;

so every time you use functions of std::string, the same function code doesn't
need to be copied to objects. The compiler only need to refer (link) those to
libstdc++

https://msdn.microsoft.com/en-us/library/by56e477%28VS.80%29.aspx
Explicit Instantiation Visual Studio 2005 Other Versions

Explicit instantiation lets you create an instantiation of a templated class
or function without actually using it in your code. Because this is useful
`when you are creating library files` that use templates for distribution,
  uninstantiated template definitions are not put into object (.obj) files.


  since templates are ordinarily in header files and by using explicit
  instantiation, make a library. see the same reason of using library.

The following explicitly instantiates MyStack for int variables and six items:

template class MyStack<int, 6>;

This statement creates an instantiation of MyStack without reserving any
storage for an object; code is generated for all members.

The following explicitly instantiates 'only' the constructor member function:

template MyStack<int, 6>::MyStack( void );

Function templates can be explicitly instantiated by redeclaring them with a
specific type argument, as seen in the example in Function Template
Instantiation.


={============================================================================
*kt_dev_cpp_050* cpp-template-efficiency-on-deleter

{efficiency-and-flexibility}
The difference in how the deleter between shared_ptr and unique_ptr is handled
may have important perforamce impacts. CPR 678.

shared_ptr<connection> p (&c, end_connection);
unique_ptr<connection, decltype(end_connection)*> p ( &c, end_connection );

<shared-ptr>
Since the deleter type is not part of shared_ptr type and not known until run
time, do not hold the deleter as a direct member. Indeed, can change the
deleter type during that shared_ptr's lifetime; can construct a shared_ptr
using one deleter type and subsequently use reset() to give that same
shared_ptr a different deleter type. Cannot have member whose type changes at
run time. Hence deleter must be stored indirectly. (Suppose by pointer)

The shared_ptr dtor must have:

// deleter known only at run time; call through pointer and requires run time
// jump to del's location such as:

del ? del(p) : delete p;

<unique_ptr>
Since the deleter type is part of unique_ptr type and is known at compile
time, the deleter can be stored directly in each unique_ptr object. Indeed,
  call might even be inlined at compile time.

// direct call to the deleter is 'instantiated'
del(p);

<design-choice>
By binding the deleter at compile time, unique_ptr avoids the run-time cost of
an `indirect call` to its deleter. In contrast, by binding at run time,
   shared_ptr makes it easier for users to override the deleter.

<code>
template<typename _Tp1, typename _Deleter> 
   __shared_ptr(_Tp1* __p, _Deleter __d)    // from ctor

  ...

   __d(__p); // Call _Deleter on __p.       // from other function


={============================================================================
*kt_dev_cpp_050* cpp-template-explicit-argument

CPR 16.2.2

The user have to specify the type of template argument when not possible for
the compiler to deduce the type since doesn't appear in the function parameter
list and there is no arguments whose type can be used to deduce the type of
T1. That way the user can choose whatever precision is appropriate.

template< typename T1, typename T2, typename T3 > 
T1 sum( T2, T3 );

auto val3 = sum(i, lng);              // cannot deduce T1
auto val3 = sum<long long>(i, lng);   // long long sum( int, long )


<can-specify-all>
The explicit template functon argument matches from left to right and the below
is poor design since have to specify all of them to get T3.

template<typename T1, typename T2, typename T3> 
T3 alternative_sum( T2, T1 );

// error, can deduce T3
auto val3 = alternative_sum<long long>(i, lng);

// ok, all are specified
auto val3 = alternative_sum<long long, int, long>(i, lng);


*cpp-q* : does it have real use case?


<normal-conversion>
As with ordinary argument, normal conversion applies on
`template-explicit-argument` since no deduction involved.

template <typename T> int compare(const T& v1, const T& v2);

long lng;

compare(lng, 1024);         // error since parameters do not match
compare<long>(lng, 1024);   // okay. compare( long, long );
compare<int>(lng, 1024);    // okay. compare( int, int );


={============================================================================
*kt_dev_cpp_051* cpp-template-type-traits cpp-type-traits

CPR 16.2.3

Suppose that want to write the function that takes a sequence and returns a
reference to an element.

template< typename It > 
??? &fcn( It beg, It end )
{
  // process the range
  return *beg;  // return a reference to an element from the range
}

vector<int> vi = { 1, 2, 3, 4 };
Blob<string> ca = { "hi", "bye" };

auto &i = fcn( vi.begin(), vi.end() );    // should return int&
auto &i = fcn( ca.begin(), ca.end() );    // should return string&

Do not know the exact type to return but know that want that type to be a
reference to the element type of the sequence. 

Can have more arguments but more template argument imposes a burden on the
user. How to solve?


<cpp-trailing-return-type> *C++11*
May use decltype(*beg) to get the type but beg don't exist until the parameter
list has been seen. The trailing return type allows us define the return type
after the parameter list is seen.

template< typename T > 
auto &fcn( It beg, It end ) -> decltype(*beg)
{
  // process the range
  return *beg;  // return a reference to an element from the range
}

This say fcn's return type is the same as the type returned by dereferencing
its beg parameter and which is a reference to the type.


<type-transformation>
Sometimes do not have direct access to the type we need. How to return 'value'
rather than a reference in this example? 

The problem is that we know almost nothing about the types we're passed. In
this function, the only operators we 'know' we can use are iterator operations
but no iterator operations that yield elemen type (as opposed to reference to
    element).

To get the element type, use type transformation template in the <type_traits>
header.

When instantiate `remove_reference<>` with a reference type, public type
memeber `type` is the referred-to type. 

remove_reference<int&>     // `type` member is `int`

template< typename T > 
auto &fcn( It beg, It end ) -> typename remove_reference<decltype(*beg)>::type
{
  // process the range
  return *beg;  // return a reference to an element from the range
}

Returns a copy of an element's value.

*cpp-q* : Still use C++11 feature, trailing return. How to do that before C++11? 


{cpp-type-traits} CLR 5.4
Almost everything in the C++ standard library is template based. To support
the programming of templates, sometimes called metaprogramming, template
utilities are provided to help both programmers and library implementers.

Type traits, which were introduced with TR1 and extended with C++11, provide a
'mechanism' to define behavior 'depending' on types. A type trait provides a
way to deal with `the properties of a type.`

// tr1/type_traits
namespace std _GLIBCXX_VISIBILITY(default)
{
  /// integral_constant
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static const _Tp                      value = __v;
      typedef _Tp                           value_type;
      typedef integral_constant<_Tp, __v>   type;
    };
  
  /// typedef for true_type
  typedef integral_constant<bool, true>     true_type;

  /// typedef for false_type
  typedef integral_constant<bool, false>    false_type;

  /// is_pointer
  template<typename _Tp>
    struct is_pointer
    : public integral_constant<bool, (__is_pointer_helper<typename
				      remove_cv<_Tp>::type>::value)>
    { };
}

<ex>
#include <iostream>

using namespace std;

template <typename T>
void foo (const T& val)
{
  // is_pointer<T> yields either a `true_type` ro `false_type`, for which
  // ::value either yields true or false.

  if (std::is_pointer<T>::value) {
    std::cout << "foo() called for a pointer" << std::endl;
  }
  else {
    std::cout << "foo() called for a value" << std::endl;
  }
}

int main()
{
  int *p;

  foo(p);
}

foo() called for a pointer

The 'trait' std::is_pointer, defined in <type_traits>, is used to check
whether type T is a pointer type. 

note: see that not include type_traits header in the example.


{traits-and-overloads}
Why use traits to provide two actions based on type better than providing two
overloads of foo(): one for ordinary types and one for pointer types?

One answer is that sometimes, too many overloads are necessary. the power of
type traits comes more from the fact that they are building blocks for
'generic' code, which can be demonstrated by two examples.

<ex>
Suppose that you have a function foo() that should be implemented differently
for integral and floating-point type arguments. The usual approach would be to
overload this function for all available integral and floating-point types:

void foo (short);             // provide integral version
void foo (unsigned short);
void foo (int);
...
void foo (float);             // provide floating-point version
void foo (double);
void foo (long double);

This repetition is not only tedious but also introduces the problem that it
might not work for new integral or floating-point types, either provided by
the standard, such as long long, or provided as user-defined types.

With the type traits, you can provide the following instead:

template <typename T>
void foo_impl (T val, std::true_type);   // provide integral version

template <typename T>
void foo_impl (T val, std::false_type);  // provide floating-point version

template <typename T>
void foo (T val)
{
  foo_impl (val, std::is_integral<T>());
}

The std::is_integral<T>() at compile time yields std::true_type or
std::false_type, which defines which of the provided foo_impl() overloads gets
instantiated.


<ex>
Another example for the usability of type traits is the need to process the
"common type" of two or more types.

For example, it would be an appropriate type of the minimum or the sum of two
values of different type. Otherwise, if I want to implement a function that
yields the minimum of two values of different types, which return type should it
have:

template <typename T1, typename T2>
??? min (const T1& x, const T2& y);

Using the type traits, you can simply use the std::common_type<> to declare this
type:

template <typename T1, typename T2>
typename std::common_type<T1,T2>::type min (const T1& x, const T2& y);


{iterator-traits} 
// for writing algorithm? needs more.

It might be useful or even necessary to be able to overload behavior for
different iterator categories. By using iterator tags and iterator traits (both
    provided in <iterator>), such an overloading can be performed.

For each iterator category, the C++ standard library provides an `iterator-tag`
that can be used as a "label" for iterators:

namespace std {
  struct output_iterator_tag {
  };
  struct input_iterator_tag {
  };
  struct forward_iterator_tag
    : public input_iterator_tag {
    };
  struct bidirectional_iterator_tag
    : public forward_iterator_tag {
    };
  struct random_access_iterator_tag
    : public bidirectional_iterator_tag {
    };
}

If you write generic code, you might not be interested only in the iterator
category. You may need the type of the elements to which the iterator refers.
Therefore, the C++ standard library provides a special template structure to
define the iterator traits.

This structure contains all relevant information about an iterator and is used
as a common interface for all the type definitions an iterator should have (the
    category, the type of the elements, and so on):

namespace std {
  template <typename T>
    struct iterator_traits {
      typedef typename T::iterator_category iterator_category;
      typedef typename T::value_type value_type;
      typedef typename T::difference_type difference_type;
      typedef typename T::pointer pointer;
      typedef typename T::reference reference;
    };
}


={============================================================================
*kt_dev_cpp_052* cpp-template-argument-deduction

For function template, deduction is process of determining the template
arguments type from the function arguments. This generates a version of the
function that best matches the given call.

<limited-conversion>
Only allows two converison in a call to function template but not others such
as derived-to-base, arithmetic, and user defined conversion.

* const conversion
Can pass a reference(or pointer) to a nonconst to const parameter that is a
reference(or pointer).

* function-to-pointer conversion
Array or a function parameter will be converted to a pointer to the function's
type if the function parameter `is not a reference type.`

template <typename T> T fobj(T, T);                   // arguments are copied
template <typename T> T fref(const &T, const &T);     // references

string s1("a value");
const string s2("another value");

fobj(s1, s2);   // calls fobj(string, string); const is ignored
fref(s1, s2);   // calls fref(const string&, const string &); 
                // use conversion to const on s1

int a[10], b[42];

fobj(a, b);     // fobj(int*, int*);
                // arrays are different sizes and hence have different type.
                // but both are converted to pointer.

fref(a, b);     // parameters are references so no convertion to pointers.
                // error since the type of a and b do not match


<more-than-one-type>
The function template can have more than one type, function parameters, to
allow normal conversion on the parameters.

template <typename T>         // '<typename T>' is template param list
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

long lng;
compare( lng, 1024 );         // compare( long, int );

Since there are limited conversions, the deduced type do not match and this is
an error when do not have the same type.

To solve this:

template <typename A, typename B>
int flexibleCompare( const A& v1, const B& v2 )
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

flexibleCompare( lng, 1024 );   // flexibleCompare( long, int );

Of course, < operator must exist that can compare those types.


<normal-conversion-for-ordinary-argument>
Ordinary type that do not involve a template type parameter have no special
processing so uses normal conversion.

template <typename T>
ostream &print( ostream &os, const T &obj )
{
    return os << obj;
}

print( cout, 42 );         // print( ostream&, int )

ofstream f("output");
print( f, 10 );            // convert ofstream to ostream&. derived-to-base.


{deduction-and-function-pointer}
The pointer pf1 points to the instantiation of compare. The type of the
parameter in function pointer, pf1, 'determines' the type of template
argument. T is bound to `int`.

template <typename T> int compare( const T&, const T& );

int (*pf1) ( const T&, const T& ) = compare;


It is an error if the template argument cannot be determined from the function
pointer type.

void func(int (*)(const string&, const string&));
void func(int (*)(const int&, const int&));

func(compare);     // error. Which instantiation of compare?

However, by looking at the function's parameter, not possible to determine a
unique type for the template arguments.

To solve this ambiguity, use template-explicit-argument.

func(compare<int>);


{deduction-and-reference}
When function parameter is `reference`, two important points:

template <typename T> void f(T &p);

<when-use-lvalue-reference>
template <typename T> void f1(T &v1);

f1(i);    // T is `int`
f1(ci);   // T is `const` `int`
f1(5);    // error since cannot bind `lvalue-reference` to `rvalue`.
          // <const-reference-to-literal>
          // const int &ri = 42;    // ok 
          // &ri = 42;              // error

template <typename T> void f2(const T &v1);

f2(i);    // T is `int`
f2(ci);   // T is `int`
f1(5);    // okay since `const &` can be bound to rvalue. T is `int`

The point is that use "const T&" to support 'any' type. The `const` is part of
function parameter type but not part of template parameter list.


<when-use-rvalue-reference>
template <typename T> void f3( const T&& );

f3(5);      // T is `int`

How about this?

f3(i);

CPR 688. Error? Since cannot bind an `rvalue-reference` to an `lvalue`? The
exception which are the foundation for how `std::move()` operate.

The first is when pass an `lvalue` to `rvalue-reference` function `parameter`,
    deduce it as argument's `lvalue-reference`.

f3(i);      // T is `int&`

Then instantiates 

void f3(const int& &&);

*reference-collapsing*
Wired? reference to reference? Ordinarily, cannot define that but allows
'indirectly' through `reference-collapsing`

X& &, X& &&, X&& & to X&. X&& && to X&&

The reference collapsing applies 'only' when a reference to a reference is
created indirectly such as in a type alias or a template parameter. so can
call f3 on lvalue.

f3(i);      // T is `int&`
f3(ci);     // T is `const int&`

void f3<int&>(int& &&); -> void f3<int&>(int&);

The point is that to pass 'any' type. So both way so the same; support any type.


<which-one>
Which one to use? This matters when write template.

template <typename T> void f3(T &&val)
{ 
    T t = val;      // copy or binding?
    t = fcn(t);     // change only t or val and t?
    if(val == t) { ... }
}


* When call f3 on `rvalue`, f3(42), T is `int` so "int t = val". t and val are
  independant.
    
* When call f3 on `lvalue`, f3(i), T is `int&` so "int& t = val". When change t, will
  change val as well. so if test will always yield true.

  note: is it legal?

  int& t = int& val; 

It is suprisingly difficult to write code that is correct when type is plain
nonreference or reference type. 

In practice, `rvalue-reference` used in one of two context: argument forwading
or template overload.

// *cpp-overload* const overloading
Record lookup( account & );             // nonconst version
Record lookup( const account &);        // const version

// *cpp-overload* copy and move overloading
void push_back( const X& );             // copy version
void push_back( X&& );                  // move version

template <typename T> void f( const T& );   // binds to `lvalue` and `const-rvalue`
template <typename T> void f( T&& );        // binds to `nonconst-rvalue`


<std-move>
The standard defines std::move() which is example that works on rvalue and
lvalue arguments through *reference-collapsing*

In other words, cannot directly bind `rvalue-reference` to `lvalue` but can
'indirectly' as `reference-collapsing`. Use std::move() to obtain an
`rvalue-reference` bound to an lvalue.

template <typename T>
typename remove_reference<T>::type&& move( T&& t )
{
  // get `rvalue-reference` of the referred-to type
  return static_cast<typename remove_reference<T>::type &&> (t);
}

string s1("hi!"), s2;

// temporary, `rvalue`, to string&& move(string &&t)
s2 = std::move( string("bye") );       
// `lvalue`, to string&& move(string &t)
s2 = std::move( s1 );


={============================================================================
*kt_dev_cpp_053* cpp-template-std-forward

{std-forward}
Some function need to forward their arguments with types 'unchanged' to
another function. In such cases, need to 'preserve' everything including
whether or not type is `const` and whether the argument is an `lvalue` or an
`rvalue`.

template <typename F, typename T1, typename T2>
void flip1(F f, T1 t1, T2 t2)
{
  f(t2, t1);
}

works fine until when use it to call a function that has a reference.

void f(int v1, int &v2)
{
  cout << v1 << " " << ++v2 << endl;
}

f(42, i);               // f changes i
flip1(f, j, 42);        // f(42, j); leaves j unchanged

The instantiation is:

void flip1(void(*fcn)(int, int&), int t1, int t2);

The problem is that j in flip1 is copied to t1 which is local to flip1 so the
changes made by f do not affect.

Solution? A function parameter that is an rvalue reference to a template
parameter 'preserves' constness and lvalue/rvalue property of its
corresponding argument.

template <typename F, typename T1, typename T2>
void flip2(F f, T1 &&t1, T2 &&t2)
{
  f(t2, t1);
}

Still flip2 solves one half of the problem since cannot be used to call a
function that has an rvalue parameter.

void g(int &&i, int& j)
{
  cout << i << " " << j << endl;
}

void flip2(void(*fcn)(int &&, int&), int t1, int t2);

// flip2(g, i, 42);    // g(42, i); g(t2, t1);
flip2(g, 42, i);    // g(i, 42); g(t2, t1);

Why? Since a function parameter, like any other variable, is an lvalue
expression. The t2 is lvaue(to rvalue-reference) and cannot 'directly' bind
lvalue to `rvalue-reference` parameter in g. 

note: WHY not reference-collapsing? Because g() is not template.


Use `std::forward()` to preserve the types of the original arguments. Unlike
std::move(), std::forward() 'must' be called with an explicit template
argument, *cpp-template-explicit-argument* and returns rvalue reference to
that type, T &&. 

template <typename F, typename T1, typename T2>
void flip(F f, T1 &&t1, T2 &&t2)                    // 1
{
  f(std::forward<T2>(t2), std::forward<T1>(t1));    // 2
}

To preserve type information is two-step process, 1 and 2.


={============================================================================
*kt_dev_cpp_053* cpp-template-overload

A function return a string representation of a given object.

// print any type
template <typename T> string debug_rep(const T &t)
{
  ostringstream ret;
  ret << t;           // use T's output operator
  return ret.str();   // return a copy of the string to which ret is bound
}

note:
Why it says, "use T's output operator" since operator<< is usually nonmember
function?

When use gdb, this "ret << t" leads to:

std::operator<< <char, std::char_traits<char>, std::allocator<char> > 
    (__os=..., __str="this is string") 
    at /include/c++/4.9.2/bits/basic_string.h:2777
2777	      return __ostream_insert(__os, __str.data(), __str.size());

This is not in "class basic_string" and in std global namespace. Looks like a
global function template.

  /**
   *  @brief  Write string to a stream.
   *  @param __os  Output stream.
   *  @param __str  String to write out.
   *  @return  Reference to the output stream.
   *
   *  Output characters of @a __str into os following the same rules as for
   *  writing a C string.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
	       const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 586. string inserter not a formatted function
      return __ostream_insert(__os, __str.data(), __str.size());
    }


When use own class like, "debug_rep(My);", emit errors:

$ ./bldcpp.sh t_templ.cpp 
t_templ.cpp: In instantiation of 'std::string debug_rep(const T&) [with T = My; std::string = std::basic_string<char>]':
t_templ.cpp:27:17:   required from here
t_templ.cpp:15:9: error: cannot bind 'std::basic_ostream<char>' lvalue to 'std::basic_ostream<char>&&'
     ret << t;
         ^
In file included from /home/kpark/gcc-build/install/include/c++/4.9.2/iostream:39:0,
                 from t_templ.cpp:1:
/include/c++/4.9.2/ostream:602:5: note: initializing argument 1 of 'std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&&, const _Tp&) [with _CharT = char; _Traits = std::char_traits<char>; _Tp = My]'
     operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)
     ^

<ex>
#include<iostream>
#include<string>
#include<sstream>

using namespace std;

class Mine 
{
    private:
        string name;

    public:
        Mine(): name(string("mine")) { cout << "mine class" << endl; }
        const string& get() { return name; }
};

ostringstream& operator<<(ostringstream& os, Mine mine) 
{ 
    os << mine.get();
    return os;
}

template <typename T> string debug_rep(const T &t)
{
    ostringstream ret;
    ret << t;
    return ret.str();
}

int main()
{
  cout << "---" << endl;

  Mine mine;

  // string str("this is string");
  // cout << debug_rep(str) << endl;
  
  cout << debug_rep(mine) << endl;   
  cout << "---" << endl;
}


Things to remember:

  When there are several overloaded templates that provide an eqaually good
  match for a call, the most specialized version is perferred.

  When a nontemplate function provides an equally good match for a call as a
  function template, the nontemplate version is preferred.


={============================================================================
*kt_dev_cpp_053* cpp-template-variadic

A template function or class that can take varying number of parameters which
is is called a parameter pack to represent zero or more parameters. Two kinds:
`template parameter pack` and `function parameter pack.`

template <typename T, typename... Args>         // Args is template param pack
void foo( const T &t, const Args& ... rest);    // rest is function param pack

int i = 0; double d = 3.14; string s = "how now brown cow";
foo( i, s, 42, d );  // three parameters in the pack
foo( s, 42, "hi" );  // two parameters in the pack
foo( d, s );         // one parameters in the pack
foo( "hi" );         // empty pack

The compiler deduces the parameter types and also the number of parameters in
  the pack, and `instantiate four different foo`:

void foo(const int&, const string&, const int&, const double&);
void foo(const string&, const int&, const char[3]&);
void foo(const double&, const string&);
void foo(const char[3]&);


<variadic-sizeof-operator>
*C++11* Use the `sizeof...` operator to know how many elements are in a pack
which is different from sizeof operator, *cpp-sizeof*

template <typename... Args> void g( Args... args)
{
  cout << sizeof... (Args) << endl;    // number of template parameters
  cout << sizeof... (args) << endl;    // number of function parameters
}

<ex>
Used GCC 4.6.3

#include <iostream>
#include <string>

template <typename T, typename... Args>
void foo(const T &t, const Args &... rest) 
{
  std::cout << "-------" << std::endl;
  std::cout << sizeof... (Args) << std::endl;
  std::cout << sizeof... (rest) << std::endl;
}

int main()
{
  int i = 0; double d = 3.14; std::string s = "how now brown cow";
  foo( i, s, 42, d );  // three parameters in the pack
  foo( s, 42, "hi" );  // two parameters in the pack
  foo( d, s );         // one parameters in the pack
  foo( "hi" );         // empty pack
}

-------
3
3
-------
2
2
-------
1
1
-------
0
0


<variadic-or-initializer-list> 
Can use an initializer-list to define a function that can take a varying
number of arguments. However, the arguments must have the 'same' type.

The point is that variadic functions are used when we know neither the number
nor the types of the arguments to process.


<variadic-recursive>
Variadic are often recursive. To stop the recustion, we also need nonvariadic
funtion.

template <typename T> 
ostream &print( ostream &os, const T &t)
{ return os << t; }

template <typename T, typename... Args>
ostream &print( ostream &os, const T &t, const Args&... rest)
{
  os << t << ", ";            // print the first argument.
  return print(os, rest...);  // recursive call; print the other arguments.
}

The key part is that the 'first' argument in rest gets bound to t. That pops
up a argument from the pack and the remaining in rest 'form' the pack for the
next call until there is the last since variadic is only viable match. 

print( cout, i, s, 42 );
...
print( cout, s, 42 );
print( cout, 42 );

When the last remains, the variadic and the nonvariadic are viable and the
nonvariadic gets called since it is more speciailized. So ends recursion.

note: The declaration of the nonvariadic version of print 'must' be 'before'
variadic version since must be 'in' scope when the variadic version is
defined. Otherwise, the variadic will recurse indefinitely.


<pack-expansion>
When expand a pack, also provide a `pattern` to be used on each expanded
element. Trigger an expansion by putting an ellipsis(...) to the right of
pattern. 

template <typename T, typename... Args>
ostream &print( ostream &os, const T &t, const Args&... rest)     // 1
{
  os << t << ", ";          
  return print(os, rest...);                                      // 2
}

* 1. Expand Args to generate function parameter pack. Applies the pattern,
  "const Args&" to 'each' element in the template pack.

* 2. Expand rest  and the pattern is the name of the function parameter pack.


To see how pattern works, more complicated pattern is: 

template <typename T> string debug_rep( const T &t );

template <typename T, typename... Args>
ostream &errorMsg( ostream &os, const Args&... rest)     // 1
{
  // print( os, debug_rep(a1), debug_rep(a2), ... );
  return print(os, `debug_rep(rest)...`);                  // pattern
}

When call this:

errorMsg( cerr, fcnName, code.num(), otherData, "other", item );

expands to:

print( cerr, debug_rep(fcnName), debug_rep(code.num()), 
               debug_rep(otherData), debug_rep("other"), debug_rep(item) );


However, this fails to compile since expanded as if five arguments to print.

template <typename T, typename... Args>
ostream &errorMsg( ostream &os, const Args&... rest)     // 1
{
  return print(os, debug_rep(rest...) );                 // pattern
}

print(cerr, debug_rep(fcnName, code.num(), otherData, "other", item));


<cpp-template-variadic-forward>
Can use variadic template together with std::forward. To illustrate this, add an
emplace_back to StrVec class.

The emplace_back is variadic member template that uses its arguments to
construct an element directly in space managed by the container.

class StrVec {
  public:
    // each function parameter will be an rvalue reference
    template <typename... Args> void emplace_back(Args &&...args)
    {
      chk_n_alloc();  // reallocate the StrVec if necessary
      alloc.construct(first_free++, std::forward<Args>(args)...);
    }
};

svec.emplace_back(10, 'c');

The pattern in the call to construct will expand to

std::forward<int>(10), std::forward<char>(c)


={============================================================================
*kt_dev_cpp_054* cpp-template-specialization

CPR 16.5

Not always possible to write a 'single' template suited for every possible
template argument. In some cases, the general template is wrong for a type. 

  * When the general template definition might not compile or might do the
    wrong thing.

  * When can take advantage of some specific knowledge to write more efficient
    code.

When cannot or do not want to use the template version, can define a
specialized version of the class or function template.


{problem}
Again, compare() is an example for which the general definition is not
appropriate for a particular type, character pointers. We want to compare
pointers by strcmp() rather than by comparing the pointer values.

// first version for any two types
template <typename T> int compare(const T&, const T&)
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

// second version for string literals. Uses `nontype-template` parameters
template <size_t N, size_t M> int compare(const char (&) [N], const (&) [M])
{
    return strcmp(p1, p2);
}

If calls compare() with character pointers, the first version will be called
because `nontype-template` version will be called only when pass a string
literal or an array.


const char *p1 = "hi", *p2 = "mom";

compare(p1, p2);          // call first
compare("hi", "mom");     // call second


{specialization}
To handle character pointers, can define a `template specialization` of the
first version. A `separate definition` of the template, specific instantiation
in which one or more template parameters are specified to have particular
types.

  *specialization-or-explitict-argument*
  Can use `cpp-template-explicit-argument` because it specifies the types?
  No becuase explict-argument `specifies the type` with the same
  defintion(code) but specialization supply different 'definition' and
  specifies definition or instantiation. Hence sometimes called
  `total-specitialzation` as oppose to partial specialization?


<for-function-template>
To indicate that we are specializing a template, use empty braket(<>) whcih
means we must supply arguments for 'all' template parameter in the original
template.

// specialized, special version of compare
template <>
int compare(const char* `const` &p1, const char* `const` &p2)
{ return strcmp( p1, p2 ); }

The hard part is to understand the function parameter type because the
function parameter 'must' match the corresponding types in the 'original'
template:

template <typename T> int compare(const T&, const T&);

const char *p1 = "hi", *p2 = "mom";

Want to use T as "const char *" and original template requires "const" version
of this "type". As with *const-on-base-type* the type to use in specialization
is "const char const *" since base type is "const char *"

This specialization becomes `nontemplate-version` which affect function
matching.


<scope-rule>
In order to specialize a template, the original template `must be in scope.`
Moreover, a declaration for a specialization must be in scope before any use
of it.

Because the compiler can generate code using the original template when a
specialization is missing, errors in declaration 'order' between a template
and specialization are easy to make but hard to find. The compiler is unlikely
to detect.

The best practice is that should have all in the same header file.
Declarations for all templates should appear first, followed by any
specialization.


<for-class-template>
As an example, specialize the library hash template to store Sales_data object
in an unordered container. Must do so in the 'same' namespace in which the
original template is defined.

CPR 709. To use unordered map with our own data type, must define a
specialization of the hash template and it must define:

  * An overloaded call operator that return a size_t and takes an object of
    the container's key type.

  * Two type members, result_type and argument_type, which are the return and
    argument types, respectively, of the call operator.

  * The default constructor and copy-assign operator.

To add members to std namespace

namespace std {
    template <>
        // indicate it is a specialization for T, Sales_data, type
        struct hash <Sales_data>
        {
            typedef size_t result_type;
            typedef Sales_data argument_type;

            size_t operator() ( const Sales_data& s ) const;
        };

    size_t hash<Sales_data>::operator()(const Sales_data &s) const
    {
        // use 'unnamed', temporary object and delegate the complexity of good
        // hash function to the library.

        return hash<string>() (s.bookNo) 
          ^ hash<unsigned>() (s.units_sold) ^ hash<double>() (s.revenue);
    }
}  // no semicolon after the end of namespace


Assuming this speciailization is in scope, this will be used automatically
when we use Sales_data as a key:

unordered_multiset<Sales_data> SDest;

Since hash<Sales_data> uses the private members of Sales_data, must make this
calss, the specific instantiation, a friend of Sales_data.
*cpp-template-friend*

// in std since we added it to that namespace
template <class T> class std::hash;

class Sales_data {
  friend class std::hash<Sales_data>;
  ...
};


The second way: Having added the declaration for the specialization to std
namespce we can define the specialization outside the std.

namespace std {
   template <> struct hash< Sales_data >;
}

template <> struct hash <Sales_data> 
{
  size_t operator() ( const Sales_data& s ) const
  {
    ...
  }
  // other members as before
}


{partial-specialization}
Differently from function template, can specify some, but not all, of the
template parameters of class template. Partial speciailization is 'only' for
class template. After the class name, specify arguments for the template
parameters we are specializing and correspond positionally to the parameters
in the original template. 

The remove_reference type-trait works through a series of specialization.

// original, most general template and for any type

template <typename T> struct remove_reference 
{
    typedef T type;
};

// partial specialization used for lvalue and rvalue reference
// *cpp-reference-quailifier*

template <typename T> struct remove_reference`<T&>` 
{ typedef T type; };

template <typename T> struct remove_reference`<T&&>`
{ typedef T type;};

The specialization's parameter list has the same number of parameters as the
original but the parameter's type in the specialization 'differ' from the
original.

int i;

// decltype(42) is `int`, use the original
remove_reference<decltype(42)>::type a;

// decltype(i) is `int&`, use the first 
remove_reference<decltype(i)>::type b;

// decltype(std::move(i)) is `int&&`, use the second
remove_reference<decltype(std::move(i))>::type c;

All three, a, b, and c, have type `int` 


{member-specialization}
Rather then specialize the whole template, can specialize specific member
function(s). If Foo is a template with a member Bar.

template <typename T> struct Foo 
{
    Foo(const T &t = T()): mem(t) {}
    void Bar() { /* ... */ }
    T mem;
};

template <> void Foo<int>::Bar()
{
  ...
}

When use Foo with any type other than int, members are instantiated as usual.
Here specializing the Bar member of Foo<int> class.

Foo<string> fs;   // instantiate Foo<string>::Foo()
fs.Bar();         // instantiate Foo<string>::Bar()

Foo<int> fi;      // instantiate Foo<int>::Foo()
fi.Bar();         // use specialization version of Foo<int>::Bar()


={============================================================================
*kt_dev_cpp_054* template-inheritance

Have got an error on GCC in following case:

template <typename Entry>
class Binary_tree 
{
  ...

  protected:
    Binary_node<Entry> *root;
};


template <typename Record>
class Search_tree: public Binary_tree<Record>
{
  public:
    ...
    Error_code tree_search( Record &target ) const;
};

template <typename Record>
Error_code Search_tree<Record>::tree_search( Record &target ) const
{
  Error_code result = success;

  // <1> Binary_node<Record> *found = search_for_node( root, target );
  // Binary_node<Record> *found = search_for_node( Search_tree<Record>::root, target );
  // Binary_node<Record> *found = search_for_node( Binary_tree<Record>::root, target );
  // Binary_node<Record> *found = search_for_node( this->root, target );
  if( found == NULL )
    return not_present;
  else
    target = found->data;

  return result;
}

The <1> caues an error:
bintree.cpp: In member function ‘Error_code Search_tree<Record>::tree_search(Record&) const’:
bintree.cpp:107:49: error: ‘root’ was not declared in this scope

Why? Googled and found:

http://www.parashift.com/c++-faq-lite/nondependent-name-lookup-members.html
[35.19] Why am I getting errors when my template-derived-class uses a member it inherits from its
template-base-class? 

Perhaps surprisingly, the following code is not valid C++, even though some compilers accept it:

template<typename T>
class B {
  public:
    void f() { }  // member of class B<T>
};

template<typename T>
class D : public B<T> {
  public:
    void g()
    {
      f();        // bad (even though some compilers erroneously (temporarily?) accept it)
    }
};

This might hurt your head; better if you sit down.

Within D<T>::g(), the name f does not depend on template parameter T, so f is known as a
nondependent name. On the other hand, B<T> is dependent on template parameter T so B<T> is called a
dependent name.

Here's the rule: the compiler does 'not' look in dependent base classes (like B<T>) when looking up
nondependent names (like f).

This doesn't mean that inheritance doesn't work. Class D<int> is still derived from class B<int>,
the compiler still lets you implicitly do the is-a conversions (e.g., D<int>* to B<int>*),
dynamic binding still works when virtual functions are invoked, etc. But there is an issue
about how names are looked up.

Workarounds:
1) Change the call from f() to this->f(). <note> this is interesting. "Since this is always
implicitly dependent in a template", this->f is dependent and the lookup is therefore deferred until
the template is actually instantiated, at which point all base classes are considered.

2) Insert using B<T>::f; just prior to calling f().

3) Change the call from f() to B<T>::f(). Note however that this might not give you what you want if
f() is virtual, since it inhibits the virtual dispatch mechanism.

So in the above example, all other cases works other than <1>


={============================================================================
*kt_dev_cpp_060* template-initialize-type-member

No problem to define T member when use template. How set initial value to them?

1. Taken from the example of template default type

template <typename T = int> 
class Numbers {
  public:
    Numbers(T v = 0): val(v) {}
  private:
    T val;
};

However, it assumes that T would be integral type. How about user or class type?


2. Uses copy assign with temporary, T().

template <typename T>
class MovingAverage
{
    public:
        MovingAverage(size_t initial_size=10)
        {
            resize(initial_size);
        }

        void reset()
        {
            accumulated_value = T();
            head = 0;
            tail = 0;
        }

        void resize(size_t new_size)
        {
            reset();
            values.resize(new_size, T());
        }

    private:
        T accumulated_value;
};


3. Other way?


={============================================================================
*kt_dev_cpp_100* read-virtual-function-call-mechanism
  
C++ under the hood

Visual C and C++ (General) Technical Articles

C++: Under the Hood Jan Gray March 1994

Jan Gray is a Software Design Engineer in Microsoft's Visual C++ Business Unit.
He helped design and implement the Microsoft Visual C++ compiler. 

Introduction

It is important to understand how your programming language is implemented. Such
knowledge dispels the fear and wonder of "What on earth is the compiler doing
here?"; imparts confidence to use the new features; and provides insight when
debugging and learning other language features. It also gives a feel for the
relative costs of different coding choices that is necessary to write the most
efficient code day to day. This paper looks "under the hood" of C++, explaining
"run-time" C++ implementation details such as class layout techniques and the
`virtual-function-call-mechanism`.

Questions to be answered include: 

1. How are classes laid out?  
2. How are data members accessed?
3. How are member functions called?
4. What is an adjuster thunk?
5. What are the costs: Of single, multiple, and virtual inheritance? Of virtual
functions and virtual function calls?  Of casts to bases, to virtual bases? Of
exception handling? 

First, we'll look at struct layout of C-like structs, single inheritance,
multiple inheritance, and virtual inheritance, then consider data member access
  and member functions, virtual and not. We'll examine the workings of
  constructors, destructors, and assignment operator special member functions
  and dynamic construction and destruction of arrays. Finally, we'll briefly
  consider the impact of exception-handling support. For each language feature
  topic, we'll very briefly present motivation and semantics for the language
  feature (although "Introduction to C++" this is not), and examine how the
  language feature was implemented in Microsoft Visual C++. Note the distinction
  between abstract language semantics and a particular concrete implementation.
  Other vendors have sometimes made different implementation choices for what
  ever reasons. In a few cases we contrast the Visual C++ implementation with
  others. 


Class Layout

In this section we'll consider the storage layouts required for different kinds
of inheritance.

C-like Structs

As C++ is based upon C, it is "mostly" upwards-compatible with C. In particular,
the working papers specify the same simple struct layout rules that C has:
  Members are laid out in their declaration order, subject to implementation
  defined alignment padding. All C/C++ vendors ensure that valid C structs are
  stored identically by their C and C++ compilers.

Here A is a simple C struct with the obvious expected member layout and padding.

A*->   A::c (padding)
       A::i

struct A {
  char c;
  int i;
}; 


C-like Structs with C++ Features

Of course, C++ is an object-oriented programming language: It provides
inheritance, encapsulation, and polymorphism by extending the mundane C struct
into the wondrous C++ class. Besides data members, C++ classes can also
encapsulate member functions and many other things. However, except for 'hidden'
data members introduced to implement virtual functions and virtual inheritance,
     the instance size is 'solely' determined by a class's data members and base
     classes.

Here B is a C-like struct with some C++ features : There are
public/protected/private access control declarations, member functions, static
members, and nested type declarations. Only the non-virtual data members occupy
space in each instance. Note that the standards committee working papers permit
implementations to reorder data members separated by an access declarator, so
these three members could have been laid out in 'any' order. (In Visual C++,
    members are always laid out in declaration order, just as if they were
    members of a C struct) 

B*->   B::bm1
       B::bm2
       B::bm3

struct B {
  public:
    int bm1;
  protected:
    int bm2;
  private:
    int bm3;
    static int bsm;
    void bf();
    static void bsf();
    typedef void* bpv;
    struct N { };
};


Single Inheritance

C++ provides inheritance to factor out and share 'common' aspects of different
types. A good example of a classes-with-inheritance data type organization is
biology's classification of living things into kingdoms, phyla, orders,
  families, genus, species, and so on. This organization makes it possible to
  specify attributes, such as "mammals bear live young" at the most appropriate
  level of classification; these attributes are then inherited by other classes,
  so we can conclude without further sp ecification that whales, squirrels, and
  people bear live young. Exceptional cases, such as platypi (a mammal, yet lays
      eggs), will require that we override the inherited attribute or behavior
  with one more appropriate for the derived class. More on that later. 

In C++, inheritance is specified by using the ": base" syntax when defining the
derived class. Here D is derived from its base class C.

C* ->    C::c1

struct C {
  int c1;
  void cf();
};

C*, D* ->   C::c1
            D::d1

struct D : C {
  int d1;
  void df();
};

Since a derived class inherits all the properties and behavior of its base
class, each instance of the derived class will contain a `complete-copy` of the
instance data of the base class. Within D, there is no requirement that C's
instance data precede D's. But by laying D out this way, we ensure that the
address of the C object within D corresponds to the address of `the-first-byte`
of the D object. As we shall see, this eliminates adding a displacement to a D*
when we need to obtain the address of its embedded C. This layout is used by all
known C++ implementations.

Thus, in a single inheritance class hierarchy, new instance data introduced in
each derived class is simply appended to the layout of the base class. Note our
layout diagram labels the `address-points` of pointers to the C and D objects
within a D . 


Multiple Inheritance

Single inheritance is quite versatile and powerful, and generally adequate for
expressing the (typically limited) degree of inheritance present in most design
problems. Sometimes, however, we have two or more sets of behavior that we wish
our derived class to acquire. C++ provides multiple inheritance to combine them. 

For instance, say we have a model for an organization that has a class Manager
(who delegates) and class Worker (who actually does the work). Now how can we
model a class MiddleManager, who, like a Worker, accepts work assignments from
his/her manager and who, like a Manager, delegates this work to his/her
employees? This is awkward to express using single inheritance: For
MiddleManager to inherit behavior from both Manager and Worker, both must be
base classes. If this is arranged so that MiddleManager inherits from Manager
which inherits from Worker , it erroneously ascribes Worker behavior to
Managers. (Vice versa, the same problem.) Of course, MiddleManager could inherit
from just one (or neither) of Worker or Manager, and instead, duplicate
(redeclare) both interfaces, but that defeats polymorphism, fails to reuse the
existing interface, and leads to maintenance woes as interfaces evolve over
time.

Instead, C++ allows a class to inherit from multiple base classes:

struct Manager ... { ... };
struct Worker ... { ... };
struct MiddleManager : Manager, Worker { ... };

How might this be represented? Continuing with our "classes of the alphabet"
example: 

struct C {
  int c1;
  void cf();
};

E* ->   E::e1

struct E {
  int e1;
  void ef();
};

C*, F* ->   C::c1
    E* ->   E::e1
            F::f1

struct F : C, E {
  int f1;
  void ff();
}; 

Struct F multiply inherits from C and E. As with single inheritance, F contains
a copy of the instance data of each of its base classes. Unlike single
inheritance, it is not possible to make the address point of each bases'
embedded instance correspond to the address of the derived class: 
  
note: since E do not have C in it therefore E should not have the same point as
C.

F f;
// (void*)&f == (void*)(C*)&f;
// (void*)&f < (void*)(E*)&f; 

Here, the address point of the embedded E within F is not at the address of the
F itself. As we shall see when we consider casts and member functions, this
`displacement` leads to a small 'overhead' that single inheritance does not
generally require. An implementation is free to lay out the various embedded
base instances and the new instance data in any order. Visual C++ is typical in
laying out the base instances in `declaration-order`, followed by the new data
members, also in declaration order. (As we shall see, this is not necessarily
    the case when some bases have virtual functions and others don't). 


Virtual Inheritance

Returning to the MiddleManager example which motivated multiple inheritance in
the first place, we have a problem. What if both Manager and Worker are derived
from Employee?

struct Employee { ... };
struct Manager : Employee { ... };
struct Worker : Employee { ... };
struct MiddleManager : Manager, Worker { ... };

Since both Worker and Manager inherit from Employee, they each contain a copy of
the Employee instance data. Unless something is done, each MiddleManager will
contain 'two' instances of Employee, one from each base. If Employee is a large
object, this 'duplication' may represent an unacceptable storage overhead. More
seriously, the two copies of the Employee instance might get modified separately
or inconsistently. We need a way to declare that Manager and Worker are each
willing to share a single embedded instance of their Employee base class, should
Manager or Worker ever be inherited with some other class that also wishes to
share the Employee base class. In C++, this "sharing inheritance" is
(unfortunately) called `virtual-inheritance` and is indicated by specifying that
a base class is virtual.

struct Employee { ... };
struct Manager : virtual Employee { ... };
struct Worker : virtual Employee { ... };
struct MiddleManager : Manager, Worker { ... };

Virtual inheritance is considerably more 'expensive' to implement and use than
single and multiple inheritance. Recall that for single (and multiple) inherited
bases and derived classes, the embedded base instances and their derived classes
either share a common address point (as with single inheritance and the
    'leftmost' base inherited via multiple inheritance), or have a simple
'constant' displacement to the embedded base instance as with multiple inherited
non-leftmost bases, such as E.  

note: so use constant displacement for multiple inheritance.

With virtual inheritance, on the other hand, there can (in general) be no fixed
displacement from the address point of the derived class to its virtual base. If
such a derived class is further derived from, the further deriving class may
have to place the `one-shared-copy` of the virtual base at some other, different
offset in the further derived class. Consider this example: 

struct C {
  int c1;
  void cf();
};

struct G : virtual C {
  int g1;
  void gf();
}; 

G* -> G::vbptr    -> GdGvbptrG
      G::g1          GdGvbptrC
C* -> C::c1

struct H : virtual C {
  int h1;
  void hf();
}; 

H* -> H::vbptr    -> HdHvbptrH
      H::h1          HdHvbptrC
C* -> C::c1

struct I : G, H {
  int i1;
  void _if();
}; 

IdGvbptrC {              G*, *I ->  G::vbptr    -> IdGvbptrG
                                    G::g1          IdGvbptrC
            IdHvbptrC {  H* ->      H::vbptr    -> IdHvbptrH
                                    H::h1          IdHvbptrC
          }           }             I::i1
                         C* ->      C::c1

Ignoring the vbptr members for a moment, notice that within a G object, the
embedded C immediately follows the G data member, and similarly notice that
within an H, the embedded C immediately follows the H data member. Now when we
layout I , we can't preserve both relationships. In the Visual C++ layout above,
       the displacements from G to C in a G instance and in an I instance are
       different.  Since classes are generally compiled without knowledge of how
       they will be derived from, each class with a virtual base must have a
       `way-to-compute` the location of the virtual base from the address point
       of its derived class. 

In Visual C++, this is implemented by 'adding' a `hidden-vbptr` ("virtual base
    table pointer") field to 'each' instance of a class with virtual bases. This
field points to a shared, `per-class` table of displacements from the address
point of the vbptr field to the class's virtual base(s). 

note: Only G and H has vbptr and this is offset to get common C through G or H

Other implementations use embedded pointers from the derived class to its
virtual bases, one per base. This other representation has the advantage of a
smaller code sequence to address the virtual base, although an optimizing code
generator can often common-subexpression-eliminate repeated virtual base access
computations. However, it also has the disadvantages of larger instance sizes
for classes with multiple virtual bases, of slower access to virtual bases of
virtual bases (unle ss one incurs yet further hidden pointers), and of a less
regular pointer to member dereference.

In Visual C++, G has a hidden vbptr which addresses a virtual base table whose
second entry is GdGvbptrC. (This is our notation for "in G, the displacement
    from G's vbptr to C". 

We omit the prefix to "d" if the quantity is constant in all derived classes.

For example, on a 32-bit platform, GdGvbptrC would be 8 (bytes). Similarly, the
embedded G instance within an I addresses a vbtable customized for G's within
I's, and so IdGvbptrC would be 20. As can be seen from the layouts of G , H ,
and I , Visual C++ lays out classes with virtual bases by: 

note: 8 and 20 is offset value

1. Placing embedded instances of the non-virtually inherited bases first, 

2. Adding a hidden vbptr unless a suitable one was inherited from one of the
non-virtual bases, 

3. Placing the new data members declared in the derived class, and, finally, 

4. Placing a single instance of each of the virtually inherited bases at the end
of the instance.

This representation lets the virtually inherited bases "float" within the
derived class (and its further derived classes) while keeping together and at
constant relative displacements those parts of the object that are not virtual
bases. 


Data Member Access

Now that we have seen how classes are laid out, let's consider the cost to
access data members of these classes. No inheritance. In absence of inheritance,
       data member access is the same as in C: a dereference off some
       displacement from the pointer to the object. 

C* pc;
pc->c1; // *(pc + dCc1); 


Single inheritance.

Since the displacement from the derived object to its embedded base instance is
a constant 0, that constant 0 can be folded with the constant offset of the
member within that base.

D* pd;
pd->c1; // *(pd + dDC + dCc1); // *(pd + dDCc1);
pd->d1; // *(pd + dDd1); 


Multiple inheritance. 

Although the displacement to a give n base, or to a base of a base, and so on,
         might be non-zero, it is still constant, and so any set of such
         displacements can be folded together into one constant displacement off
         the object pointer. Thus even with multiple inheritance, access to any
         member is inexpensive.

F* pf;
pf->c1; // *(pf + dFC + dCc1); // *(pf + dFc1);
pf->e1; // *(pf + dFE + dEe1); // *(pf + dFe1);
pf->f1; // *(pf + dFf1); 


Virtual inheritance. 

Within a class with virtual bases, access to a data member or non-virtually
inherited base class is again just a constant displacement off the object
pointer. However, access to a data member of a virtual base is comparatively
expensive, since it is necessary to fetch the vbptr, `fetch-a-vbtable-entry`,
  and then add that displacement to the vbptr address point, just to compute the
  address of the data member. However, as shown for i.c1 below, if the type of
  the derived class is statically known, the layout is also known, and it is
  unnecessary to load a vbtable entry to find the displacement to the virtual
  base.

I* pi;
pi->c1; // *(pi + dIGvbptr + (*(pi+dIGvbptr))[1] + dCc1);
pi->g1; // *(pi + dIG + dGg1); // *(pi + dIg1);
pi->h1; // *(pi + dIH + dHh1); // *(pi + dIh1);
pi->i1; // *(pi + dIi1);
I i;
i.c1; // *(&i + IdIC + dCc1); // *(&i + IdIc1); 

What about access to members of transitive virtual bases, for example, members
of virtual bases of virtual bases (and so on)? Some implementations follow one
embedded virtual base pointer to the intermediate virtual base, then follow its
virtual base pointer to its virtual base, and so on.  Visual C++ optimizes such
access by using additional vbtable entries which provide displacements from the
derived class to any transitive virtual bases. 

Casts

Except for classes with virtual bases, it is relatively inexpensive to
explicitly cast a pointer into another pointer type. If there is a base-derived
relationship between class pointers, the compiler simply adds or subtracts the
displacement between the two (often 0). 

F* pf;
(C*)pf; // (C*)(pf ? pf + dFC : 0); // (C*)pf;
(E*)pf; // (E*)(pf ? pf + dFE : 0); 

In the C* cast, no computations are required, because dFC is 0. In the E* cast,
   we must add dFE , a non-zero constant, to the pointer. C++ requires that null
   pointers (0) remain null after a cast.  Therefore Visual C++ checks for null
   before performing the addition. This check occurs only when a pointe r is
   implicitly or explicitly converted to a related pointer type, not when a
   derived* is implicitly converted to a base*const this pointer when a base
   member function is invoked on a derived object. 

As you might expect, casting over a virtual inheritance path is relatively
expensive: about the same cost as accessing a member of a virtual base: 

I* pi;
(G*)pi; // (G*)pi;
(H*)pi; // (H*)(pi ? pi + dIH : 0);
(C*)pi; // (C*)(pi ? (pi+dIGvbptr + (*(pi+dIGvbptr))[1]) : 0); 

In general, you can avoid a lot of expensive virtual base field accesses by replacing them with one
cast to the virtual base and base relative accesses: 

/* before: */              ... pi->c1 ... pi->c1 ...
/* faster: */ C* pc = pi;  ... pc->c1 ... pc->c1 ... 


Member Functions

A C++ member function is just another member in the scope of its class. Each
(non-static) member function of a class X receives a special `hidden-this`
parameter of type X *const , which is implicitly initialized from the object the
member function is applied to. Also, within the body of a member function,
member access off the 'this' pointer is implicit. 

struct P {
  int p1;
  void pf(); // new
  virtual void pvf(); // new
}; 

P* ->    P::vfptr    -> &P::pvf
         P::p1

P has a non-virtual member function pf() and a virtual member function pvf(). It
is apparent that virtual member functions incur an instance size hit, as they
require a `virtual-function-table-pointer`. More on that later. Notice there is
no instance cost to declaring non-virtual member functions. Now consider the
definition of P::pf() : 

void P::pf() { // void P::pf([P *const this])
  ++p1;        // ++(this->p1);
} 

Here P::pf() receives a hidden this parameter, which the compiler has to pass
each call. Also note that member access can be more expensive than it looks,
     because member accesses are this relative. On the other hand, compilers
     commonly enregister this so member access cost is often no worse than
     accessing a local variable. On the other hand, compilers may not be able to
     enregister the instance data itself because of the possibility this is
     aliased with some other data. 


Overriding Member Functions `virtual-function-call-mechanism`

Member functions are inherited just as data members are. Unlike data members, a
derived class can override, or replace, the actual function definition to be
used when an inherited member function is applied to a derived instance. Whether
the override is static (determined at compile time by the static types involved
    in the member function call) or dynamic (determined at run-time by the
      dynamic object addressed by the object pointer) depends upon whether the
    member function is declared virtual.  


Class Q inherits P's data and function members. It declares pf(), overriding
P::pf(). It also declares pvf(), a virtual function overriding P::pvf(), and
declares a new non-virtual member function qf(), and a new virtual function
qvf(). 

struct P {
  int p1;
  void pf();            // new
  virtual void pvf();   // new
}; 

struct Q : P {
  int q1;
  void pf();            // overrides P::pf
  void qf();            // new
  void pvf();           // overrides P::pvf
  virtual void qvf();   // new
};

P*, Q*   ->    P::vfptr    -> &Q::pvf
               P::p1       -> &Q::qvf
               Q::q1

note: this is Q instance

For non-virtual function calls, the member function to call is statically
determined, at compile time, by the type of the pointer expression to the left
of the -> operator. 

In particular, even though ppq points to an instance of Q, ppq->pf() calls
P::pf(). Also notice the pointer expression `left-of-the` -> is passed as the
hidden this parameter. 

P p; P* pp = &p; Q q; P* ppq = &q; Q* pq = &q;
pp->pf();   // pp->P::pf();   // P::pf(pp);
ppq->pf();  // ppq->P::pf();  // P::pf(ppq);
pq->pf();   // pq->Q::pf();   // Q::pf((P*)pq);
pq->qf();   // pq->Q::qf();   // Q::qf(pq); 


For `virtual-function-calls`, the member function to call is determined at
runtime. Regardless of the declared type of the pointer expression left of the
-> operator, the virtual function to call is the one appropriate to the type of
the 'actual' instance addressed by the pointer. In particular, although ppq has
type P*, it addresses a Q, and so Q::pvf() is called.

pp->pvf();  // pp->P::pvf();  // P::pvf(pp);
ppq->pvf(); // ppq->Q::pvf(); // Q::pvf((Q*)ppq);
pq->pvf();  // pq->Q::pvf();  // Q::pvf((P*)pq); 


`virtual-function-call-mechanism`

`hidden-vfptr-members` are introduced to implement this mechanism. A vfptr is
added to a class (if it doesn't already have one) to address that
`class-virtual-function-table` (vftable). `each-virtual-function` in a class has
a corresponding entry in that class's vftable. Each entry holds the address of
the virtual function override appropriate to that class. Therefore, calling a
virtual function requires 'fetching' the `instance-vfptr`, and indirectly
calling through one of the vftable entries addressed by that pointer. This is in
'addition' to the usual function call overhead of parameter passing, call, and
return instructions. In the example above, we fetch q's vfptr, which addresses
Q's vftable, whose first entry is &Q::pvf. Thus Q::pvf() is called. 

Looking back at the layouts of P and Q, we see that the Visual C++ compiler has
placed the hidden vfptr member `at-the-start` of the P and Q instances. This
helps ensure that virtual function dispatch is as fast as possible. In fact, the
Visual C++ implementation ensures that the first field in any class 'with'
virtual functions is always a vfptr. This can require inserting the new vfptr
before base classes in the instance layout, or even require that a right base
class that does begin with a vfptr be placed before a left base that does not
have one.


<vtable-per-class>
Most C++ implementations will share or reuse an inherited base's vfptr. Here Q
did 'not' receive an 'additional' vfptr to address a table 'for' its new virtual
function qvf(). Instead, a qvf entry is appended to the end of P's vftable
layout. In this way, `single-inheritance` remains inexpensive. Once an instance
has a vfptr it doesn't need another one. New derived classes can introduce yet
more virtual functions, and their vftable entries are simply 'appended' to the
end of their one per-class vftable. 

note: 
single inheritance means one level of inheritance so single inheritance is
different from single hierachy of inheritance.


Virtual Functions: Multiple Inheritance

<understand-trunk>
It is possible for an instance to contain more than one vfptr if it inherits
them from multiple bases, each with virtual functions. Consider R and S: 

struct P {
  int p1;
  void pf();            // new
  virtual void pvf();   // new
}; 

struct R {
  int r1;
  virtual void pvf(); // new
  virtual void rvf(); // new
}; 

R*    ->    R::vfptr    -> &R::pvf
            R::r1       -> &R::rvf

struct S : P, R {
  int s1;
  void pvf(); // overrides P::pvf and R::pvf
  void rvf(); // overrides R::rvf
  void svf(); // new
}; 

P*, S*->    P::vfptr    -> &S::pvf
            P::r1
    R*->    R::vfptr    -> &thunk1     // note: this is vtable entry
            R::r1       -> &S::rvf
            S::s1

            trunk1: this -= SdPR; goto S::pvf

note: see R has its own vfptr

Here R is just another class with some virtual functions. Since S multiply
inherits, from P and R, it contains an embedded instance of each, plus its own
instance data contribution, S::s1. Notice the right base R has a different
address point than do P and S, as expected with multiple inheritance. S::pvf()
  overrides both P::pvf() and R::pvf(), and S::rvf() overrides R::rvf(). Here
  are the required semantics for the pvf override: 

S s; S* ps = &s;
((P*)ps)->pvf();  // ((P*)ps)->P::vfptr[0])((S*)(P*)ps)
((R*)ps)->pvf();  // ((R*)ps)->R::vfptr[0])((S*)(R*)ps)
ps->pvf();        // one of the above; calls S::pvf() 

note:
This is code that compiler generate to follow vptr when virtual function call is
made.

Since S::pvf() overrides both P::pvf() and R::pvf(), it must replace their
vftable entries in the S vftable s. However, notice that it is possible to
invoke pvf() both as a P and an R. The problem is that R's address point does
not correspond to P's and S's. The expression (R*)ps does not point to the same
part of the class as does (P*)ps. Since the function S::pvf() expects to receive
an S* as its hidden this parameter, the virtual function call itself must
automatically convert the R* at the call site into an S* at the callee.

Therefore, S's copy of R's vftable's pvf slot takes the address of an adjuster
thunk, which applies the address adjustment necessary to convert an R* pointer
into an S* as desired. In MSC++, for multiple inheritance with virtual
functions, adjuster thunks are required only when a derived class virtual
function overrides virtual functions of multiple base classes. 

note:
The S has own vftable since each class has one. Since this is S instance, always
call S::pvf regardless of which address point is used.

// class A vtable  class B vtable  class C vtable
// [1] A::f        [1] { A sub     [1] { A sub
// [2] A::f        [2] }           [2] }      
//                 [3] B::f        [3] { B sub
//                 [4] B::f        [4] }
//                                 [5] { C sub
//                                 [6] }
// 
// vptr            vptr            vptr
// instances of A  instances of B  instances of C
// 
// For C's instances, if functions are overrides and are virtual, then update
// related vtable for C class and if no virtual, compiler will not generate code
// to run virtual mechanism.  


Address Points and "Logical This Adjustment"

Consider next S::rvf(), which overrides R::rvf(). Most implementations note that S::rvf() must have
a hidden this parameter of type S*. Since R's rvf vftable slot may be used when this call occurs:

((R*)ps)->rvf(); // (*((R*)ps)->R::vfptr[1])((R*)ps)

Most implementations add another thunk to convert the R* passed to rvf into an S*. Some also add an
additional vftable entry to the end of S’s vftable to provide a way to call ps->rvf() without first
converting to an R*. MSC++ avoids this by intentionally compiling S::rvf() so as to expect a this
pointer which addresses not the S object but rather the R embedded instance within the S. (We call
    this "giving overrides the same expected address point as in the class that first introduced
    this virtual function".) This is all done transparently, by applying a "logical this adjustment"
to all member fetches, conversions from this , and so on, that occur within the member function.
(Just as with multiple inheritance member access, this adjustment is constant-folded into other
 member displacement address arithmetic.) Of course, we have to compensate fo r this adjustment in
our debugger. 

ps->rvf(); // ((R*)ps)->rvf(); // S::rvf((R*)ps)

Thus MSC++ generally avoids creating a thunk and an 'additional' extra vftable entry when overriding
virtual functions of non-leftmost bases. 

Adjuster Thunks

As described, an adjuster thunk is sometimes called for, to adjust this (which is found just below
    the return address on the stack, or in a register) by some constant displacement en route to the
called virtual function. Some implementations (especially cfront-based ones) do not employ adjuster
thunks. Rather, they add additional displacement fields to each virtual function table entry.
Whenever a virtual function is called, the displacement field, which is quite often 0, is added to
the object address as it is passed in to become the this pointer: 

ps->rvf();
// struct { void (*pfn)(void*); size_t disp; };
// (*ps->vfptr[i].pfn)(ps + ps->vfptr[i].disp);


The disadvantages of this approach include both larger vftable s and larger code sequences to call
virtual functions. More modern PC-based implementations use adjust-and-jump techniques:


S::pvf-adjust: // MSC++
this -= SdPR;
goto S::pvf()

Of course, the following code sequence is even better (but no current implementation generates it):

S::pvf-adjust:
this -= SdPR; // fall into S::pvf()
S::pvf() { ... } 


Virtual Functions: Virtual Inheritance

Here T virtually inherits P and overrides some of its member functions. In Visual C++, to avoid
costly conversions to the virtual base P when fetching a vftable entry, new virtual functions of T
receive entries in a 'new' vftable, requiring a new vfptr, introduced at the top of T. 

struct T : virtual P {
  int t1;
  void pvf();           // overrides P::pvf
  virtual void tvf();   // new
}; 

note: this layout is different from usual inheritance.

TdTvbptrP {  T* ->  T::vfptr     -> &T::tvf
                    T::vbptr     -> TdTvbptrT
          }         T::t1           TdTvbptrP
             P* ->  P::vfptr     -> &T::pvf
                    P::p1

void T::pvf() {
  ++p1;           // ((P*)this)->p1++; // vbtable lookup!
  ++t1;           // this->t1++;
}

As shown above, even within the definition of a virtual function, access to data members of a
virtual base must still use the vbtable to fetch a displacement to the virtual base. This is
necessary because the virtual function can be subsequently inherited by a further derived class with
different layout with respect to virtual base placement. And here is just such a class: 

struct U : T {
  int u1;
}; 


             T* ->  T::vfptr     -> &T::tvf
UdTvbptrP {         T::vbptr     -> UdTvbptrT
                    T::t1           UdTvbptrP
          }         U::u1
             P* ->  P::vfptr     -> &trunk2
                    P::p1

                    trunk2: this -= (UdP-TdP); goto T::pvf

Here U adds another data member, which changes the dP , the displacement to P . Since T::pvf expects
to be called with a P* in a T , an adjuster thunk is necessary to adjust T this so it arrives at the
callee addressing just past T::t1 (the address point of a P* in a T T). (Whew!  That’s about as
complex as things get!) 

Special Member Functions

This section examines hidden code compiled into (or around) your special member functions.

Constructors and Destructors

As we have seen, sometimes there are hidden members that need to be initialized during construction
and destruction. Worst case, a constructor may perform these activities

1. If "most-derived," initialize vbptr field(s) and call constructors of virtual bases.
2. Call constructors of direct non-virtual base classes.
3. Call constructors of data members.
4. Initialize vfptr field(s).
5. Perform user-specified initialization code in body of constructor definition.

A "most-derived" instance is an instance th at is not an embedded base instance within some other
derived class.

So, if you have a deep inheritance hierarchy, even a single inheritance one, construction of an
object may require many successive initializations of a class's vfptr. (Where appropriate, Visual
    C++ will optimize away these redundant stores.) Conversely, a destructor must tear down the
object in the exact reverse order to how it was initialized:

1. Initialize vfptr field(s).
2. Perform user-specified destruction code in body of destructor definition.
3. Call destructors of data members (in reverse order).
4. Call destructors of direct non-virtual bases (in reverse order).
5. If "most-derived," call destructors of virtual bases (in reverse order).

In Visual C++, constructors for classes with virtual bases receive a hidden “most-derived flag” to
indicate whether or not virtual bases should be initialized. For destructors, we use a "layered
destructor model," so that one (hidden) destructor function is synthesized and called to destroy a
class including its virtual bases (a "most-derived" instance) and another to destroy a class
excluding its virtual bases. The former calls the latter, then destroys virtual bases (in reverse
    order). 

Virtual Destructors and Operator Delete

Consider structs V and W. 

V*    ->    V::vfptr    -> &V::~V

struct V {
  virtual ~V();
}; 

W*    ->    V::vfptr    -> &W::~W

struct W : V {
  operator delete();
}; 

Destructors can be virtual. A class with a virtual destructor receives a hidden vfptr member, as
usual, which addresses a vftable. The table contains an entry holding the address of the virtual
destructor function appropriate for the class. What is special about virtual destructors is they are
implicitly invoked when an instance of a class is deleted. The call site (delete site) does not know
what the dynamic type being destroyed is, and yet it must invoke the appropriate operator delete for
that type. 

For instance, when pv below addresses a W, after W::~W() is called, its storage must be destroyed
using W::operator delete() .

V* pv = new V;
delete pv;           // pv->~V::V(); // use ::operator delete()
pv = new W;
delete pv;           // pv->~W::W(); // use W::operator delete()
pv = new W;
::delete pv;         // pv->~W::W(); // use ::operator delete()

To implement these semantics, Visual C++ extends its "layered destructor model" to automatically
create another hidden destructor helper function, the "deleting destructor," whose address replaces
that of the "real" virtual destructor in the virtual function table. This function calls the
destructor appropriate for the class, then optionally invokes the appropriate operator delete for
the class. 

Arrays

Dynamic (heap allocated) arrays further co mplicate the responsib ilities of a virtual destructor.
There are two sources of complexity.  First, the dynamic size of a heap allocated array must be
stored along with the arra y itself, so dynamically allocated arrays automatically allocate extra
storage to hold the number of array elements. The other complication occurs because a derived class
may be larger than a base class, yet it is imperative that an array delete correctly de stroy each
array elemen t, even in contexts where the array size is not evident:

struct WW : W { int w1; };
pv = new W[m];
delete [] pv; // delete m W's (sizeof(W) == sizeof(V))
pv = new WW[n];
delete [] pv; // delete n WW's (sizeof(WW) > sizeof(V))

Although, strictly speaking, polymorphic array delete is undefined behavior, we had several customer
requests to implement it anyway. Th erefore, in MSC++, th is is implemented by yet another
synthesized virtual destructor he lper function, the so-called “vector delete destructor,” which
(since it is custom ized for a particular class, such as WW) has no difficulty iterating through the
array elem ents (in reverse order), callin g the appropriate destructor for each. 

Exception Handling

Briefly, the exception handling proposal in the C++ standards committee working papers provides a
facility by which a function can notify its callers of an exceptional condition and select
appropriate code to deal with the situation. This provides an alternative mechanism to the
conventional method of checking error status return codes at every function call return site.

Since C++ is object-oriented, it should come as no surprise that objects are employed to represent
the exception state, and that the appropriate exception handler is selected based upon the static
or dynamic type of except ion object "thrown." Also, since C++ always ensures that frame objects
that are going out of scope are properly destroyed, implementations must ensure that in
transferring control (unwinding the stack frame) from throw site to "catch" site, (automatic) frame
objects are properly destroyed. Consider this example: 

struct X { X(); };         // exception object class
struct Z { Z(); ~Z(); };   // class with a destructor
extern void recover(const X&);
void f(int), g(int);

int main() {
  try {
    f(0);
  } catch (const X& rx) {
    recover(rx);
  }
  return 0;
}

void f(int i) {
  Z z1;
  g(i);
  Z z2;
  g(i-1);
}

void g(int j) {
  if (j < 0)
    throw X();
}

This program will throw an exception. main() establishes an exception handler context for its call
to f(0), which in turn constructs z1, calls g(0), constructs z2, and calls g(-1). g() detects the
negative argument condition and throws an X object exception to whatever caller can handle it.
Since neither g() nor f() established an exception handler context, we consider whether the
exception handler established by main() can handle an X object exception. Indeed it can. Before
control is transferred to the catch clause in main(), however, objects on the frame between the
throw site in g() and the catch site in main() must be destroyed. In this case, z2 and z1 are
therefore destroyed.

An exception handling implementation might employ tables at the throw site and the catch site to
describe the set of types that might catch the thrown object (in general) and can catch the thrown
object at this specific catch site, respectively, and generally, how the thrown object should
initialize the catch clause "actual parameter." Reasonable encoding choices can ensure that these
tables do not occupy too much space.

However, let us reconsider function f(). It looks innocuous enough. Certainly it contains neither
try, catch, nor throw keywords, so exception handling would not appear to have much of an impact
on f(). Wrong! The compiler must ensure that, once z1 is constructed, if any subsequently called
function were to raise an exception ("throw") back to f(), and therefore out of f(), that the z1
object is properly destroyed. Similarly, once z2 is constructed, it must ensure that a subsequent
throw is sure to destroy z2 and then z1.

To implement these "unwind semantics," an implementation must, behind the scenes, provide a
mechanism to dynamically determine the context (site), in a caller function, of the call that is
raising the exception. This can involve additional code in each function prolog and epilog, and
worse, updates of state variables between each set of object initializations. For instance, in the
example above, the context in which z1 should be destroyed is clearly distinct from the subsequent
context in which z2 and then z1 should be destroyed, and therefore Visual C++ updates (stores) a new
value in a state variable after construction of z1 and again after construction of z2. All these
tables, function prologs, epilogs, and state variable updates, can make exception handling
functionality a significant space and speed 'expense'. As we have seen, this expense is incurred
even in functions that do not employ exception handling constructs. Fortunately, some compilers
provide a compilation switch and other mechanisms to disable exception handling and its overhead
from code that does not require it. 

Summary

There, now go write your own compiler. Seriously, we have considered many of the significant C++
run-time implementation issues. We see that some wonderful language features are almost free, and
others can incur significant overhead. These implementation mechanisms are applied quietly for you,
       behind the curtains, so to speak, and it is often hard to tell what a piece of code costs
       when looking at it in isolation. The frugal coder is well advised to study the generated
       native code from time to time and question whether use of this or that particularly cool
       language feature is worth its overhead. 


={============================================================================
*kt_dev_cpp_102* ref: MEC++24 understand the cost of virtual functions

Each class in a program that 'declares' or 'inherits' virtual functions has
its own vtbl, and the entries in a class's vtbl are pointers to the
implementations of the virtual functions for that class.

<first-cost>
Space for a virtual table for each class that contains virtual functions. The
size of a class's vtbl is proportional to the number of virtual functions
declared for that class including those it inherits from its base classes.

The total amount of space required for virtual tables is not usually
significant, but if you have a large number of classes or a large number of
virtual functions in each class, you may find that the vtbls take a
significant bite out of your address space.

<second-cost>
Size cost of vptr which links between objects which are of the same class and
per-class vtable.

Even on systems with unconstrained memory, you may find that the performance
of your software decreases, because larger objects mean fewer fit on each
cache or virtual memory page, and that means your paging activity will
probably increase.

<third-cost>
You effectively give up inlining since inline is done at compile time but
virtual uses dynamic mechanism so compiler do not inline virtuals.

<Q> This section said that virtual functions per se are not usually a
performance bottleneck.  Really?

<forth-cost>
With multiple inheritance, offset calculations to find vptrs within objects
become more complicated.  there are multiple vptrs within a single object (one
    per base class). As a result, both the per-class and the per-object space
overhead for virtual functions increases, and the runtime invocation cost
grows slightly, too. See references for more.

<fifth-cost>
With virtual base class, implementations of virtual base classes often use
pointers to virtual base class parts as the means for avoiding the
replication, and one or more of those pointers may be stored inside your
objects. See adding pointer to virtual base in a object.

class A { ... };
class B: virtual public A { ... };
class C: virtual public A { ... };
class D: public B, public C { ... };

            B data 
            pointer to virtual base class
            C data
            pointer to virtual base class
            D data
            A data


{RTTI-cost}
RTTI can discover info about object and class at run-time. How? That
information is stored in an object of type type_info, and you can access the
type_info object for a class by using the typeid operator. There is a single
copy for each class. 

The language specification states that we're guaranteed accurate information
on an object's dynamic type 'only' if that type has at least one virtual
function. This makes RTTI data sound a lot like a virtual function table. So
RTTI was designed to be implementable in terms of a class's vtbl.

Typical implementation is:

vtable       
[0] -> C1's type_info   // pointer to type_info object
[1] -> C1::~C1  
[2] -> C1::f1  
[3] -> C1::f2  
[4] -> C1::f3 

Therefore, no size increase in object but in vtbl.


={============================================================================
*kt_dev_cpp_103* ref: others

This is the link found above articles and there are more yet to see.
http://cloudfundoo.wordpress.com/2012/04/27/deep-c-understanding-c-object-layout/


={============================================================================
*kt_dev_cpp_104* ref: why singletons are controversial

https://code.google.com/p/google-singleton-detector/wiki/WhySingletonsAreControversial

note: here suppose that talks about class singleton but singleton+factory.

Why Singletons Are Controversial

The use of singletons is actually a fairly controversial subject in the Java community; what was
once an often-used design pattern is now being looked at as a less than desirable coding practice.

The problem with singletons is that they introduce global state into a program, allowing anyone to
access them at anytime (ignoring scope). Even worse, singletons are one of the most overused design
patterns today, meaning that many people introduce this possibly detrimental global state in
instances where it isn't even necessary. What's wrong with singletons' use of global state?

First, programs using global state are very difficult to test. One of the hallmarks of testability
is a loose coupling of classes, allowing you to isolate a single class and test it completely. When
one class uses a singleton (and I'm talking about a classic singleton, one that enforces it own
    singularity thorough a static getInstance() method), the singleton user and the singleton become
inextricably coupled together. It is no longer possible to test the user (class) without also testing the
singleton. In many cases, this is a deal breaker that can prevent a developer from testing a class
at all, especially if the singleton represents a 'resource' that should not be updated by tests (i.e.
    an important database). The ideal solution here is to pass in the singleton as a parameter in
the user's constructor, allowing a tester to easily mock out the singleton for tests. The singleton
then doesn't have to enforce its own singularity; this can be handled by the client or a factory
class, which could produce the real version or a test version, eliminating the global state
altogether. In fact, it should be considered a violation of the Single Responsibility Principle of
OO design to have an object responsible for its own singularity as well as its normal tasks.

Second, programs that rely on global state hide their dependencies. One of the unique abilities of a
singleton is that it can be accessed anywhere though its globally available static method (i.e.
    getInstance()), allowing programmers to use it inside of a method without having to pass it in
expressly through parameters. While this may seem easier to the programmer, relying on this static
instance means that the signatures of methods no longer show their 'dependencies', because the method
could pull a singleton "out of thin air." This means that users need knowledge of the inner workings
of code to properly use it, making it more difficult to use and test.

Tying these two problems together shows another issue with singletons. In todays world of
test-driven and agile development, it is more important than ever to have small tests covering most
of your code. One of the important things about these tests is that they must be able to be run in
any order (not dependent on each other), which can become a problem with singleton usage. Because
the dependencies of some given methods aren't 'clear' when they rely on singletons (getting them from
static getters), a tester may unknowing write two tests that actually depend on each other by
modifying a shared resource (the singleton). This can produce flaky tests, ones that pass when run
in one order but fail when run in another, which aren't very useful.

Still not convinced? Well, this certainly wasn't originally my idea, and it's not even that new. If
you're looking for some more compelling arguments, check out some of these sources:

All pages with Singleton in their title at the Portland Pattern Repository Wiki

Use Your Singletons Wisely (IBM developerWorks) 


={============================================================================
*kt_dev_cpp_300* case: framework {tizen-case}

From Tizen and points to see are:

o Used factory-func to create a self in the derived class but used static-factory-func. Have
separation and single point of acess to create whole instances.

o Not used singleton but used protected and private ctor or/and dtor in a tree. The protected is
used like singleton to allow derived to create base part.

o Used pimpl-idiom but do not have the same interface between them. not necessary to have the same
interface 

o the way to pass cpp func addresses to c

 
App: ABC                                     _AppImpl: public interface classes
                                                friend class App
 'protected': ctor(); new _AppImpl              'private': ctor and dtor (only App can create AppImpl)
 'static' App* GetInstance(); calls ->          static _AppImpl* GetInstance()
                                                Construct()
                                                Execute()
 |
 |
 |
ServiceApp:                                  _ServiceAppImpl: public interface classes
 'protected': ctor(); new _ServiceAppImpl       'private': ctor and dtor
 static ServiceApp* GetInstance(); ->           static _ServiceAppImpl* GetInstance()
 static Execute(); 
   : use user provided factory-func to create user class and creates all instances
   : register a event listener and run efl_main

 | 
 | Framework 
 |-----------------------------------------------------------------------------
 | User classes
 |----------------------------------
 |                                 | ...
AppService:                       XXXService:
 static CreateInstance();
   : member-static-factory-func to create AppService. This is interesting because used subclassing
   to decide what to create but used static-factory-func.

OspMain():
   result r = Tizen::App::Service::Execute( AppService::CreateInstance, &args);
   (result r = Tizen::App::ServiceApp::Execute( AppService::CreateInstance, &args); )


// App

class App
{
  // interfaces
  public: 
    virtual OnXXX()=0;
    virtual void OnLowMemory(void);

    // very few use of forwarding to impl.
    virtual OnYYY()
    { __pAppImpl->OnYYY(); }

    static App* GetInstance();
    {
      _AppImpl* pAppImpl = _AppImpl::GetInstance();

      if (pAppImpl != null)
      {  // [KT] why need this as it returns App* which is passed to Impl?
        return pAppImpl->GetAppInstance();
      }

      return null;
    }

    virtual ~App(void)			# see virtual
    { delete __pAppImpl; }

  protected:
    App(void);
    { __pAppImpl = 'new' (std::nothrow) _AppImpl('this'); }

  private:
    class _AppImpl* __pAppImpl;
};


// _AppImpl

class _AppImpl : public IEventListener
{
  public:
    'static' _AppImpl* GetInstance()
    { return __pAppImpl; }

    App* _AppImpl::GetAppInstance(void)
    { return __pApp; }

    result Construct(const Tizen::Base::Collection::IList* pArgs);
    result Execute(_IAppImpl* pIAppImpl);
    {
      pAppImpl->__pIAppImpl = pIAppImpl;

      app_event_callback_s state_handler;

      state_handler.create = &OnCreate;
      state_handler.service = &OnService;
      state_handler.terminate = &OnTerminate;
      state_handler.pause = &OnPause;
      state_handler.resume = &OnResume;
      state_handler.device_orientation = NULL;

      state_handler.low_memory = &OnLowMemory;
      state_handler.low_battery = NULL;
      state_handler.language_changed = &OnLanguageChanged;
      state_handler.region_format_changed = &OnRegionFormatChanged;

      // see how to pass data from cpp to c and efl_main should copy since it is local
      // 
      eflResult = app_efl_main(&argc, &pArgv, &state_handler, this);
    }

    // same name but static. what will happen?
    'static' void OnLowMemory(void* user_data);

  private:

    _AppImpl::_AppImpl(App* pApp)
      : ...
        , __pApp(pApp)
          , __pIAppImpl(null)
  { __pAppImpl = this; }

    virtual ~_AppImpl(void)
    { __pAppImpl = null; }

    'static' _AppImpl* __pAppImpl;

    App* __pApp;
    _IAppImpl* __pIAppImpl;

    // [KT] otherwise, compile errer when App creates Impl
    friend class App;
};


// ServiceApp(Service) since used typedef ServiceApp Service

class ServiceApp : public Tizen::App::App
{
  public:
    virtual ~ServiceApp(void)
    { delete __pServiceAppImpl; }

    'static' ServiceApp* GetInstance(void)
    {
      _ServiceAppImpl* pServiceAppImpl = _ServiceAppImpl::GetInstance();
      if (pServiceAppImpl == null)
      {
        return null;
      }

      return pServiceAppImpl->GetServiceAppInstance();
    }

    'static' result Execute(ServiceAppInstanceFactory pServiceAppFactory, 
        const Tizen::Base::Collection::IList* pArguments);
    {
      result r = E_SUCCESS;

      ServiceApp* pServiceApp = null;
      _AppImpl* pAppImpl = null;

      // call AppService::CreateInstance. create <AppService> instance
      // use pServiceApp only when exception happens to delete. Here done all creations of objects. 
      pServiceApp = pServiceAppFactory();

      // free to use all instances
      pAppImpl = _AppImpl::GetInstance();

      _ServiceAppImpl* 'pServiceAppImpl' = _ServiceAppImpl::GetInstance();

      // add it as event listner and set app state to initializing
      r = pAppImpl->Construct(pArguments);

      // derive-to-base conversion as _ServiceAppImpl to _IAppImpl
      // pass cpp Onxx funcs to c efl and run app_efl_main
      r = pAppImpl->Execute(pServiceAppImpl); 
    }

  protected:
    ServiceApp(void)
    { __pServiceAppImpl = 'new' (std::nothrow) _ServiceAppImpl('this'); }

  private:
    ServiceApp(const ServiceApp& rhs);
    ServiceApp& operator =(const ServiceApp& rhs);

    class _ServiceAppImpl* __pServiceAppImpl;
}


// _ServiceAppImpl

class _ServiceAppImpl
: public Tizen::Base::Object
, public Tizen::App::_IAppImpl
, public Tizen::Base::Runtime::ITimerEventListener
, virtual public Tizen::Base::Runtime::IEventListener
{
  public:
    static _ServiceAppImpl* GetInstance();
    { return __pServiceAppImpl; }

  private:
    _ServiceAppImpl(ServiceApp* pServiceApp)
      : __pAppImpl(_AppImpl::GetInstance())
        , __pServiceApp(pServiceApp)
        , __pAppTerminatingInternalEventListener(null)
        , __pLifeDurationTimer(null)
        , __lifeDuration(0)
        , __pauseLifeDurationTimer(false)
  {
    __pServiceAppImpl = this;
  }

    ServiceApp*
      _ServiceAppImpl::GetServiceAppInstance(void)
      {
        return __pServiceApp;
      }

    virtual ~_ServiceAppImpl(void);

    static _ServiceAppImpl* __pServiceAppImpl;
    _AppImpl* __pAppImpl;
    ServiceApp* __pServiceApp;
    _IAppEventListener* __pAppTerminatingInternalEventListener;

    friend class ServiceApp;
};


// AppService. client class which is out of framework and namespace.

class AppService
: public Tizen::App::ServiceApp
, public Tizen::App::Package::IPackageInstallationEventListener
, public Tizen::App::_IAppManagerEventListener
, public Tizen::System::IBootEventListener
, virtual public Tizen::Base::Runtime::IEventListener
{

  public:
    // create self
    'static' Tizen::App::ServiceApp* CreateInstance(void)
    {
      // [KT] why static?
      'static' AppService* pAppService = new (std::nothrow) AppService();
      __pAppService = pAppService;

      // convert to base
      return pAppService;
    }

    static AppService* GetAppServiceInstance(void);
    AppService();
    virtual ~AppService();

    // OnXXX interfaces
    virtual bool OnAppInitializing(Tizen::App::AppRegistry& appRegistry);
    ...
      virtual void OnLowMemory(void);

    static AppService* __pAppService;
};

OspMain() {

   result r = Tizen::App::Service::Execute(AppService::CreateInstance, &args);
   (result r = Tizen::App::ServiceApp::Execute(AppService::CreateInstance, &args); )
}

int main(int argc, char* pArgv[])
{
   int r = OspMain(argc, pArgv);
}


={============================================================================
*kt_dev_cpp_301* case: wrapper

{example-one} {wrapper}
This is taken from *kt_dev_mecpp_007* to discuss it again: This case is that main is in c and is to
use some features written cpp.

C source(.c and gcc)        wrapper header(.h)        wrapper class(.cpp and g++)

#include "wrapper.h"                                  #include "wrapper.h" 
                            extern "C"                extern "C"
                            {   typedefs               {
										  int wraaper_func();       int wrapper_func()
										  ...                       {
									 }                                ....
                                                          }
																			 ...
																		}

Here wrapper is used to bridge between cpp and c:

int wrapper_func()
{
	ClassX* pclass = new Class( params );

	pclass->func();
	...
}


{example-two} {{add-reference-counting-to-existing-classes}} {wrapper} {forwarding}
How to add this reference-counting feature, RCObject, to a class which is in libary and do not
have source? Here Widget is library class:

            RCObject
			    |
RCWidget -> Widget
+RCPtr

>
 Use that most problems in Computer Science can be solved with an additional level of indirection.
 See how to forward and how to get around the problem.
<

                  RCObject
			          |
RCWidget       -> CounterHolder    -> Widget
+RCIPtr
  (counter)->      (pointee)->

Here Widget or CounterHolder is <reference-counted-object>


template<class T>
class RCIPtr {
	 public:
		  RCIPtr(T* realPtr = 0);
		  ...
		  RCObject& getRCObject() // give clients access to
		  { return *counter; } // isShared, etc.

	 private:
		  struct CountHolder: public RCObject {
				~CountHolder() { delete pointee; }
				T *pointee;
		  };

		  CountHolder *counter;
		  void init();
};

template<class T>
void RCIPtr<T>::init()
{
	 if (counter->isShareable() == false) {
		  T *oldValue = counter->pointee;
		  counter = new CountHolder;
		  counter->pointee = oldValue ? new T(*oldValue) : 0;
	 }
	 counter->addReference();
}

template<class T>
RCIPtr<T>::RCIPtr(T* realPtr) : counter( 'new' CountHolder)
{
	 counter->pointee = realPtr;
	 init();
}

class RCWidget {
	 public:
		  # <see-how-to-pass-widget> 
		  RCWidget(int size): value( 'new' Widget(size)) {} 

        # <forwarding> [see-how-to-forward]
		  void doThis()
		  {
				if (value.getRCObject().isShared()) { 
					 value = new Widget(*value); 
				}
				value->doThis();
		  }

		  int showThat() const { return value->showThat(); }

	 private:
		  RCIPtr<Widget> value;
};


={============================================================================
*kt_dev_cpp_302* case: porting layer

{case-one}
The case which use singleton to have a porting layer for different platforms.

├── Interfaces
│   ├── Core
│   │   ├── IPluginRegister.h
│   │   └── SectionDataDefines.h
│   └── PortingLayer (has interface classes)
│       ├── IAPLAppLaunch.h
│       ├── IAPLAVControl.h
│       ├── ...
│       ├── IAPLMutex.h
│       ├── IAPLOSAbstraction.h
│       └── IApplitePortingLayer.h
├
├── PortingLayer (for platform A)
│   ├── Inc (headers for each class which implements each interface
│   │   ├── APLAVController.h
│   │   ├── APLDebug.h
│   │   ├── ...
│   │   ├── APLMutex.h
│   │   ├── APLOSAbstraction.h
│   │   └── ApplitePortingLayer.h
│   └── Src (sources for each class which implements eash interface, functionality)
│       ├── APLAVController.cpp
│       ├── APLDebug.cpp
│       ├── ...
│       └── ApplitePortingLayer.cpp (this is the gate class)


User                 CApplitePortingLayer : publuc IApplitePortingLayer
getInstace()         - get functions to get each interface pointer
Ins->getInterface(); - pointer members for each interface

                     CInterfaceA : public IInterfaceA             CInterfaceB ...
                     - *.h, *.cpp
                     - actual platform specific implementation


class CApplitePortingLayer : public IApplitePortingLayer
{

private:
	///default constructor
	CApplitePortingLayer(){};

public:
	uses singleton
	has all getXXX funcs for each functionality which returns member pointer for each.
	ctor creates all interface classes and set member pointers.

	///This function creates the porting layer interfaces. factory-func
	static CApplitePortingLayer* Instance(CReceiverAppBase* receiver);
	{
		 if (m_singleton == NULL)
		 {
			  m_singleton = new CApplitePortingLayer(receiver);
		 }
		 return m_singleton;
	}

	///This function gets the porting layer interfaces if created.
	static CApplitePortingLayer* GetInstance();
	{
		return m_singleton;
	}
}

Creates all concrete classes which implments interfaces.

CApplitePortingLayer::CApplitePortingLayer(CReceiverAppBase* receiver)
:m_receiver(receiver)
{
	m_graphics =  new CAPLGraphics((IReceiverAppPorting*)receiver, receiver->GetViewIndex());
	m_debug = new CAPLDebug((PCTask*)receiver, receiver->GetTCTv());
	m_mediaManager = new CAPLMediaManager((IReceiverAppPorting*)receiver, receiver->GetTCWindowByAutoSelect(), (PCTask*)receiver);		m_OSAbstraction = new CAPLOSAbstraction((IReceiverAppPorting*)receiver, receiver->GetTCTv(), (PCTask*)receiver);
	m_persistentStorage = new CAPLPersistentStorage();
	m_sectionFilter = new CAPLSectionFilter(receiver->GetTCWindowByAutoSelect(), (PCTask*)receiver);
	m_serviceInformation = CAPLServiceInformation::Instance((IReceiverAppPorting*)receiver, 
			receiver->GetTCTv(), receiver->GetTCWindowByAutoSelect());
	m_systemProperties = new CAPLSystemProperties((IReceiverAppPorting*)receiver, 
			receiver->GetTCTv(), receiver->GetTCWindowByAutoSelect());
	m_security = new CAPLSecurity();
	m_serial = new CAPLSerial();
	m_typeface = CAPLTypeface::getInstance();
	m_appLaunch = new CAPLAppLaunch((IReceiverAppPorting*)receiver);

    //initialise curl here, needed for both network and X509 operations
    CAPLCurl::InitCurl();
}

The good thing is that make CApplitePortingLayer singleton and manage other interfaces via it rather
than making every interface a singleton class.

This approach means that each concrete implementation calss, Cxx, implements interfaces and users
will use it directly. If the client is CPP file, that's fine and each Cxx can have typedefs, enums
and so on but if C file then do not work. For C files, each Cxx class provide C function and there
should be a way to share typedefs between CPP and C files. So should be a single header which has
common typedefs for C and CPP land.

Also can use that make all interface concrete class to have private interfaces and make a friend
between CApplitePortingLayer and otheres. That makes only CApplitePortingLayer can create and use
those.

{case-two}
├── OAL (OS AL)
│   ├── Inc
│   │   ├── ...h
│   │   └── ...h
│   └── Src 
│       ├── LINUX (this is folder which has platform implementation)
│       ├── WINDOWS
│       ├── VXWORS
│       ├── ...


={============================================================================
*kt_dev_cpp_303* case: inheritance

In the porting layer design and implementation, have drawn the class hierarchy.

 ISession (ABC) and more...      IEvent 

 IDriver : public ISession, public IEvent

 CDsm : public IDriver and more...

When add more interface classes which are ABC and add more concrete derived classes, shall add the
same member functions in a header and source of a derived class. Otherwise, will have compile/link
error since ABC forces derived class to define functions. See {error-when-create-abc} for what
happens when not overrides pure virtual functions. Tedious. Any other better way?

1> How about having a pure-virtual-dtor to make a ABC and having normal virtual members?  If have a
class definition and the defintion of a pure-virtual-dtor in the header, get a multiple defintion
error since this is included in every file which use it. Can have source file which has a dtor
definition but still needs definitions for other members. If not, get errors as 3>.

2> How about having a virtual members for interface classes? Since it has implementation, that is
okay for a derived class not to override or implement it. So no tedious work. However, cannot force
derived to override and can forget to implement it. Here talking about 'interface' class.

3> What will happen when changes pure virtual functions to normal virtual functions but do not have
implementation? Simply changes a header since it has a header only as a interface class.

Linking CXX executable mhegproto
port/libmhport.a(CDsm.cpp.o): In function `~ISession':
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'
port/libmhport.a(CDsm.cpp.o): In function `~IDriver':
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/PortLayer.h:36: undefined reference to `vtable for IEvent'
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/PortLayer.h:36: undefined reference to `vtable for IEvent'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTV7IDriver[vtable for IDriver]+0x94): undefined reference to `IEvent::subscribeEvent(void*, char const*, void (*)(void*, unsigned int), void*, void**, int, int)'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTV7IDriver[vtable for IDriver]+0x98): undefined reference to `IEvent::unsubscribeEvent(void*)'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTV7IDriver[vtable for IDriver]+0x9c): undefined reference to `IEvent::getVersionEvent(void*, int*, int*)'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTI7IDriver[typeinfo for IDriver]+0x28): undefined reference to `typeinfo for IEvent'
port/libmhport.a(CDsm.cpp.o): In function `.LANCHOR0':
CDsm.cpp:(.rodata+0x5ac): undefined reference to `IEvent::subscribeEvent(void*, char const*, void (*)(void*, unsigned int), void*, void**, int, int)'
CDsm.cpp:(.rodata+0x5b0): undefined reference to `IEvent::unsubscribeEvent(void*)'
CDsm.cpp:(.rodata+0x5b4): undefined reference to `IEvent::getVersionEvent(void*, int*, int*)'
port/libmhport.a(CCi.cpp.o): In function `~ISession':
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'

This shows how GCC implements vtables for a class.


={============================================================================
*kt_dev_cpp_304* case: overloads

{overloads-ctor}
Has many ctor overloads to create different SCE objects depending on different event sources.

SCE::SCE(boost::weak_ptr<MetadataRepositories> repos,
   const std::string& lang,
   const NS_IRON_SYSTEM::Event& dttEvent) :
{}


SCE::SCE(shared_ptr<SCE>& dttEvent, shared_ptr<SCE>& masEvent):
{
}

SCE::SCE(shared_ptr<SCE>& masEvent, const uint32_t start_, const uint32_t end_):
{}

SCE::SCE(boost::weak_ptr<MetadataRepositories> repos, const SystemEventWrapper& masEvent) :
{
}

SCE::SCE(boost::weak_ptr<MetadataRepositories> repos, 
    boost::shared_ptr<Service> service_, uint32_t start_, uint32_t end_):
    synopsis(),
{}


{overloads-call-operator}
Likewise, has many () overloads to call () operator depending on arguments. 

ServicePtrVecPtr operator()(
        const std::vector<NS_SYSTEM::Result>& sysServices,
        ServicePtrVecPtr) const;

SummaryResultSetPtr operator()(
        const NS_SYSTEM::ResultSet&, SummaryResultSetPtr, uint32_t requestedStartIndex = 0) const;

CategoryResultSetPtr operator()(
        const NS_SYSTEM::ResultSet&, CategoryResultSetPtr) const;

PublicationResultSetPtr operator()(
        const NS_SYSTEM::ResultSet&, PublicationResultSetPtr) const;

ProgrammePtr operator()(
        const NS_SYSTEM::Result&, ProgrammePtr) const;

FullEventPtr operator()(
        const NS_SYSTEM::Result&, FullEventPtr) const;


# ============================================================================
#{ STL
={============================================================================
*kt_dev_stl_000* cpp-stl

http://www.sgi.com/tech/stl/ 

{stl-design-rationale}
The idea behind the STL is to beat the combinatorial explosion of containers
and functions that implement the same data structures and algorithms without
forcing all program structures to be objects that are all in the same
hierarchy. As long as a type has the needed properties, it works with STL
containers or algorithms, no matter what class hierarchies it is or isn't part
of.

STL provides a collection of such things that are recognized as both useful
and reasonable design. The picky could point out std::string as a
counter-example to good design, here. 


The concept of the STL is based on a 'separation' of data and operations. The
data is managed by container classes, and the operations are defined by
configurable algorithms. Iterators are the 'glue' between these two
components.

This STL concept contradicts the original idea of object-oriented programming:
However, the reason for doing so is very important. In principle, you can
combine every kind of container with every kind of algorithm, so the result is
a very 'flexible' but still rather 'small' framework.

One fundamental aspect of the STL is that all components work with 'arbitrary'
types. Thus, the STL is a good example of the concept of 'generic'
programming. Containers and algorithms are generic for arbitrary types and
classes, respectively.


{components}

1. container

Containers are used to manage 'collections' of objects of a certain kind.
Every kind of container has its own advantages and disadvantages, so having
different container types reflects different requirements for collections in
programs.

2. iterator

Iterators are used to step through the elements of collections of objects. The
major advantage of iterators is that they offer a small but common interface
for any arbitrary container type. 

The interface for iterators is almost the same as for ordinary pointers. To
increment an iterator, you call operator ++. To access the value of an
iterator, you use operator *. 

So, you might consider an iterator a kind of a smart pointer that translates
the call "go to the next element" into whatever is appropriate.

3. algorithm

Algorithms are used to process the elements of collections. Algorithms use
iterators. Thus, because the iterator interface for iterators is common for
all container types, an algorithm has to be written only once to work with
arbitrary containers.


{error-handling}
The design goal of the STL was the best performance rather than the highest
security. Error checking wastes time, so almost 'none' is done. Two reasons:

1. Error checking reduces performance, and speed is still a general goal of
programs. As mentioned, good performance was one of the design goals of the
STL.

2. If you prefer safety over speed, you can still get it, either by adding
wrappers or by using special versions of the STL. But when error checking is
built into all basic operations, you can't program to avoid error checking to
get better performance. For example, when every subscript operation checks
whether a range is valid, you can't write your own subscripts without
checking.  However, it is possible the other way around.

The C++ standard library states that any STL use that violates preconditions
results in undefined behavior because these errors occur at 'runtime', not at
compile time, they cause undefined behavior. In particular, the use of the STL
requires that the following be met:

<precondition>
1. Iterators must be valid. For example, they must be initialized before they
are used. Note that iterators may become invalid as a side effect of other
operations. In particular, iterators become invalid

- for vectors and deques, if elements are inserted or deleted or reallocation takes place, and
- for unordered containers, if 'rehashing' takes place (which also might be the result of an
insertion).

2. Iterators that refer to the past-the-end position have no element to which
to refer. Thus, calling operator * or operator -> is not allowed. This is
especially true for the return values of the end(), cend(), and rend()
  container member functions.

3. Ranges must be valid:
- Both iterators that specify a range must refer to the same container.
- The second iterator must be reachable from the first iterator.

4. If more than one source range is used, the second and later ranges usually
must have at least as many elements as the first one.

5. Destination ranges must have enough elements that can be overwritten;
otherwise, insert iterators must be used.


{exception-handling}
As a result of these discussions, the C++ standard library since C++98 gives
the following basic guarantee for exception safety: The C++ standard library
will not leak resources or violate container invariants in the face of
exceptions.

Regarding this stronger guarantee; atomic with respect to exceptions or
transaction safe, the C++ standard library now guarantees the following:

The library reference, p249 for details.

Note that all these guarantees are based on the requirement that 'destructors'
never throw, which should always be the case in C++. The C++ standard library
makes this promise, and so must the 'application' programmer.

<what-container-consideration>
If you need a container with full commit-or-rollback ability, you should use
either a list (without calling or special handling for remove(), remove_if(),
    merge(), sort(), and unique()) or an associative/unordered container
(without calling their multiple-element insert operations). This avoids having
to make copies before a modifying operation to ensure that no data gets lost.
Note that making copies of a container could be very expensive.

If you can't use a node-based container and need the full commit-or-rollback
ability, you have to provide wrappers for each critical operation.


{guarantees}
From ESTL p5. The revolutionary aspect of STL is its complexity guarantees
regardless of the STL platform you are using.


={============================================================================
*kt_dev_stl_001* cpp-pair cpp-tuple

{cpp-pair}
The class pair treats two values as a 'single' unit. The pair is defined in
<utility> header and the default pair ctor do `value-init` since it will use
T().

As usual, pair class is dependant on type T; menas that dependant on
operations provided by type T.

namespace std {

  /// Struct holding two objects of arbitrary type.
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;    /// @c first_type is the first bound type
      typedef _T2 second_type;   /// @c second_type is the second bound type

      _T1 first;                 /// @c first is a copy of the first object
      _T2 second;                /// @c second is a copy of the second object

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 265.  std::pair::pair() effects overly restrictive
      /** The default constructor creates @c first and @c second using their
       *  respective default constructors.  */
      _GLIBCXX_CONSTEXPR pair()
        : first(), second() { }

      /** Two objects may be passed to a @c pair constructor to be copied.  */
      _GLIBCXX_CONSTEXPR pair(const _T1& __a, const _T2& __b)
        : first(__a), second(__b) { }
    };

  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }
}

See that it is declared as struct instead of class so that all members are
public. Here are some operations to see:

pair<T1,T2> p
Default constructor; creates a pair of values of types T1 and T2, initialized
with their default constructors

pair<T1,T2> p(val1,val1)
Creates a pair of values of types T1 and T2, initialized with val1 and val1

pair<T1,T2> p(rv1,rv2)
Creates a pair of values of types T1 and T2, move initialized with rv1 and rv2

p.first 
Yields the first value inside the pair (direct member access)

p.second 
Yields the second value inside the pair (direct member access)

*C++11*
get<0>(p) Equivalent to p.first (since C++11)
get<1>(p) Equivalent to p.second (since C++11)


p1 == p2 
Returns whether p1 is equal to p2 (equivalent to p1.first==p2.first &&
    p1.second==p2.second)

p1.swap(p2) Swaps the data of p1 and p2 (since C++11)
swap(p1,p2) Same (as global function) (since C++11)

make_pair(val1,val2) 

Returns a pair with types and values of val1 and val2. 
The make_pair() function template enables you to create a value pair 'without'
writing the types explicitly since the type is deduced from.

std::pair<int,char>(42,’@’)
std::make_pair(42,’@’)

<ex>
note: no need to include <utility> and make_pair uses ().

#include <iostream>

using namespace std;

template <typename T1, typename T2>
std::ostream& operator<< (std::ostream& strm, const std::pair<T1,T2> &p)
{
  strm << "{" << p.first << " ," << p.second << "}";
}

int main()
{
  pair<int,int> ipair(80,88);
  cout << ipair << endl;
  cout << pair<int,int>(55,88) << endl;

  cout << make_pair(80,88) << endl;
  cout << make_pair(55,88) << endl;
}

{80 ,88}
{55 ,88}
{80 ,88}
{55 ,88}


<ex>
Finds the lowest among items which are not used or visited.

#include <iostream>
#include <vector>
#include <climits>

int main()
{
  std::vector<std::pair<int,bool>> 
    vint{{5,false},{3,false},{7,false},{1,true},{2,false},{8,false},{9,false}};
  
  std::vector<std::pair<int,bool>> vint;
  vint.push_back(std::make_pair(5,false));
  vint.push_back(std::make_pair(3,false));
  vint.push_back(std::make_pair(7,false));
  vint.push_back(std::make_pair(1,true));
  vint.push_back(std::make_pair(2,false));
  vint.push_back(std::make_pair(8,false));
  vint.push_back(std::make_pair(9,false));

  int lvalue, lindex, index;

  lvalue = INT_MAX;
  index = lindex = 0;

  // *cpp-auto*
  for(const auto& e: vint)
  {
    if( !e.second && e.first < lvalue )
    {
      std::cout << "pair(" << e.first << ", " << e.second << ")" << std::endl;

      lvalue = e.first;
      lindex = index;
    }
    ++index;
  }
  
  std::cout << "lvalue: " << vint[lindex].first << ", lindex: " << lindex << std::endl;
}


<move-or-copy>
You can influence the type make_pair() yields by forcing either move or
reference semantics.

For move semantics, you simply use std::move() to declare that the passed
argument is no longer used:

std::string s, t;
...
auto p = std::make_pair(std::move(s),std::move(t));
... // s and t are no longer used

To force reference semantics, you have to use ref(), which forces a reference
type, or cref(), which forces a constant reference type. For example, in the
following statements, a pair refers to an int twice so that, finally, i has the
value 2:

#include <iostream>
#include <functional>

int main()
{
  int i = 0;
  auto p = std::make_pair(std::ref(i), std::ref(i));

  p.first++;
  p.second++;

  std::cout << "i: " << i << std::endl;
}

i: 2

note: see how references are pakced into the pair.

<comparison>

namespace std {
  template <typename T1, typename T2>
    bool operator== (const pair<T1,T2>& x, const pair<T1,T2>& y) {
      return x.first == y.first && x.second == y.second;
    }
}

note: The first value has higher priority. Thus, if the first values of two
pairs differ, the result of their comparison is used as the result of the
overall comparison of the pairs.


{cpp-stl-tuple}
Tuples extends the concept of pairs to an 'arbitrary' number of heterogeneous
elements.

<ex>
#include <tuple>
#include <iostream>

using namespace std;

int main()
{
  tuple<int, float, string> t1( 41, 6.3, "nico" );

  // iterate over elements
  cout << get<0>(t1) << " ";
  cout << get<1>(t1) << " ";
  cout << get<2>(t1) << " ";
  cout << endl;

  auto t2 = make_tuple( 22, 44, "two" );

  // assign second value in t2 to t1
  get<1>(t1) = get<1>(t2);

  if( t1 > t2 )
  {
    cout << "t1 is bigger than t2" << endl;
    t1 = t2;
  }

  // iterate over elements
  cout << get<0>(t1) << " ";
  cout << get<1>(t1) << " ";
  cout << get<2>(t1) << " ";
  cout << endl;
}

41 6.3 nico 
t1 is bigger than t2
22 44 two 


<iteration>
A tuple is no ordinary container class where you can iterate over the elements.
Instead, you have to know the index of elements you want to access at compile
time. Passing an index at runtime is 'not' possible:

int i;
get<i>(t1) // compile-time error: i is no compile-time value

The good news is that it is also a compile-time error to pass an 'invalid'
index:

get<3>(t1) // compile-time error if t1 has only three elements


<tuple-tie>
tie(ref1,ref2,...)
Creates a tuple of references, which allows extracting (individual) values out
of a tuple

note: 
To make the getting values out of tuple easy than using get<x>.


#include <tuple>
#include <iostream>

using namespace std;

int main()
{
  int i; float f; string s;
  
  tuple<int, float, string> t1( 41, 6.3, "nico" );

  tie(i, f, s) = t1;

  // iterate over elements
  // cout << get<0>(t1) << " ";
  // cout << get<1>(t1) << " ";
  // cout << get<2>(t1) << " ";
  // cout << endl;

  cout << i << " ";
  cout << f << " ";
  cout << s << " ";
  cout << endl;

  tie(i, f, s) = make_tuple( 22, 44, "two" );

  cout << i << " ";
  cout << f << " ";
  cout << s << " ";
  cout << endl;
}

41 6.3 nico 
22 44 two 


The use of std::ignore allows ignoring tuple elements while parsing with tie().
This can be used to extract tuple values partially:

std::tuple <int,float,std::string> t(77,1.1,"more light");

int i;
std::string s;
std::tie(i,std::ignore,s) = t; // assigns first and third value of t to i and s

<move-or-copy>
As with pair, can force move or copy of tuple.

<tuple-initializer>
The constructor taking a variable number of arguments to initialize a tuple is
declared as 'explicit':

namespace std {
  template <typename... Types>
    class tuple {
      public:
        explicit tuple(const Types&...);
        template <typename... UTypes> explicit tuple(UTypes&&...);
        ...
    };
}

This situation, however, has consequences when using initializer lists to define
values of a tuple.  For example, you can't use the assignment syntax to
initialize a tuple because that is considered to be an implicit conversion:

std::tuple<int,double> t1(42,3.14);    // OK, old syntax
std::tuple<int,double> t2{42,3.14};    // OK, new syntax
std::tuple<int,double> t3 = {42,3.14}; // ERROR <Q> why? See copy ctor


std::vector<std::tuple<int,float>> v { {1,1.0}, {2,2.0} }; // ERROR

std::tuple<int,int,int> foo() {
  return { 1, 2, 3 }; // ERROR
}


std::vector<std::pair<int,float>> v1 { {1,1.0}, {2,2.0} }; // OK

std::vector<int> foo2() {
  return { 1, 2, 3 }; // OK
}

For tuples, you have to 'explicitly' convert the initial values into a tuple

std::vector<std::tuple<int,float>> 
  v { std::make_tuple(1,1.0), std::make_tuple(2,2.0) }; // OK

std::tuple<int,int,int> foo() {
  return std::make_tuple(1,2,3); // OK
}

<tuple-print>
The tuple class was first made public in the 'boost' library. There, tuple had
an interface to write values to output streams, but there is no support for this
in the C++ standard library. With the following header file, you can print any
tuple with the standard output operator <<

#include <iostream>
#include <tuple>

using namespace std;

// helper: print element with index IDX of tuple with MAX elements
template <int IDX, int MAX, typename... Args>
struct PRINT_TUPLE {
  static void print( std::ostream& strm, const std::tuple<Args...> &t)
  {
    strm << std::get<IDX>(t) << (IDX+1==MAX ? "" : ",");
    PRINT_TUPLE<IDX+1, MAX, Args...>::print(strm, t);
  }
};

// partial specialization to end the recursion
template <int MAX, typename... Args>
struct PRINT_TUPLE<MAX, MAX, Args...>
{
  static void print( std::ostream& strm, const std::tuple<Args...>& t)
  {}
};

template <typename... Args>
std::ostream& operator<<( std::ostream& strm, const std::tuple<Args...> &t)
{
  strm << "[";
  PRINT_TUPLE<0, sizeof...(Args), Args...>::print(strm, t);
  return strm << "]";
}


int main()
{
  tuple<int, float, string> t1( 41, 6.3, "nico" );
  cout << "io: " << t1 << endl; 
}


This code makes heavy use of template metaprogramming to recursively iterate at
compile time over the elements of a tuple. Each call of PRINT_TUPLE<>::print()
  prints one element and calls the same function for the next element. A partial
  specialization, where the current index IDX and the number of elements in the
  tuple MAX are equal, ends this recursion.


={============================================================================
*kt_dev_stl_081* std::ref

C++SLR 5.4.3 Reference Wrappers

Class std::reference_wrapper<>, declared in <functional>, is used primarily to
"feed" references to function templates that take their parameter by value. For
a given type T, this class provides ref() for an implicit conversion to T& and
cref() for an implicit conversion to const T&, which usually allows function
templates to work on references without specialization.

For example, after a declaration such as

template <typename T>
void foo (T val);

by calling

int x;
foo (std::ref(x));

T becomes int&, whereas by calling

int x;
foo (std::cref(x));

T becomes const int&.

This feature is used by the C++ standard library at various places. For example:

* make_pair() uses this to be able to create a pair<> of references
* make_tuple() uses this to be able to create a tuple<> of references
* Binders use this to be able to bind references
* Threads use this to pass arguments by reference


={============================================================================
*kt_dev_cpp_0000* cpp-bool-in-condition

{cxx-getline}
The std::getline is declared as:

istream& getline (istream& strm, string& str);

All characters, including leading whitespaces, are extracted until any of the
following happens:

* strm.good() is false (which might cause an appropriate exception)
* delim or strm.widen('\n') is extracted
* str.max_size() characters are stored

How can we use getline() to read multiple lines in loop such as:

  while (getline(...))

It returns a stream and when you use it in a boolean context the compiler
looks for an conversion operator that can convert it into a type that can be
used in the boolean context.

In this case stream has operator void*(). As this results in a pointer it can
be used in a boolean context. When called it checks the error flags. If either
failbit or badbit are set then it returns NULL which is equivalent to FALSE
otherwise it returns a pointer to self or something else valid though you
should not use this fact.

So you can use a stream in any context that would require a boolean test.

// 4.7.2/bits/basic_ios.h
//
// 27.4.5  Template class basic_ios
/**
*  @brief  Virtual base class for all stream classes.
*  @ingroup io
*
*  Most of the member functions called dispatched on stream objects
*  (e.g., @c std::cout.foo(bar);) are consolidated in this class.
*/
template<typename _CharT, typename _Traits>
class basic_ios : public ios_base
{
public:
  //@{
  /**
   *  @brief  The quick-and-easy status check.
   *
   *  This allows you to write constructs such as
   *  <code>if (!a_stream) ...</code> and <code>while (a_stream) ...</code>
  */
  operator void*() const
  { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

  bool
  operator!() const
  { return this->fail(); }
  //@}
}


={============================================================================
*kt_dev_cpp_0000* cpp-container

According to the way the order of elements is defined. See difference between
`ordered` and `sorted` term.


{sequence}
`sequence-containers` are `ordered-collections` in which every element has a
certain 'position'. This position depends on the time and place of the
insertion, but it is 'independent' of the value of the element. 

For example, if you put six elements into an ordered collection by appending
each element at the end of the collection, these elements are in the 'exact'
`insert-order` in which you put them.

The STL contains five predefined sequence container classes: 
  array, vector, deque, list, and forward_list.


{associative}
`associative-containers` are `sorted-collections` in which the position of an
element depends on its 'value' (or key, if it’s a key/value pair) due to a
certain 'sorting' criterion. 

If you put six elements into a collection, their 'value' determines their
order. The order of insertion doesn't matter. atomatic sorting.

The STL contains four predefined associative container classes: 
  set, multiset, map, and multimap.


{associative-unordered}
`unordered-containers` (associative) containers are 'unordered' collections in
which the position of an element doesn't matter. The only important question
is whether a specific element is 'in' such a collection.

Thus, if you put six elements into a collection, their order is undefined and
might change over time. 

The STL contains four predefined unordered container classes: 
  unordered_set, unordered_multiset, unordered_map, and unordered_multimap.


{implementation}
Sorted collections have the additional ability to be ordered according to a
sorting criterion.

However, the STL collection types are completely distinct from one another and
have very different implementations that are not derived from one another. As
we will see:

* Sequence containers are usually implemented as arrays or linked lists.
* Associative containers are usually implemented as binary trees.
* Unordered containers are usually implemented as hash tables.

The particular implementation of any container is not defined by the C++
standard library. However, the behavior and complexity specified by the
standard do not leave much room for variation. So, in practice, the
implementations differ only in minor details.


<contiguous-and-node-based> the other criteria
string, vector, deque, and array are 'contiguous' memory. Hence, insert/delete
in the middle can be expensive since have to move elements but fast access.

All node-based containers (lists, forward lists, sets, multisets, maps, and
multimaps), including the unordered containers,


={============================================================================
*kt_dev_cpp_0000* cpp-container-element-type

C++LR 244.

Containers, iterators, and algorithms of the STL are templates. Thus, they can
process both predefined or user-defined types. However, because of the
operations that are called, some requirements apply. The elements of STL
containers must meet the following three fundamental requirements:

* An element must be 'copyable' or 'movable'. 

Thus, an element type implicitly or explicitly has to provide a copy or move
constructor. A generated copy should be equivalent to the source. This means
that any test for equality returns that both are equal and that both source
and copy behave the same.

* An element must be (move) 'assignable' by the assignment operator. 

Containers and algorithms use assignment operators to overwrite old elements
with new elements.

* An element must be 'destroyable' by a destructor. 

Containers destroy their internal copies of elements when these elements are
removed from the container. Thus, the destructor must not be private. Also, as
usual in C++, a destructor must not throw; otherwise, all bets are off.

*cpp-ctor-default*
These three operations are generated implicitly for any class. Thus, a class
meets the requirements automatically, provided that no special versions of
these operations are defined and no special members disable the sanity of
those operations.

Elements might also have to meet the following requirements:

* For some member functions of sequence containers, the default constructor
must be available. For example, it is possible to create a nonempty container
or increase the number of elements with no hint of the values those new
elements should have. These elements are created without any arguments by
calling the default constructor of their type.

* For several operations, the test of equality with operator == must be
defined and is especially needed when elements are searched. For unordered
containers, however, you can provide your own definition of equivalence if the
elements do not support operator == (see Section 7.9.7, page 379).
*cpp-map-element-type*

* For associative containers, the operations of the sorting criterion must be
provided by the elements. By default, this is the operator <, which is called
by the less<> function object.

* For unordered containers, a hash function and an equivalence criterion must
be provided for the elements. See Section 7.9.2, page 363, for details.


{requirement-on-key-type-for-ordered-container} 
C++P 425. The ordered container uses opearator<() for ordering relation which
defines so called "strick weak ordering":

"equivalent" means:
  Neither two keys "less than" the other, then those are "equivalent"

Here the library <template-less>

namespace std {
  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };
};


{value-reference-semantics}
STL containers provide 'value' semantics. The containers contain the values of
the objects you insert rather than the objects themselves. In practice,
    however, you may also need 'reference' semantics. This means that the
    containers contain references to the objects that are their elements.

The approach of the STL to support only value semantics has both strengths and
weaknesses.

<pros>
* Copying elements is simple.

* References are error prone. 
You must ensure that references don't refer to objects that no longer exist.
You also have to manage circular references, which might occur.

<cons>
* Copying elements might result in bad performance or may not even be
  possible.

* Managing the same object in several containers at the same time is not
  possible.

Unfortunately, there is no support for reference semantics in the C++ standard
library. However, you can implement reference semantics in terms of value
semantics. The obvious approach to implementing reference semantics is to use
pointers as elements. However, ordinary pointers have the usual problems. A
better approach is to use a kind of smart pointer.


={============================================================================
*kt_dev_cpp_0000* cpp-container-common-operations

Usually, the STL containers provide only those special member functions that
in general have "good" performance, where "good" normally means constant or
logarithmic complexity. This prevents a programmer from calling a function
that might cause bad performance.

<emplace>
Here c means container and the emplace_* construct a object 'directly' in a
container rather then copying from a temporary.

c.emplace_back( "978-3403", 25, 15.99 );
c.push_back( Sales_data("978-3403", 25, 15.99) );  // use temp object

*cpp-array-begin*
// initialize-from-c-array from *C++11* supports std::begin()
int intarr[] = { 0, 1, ... };
vector<int> ivec( std::begin(intarr), std::end(intarr) );


<initialize> *cpp-list-init* *C++11*
ContType c(initlist)
ContType c = initlist

vector<string> articles = { "a", "an", "the" };
vector<string> articles{ "a", "an", "the" };

// from-range
ContType c(beg,end)
Creates a container and initializes it with copies of all elements of
[beg,end) (not for array<>)

When initialize a container from other container, container and 'element' type
  must be indentical. The constructor for a given range provides the ability
  to initialize the container with elements of another container if there is
  an automatic conversion from the source element type to the destination
  element type.

vector<const char*> articles = { "a", "an", "the" };
forward_list<string> words (articles.begin(), articles.end());


// from-move *C++11* *cpp-move-iterator*
std::list<std::string> l;

// move all elements of the list into a vector
std::vector<std::string> c(std::make_move_iterator(l.begin()),
                           std::make_move_iterator(l.end()) );


ContType c(rv)
ContType c = rv
Move constructor; creates a new container, taking the contents of the rvalue
rv (since C++11; not for array<>)

std::vector<int> v1;

// move contents of v1 into v2, state of v1 undefined afterward
std::vector<int> v2 = std::move(v1);


<push_back>
provided for `all sequence containers,` where appending an element is possible
and reasonably fast.

coll.push_back(i);

<cxx-size-cxx-empty>
size() is provided for any container class except forward_list because it
couldn't have constant complexity there.

coll.size();

empty() returns whether the number of elements is zero (begin()==end()). 

note: 
Should prefer it over size()==0, because it might be implemented more
efficiently than size(), and size() is not provided for forward lists.


<resize>
is used to change the number of elements except array including increse from
size 0. If the size grows, you can pass an additional parameter to specify the
value of the 'new' elements. Otherwise, use default ctor.

coll.resize(10,99);

<comparison>
For all but unordered containers, the usual comparison operators ==, !=, <,
    <=, >, and >= are defined according to the following three rules:

o. Both containers must have the same 'type'.

o. Two containers are equal if their elements are 'equal' and have the same
'order'. To check equality of elements, operator == is used.

o. To check whether a container is less than another container, a
lexicographical comparison is done

For unordered containers, only the operators == and != are defined. They
return true when each element in one container has an equal element in the
other container. The order doesn't matter (that's why they are unordered
containers).

<clear>
Removes all elements (empties the container; not for array<>)


C++LR 7.1.2

{assign} constant complexity

c = c2         
Assigns all elements of c2 to c

c = rv         
Move assigns all elements of the rvalue rv to c (since C++11; not for array<>)

c = initlist   
Assigns all elements of the initializer list initlist (since C++11; not for
array<>)

If you assign containers, you 'copy' all elements of the source container and
remove all old elements in the 'destination' container. Thus, assignment of
containers is relatively 'expensive'.


<ex>
vector<int> vi1(3, 5);  // vi1(size, val)
vector<int> vi2(6, 2);

cout << vi1.size() << ":" << vi2.size() << endl;
// 3:6

vi2 = vi1;              // see

cout << vi1.size() << ":" << vi2.size() << endl;
// 3:3


Applies to the whole container.

vector<int> ivec = { 1, 2, 3, 4, 5, 6 };
ivec.size();          // 7

ivec = { 1, 2, 5 };
ivec.size();          // 3


vector<string> v;
v = {"a", "the", "an"};


std::vector<int> v1;
std::vector<int> v2;

// move contents of v1 into v2, state of v1 undefined afterward
v2 = std::move(v1);

<ex>
// this moves really since v2 becomes empty after move.
#include <iostream>
#include <vector>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const std::string &msg, const T& coll )
{
  std::cout << msg;

  for( const auto &elem : coll )
    std::cout << ' ' << elem << ": ";

  std::cout << std::endl;
}

int main()
{
  vector<int> ivec1{1,2,3,4,5,6};
  PRINT_ELEMENTS("ivec1 : ", ivec1 );

  vector<int> ivec2{7,8,9};
  PRINT_ELEMENTS("ivec2 : ", ivec2 );

  // ivec1 = ivec2;
  ivec1 = std::move(ivec2);

  PRINT_ELEMENTS("ivec1 : ", ivec1 );
  cout << "ivec1 : size : " << ivec1.size() << endl;

  PRINT_ELEMENTS("ivec2 : ", ivec2 );
  cout << "ivec2 : size : " << ivec2.size() << endl;
}

ivec1 :  1:  2:  3:  4:  5:  6: 
ivec2 :  7:  8:  9: 
ivec1 :  7:  8:  9: 
ivec1 : size : 3
ivec2 : 
ivec2 : size : 0                  // see state after move


{swap} constant complexity
Since C++98, 'all' containers provide a swap() 'member' function to swap
contents of two containers. In fact, it swaps only some 'internal' pointers
that refer to the data (elements, allocator, sorting criterion, if any). So,
     swap() is guaranteed to have only 'constant' complexity, not the linear
     complexity of a copy assignment.

Iterators and references to elements of a container follow swapped elements.
After swap(), iterators and references 'still' refer to the elements they
referred to before, which, however, are in a different container then.

c1.swap(c2) Swaps the data of c1 and c2
swap(c1,c2) Swaps the data of c1 and c2

note: that for containers of type array<>, the behavior of swap() is slightly
different. Because you can't internally just swap pointers, swap() has
'linear' complexity, and iterators and references refer to the same container
but different elements afterward. <Q> only for array?


{subscript}
The operator[] has different sementics in sequential and associative.

return reference

s[n]  return a reference to the element at position n in string.
v[n]  return a reference to the element at position n in vector.


for sequential

The index must be 'in' range as C array does. The operator does 'not' check
whether the index is in range and the program must ensure that the index is
valid. To ensure that can use at() that throws `out_of_range` if the index is
invalid.

  A safer way to access a character is to use the at() member function.
  However, such a check costs runtime, so the check is 'not' provided for the
  usual accessing of characters of a string.


for associative

As explained in `associative-array`, since not having an element for an index
is not an error, so insert a new element. Also use at() not to insert element
accidentally in which throw out_of_range.


={============================================================================
*kt_dev_cpp_0000* cpp-container-insert-erase

There are some differences between containers as to what to return from insert
and erase and arguments. 


{cpp-vector-insert-cpp-vector-erase}
Table 7.14. Insert and Remove Operations of Vectors

c.push_back(elem)       Appends a copy of elem at the end
c.pop_back()            `Removes` the last element (`does not return it`)

c.insert(pos,elem)      Inserts a copy of elem before iterator position pos and
                        returns the position of the new element

c.insert(pos,n,elem)    Inserts n copies of elem before iterator position pos
                        and returns the position of the first new element (or
                        pos if there is no new element)

c.insert(pos,beg,end)   Inserts a copy of all elements of the range [beg,end)
                        before iterator position pos and returns the position
                        of `the first new element` (or pos if there is no new
                        element)

c.insert(pos,initlist)  Inserts a copy of all elements of the initializer list
                        initlist before iterator position pos and returns the
                        position of the first new element (or pos if there is
                        no new element; since C++11)

c.erase(pos)            Removes the element at iterator position pos and
                        `returns the position of the next element`

c.erase(beg,end)        Removes all elements of the range [beg,end) and
                        returns the position of the next element

c.resize(num)           Changes the number of elements to num (if size() grows new
                        elements are created by their default constructor)

c.resize(num,elem)      Changes the number of elements to num (if size() grows
                        new elements are copies of elem)

c.clear()               Removes all elements (empties the container)


{cpp-set-insert-cpp-set-erase}
All elements are considered 'constant'. Means that iterators are also
constant:

  * Can't call any 'modifying' algorithm on the elements of a set or a
    multiset. 

  * To change the key of an element, you have only one choice: You must
    replace the old element with a new element that has the same value.


Table 7.39. Insert and Remove Operations of Sets and Multisets

c.insert(val)       Inserts a copy of val and returns the position of the new
                    element and, for sets, whether it succeeded

c.insert(pos,val)   Inserts a copy of val and returns the position of the new
                    element (pos is used as a hint pointing to where the
                    insert should start the search)

c.insert(beg,end)   Inserts a copy of all elements of the range [beg,end)
                    (returns nothing)

c.insert(initlist)  Inserts a copy of all elements in the initializer list
                    initlist (returns nothing; since C++11)

c.erase(val)        Removes all elements equal to val and returns the number
                    of removed elements

c.erase(pos)        Removes the element at iterator position pos and returns
                    the following position (`returned nothing before C++11`)

c.erase(beg,end)    Removes all elements of the range [beg,end) and returns
                    the following position (returned nothing before C++11)

c.clear()           Removes all elements (empties the container)


<different-return>
The return types of the inserting functions insert() and emplace() differ as
follows:

`set` provide the following interface:

pair<iterator,`bool`>  insert (const value_type& val);
iterator             insert (const_iterator posHint, const value_type& val);

template <typename... Args> pair<iterator, `bool`> 
  emplace (Args&&... args);
template <typename... Args> iterator 
  emplace_hint (const_iterator posHint, Args&&... args);

`multiset` provide the following interface:

iterator insert (const value_type& val);
iterator insert (const_iterator posHint, const value_type& val);

template <typename... Args> iterator 
  emplace (Args&&... args);
template <typename... Args> iterator 
  emplace_hint (const_iterator posHint, Args&&... args);

The bool in return is only for set since insert in multiset always succeed.
multisets allow duplicates, whereas sets do not. Thus, the insertion of an
element might fail for a set if it already contains an element with the same
value. Therefore, the return type for a set returns two values by using a pair
structure

* The member second of the pair structure returns whether the insertion was
  successful.

* The member first of the pair structure returns the position of the newly
  inserted element or the position of the still existing element.

Position argument? As said, position is used it as a 'hint'. The prime purpose
is that you have one insert function that has the same interface for all
container types. Remember `sequence-container` use insert(pos, val) interface. 


{cpp-map-insert-cpp-map-erase}
Unlike set, maps provide a more convenient way to modify the key of an
element. Instead of calling replace_key(), you can simply write the following:

// insert new element with value of old element
coll["new_key"] = coll["old_key"];

Table 7.45. Insert and Remove Operations of Maps and Multimaps

c.insert(val)       Inserts a copy of val and returns the position of the new
                    element and, for maps, whether it succeeded

c.insert(pos,val)   Inserts a copy of val and returns the position of the new
                    element (pos is used as a hint pointing to where the
                    insert should start the search)

c.insert(beg,end)   Inserts a copy of all elements of the range [beg,end)
                    (returns nothing)

c.insert(initlist)  Inserts a copy of all elements in the initializer list
                    initlist (returns nothing; since C++11)

c.erase(val)        Removes all elements equal to val and returns the number
                    of removed elements

c.erase(pos)        Removes the element at iterator position pos and returns
                    the following position (returned nothing before C++11)

c.erase(beg,end)    Removes all elements of the range [beg,end) and returns
                    the following position (returned nothing before C++11)

c.clear()           Removes all elements (empties the container)

coll.insert( { word, 1} );    // *C++11* most convenient way
coll.insert( std::map<std::string,int>::value_type( word, 1) );
coll.insert( decltype(coll)::value_type( word, 1) );
coll.insert( make_pair(word, 1) );
coll.insert( pair<string, size_t>(word, 1) );


<position-hint>
Passing a position(iterator) to insert doesn't sound useful for associative and
unordered containers? The position is taken as a 'hint' to start the search for
the correct position. However, containers are free to ignore it.

All sequence containers except array has only insert(pos, val) but
associatives have insert(val) and insert(pos, val). That's why associatives
has two versions for the same purpose.

note: This is why should be careful about using range for.


<return-position>
The text reads: 
  "c.insert(pos, elem): inserts a copy of elem 'before' iterator pos and
  returns the position of the new element"

   [ pos-1 ] [ pos ] [pos+1]

insert invalidate iterator from pos since they are after the insertion point.


<ex>
// *end() is always error and use of end() is okay.

vec<int> veci;
veci.push_back(1); .. to (3); // [1,2,3,E)
veci.insert( veci.end(), 4 );

1 2 3 4

<ex>
list<string> lst;
auto iter = lst.begin();

while( cin >> word )
   iter = lst.insert( iter, word ); // or lst.push_front(word);

[three, two, one]

while(...)
   lst.insert(iter, word);

[one, two, three]                       // see no iter update

In the latter case, iter remains the same, `off-the-end`, in list and works
fine. However, this approach will creates core dump in case of vector because
addition and deletion will invalidate iterator of vector.


{iter-invalidated} CPR 353.
Operations that add or remove elements from a container could invalidate
pointers, references, or iterator to container elements. Using an invalidated
pointer is the same kind of problems as using an unitialized pointer. 

This is only for sequential containers that use `contiguous-memory`

After `add` an element:

* Iterators, pointers, and references to a `vector` or `string` are invalid if
  the container was reallocated. If no rellocation happens, indirect
  references before the insertion remain valid; those after insertion are
  invalid.

* Same for `deque` if we add elements anywhere but at the front or back. If we
  add at the front or back, iterators are invalidated but references and
  pointers to exisiting elements are not.

* Iterators, pointers, and references to `list` or `forward_list` remain valid.

After `remove` an element:

* All other iterators, references, and pointers to a `vector` or `string`
  remain valid before the removal point. The `off-the-end` iterator is always
  invalidated.

* All others to a `deque` are invalidated if the removed elements are anywhere
  but the front or back.

* All others to `list` or `forward_list` remains valid.


<ex>
// = 04 ======
// 1:5:6:7:2:3:4:

void t_iter_04()
{
  std::vector<int> veci{1,2,3,4};
  // std::vector<int>::iterator it;

  auto it = find(veci.begin(), veci.end(), 2);
  if( it != veci.end())
  {
    it = veci.insert( it, 7 );
    it = veci.insert( it, 6 );
    it = veci.insert( it, 5 );

    // Q: This seems okay since inserting element at the same pos,2? what will
    // happen?
    //
    // veci.insert( it, 7 );
    // veci.insert( it, 6 );
    // veci.insert( it, 5 );
    //
    // core dump since it gets invalidated.
  }

  for ( const auto &e : veci )
  {
    std::cout << e << ":";
  }
  std::cout << std::endl;
}


<ex>
// = 05 ======
// 1:1:3:3:5:5:7:7:9:9:

// the point is to update it on each trip of the loop

void t_iter_05()
{
    std::vector<int> iv{0,1,2,3,4,5,6,7,8,9};

    for (auto it = iv.begin(); it != iv.end();)
    {
        // if see odd values
        if (*it % 2)
        {
            // *cpp-iter-arthimetic*
            // repeat the item. it points the item repeated. so +2 to point the
            // item which are not checked.
            it = iv.insert(it, *it);
            it += 2;
        }
        // if see even vales
        else
        {
            // update it as erase returns next elements.
            it = iv.erase(it);
        }
    }

    for (const auto &e : iv)
        cout << e << ":";
    cout << endl;
}


<ex>
* invalidated iterators also apply to associative containers. erase for map
  which invalidate iterators for `erased` elements.

* `erase()`/`insert()` returns void for associative containers. not any more
  since C++11 and see map cases.

Can't use the find() member functions to remove elements that have a certain
value instead of a certain key. So can use loop but careful not to saw off the
branch on which you are sitting.

Calling erase() for the element to which you are referring with pos invalidates
pos as an iterator of coll and calling ++pos results in undefined behavior.
note: this invalidates only current one since it's map.

void t_iter_06()
{
    std::map<std::string, int> coll{{"one", 1}, {"two", 2}, {"three", 3}, {"four", 4}, {"five", 5}};

    for (const auto &e : coll)
        cout << e.first << "," << e.second << endl;

    int value = 2;

    // note that cbegin also works
    for (auto it = coll.cbegin(); it != coll.cend(); ++it)
    {
        // may cause runtime error but not always. undefined. 
        if (it->second == value)
            coll.erase(it);
    }

    cout << "===========" << endl;
    for (const auto &e : coll)
        cout << e.first << "," << e.second << endl;
}

void t_iter_07()
{
    std::map<std::string, int> coll{{"one", 1}, {"two", 2}, {"three", 3}, {"four", 4}, {"five", 5}};

    for (const auto &e : coll)
        cout << e.first << "," << e.second << endl;

    int value = 2;

    // note that cbegin also works and no increase in control statement.
    for (auto it = coll.cbegin(); it != coll.cend();)
    {
        // before C++11 since erase returns nothing. *cpp-side-effect*
        if (it->second == value)
            coll.erase(it++);
        else
            ++it;
    }

    cout << "===========" << endl;
    for (const auto &e : coll)
        cout << e.first << "," << e.second << endl;
}

void t_iter_08()
{
    std::map<std::string, int> coll{{"one", 1}, {"two", 2}, {"three", 3}, {"four", 4}, {"five", 5}};

    for (const auto &e : coll)
        cout << e.first << "," << e.second << endl;

    int value = 2;

    // note that cbegin also works and no increase in control statement.
    for (auto it = coll.cbegin(); it != coll.cend();)
    {
        // afer C++11 since erase returns next elements.
        if (it->second == value)
            it = coll.erase(it);
        else
            ++it;
    }

    cout << "===========" << endl;
    for (const auto &e : coll)
        cout << e.first << "," << e.second << endl;
}


={============================================================================
*kt_dev_cpp_0000* cpp-container-remove

In practice, there are some limits and workarounds you should know. Many of
these have to do with modifications. These aspects are surprising and show the
'price' of the STL concept that separates containers and algorithms with great
flexibility.

{for-sequential} *ex-algo-remove* 

// = 09 ======
// before : 12 elements
// 6 5 4 3 2 1 1 2 3 4 5 6 
// after  : 12 elements
// 6 5 4 2 1 1 2 4 5 6 5 6 

void t_iter_09()
{
    std::list<int> coll;

    for (int i = 1; i <= 6; ++i)
    {
        coll.push_back(i);
        coll.push_front(i);
    }

    cout << "before : " << coll.size() << " elements" << endl;
    copy(coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
    cout << endl;

    // remove all elements with value 3
    remove(coll.begin(), coll.end(), 3);

    cout << "after  : " << coll.size() << " elements" << endl;
    copy(coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
    cout << endl;
}

So *algo-remove* reorder:

<elemenets not matched> <elements matched>
                       |
                        += return the past of the last element

Thus, `remove()` did not change the number of elements in the collection for
which it was called. Revised the code to actually remove by calling 'member'
function. 

note: 
coll.remove() is only for list and forward_list since no such member function
for others.

Why don't algorithms call erase() by themselves? This question highlights the
price of the flexibility of the STL. The STL separates data structures and
algorithms by using iterators as the interface. However, iterators are an
abstraction to represent a 'position' in a container. In general, iterators do
not know their containers. Thus, the algorithms, which use the iterators to
access the elements of the container, can't call any member function for it.

// = 10 ======
// before : 12 elements
// 6 5 4 3 2 1 1 2 3 4 5 6 
// after  : 12 elements
// 6 5 4 2 1 1 2 4 5 6 5 6 
// number of removed elements: 2
// erased : 10 elements
// 6 5 4 2 1 1 2 4 5 6 

void t_iter_10()
{
    std::list<int> coll;

    for (int i = 1; i <= 6; ++i)
    {
        coll.push_back(i);
        coll.push_front(i);
    }

    cout << "before : " << coll.size() << " elements" << endl;
    copy(coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
    cout << endl;

    // remove all elements with value 3. save logical end.
    auto end = remove(coll.begin(), coll.end(), 3);

    cout << "after  : " << coll.size() << " elements" << endl;
    copy(coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
    cout << endl;

    // *algo-distance*
    cout << "number of removed elements: " << distance(end, coll.end()) << endl;

    coll.erase(end, coll.end());

    cout << "erased : " << coll.size() << " elements" << endl;
    copy(coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
    cout << endl;
}


{for-associative}
Manipulation algorithms-those that remove elements and those that reorder or
modify elements-have another 'problem' when you try to use them with
associative or unordered containers:

Associative and unordered containers can't be used as a destination. The
reason is simple:

If they would work for associative or unordered containers, modifying
algorithms could change the value or position of elements, thereby violating
the order maintained by the container

In order to maintain internal order, every iterator for an associative and
unordered container is declared as an iterator for a 'constant' value or key.

<ex>
#include <iostream>
#include <set>
#include <algorithm>
#include <iterator>

using namespace std;

int main()
{
  set<int> coll{1,2,3,4,5,6,7,8,9};

  // print 
  cout << "pre : " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;

  remove( coll.begin(), coll.end(), 3 );

  // print 
  cout << "post: " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;
}

// same error when use remove(coll.cbegin(), coll.cend(), 3)

In file included from /usr/include/c++/4.6/algorithm:63:0,
                 from sam01.cpp:3:
/usr/include/c++/4.6/bits/stl_algo.h: In function '_FIter std::remove(_FIter, _FIter, const _Tp&) 
   [with _FIter = std::_Rb_tree_const_iterator<int>, _Tp = int]':
sam01.cpp:17:39:   instantiated from here
/usr/include/c++/4.6/bits/stl_algo.h:1106:13: error: assignment of read-only location 
   '__result.std::_Rb_tree_const_iterator<_Tp>::operator* [with _Tp = int, std::_Rb_tree_const_iterator<_Tp>::reference = const int&]()'


How does one remove elements in associative containers? The answer is simple:
Call their member functions

<ex>
#include <iostream>
#include <set>
#include <algorithm>
#include <iterator>

using namespace std;

int main()
{
  set<int> coll{1,2,3,4,5,6,7,8,9};

  // print 
  cout << "pre : " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;

  int num = coll.erase(3);

  // print number of removed elements
  cout << "number of removed elements: " << num << endl;

  // print 
  cout << "pre : " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;
}

pre : 9 elements
1 2 3 4 5 6 7 8 9 
number of removed elements: 1
pre : 8 elements
1 2 4 5 6 7 8 9 


{algorithm-or-member-function}
Even if you are able to use an algorithm, it might be a bad idea to do so. A
container might have member functions that provide much better performance.

Calling remove(val) for elements of a 'list' is a good example of this. If you
call remove() for elements of a list, the algorithm doesn't know that it is
operating on a list and thus does what it does for any container: reorder the
elements by changing their values. If, for example, the algorithm removes the
first element, all the following elements are assigned to their previous
elements. This behavior contradicts the main advantage of lists: the ability
to insert, move, and remove elements by modifying the links instead of the
values.

note: 
The `remove()` member is only for list and forward_list and erase for others.

To avoid bad performance, lists provide special member functions for all
manipulating algorithms. You should 'always' prefer them. 

The problem is, you have to know that a member function exists that has
significantly better performance for a certain container. You have to change
the code when you switch to another container type.

<container-specific>
The `list` and `forward_list` define several algorithms as memebers because can
use generic ones with list but at a cost in performance. These container
spscific ones are merge, sort, unique, remove and reserse. The member version
should be used in preference to the generic for list and forward_list.

Also, a important difference between the list-specific and the generic is that
the list version change the underlying containers.

// *ex-algo-remove*
int main()
{
  list<int> coll;

  // insert elements from 6 to 1 and 1 to 6
  for (int i=1; i<=6; ++i) {
    coll.push_front(i);
    coll.push_back(i);
  }

  // remove all elements with value 3 (poor performance)
  coll.erase (remove(coll.begin(),coll.end(), 3), coll.end());

  // remove(val) 'all' elements with value 4 (good performance)
  coll.remove (4);
}


={============================================================================
*kt_dev_cpp_0000* cpp-container-performance

{amortized}
Some complexity definitions in the C++ reference manual are specified as
amortized. This means that the operations in the long term behave as
described.  However, a single operation may take longer than specified. 

For example, if you append elements to a dynamic array, the runtime depends on
whether the array has enough memory for one more element. If there is enough
memory, the complexity is constant because inserting a new last element always
takes the same time. However, if there is not enough memory, the complexity is
linear because, depending on the number of elements, you have to allocate new
memory and copy all elements. 

Reallocations are rather rare, so any sufficiently long sequence of that
operation behaves as if each operation has constant complexity. Thus, the
complexity of the insertion is 'amortized' constant time.


C++PL 894

List refers to insertion and deletion not necessarily at the ends of a
container.

+ suffix indicates that occasionally a significant extra cost incurred and
means armortized.

                []              List      Front     Back      Iterators
vector          const,O(1)      O(n)+               const+    random
list                            const     const     const     bi

map             O(log(n))       O(log(n))+                    bi
multimap                        O(log(n))+                    bi
set                             O(log(n))+                    bi
multiset                        O(log(n))+                    bi

unordered_map   const+          const+                        forward 
unordered_multimap              const+                        forward 
unordered_set                   const+                        forward 


={============================================================================
*kt_dev_cpp_0000* cpp-container-sequential

Consider performance trade-offs between insert/delete and random-access.

vector      : random-access, fast insert/delete at the back
string      : random-access, fast insert/delete at the back
deque       : double-ended q, random-access, fast insert/delete at front/back
array       : C++11. fixed size. possible to copy and assign.

string, vector, deque, and array are `contiguous-memory`. Hence, insert/delete
in the middle can be expensive since have to move elements but fast access.

list        : double llist, bi-directional, fast insert/delete at any point
forward list: single llist, forward, support push_front only.

these provides sequential access and may have memory overhead but fast
insert/delete.

note:
The forward_list don't support size() but others do. The size() has fast and
constant time which is different from ESTL so seems it's true for C++11? Primus
says C++ library has improved significantly in recent.

*cpp-iter-arithmetic*
The list and forward_list don't support iterator arithmetic since this is for
containers that supports random access; string, vector, deque and array.


={============================================================================
*kt_dev_cpp_0000* cpp-container-cpp-vector

A vector manages its elements in a 'dynamic' array and supports random access,
which means you can access each element directly with the corresponding index.

{code}
  // /usr/include/c++/4.7.2/bits/stl_vector.h

  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
      /**
       *  Returns a read/write reference to the data at the first
       *  element of the %vector.
       */
      reference
      front()
      { return *begin(); }

      // iterators
      /**
       *  Returns a read/write iterator that points to the first
       *  element in the %vector.  Iteration is done in ordinary
       *  element order.
       */
      iterator
      begin() _GLIBCXX_NOEXCEPT
      { return iterator(this->_M_impl._M_start); }

      /**
       *  Returns a read-only (constant) iterator that points to the
       *  first element in the %vector.  Iteration is done in ordinary
       *  element order.
       */
      const_iterator
      begin() const _GLIBCXX_NOEXCEPT
      { return const_iterator(this->_M_impl._M_start); }

      /**
       *  Returns a read/write iterator that points one past the last
       *  element in the %vector.  Iteration is done in ordinary
       *  element order.
       */
      iterator
      end() _GLIBCXX_NOEXCEPT
      { return iterator(this->_M_impl._M_finish); }

      /**
       *  Returns a read-only (constant) iterator that points one past
       *  the last element in the %vector.  Iteration is done in
       *  ordinary element order.
       */
      const_iterator
      end() const _GLIBCXX_NOEXCEPT
      { return const_iterator(this->_M_impl._M_finish); }

    };


<<ctor-and-dtor>
vector<T> c(n,elem);
Creates a vector initialized with n copies of element elem


<ex>
#include <iostream>
#include <memory>
#include <vector>

using namespace std;

int main()
{
  vector<int> coll;

  for(int i=1; i <= 6; i++)
    coll.push_back(i);

  for(int i=0; i < coll.size(); i++)
    cout << coll[i] << ' ';

  cout << endl;
}


{reallocation} cpp-vector-reallocation
To support fast random access, vector elements are stored 'contiguously'. To
maintain contiguous memory and to avoid reallocating a container each time an
element is added, the allocation strategy is: 

  When they have to get new memory, `vector` and `string` implementations
  typically allocate 'capacity' beyond what is immediately needed. Thus there
  is no need to 'reallocate' the container for each new element. The vector
  has to move all of its elements each time when it reallocates memory.

The capacity of a vector is important for two reasons:

o. Reallocation invalidates all references, pointers, and iterators for elements
  of the vector.

  "This means its memory may or may not move. Because of this uncertainty, must
  consider any existing iterators into `vector` to be invalidated. - EXPC++ p3"

o. Reallocation takes time.

c.shrink_to_fit();   
C++11. request to reduce capacity() to equal size()

c.capacity();        
returns `the maximum possible number of elements` without reallocation.

c.reserve(n);        
allocate space for at least n elements


<reserve-or-constructor>
To avoid reallocation, you can use reserve() to ensure a certain capacity
before you really need it. In this way, you can ensure that references remain
valid as long as the capacity is not exceeded

std::vector<int> v;  // create an empty vector
v.reserve(80);       // reserve memory for 80 elements

Or is to initialize a vector with enough elements by passing additional
arguments to the constructor.

std::vector<T> v(5); // creates a vector and initializes it with five values
                     // (calls five times the default constructor of type T)

note: 
The type of the elements must provide a default constructor for this ability.
For fundamental types, zero initialization is guaranteed. 

But for complex types, even if a default constructor is provided, the
initialization takes time. If the only reason for initialization is to reserve
memory, you should use reserve().

<shrink-to-fit>
Unlike for strings, it is not possible to call reserve() for vectors to shrink
the capacity. Calling reserve() with an argument that is less than the current
capacity is a no-op. Furthermore, how to reach an optimal performance
regarding speed and memory use is implementation defined. When reallocation is
needed, how much memory it will allocate is implementation specific.

Because the capacity of vectors never shrinks, it is guaranteed that
references, pointers, and iterators remain valid even when elements are
deleted, provided that they refer to a position before the manipulated
elements.

C++11 introduced shrink_to_fit() which is a 'non-binding' request to shrink
the capacity to fit the current number of elements: Valid only for vector,
    string, and deque. capacity and reserve valid only for vector and string.

There is no guarantee that shrink_to_fit will return a memory since it's a
only 'request'.


{element-access} CLR 7.3.2
Table 7.12. Direct Element Access of Vectors

As usual in C and C++, the first element has index 0, and the last element has
index size()-1. Thus, the nth element has index n-1. 

For nonconstant vectors, `these operations return a reference` to the element.
Thus, you could modify an element by using one of these operations, provided
it is not forbidden for other reasons.

c[idx]      Returns the element with index idx (no range checking)
c.at(idx)   Returns the element with index idx (throws range-error exception if
            idx is out of range)

c.front()   Returns the first element (no check whether a first element exists)

c.back()    Returns the last element (no check whether a last element exists)
            (does not remove it)


<at-range-check>
Only at() performs range checking. If the index is out of range, at() throws an
`out_of_range` exception (see 4.3, page 41). All other functions do not check. A
range error results in undefined behavior. 

Calling operator[], front(), and back() for an empty container always results in
`undefined` behavior. So, you must ensure that the index for operator[] is valid
and that the container is not empty when either front() or back() is called.


<ex>
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  // create empty vector for strings
  vector<string> sentence;
  // reserve memory for five elements to avoid reallocation
  sentence.reserve(5);

  // append some elements
  sentence.push_back("Hello,");
  sentence.insert(sentence.end(),{"how","are","you","?"});

  // print elements separated with spaces
  copy (sentence.cbegin(), sentence.cend(),
      ostream_iterator<string>(cout," "));
  cout << endl;

  // print ‘‘technical data’’
  cout << " max_size(): " << sentence.max_size() << endl;
  cout << " size()    : " << sentence.size() << endl;
  cout << " capacity(): " << sentence.capacity() << endl;

  // swap second and fourth element
  swap (sentence[1], sentence[3]);
  // insert element "always" before element "?"
  sentence.insert (find(sentence.begin(),sentence.end(),"?"), "always");
  // assign "!" to the last element
  sentence.back() = "!";

  // print elements separated with spaces
  copy (sentence.cbegin(), sentence.cend(),
      ostream_iterator<string>(cout," "));
  cout << endl;

  // print some ‘‘technical data’’ again
  cout << " size()    : " << sentence.size() << endl;
  cout << " capacity(): " << sentence.capacity() << endl;

  // delete last two elements
  sentence.pop_back();
  sentence.pop_back();

  // shrink capacity (since C++11)
  sentence.shrink_to_fit();
  // print some ‘‘technical data’’ again
  cout << " size()    : " << sentence.size() << endl;
  cout << " capacity(): " << sentence.capacity() << endl;
}

Hello, how are you ? 
 max_size(): 1073741823
 size()    : 5
 capacity(): 5
Hello, you are how always ! 
 size()    : 6
 capacity(): 10         // x2
 size()    : 4
 capacity(): 10         // no change


={============================================================================
*kt_dev_cpp_0000* cpp-container-cpp-vector-bool

{vector-bool}
For Boolean elements, the C++ standard library provides a 'specialization' of
vector<>. Such a usual implementation would reserve at least 1 byte for each
element. The vector<bool> specialization usually uses internally only 1 bit
for an element, so it is typically eight times smaller.

But such an optimization also has a snag: In C++, the smallest addressable
value must have a size of at least 1 byte. Thus, such a specialization of a
vector needs special handling for references and iterators.

As a result, a vector<bool> does not meet all requirements of other vectors.
For example, a vector<bool>::reference is not a true lvalue and
vector<bool>::iterator is 'not' a random-access iterator.

In addition, vector<bool> might perform 'worse' than normal implementations,
   because element operations have to be transformed into bit operations.
   However, how vector<bool> is implemented is implementation specific. Thus,
   the performance (speed and memory) might differ.

class vector<bool> is more than a specialization of vector<> for bool. It also
provides some special bit operations. You can handle bits or flags in a more
convenient way.

`vector<bool>` has a dynamic size, so you can consider it a bitfield with
`dynamic-size`. Thus, you can add and remove bits. If you need a bitfield with
`static-size`, you should use `bitset` rather than a vector<bool>.

The additional operations of vector<bool> are:

c.flip()             Negates all Boolean elements (complement of all bits)

c[idx].flip()        Negates the Boolean element with index idx (complement of a
                     single bit)

c[idx] = val         Assigns val to the Boolean element with index idx
                     (assignment to a single bit)

c[idx1] = c[idx2]    Assigns the value of the element with index idx2 to the
                     element with index idx1

note: default value is false.

<cpp-design-proxy>
How this "c[idx].flip()" possible since type bool is fundamental type? Here,
    the class vector<bool> uses a common trick, called a proxy. For
    vector<bool>, the return type of the subscript operator (and other
        operators that return an element) is an auxiliary class. If you need
    the return value to be bool, an automatic type conversion is used. For
    other operations, the member functions are provided. The relevant part of
    the declaration of vector<bool> looks like this:

namespace std {
  template <typename Allocator> `class vector`<bool,Allocator> {
    public:

      // auxiliary proxy type for element modifications:
      `class reference` {
        ...
        public:
          reference& operator= (const bool) noexcept; // assignments
          reference& operator= (const reference&) noexcept;
          operator bool() const noexcept; // automatic type conversion to bool
          void flip() noexcept;           // bit complement
      };

      ...

      // operations for element access return reference proxy instead of bool:
      reference operator[](size_type idx);
      reference at(size_type idx);
      reference front();
      reference back();
      ...
  };
}


={============================================================================
*kt_dev_cpp_0000* cpp-container-cpp-deque

This is an abbreviation for "double-ended queue" and a dynamic 'array' that
can grow in 'both' directions. Thus, inserting elements at the end and at the
beginning is fast. However, inserting elements in the middle takes time
because elements must be moved.

{element-access}
c[idx]    
Returns the element with index idx (no range checking)

c.at(idx) 
Returns the element with index idx (throws range-error exception if idx is out
of range)

<ex>
#include <iostream>
#include <deque>

using namespace std;

int main()
{
  deque<float> coll;

  for(int i=1; i <= 6; i++)
    coll.push_front(i*1.1);

  for(int i=0; i < coll.size(); i++)
    cout << coll[i] << ' ';

  cout << endl;
}

6.6 5.5 4.4 3.3 2.2 1.1


={============================================================================
*kt_dev_cpp_0000* cpp-container-cpp-array

An array(an instance of the container class array<>) models a static array. It
wraps an ordinary static C-style array providing the interface of an STL
container. Only a replacement of element values is possible.

This manages its elements in an array of fixed size and the number of elements
is a part of the type of an array.

If you need a sequence with a fixed number of elements, class array<> has the
best performance because memory is allocated on the 'stack' (if possible),
reallocation never happens, and you have random access.

#include <array>

namespace std {
  template <typename T, size_t N>
    class array;
}

<initialize>
array<> is the 'only' container whose elements are default initialized when
nothing is passed to initialize the elements. This means that for fundamental
types, the initial value might be undefined rather than zero like vector

std::array<int,4> x;       // OOPS: elements of x have undefined value
std::array<int,4> x = {};  // OK: all elements of x have value 0 (int())

<element-access>
For nonconstant arrays, these operations return a reference to the element.
Thus, you could modify an element by using one of these operations

c[idx]      Returns the element with index idx (no range checking)
c.at(idx)   Returns the element with index idx (throws range-error exception if idx is out of range)
c.front()   Returns the first element (no check whether a first element exists)
c.back()    Returns the last element (no check whether a last element exists)

<use-array-as-c-array>
Guarantees that the elements of an array<> are in contiguous memory. Thus, you
can expect that for any valid index i in array a, the following yields true:

&a[i] == &a[0] + i

This guarantee has some important consequences. It simply means that you can
use an array<> wherever you can use an ordinary C-style array.

std::array<char,41> a;           // create static array of 41 chars
strcpy(&a[0],"hello, world");    // copy a C-string into the array
printf("%s\n", &a[0]);           // print contents of the array as C-string

you don't have to use the expression &a[0] to get direct access to the
elements in the array, because the member function data() is provided for this
purpose:

std::array<char,41> a;           // create static array of 41 chars
strcpy(a.data(),"hello, world"); // copy a C-string into the array
printf("%s\n", a.data());        // print contents of the array as C-string


<ex>
#include <iostream>
#include <array>

using namespace std;

int main()
{
  array<string, 5> coll{"hello", "world"};

  for(int i=0; i < coll.size(); i++)
    cout << i << ": " << coll[i] << endl;
}


0: hello
1: world
2: 
3: 
4: 

<ex>
#include <iostream>
#include <array>
#include <functional>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  array<int, 10> coll = {11,22,33,44};

  PRINT_ELEMENTS(coll, "initialized: " );

  coll.back() = 9999999;
  coll[coll.size()-2] = 42;

  PRINT_ELEMENTS(coll, "modified   : " );

  cout << "sum: " << accumulate( coll.begin(), coll.end(), 0 ) << endl;

  transform( coll.cbegin(), coll.cend(),        // source
              coll.begin(), negate<int>());     // destination, operation

  PRINT_ELEMENTS(coll, "negated    : " );
}

initialized: 11 22 33 44 0 0 0 0 0 0 
modified   : 11 22 33 44 0 0 0 0 42 9999999 
sum: 10000151
negated    : -11 -22 -33 -44 0 0 0 0 -42 -9999999 


<ex>
#include <iostream>
#include <array>
#include <cstring>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  array<char, 41> coll = {"this is an char array"};
  PRINT_ELEMENTS(coll, "initialized: " );

  strcpy( &coll[0], "use the address of first");
  PRINT_ELEMENTS(coll, "strcpyed   : " );

  strcpy( coll.data(), "use data member");
  PRINT_ELEMENTS(coll, "strcpyed   : " );
}

initialized: t h i s   i s   a n   c h a r   a r r a y                     
strcpyed   : u s e   t h e   a d d r e s s   o f   f i r s t                  
strcpyed   : u s e   d a t a   m e m b e r  o f   f i r s t                  


={============================================================================
*kt_dev_cpp_0000* cpp-container-cpp-list

A list<> is implemented as a 'doubly' linked list of elements and do not
provide random access. The advantage of a list is that the insertion or
removal of an element is fast at any position.

<ex>
#include <iostream>
#include <list>

using namespace std;

int main()
{
  list<char> coll;

  for(char c = 'a'; c <= 'z'; c++ )
    coll.push_back(c);

  for( auto &elem : coll )
    cout << elem << ' ';
  
  cout << endl;
}


{no-random-access}
A direct element access by using operator[] is not provided for lists. This is
because lists don't provide random access, and so an operator[] would have bad
performance.

double& List_container::operator[](int i)
{
  for (auto& x : ld) {
    if (i==0) return x;
    --i;
  }

  throw out_of_range("List container");
}


{list-erase}
the header from begin() gets updated when use erase(start, end) to trim
entries in the front.

#include <iostream>
#include <list>

typedef std::list<double> LIST;

int main()
{
  int n;
  double item;
  LIST dlist; 
  LIST::iterator iHead;

  std::cout << "type in an integer n(loop count) followed by n decimal numbers." 
      << std::endl;

  std::cin >> n;

  for(int i=0; i<n; i++)
  {
    std::cin >> item;
    dlist.push_back(item);
  }

  std::cout << "input is done and you have entered " << dlist.size() 
      << " items" << std::endl;

  iHead = dlist.begin();

  for(; iHead != dlist.end(); iHead++) 
  {
    std::cout << "items: " << *iHead << std::endl; 
  }

  iHead = dlist.begin(); iHead++; iHead++;
  std::cout << "items: " << *iHead << std::endl; 
  dlist.erase( dlist.begin(), iHead );

  std::cout << "input is done and you have entered " << dlist.size() 
      << " items" << std::endl;

  iHead = dlist.begin();

  for(; iHead != dlist.end(); iHead++) 
  {
    std::cout << "items: " << *iHead << std::endl; 
  }
}

$ ./a.out 
type in an integer n(loop count) followed by n decimal numbers.
5
10
20
30
40
50
input is done and you have entered 5 items
items: 10
items: 20
items: 30
items: 40
items: 50
items: 30
input is done and you have entered 3 items
items: 30
items: 40
items: 50


{member-function}

c.clear() 
Removes all elements (empties the container)


C++ SLR 8.8 Special Member Functions for Lists and Forward Lists

void list::splice (const_iterator pos, list& source);
void list::splice (const_iterator pos, list&& source);

* Move all elements of the list source into *this and insert them at the
position of iterator pos.

* After the call, source is empty.

* If source and *this are identical, the behavior is undefined. Thus, the
caller must ensure that source is a different list. To move elements inside
the same list, you must use the following forms of splice().

* The caller must ensure that pos is a valid position of *this; otherwise, the
behavior is undefined.

* Pointers, iterators, and references to members of source remain valid. Thus,
they belong to this afterward.

* This function does not throw.

* The second form is available since C++11. Before C++11, type iterator was
used instead of const_iterator.

* Provided by list.


void list::splice (const_iterator pos, list& source, const_iterator sourcePos)
void list::splice (const_iterator pos, list&& source, const_iterator sourcePos)

* Move the element at the position sourcePos of the list source into *this and
insert it at the position of iterator pos.


={============================================================================
*kt_dev_cpp_0000* cpp-container-cpp-forward-list

A forward_list<> is implemented as a 'singly' linked list of elements. As a
consequence, where all operations that move backward or would cause a
performance penalty are not supported. 

note: For this reason, member functions such as push_back() and even size()
are not provided.

<example>
#include <iostream>
#include <forward_list>

using namespace std;

int main()
{
  forward_list<long> coll{2,3,5,7,11,13,17};

  // poor performance
  coll.resize(9);
  coll.resize(10,99);

  for( auto &elem : coll )
    cout << elem << ' ';
  
  cout << endl;
}

2 3 5 7 11 13 17 0 0 99

<ex> 
// This is *cpp-is-implemented-in-terms-of* to have size() which is not
// supported.

#include <iostream>
#include <forward_list>

template<typename T>
class Forward_list {
  private:
    size_t count;
    std::forward_list<T> list;

  public:
    typedef typename std::forward_list<T>::iterator iterator;

    Forward_list() : count(0) {}

    void push_front(const T& elem) {
      count++;
      list.push_front(elem);
    }

    size_t size() const {
      return count;
    }

    // note: "iterator begin() const" causes compile error
    iterator begin() {
      return list.begin();
    }

    iterator end() {
      return list.end();
    }
};

int main()
{
  int n, item;
  Forward_list<int> ilist;
  Forward_list<int>::iterator ihead;

  std::cout << 
    "type in an integer n(loop count) followed by n decimal numbers." << std::endl;

  std::cin >> n;

  for(int i=0; i<n; i++)
  {
    std::cin >> item;
    ilist.push_front(item);
  }

  std::cout << 
    "input is done and you have entered " << ilist.size() << " items" << std::endl;

  ihead = ilist.begin();

  for(; ihead != ilist.end(); ihead++) 
  {
    std::cout << "items: " << *ihead << std::endl; 
  }
}

type in an integer n(loop count) followed by n decimal numbers.
5
10
20
30
40
50
input is done and you have entered 5 items
items: 50
items: 40
items: 30
items: 20
items: 10


={============================================================================
*kt_dev_cpp_0000* cpp-container-associative

Associative containers sort their elements automatically according to a
certain ordering criterion. By default, the containers compare the elements or
the keys with `operator<`. However, you can supply your own comparison
function to define another `sort-criterion`.


<what-container-consideration>

Pros:
Typically implemented as binary trees. The associative containers differ in
the kinds of elements they support and how they handle duplicates. GCC uses
`red black tree` which is balanced binary tree and search functions have
`log(n)` 'logarithmic' complexity.

Since uses the same rb tree, can consider a cpp-set as a special kind of
cpp-map, in which the value is 'identical' to the key.


Cons:
However, automatic sorting also imposes an important constraint on sets and
multisets: You may not change the value of an element directly, because doing
so might compromise the correct order.

Therefore, to modify the value of an element, you must remove the element
having the old value and insert a new element that has the new value. 

The interface reflects this behavior: 

* `set` and `multiset` don't provide operations for direct element access.
  note: However, maps has.

* Indirect access via iterators has the constraint that, from the iterator's
  point of view, the element value is 'constant'.
  note: means that  cannot use modifying algorithm like algo-remove


{element-access}
sets and multisets do not provide direct element access, so you have to use
range-based for loops or iterators. Sets and multisets provide the usual
member functions for iterators (Table 7.38).

c.begin()   Returns a bidirectional iterator for the first element
c.end()     Returns a bidirectional iterator for the position after the last
            element
c.cbegin()  Returns a constant bidirectional iterator for the first element
            (since C++11)
c.cend()    Returns a constant bidirectional iterator for the position after
            the last element (since C++11)
c.rbegin()  Returns a reverse iterator for the first element of a reverse
            iteration
c.rend()    Returns a reverse iterator for the position after the last element
            of a reverse iteration
c.crbegin() Returns a constant reverse iterator for the first element of a
            reverse iteration (since C++11)
c.crend()   Returns a constant reverse iterator for the position after the
            last element of a reverse iteration (since C++11)


{iterator-category}
As with all associative container, the iterators are `bidirectional iterators`
Thus, you can't use them in algorithms that are provided 'only' for
random-access iterators, such as algorithms for sorting or random shuffling.


{same-type}
Comparisons are provided only for containers of the same type which includes
sorting criterion. Thus, the elements and the sorting criterion must have the
same types; otherwise, a type error occurs at compile time. For example:

std::set<float> c1;                       // sorting criterion: std::less<>
std::set<float,std::greater<float> > c2;  // std::greater<>
...
if (c1 == c2) { // ERROR: different types
...
}


{change-sorting-criterion} stl-set stl-multiset

set c(op)         Creates an empty set/multiset that uses op as the sorting 
                  criterion

set<Elem>         A set that by default sorts with less<> (operator <)
set<Elem,Op>      A set that by default sorts with Op
multiset<Elem>    A multiset that by default sorts with less<> (operator <)
multiset<Elem,Op> A multiset that by default sorts with Op


<cpp-map-element-type>
if two 'containers' are 'compared' by operator ==, the elements in both
containers are compared using their operator ==, which means that operator ==
has to be provided for the 'element' type.

map c(op)            Creates an empty map/multimap that uses op as the sorting
                     criterion

map<Key,Val>         A map that by default sorts keys with less<> (operator <)
map<Key,Val,Op>      A map that by default sorts keys with Op
multimap<Key,Val>    A multimap that by default sorts keys with less<> (operator <)
multimap<Key,Val,Op> A multimap that by default sorts keys with Op

There are two ways to set sorting criterion.


<as-a-template-parameter>
In this case, the sorting criterion is 'part' of the type. This is the usual
way to specify the sorting criterion. To be more precise, the second parameter
is the 'type' of the sorting criterion. The concrete sorting criterion is the
function 'object' that gets created with the container. To do this, the
constructor of the container calls the default constructor of the type of the
sorting criterion.

typedef std::set<int, std::greater<int>> IntSet; 
typedef std::map<float, std::string, std::greater<float>> coll; 


<as-a-constructor-parameter> 
You might have a type for several sorting criteria that allows having
different initial values or states. This is useful when processing the sorting
criterion at 'runtime' and when sorting criteria are needed that are different
(criterion) but of the same data type.

<ex>
multiset< std::shared_ptr<Quote>, decltype(compare)*> items{ compare };

<ex>
You need a special type for the sorting criterion: one that lets you pass your
sorting details at runtime.

#include <iostream>
#include <set>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

class RuntimeCmp
{
  public:
    enum cmp_mode {normal, reverse};

  private:
    cmp_mode mode;

  public:
    RuntimeCmp( cmp_mode m = normal ) : mode(m) { }

    // call operator. comparison of 'elements': member function for any element type
    template<typename T>
      bool operator() ( const T& t1, const T& t2 ) const
      { return mode == normal ? t1 < t2 : t2 < t1; }

    // comparison of sorting criteria
    bool operator==( const RuntimeCmp& rc ) const 
    { return mode == rc.mode; }
};

typedef set<int, RuntimeCmp> IntSet;

int main()
{
  // use default sorting criterion
  IntSet coll1{ 4, 7, 5, 1, 6, 2, 5 }; 
  PRINT_ELEMENTS(coll1, "coll1 : ");

  // create sorting criterion with reverse order
  RuntimeCmp reverse_order(RuntimeCmp::reverse);

  IntSet coll2(reverse_order);            // <key> set c(op)
  coll2 = { 4, 7, 5, 1, 6, 2, 5 };
  PRINT_ELEMENTS(coll2, "coll2 : ");

  coll1 = coll2;                          // <key> instant change of criterion
  coll1.insert(3);
  PRINT_ELEMENTS(coll1, "coll1 : ");

  // One of Nonmodifying operations for set family
  //
  // c.key_comp() Returns the comparison criterion
  //
  // c.value_comp() Returns the comparison criterion for values as a whole
  // (same as key_comp())

  if( coll1.value_comp() == coll2.value_comp() )
    cout << "coll1 and coll2 have the same sorting criterion" << endl;
  else
    cout << "coll1 and coll2 have the different sorting criterion" << endl;
}

coll1 : 1 2 4 5 6 7 
coll2 : 7 6 5 4 2 1 
coll1 : 7 6 5 4 3 2 1 
coll1 and coll2 have the same sorting criterion

note: the class RuntimeCmp provides the general ability to specify, at
runtime, the sorting criterion for any type.

note: that coll1 and coll2 have the same type, which is 'not' the case when
passing less<> and greater<> as sorting criteria. 

If try to use set c<elem, op> then not compile since they are different type.

typedef set<int> LessSet;
typedef set<int, greater<int>> GreaterSet;

int main()
{
  // use default sorting criterion
  LessSet coll1{ 4, 7, 5, 1, 6, 2, 5 }; 
  PRINT_ELEMENTS(coll1, "coll1 : ");

  GreaterSet coll2{ 4, 7, 5, 1, 6, 2, 5 };
  PRINT_ELEMENTS(coll2, "coll2 : ");

  // coll1 = coll2;                       // ERROR
  // coll1.insert(3);
  // PRINT_ELEMENTS(coll2, "coll1 : ");

  //if( coll1.value_comp() == coll2.value_comp() )    // ERROR
  //  cout << "coll1 and coll2 have the same sorting criterion" << endl;
  //else
  //  cout << "coll1 and coll2 have the different sorting criterion" << endl;
}

note: also that the assignment operator assigns the elements and the sorting
criterion; If change coll1 as below and run the program:

  IntSet coll1{ 4, 7 }; 

Then the result:

coll1 : 4 7 
coll2 : 7 6 5 4 2 1 
coll1 : 7 6 5 4 3 2 1 
coll1 and coll2 have the same sorting criterion

That seems useful since if use c<elem, op> approach, copy each item into the
other set which has different sorting criterion.

<example>
1. How to define a sorting criterion at runtime
2. How to compare strings in a case-insensitive way

#include <iostream>
#include <map>
#include <algorithm>
#include <iomanip>      // for setw()

using namespace std;

class RuntimeStringCmp
{
  public:
    enum cmp_mode {normal, nocase};

  private:
    const cmp_mode mode;

    // aux to compare case insensitive
    static bool nocase_compare( char c1, char c2 )
    { return toupper(c1) < toupper(c2); }

  public:
    RuntimeStringCmp( cmp_mode m = normal ) : mode(m) { }
    
    // the comparison. must be const on all args; otherwise type mismatch compile error
    // 
    // The reference p548. 
    // Lexicographical comparison means that sequences are compared element-by-element. For string
    // element is char
    //
    // bool
    // lexicographical_compare (InputIterator1 beg1, InputIterator1 end1, 
    //                          InputIterator2 beg2, InputIterator2 end2, 
    //                          CompFunc op)
    //
    bool operator() ( const string &s1, const string &s2 ) const 
    {
      if( mode == normal )
        return s1 < s2;
      else
        return lexicographical_compare( s1.begin(), s1.end(),
            s2.begin(), s2.end(), nocase_compare );
    }
};

// container type
typedef map<string, string, RuntimeStringCmp> ssmap;

// fill and print container
void fillAndPrint( ssmap &coll );

int main()
{
  ssmap coll1;
  fillAndPrint(coll1);

  RuntimeStringCmp ignorecase(RuntimeStringCmp::nocase);

  ssmap coll2(ignorecase);
  fillAndPrint(coll2);
}

void fillAndPrint( ssmap &coll )
{
  // insert elements in random order
  coll["Deutschland"] = "Germany";
  coll["deutsch"] = "German";
  coll["Haken"] = "snag";
  coll["arbeiten"] = "work";
  coll["Hund"] = "dog";
  coll["gehen"] = "go";
  coll["Unternehmen"] = "enterprise";     // duplicate
  coll["unternehmen"] = "undertake";
  coll["gehen"] = "walk";
  coll["Bestatter"] = "undertaker";

  // prints
  cout.setf( ios::left, ios::adjustfield );

  for( const auto &elem : coll )
    cout << setw(15) << elem.first << " " << elem.second << endl;

  cout << endl;
}

Bestatter       undertaker
Deutschland     Germany
Haken           snag
Hund            dog
Unternehmen     enterprise
arbeiten        work
deutsch         German
gehen           walk
unternehmen     undertake

arbeiten        work
Bestatter       undertaker
deutsch         German
Deutschland     Germany
gehen           walk
Haken           snag
Hund            dog
Unternehmen     undertake

note: The second block changed the order due to 'nocase' criterion.  
note:
that the second block has one item 'less' because the uppercase word
"Unternehmen" is, from a case-insensitive point of view, equal to the
lowercase word "unternehmen" note: The signature of operator() must be const.


={============================================================================
*kt_dev_cxx_0000* cxx-container-cxx-set cpp-multiset

// bits/stl_set.h

#include <set>

namespace std {

  template<typename _Key, 
    typename _Compare = `std::less<_Key>`,
	 typename _Alloc = std::allocator<_Key> >
    class set
    {
    };

  template <typename T,
  typename Compare = less<T>,
  typename Allocator = allocator<T> >
    class multiset;
}


{cxx-set-type-requirement}
The elements of a set or a multiset may have any type T that is 'comparable'
according to the sorting criterion. The optional second template argument
defines the sorting criterion and if not passed, the default criterion `less`
is used.


{cxx-set-search-operations} cpp-container-search
Because they are optimized for fast searching of elements, sets and multisets
provide `special search functions` (Table 7.36). These functions are special
versions of general algorithms that have the same name. 

You should always 'prefer' the optimized versions for sets and multisets to
achieve logarithmic complexity instead of the linear complexity of the
`general algorithms.`

      /**
       *  @brief  Finds the number of elements.
       *  @param  __x  Element to located.
       *  @return  Number of elements with specified key.
       *
       *  This function only makes sense for multisets; for set the result will
       *  either be 0 (not present) or 1 (present).
       */
      size_type
      count(const key_type& __x) const;

c.count(val)      
Returns the number of elements with value val

      /**
       *  @brief Tries to locate an element in a %set.
       *  @param  __x  Element to be located.
       *  @return  Iterator pointing to sought-after element, or end() if not
       *           found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns an iterator
       *  pointing to the sought after element.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */
      iterator
      find(const key_type& __x);

c.find(val)       
Returns the position of the `first element` with value val (or end() if none
    found)

  *cxx-set-find-vs-count*
  For containers with single key, find and count do the same (but the return
      is different) but for containers with multiple key, count has to do more
  work since still has to count how many elements have the same key. So if
  don't need the count, it's best to use find.


<cxx-multset-order-of-duplicates>
For multisets, since C++11 it is guaranteed that insert(), emplace(), and
erase() preserve the relative ordering of equivalent elements, and that
inserted elements are placed `at-the-end` of existing equivalent values.

For multisets, since C++11 it is guaranteed that insert(), emplace(), and
erase() preserve the relative ordering of equivalent elements, and that
inserted elements are placed at the end of existing equivalent values.

  x   x   x   x   x   x   x
      [  equal    ) 
      lower       upper
      
c.lower_bound(val) 
Returns an iterator to the first element with key not less than val.

c.upper_bound(val) 
Returns an iterator to the first element with key greater than val.

c.equal_range(val) 
Returns a range, pair of iterators, denoting the elements with val

lower_bound() returns the position of the first element that has the same or a
greater value than the argument, whereas upper_bound() returns the position of
the first element with a greater value. Thus, equal_range() returns the range
of elements that have the same value as the argument.

If lower_bound() or the first value of equal_range() is equal to upper_bound()
or the second value of equal_range()

Not only to find. Can be used to get a position to be inserted in sorted
order.


<ex>
When there are multiple elements of the same key, those will be `adjacent`
within the container.

// this is for multimap
string search_item("Alain de Botton");

auto entries = aurthors.count(search_item);
auto iter = aurthors.find(search_item);

// this relys on the fact that multiple elements are adjacent.
while (entries) {
  cout << iter->second << endl;
  ++iter;
  --entries;
}

// 
for (auto beg = authors.lower_bound(search_item),
    end = authors.upper_bound(search_item);
    beg != end;
    ++beg)
  cout << beg->second << endl;

// return a pair of iterators
for (auto pos = authors.equal_range(search_item);
    pos.first != pos.second;
    ++pos.first)
  cout << pos.first->second << endl;


<ex>
#include <iostream>
#include <set>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  set<int> coll;

  coll.insert(1);
  coll.insert(2);
  // coll.insert(3);
  coll.insert(4);
  coll.insert(5);
  coll.insert(6);

  PRINT_ELEMENTS( coll, "coll: ");

  cout << "lower_bound(3): " << *coll.lower_bound(3) << endl;
  cout << "upper_bound(3): " << *coll.upper_bound(3) << endl;
  cout << "equal_range(3): " << *coll.equal_range(3).first << " "
                             << *coll.equal_range(3).second << endl;

  cout << "lower_bound(5): " << *coll.lower_bound(5) << endl;
  cout << "upper_bound(5): " << *coll.upper_bound(5) << endl;
  cout << "equal_range(5): " << *coll.equal_range(5).first << " "
                             << *coll.equal_range(5).second << endl;
}

coll: 1 2 4 5 6
lower_bound(3): 4
upper_bound(3): 4          // see it is > 3
equal_range(3): 4 4
lower_bound(5): 5
upper_bound(5): 6          // see it is > 5
equal_range(5): 5 6

note: 
these _bound members usually used for multiset, can be used with set.


={============================================================================
*kt_dev_cpp_0000* cpp-container-cpp-map cpp-multimap cpp-size-t

<cpp-size-t>
type `size_t` is a machine-specific `unsigned type` that is guaranteed to be
large enough to hold the size of `any` object in memory.

// /usr/include/c++/4.9/cstddef

#ifndef _GLIBCXX_CSTDDEF
#define _GLIBCXX_CSTDDEF 1

#pragma GCC system_header

#include <bits/c++config.h>
#include <stddef.h>

#if __cplusplus >= 201103L
namespace std
{
  // We handle size_t, ptrdiff_t, and nullptr_t in c++config.h.
  using ::max_align_t;
}
#endif

#endif // _GLIBCXX_CSTDDEF


// c++config.h
namespace std
{
  typedef __SIZE_TYPE__ 	size_t;
  typedef __PTRDIFF_TYPE__	ptrdiff_t;

#if __cplusplus >= 201103L
  typedef decltype(nullptr)	nullptr_t;
#endif
}

// <cpp-red-black-tree>
// /usr/include/c++/4.9/bits/stl_tree.h

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef size_t 				size_type;
    };


// /usr/include/c++/4.9/bits/stl_map.h

namespace std {

  template <typename _Key, typename _Tp, typename _Compare = `std::less<_Key>`,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key                                          key_type;
      typedef _Tp                                           mapped_type;

      typedef std::pair<const _Key, _Tp>                    value_type;

      typedef typename _Rep_type::size_type              size_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
		       key_compare, _Pair_alloc_type> _Rep_type;

      typedef _Compare                                      key_compare;
      typedef _Alloc                                        allocator_type;
      ...
    };
}


{cpp-map-type-requirement}
The elements of a map or a multimap may have any types Key and Tp that meet
the following two requirements:

* Both key and value must be copyable or movable.
* The key must be comparable with the sorting criterion. the default is `less`

As with set, key is 'constant'. However, a direct modification of the value of
the element is still possible, provided that the type of the value is not
constant.


{cpp-map-value-type}
*cpp-remember*
When we dereference an iterator, get a reference to the container's `value type`

The value_type is `pair<'const' key_type, mapped_type>` so implies key cannot
be changed: 

      typedef std::pair<const _Key, _Tp>                    value_type;

This affects the use with algorithms because key is const, only be used with
algorithm that is read-only and the use is limited to search 

but associative is better in searching so 'little' use of map with algorithm.
In practice, associative can be used as a source or dest in algorithm.

map<string, int>::value_type v3;    // pair< const string, int > 
map<string, int>::key_type v4;      // string
map<string, int>::mapped_type v5;   // int


{element-access}
The usual way to access elements in associative container is via `range-for`
loops or iterators. An exception to that rule is that maps provide at() and
the subscript operator[] to access elements directly

reference container::operator[] (size_type idx)
const_reference container::operator[ ] (size_type idx) const

T& map::operator [] (const key_type& key)
T& map::operator [] (key_type&& key)

reference container::at (size_type idx)
const_reference container::at (size_type idx) const

T& map::operator at (const key_type& key)
const T& map::operator at (const key_type& key) const


<cpp-map-fetch> <associative-array> <cpp-map-default-value>
The 'both' maps and unordered maps can also be thought of as an
`associative-array`, an array whose index is not an integer value. As a
consequence, both containers provide the subscript operator [ ].

However, that the subscript operator does not behave like the usual subscript
operator for arrays: Not having an element for an index is 'not' an error. A
new index (or key) is taken as a reason to create and 'insert' a new element
that has the index as the key. `Thus, you can't have an invalid index.`

c[key] 
Inserts an element with key, if it does not yet exist, and returns a reference
to the value of the element with key (only for nonconstant maps)

c.at(key) 
Returns a reference to the value of the element with key (since C++11)

coll.at("vat1") = 0.16;

Passing an invalid index (less than 0 or equal to size() or greater than
size()) throws an out_of_range exception.


The fecth 'only' works for map but not multimaps since there are multiple
matches. Why not set? Since set has only key. Unlike other containers, [] op
on map returns `mapped_type` but dereferencing of iterator returns
`value_type`. 

  "Thus, to use this feature, you can't use a value type that has no default
  constructor." 

// bits/stl_map.h

      // [23.3.1.2] element access
      /**
       *  @brief  Subscript ( @c [] ) access to %map data.
       *  @param  __k  The key for which data should be retrieved.
       *  @return  A reference to the data of the (key,data) %pair.
       *
       *  Allows for easy lookup with the subscript ( @c [] )
       *  operator.  Returns data associated with the key specified in
       *  subscript.  If the key does not exist, a pair with that key
       *  is created using default values, which is then returned.
       *
       *  Lookup requires logarithmic time.
       */
      mapped_type&
      operator[](const key_type& __k)
      {
        __i = insert(__i, value_type(__k, mapped_type()));
      }


<ex> *ex-count-words* *ex-count-keyword*

string word;
map<string, size_t> word_count;

while( cin >> word )
   ++word_count[word];

// *C++11* *cpp-pair*
for( const auto &w : word_count )
   cout << w.first << " occurs" << 
          w.second << ((w.second>1) ? "times" : " time") << endl;

// before C++11 since no range-for
std::map<std::string,float> coll;
std::map<std::string,float>::iterator pos;

for (pos = coll.begin(); pos != coll.end(); ++pos) {
  std::cout << "key: " << pos->first << "\t" << "value: " 
    << pos->second << std::endl;
}


{cxx-map-search-operations} cxx-container-search
`As for sets and multisets,` maps and multimaps provide special search member
functions that perform better because of their internal tree structure

c.count(val) 
Returns the number of elements with 'key' val

c.find(val) 
Returns the position(iterator) of `the first element with key` or end() if
none found

<when-use-find> <insert-can-be-costly-or-mistake> <insert-when-not-exist>
word_count[word] = 1; 

Happens 3 setps but 3) could be extra

* Search key and not found
* Insert temp element pair{word, 0}. value init since default ctor is called
* Assign it with 1

When accessing map with key which is not exist, cause addition. Inserts a new
element with key "ottto" and prints its value, which is 0 by default.

std::cout << coll["ottto"];

The real bug which meant to print out debug message but creates one elements
which is not added before due to if and else logic in the code.

NICKEL_TRACE("getSourceInformation: "
        << "configuration: " << sourceInfo["CONFIGURATION"]
        << "video size   : " << sourceInfo["VIDEO_WIDTH"]);


Searching for elements that have a certain 'value' but not key promotes bad
performance.

You can't use the find() member function to search for an element that has a
certain 'value'. Instead, have to use a general algorithm, such as the
find_if() algorithm, or program an explicit loop. Here is an example of a
simple loop:

std::multimap<std::string,float> coll;

// do something with all elements having a certain value
std::multimap<std::string,float>::iterator pos;

for (pos = coll.begin(); pos != coll.end(); ++pos) {
  if (pos->second == value) {
    do_something();
  }
}

<ex> *algo-find-if*
#include <iostream>
#include <map>
#include <algorithm>

using namespace std;

int main()
{
  // both works
  map<float,float> coll = { {1,7}, {2,4}, {3,2}, {4,3}, {5,6}, {6,1}, {7,3} };
  map<float,float> coll{ {1,7}, {2,4}, {3,2}, {4,3}, {5,6}, {6,1}, {7,3} };

  auto posKey = coll.find(3.0);
  if( posKey != coll.end() )
  {
    cout << "key 3.0 found!(" << posKey->first << "," << 
      posKey->second << ")" << endl;
  }

  auto posVal = find_if( coll.cbegin(), coll.cend(),
      [] ( const pair<float,float> &elem ) {
        return elem.second == 3.0;
        } );
  if( posVal != coll.end() )
  {
    cout << "value 3.0 found!(" << posVal->first << "," << 
      posVal->second << ")" << endl;
  }
}

key 3.0 found!(3,2)
value 3.0 found!(4,3)


<ex> print duplicates in multimap
#include <iostream>
#include <string>
#include <map>

int main()
{
  std::string str = "total";

  std::multimap<std::string, std::string> authors;

  authors.insert( {"Kit, Park", "How to get through"} );
  authors.insert( {"Barth, John", "Sot-Weed Factor"} );
  authors.insert( {"Barth, John", "Lost in the Funhouse"});
  authors.insert( {"Andy, Steve", "Enterprise"});
  authors.insert( {"Barth, John", "A way to success"});

  std::string search_item("Barth, John");

  auto entries = authors.count( search_item );  // num of elements
  std::cout << "entries: " << entries << std::endl;

  auto iter = authors.find( search_item );      // first entry

  while( entries ) {
    // print each title
    std::cout << "count: " << entries << ", title: " << iter->second << std::endl;
    ++iter;
    --entries;
  }

  iter = authors.begin();
  for( iter; iter != authors.end(); ++iter )
    std::cout << "title: " << iter->second << std::endl;
}


entries: 3
count: 3, title: Sot-Weed Factor          // {
count: 2, title: Lost in the Funhouse
count: 1, title: A way to success         // }

title: Enterprise
title: Sot-Weed Factor                    // {
title: Lost in the Funhouse
title: A way to success                   // }
title: How to get through

See that the order of duplicates is maintained.

<ex> or use _bound calls
for(auto beg = authors.lower_bound( search_item ), 
    end = authors.upper_bound( search_item );
   beg != end;
   ++beg )
   cout << beg->second << endl;


<ex> or use equal_range()
// most direct way and return pair of iter in range [first, off-the-end). Like
// above, if not found return the same.

for( auto pos = authors.equal_range( search_item ); 
    pos.first != pos.second; ++pos.first)
   cout << pos.first->second << endl;


`As for set,` different iterator return for map and multimap. As for multiset,
you can't use erase() to remove only the first element of these duplicates
because erase() removes all.

std::multimap<std::string,float> coll;

auto pos = coll.find(key);
if (pos != coll.end()) {
  coll.erase(pos);
}


<ex> *ex-algo-max-element* 
#include <iostream>
#include <map>
#include <algorithm>

using namespace std;

int main()
{
  multimap<int,string> coll = { {1, "one"}, {2, "two"}, {7, "seven"}, {3, "three"}, 
    {4, "four"}, {5, "five"}, {6, "six"}, {7, "seventh"}, {7, "7th"} };

  auto posKey = coll.find(3);
  if( posKey != coll.end() )
  {
    cout << "key 3 found (" << posKey->first << ", " << posKey->second << ")" << endl;
  }

  auto maxpos = max_element( coll.cbegin(), coll.cend() );
  if( maxpos != coll.end() )
  {
    cout << "max found (" << maxpos->first << ", " << maxpos->second << ")" << endl;
  }

  cout << "{";

  for( auto pos = coll.equal_range(maxpos->first); pos.first != pos.second; ++pos.first )
    cout << pos.first->second << ", ";
  
  cout << "}" << endl;
}

key 3 found (3, three)
max found (7, seventh)
{seven, seventh, 7th, }


{cpp-map-assign}

#include<iostream>
#include<iomanip>
#include<string>
#include<map>

using namespace std;

int main()
{
  // dict1
  map<string, string> dict1;

  dict1.insert(
      {
        { "day", "Tag" }, { "strange", "fremd" },
        { "car", "Auto" }, { "smart", "elegant" }
      }
      );

  // prints all elements
  cout.setf (ios::left, ios::adjustfield);
  cout << ' ' << setw(10) << "engligh " << "german " << endl;

  cout << setfill('-') << setw(20) << "" << setfill(' ') << endl;
  for( const auto& elem : dict1 ) {
    cout << ' ' << setw(10) << elem.first << elem.second << endl;
  }
  cout << endl;

  // dict2
  map<string, string> dict2;

  dict2.insert(
      {
        { "width", "1024" }, { "height", "768" },
        { "cofig", "ABR" }, { "video", "MP4" },
        { "audio", "stereo" }, { "codec", "dash" },
        { "media", "ts" }, { "app", "ms-x" }
      }
      );

  // prints all elements
  cout.setf (ios::left, ios::adjustfield);
  cout << ' ' << setw(10) << "property " << "value " << endl;

  cout << setfill('-') << setw(20) << "" << setfill(' ') << endl;
  for( const auto& elem : dict2 ) {
    cout << ' ' << setw(10) << elem.first << elem.second << endl;
  }
  cout << endl;

  // copy map
  dict1 = dict2;

  // prints all elements
  cout.setf (ios::left, ios::adjustfield);
  cout << ' ' << setw(10) << "engligh " << "german " << endl;

  cout << setfill('-') << setw(20) << "" << setfill(' ') << endl;
  for( const auto& elem : dict1 ) {
    cout << ' ' << setw(10) << elem.first << elem.second << endl;
  }
  cout << endl;

  cout << "size of dict1: " << dict1.size() 
    << ", size of dict2: " << dict2.size() << endl;
}


$ ./a.out 
 engligh   german 
--------------------
 car       Auto
 day       Tag
 smart     elegant
 strange   fremd

 property  value 
--------------------
 app       ms-x
 audio     stereo
 codec     dash
 cofig     ABR
 height    768
 media     ts
 video     MP4
 width     1024

 engligh   german 
--------------------
 app       ms-x
 audio     stereo
 codec     dash
 cofig     ABR
 height    768
 media     ts
 video     MP4
 width     1024

size of dict1: 8, size of dict2: 8


={============================================================================
*kt_dev_cpp_0000* cpp-container-cpp-unordered

The cost of a map lookup is O(log(n)) where n is the number of elements in the
map. That’s pretty good. For example, for a map with 1,000,000 elements, we
perform only about 20 comparisons and indirections to find an element.
However, in many cases, we can do better by using a hashed lookup rather than
comparison using an ordering function, such as <. The standard-library hashed
containers are referred to as “unordered” because they don’t require an
ordering function:

In unordered containers, elements have no defined order. Thus, if you insert
three elements, they might have any order when you 'iterate' over all the
elements in the container. If you insert a fourth element, the order of the
elements previously inserted might change due to 'rehasing'. The only
important fact is that a specific element is somewhere in the container. Even
when you have two containers with equal elements inside, the order might be
different. Think of it as like a 'bag'.

Unordered containers are typically implemented as a 'hash' table. Thus,
internally, the container is an array of linked lists. But because such a fast
  perfect hash function is not always possible or might require that the array
  consumes a huge amount of memory, the elements in the array are linked lists
  so that you can store more than one element at each array position.


<default-hash>
A default hash function is provided for fundamental types and strings, but we
would have to declare our own hash function for other types.

All these unordered container classes have optional template arguments to
specify a hash function and an 'equivalence' criterion. note: why equal? since
no order.


{type-requirement}
Use '==' op and hash func.


{performance} amortized complexity
Because the complexity for element access is amortized constant for unordered
maps rather than logarithmic for maps, you should usually prefer unordered
maps over maps unless you need the sorting.

{duplicate-order}
The only guarantee is that duplicates, which are possible because a multiset
is used, are grouped together in the order of their insertion.

<ex>
#include <iostream>
#include <string>
#include <unordered_set>

using namespace std;

int main()
{
  unordered_multiset<string> cities{"Braunschweig", "Hanover", "Frankfurt", "New York",
    "Chicago", "Toronto", "Paris", "Frankfurt"};

  for( const auto &elem : cities )
    cout << elem << ' ';
  
  cout << endl;

  // insert additional elements
  cities.insert({"London", "Munich", "Hanover", "Braunschweig"});

  for( const auto &elem : cities )
    cout << elem << ' ';
  
  cout << endl;
}

Hanover Paris Frankfurt Frankfurt Chicago New York Braunschweig Toronto 
Munich Chicago New York Toronto London Frankfurt Frankfurt Paris Hanover Hanover Braunschweig
Braunschweig 


={============================================================================
*kt_dev_cpp_0000* cpp-container-adaptor

stack, queue, priority_queue

{stack-stl}
The {ref-001} says that STL stack uses deque by default and can change by giving it second
paramenter.

template <class T, class Container = deque<T> > class stack;

std::stack<int,std::vector<int>> st;

<container>
The deque was chosen because, unlike vectors, deques free their memory when elements are removed and
don't have to copy all elements on reallocation (see Section 7.12, page 392, for a discussion of
when to use which container).

<interface>
This interface is somewhat inconvenient, but it performs better if you want only to remove the next
element without processing it. Note that the behavior of top() and pop() is 'undefined' if the stack
contains no elements. The member functions size() and empty() are provided to check whether the
stack contains elements.

<example>
#include <iostream>
#include <stack>

int main()
{
  int n;
  double item;
  std::stack<double> numbers;

  std::cout << "type in an integer n followed by n decimal numbers." << std::endl;

  std::cin >> n;

  for(int i=0; i<n; i++)
  {
    std::cin >> item;
    numbers.push(item);
  }

  std::cout << "input is done and you have entered." << std::endl;

  numbers.top() = 99;         // modify top element

  while( !numbers.empty() )
  {
    // access next element. top() returns a reference to the top element in a stack. 
    std::cout << numbers.top() << " : ";
    numbers.pop();            // void pop()
  }

  std::cout << std::endl;
}

$ ./usestack
type in an integer n followed by n decimal numbers.
10
1 2 3 4 5 6 7 8 9 10 11 12
input is done and you have entered.
99 : 9 : 8 : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 

<example> from the reference 12.1.3 <is-implemented-in-terms-of-example>
The standard class stack<> prefers speed over convenience and safety. This is own stack class, which
has the following two advantages:

1. pop() returns the next element.
2. pop() and top() throw exceptions when the stack is empty. Unlike the standard stack class, this
one throws an exception rather than resulting in undefined behavior.

In addition, have skipped the members that are not necessary for the ordinary stack user, such as
the comparison operations.

#include <deque>
#include <exception>

template<typename T>
class Stack {
  private:
    std::deque<T> coll;

  public:
    // exception class for pop and top with empty stack
    class ReadEmptyStack : public std::exception {
      public:
        virtual const char* what() const noexcept {
          return "read empty stack";
        }
    };

    typename std::deque<T>::size_type size() const {
      return coll.size();
    }

    bool empty() const {
      return coll.empty();
    }

    void push(const T& elem) {
      coll.push_back(elem);
    }

    T pop() {
      if( coll.empty() )
        throw ReadEmptyStack();

      T elem( coll.back() );
      coll.pop_back();
      return elem;
    }

    T& top() {
      if( coll.empty() )
        throw ReadEmptyStack();

      return coll.back();
    }
};

#include <iostream>

using namespace std;

int main()
{
  cout << "main: { " << endl;

  try {
    Stack<int> st;

    st.push(1); st.push(2); st.push(3);

    cout << st.pop() << ' ' << st.pop() << ' ';

    st.top() = 77;

    st.push(4); st.push(5);

    st.pop();

    // at this point, there are two elements in the stack and expect a exception.
    cout << st.pop() << ' ';
    cout << st.pop() << endl;
    cout << st.pop() << endl;
  }
  catch( const exception& e ) {
    cerr << "execption: " << e.what() << endl;
  }

  cout << "main: } " << endl;
}

main: { 
2 3 4 77
execption: read empty stack
main: } 


{queue-stl}
Like stack, STL queue uses deque by default and can change by giving it second paramenter. Also see
that it has similar interface as stack:

template <class T, class Container = deque< T> > class queue;

#include <iostream>
#include <queue>

int main()
{
  int n;
  double item;
  std::queue<double> numbers;

  // n to specify the number of items and type iterms after
  std::cout << "type in an integer n followed by n decimal numbers." << std::endl;

  std::cin >> n;

  for(int i=0; i<n; i++)
  {
    std::cin >> item;
    numbers.push(item);
  }

  std::cout << "input is done and you have entered." << std::endl;

  while( !numbers.empty() )
  {
    // access next element. front() returns a reference to the first element in a queue. 
    std::cout << numbers.front() << " : ";
    numbers.pop();
  }

  std::cout << std::endl;
}

kit@kit-vb:~/work$ ./usequeue
type in an integer n(loop count) followed by n decimal numbers.
10
1 2 3 4 5 6 7 8 9 10 11 12
input is done and you have entered.
1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10 : 


={============================================================================
*kt_dev_cpp_0000* cpp-container-print-elements

#include <iostream>
#include <string>
#include <vector>

template<typename T>
void PRINT_ELEMENTS( const T &con, const std::string &delm = " " )
{
  for( const auto &elem : con )
    std::cout << elem << delm;

  std::cout << std::endl;
}

int main()
{
  std::vector<int> vcon{1, 2, 3, 4, 5};

  std::cout << "-----------" << std::endl;
  PRINT_ELEMENTS(vcon);
  PRINT_ELEMENTS(vcon, ",");
  std::cout << "-----------" << std::endl;
}

However, need a change for map:

template<typename T>
inline void PRINT_ELEMENTS_MAP( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << "{" << elem.first << ", " << elem.second << "}" << endl;

  std::cout << std::endl;
}

Q: range-for only works for sequential containers? No

PRINT_ELEMENTS or _MAPS for:
  set, list, map      // works
  unordered_map       // works but not ordered


={============================================================================
*kt_dev_cpp_0000* cpp-iter

{generalization-of-pointer}
A concept of an object that represents positions of elements in a container.
Objects that fulfill this concept are called iterators.

The following fundamental operations define the behavior of an iterator:

* operator*() returns the element of the `current position.` If the elements
  have members, you can use operator->() to access those members directly from
  the iterator.

* Operator ++ lets the iterator step forward to the next element. 'most'
  iterators also allow stepping backward by using operator --.

* Operators == and != return whether two iterators represent the same position.

* Operator = assigns an iterator (the position of the element to which it
  * refers).

These operations provide exactly the interface of ordinary pointers in C and
C++ when these pointers are used to iterate over the elements of an ordinary
array.

The difference is that iterators may be 'smart' pointers. Or iterators are an
abstraction to represent a 'position' in a container.


{iterator-categories}
An iterator of a higher category provides all the operations of lower ones.

* input iterator 
  'read' but not write, single-pass, increment only. Must supports ==, !=, ++,
  *, -> and cannot save the state of an input iterator such as stream. Hence
  single pass.

* output iterator
  'write' but not read, single-pass, increment only. Must supports ++, * and as
  with input, single pass.

* forward iterator
  read and write, multi-pass, increment only. Can read and write a sequence
  forward only; ++ operator. unordered_set, unordered_multiset, unordered_map,
  and unordered_multimap are "at least" forward iterators

* bidirectional iterator
  read and write, multi-pass, increment and decrement. Can read and write a
  sequence forward or backword; ++ and -- operator. list, set, multiset, map,
  and multimap.

* `random-access` iterator
  read and write, multi-pass, full `iterator-arithmetic`, `constant-time-access`
  to any position in the sequence. Supports all the functionality of
  bidirectional iterators. In addition, supports:

// note: TODO more detail?
// 
// 'relational' operators, addition and subtraction operators on an iterator and an
// integral value, subtraction operator when applied to two iterators, and
// subscript operator.
// 
// vector, deque, array, and strings


{cpp-iter-code}

// bits/stl_iterator_base_types.h

  /**
   *  @brief  Common %iterator class.
   *
   *  This class does nothing but define nested typedefs.  %Iterator classes
   *  can inherit from this class to save some work.  The typedefs are then
   *  used in specializations and overloading.
   *
   *  In particular, there are no default implementations of requirements
   *  such as @c operator++ and the like.  (How could there be?)
  */
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {
      /// One of the @link iterator_tags tag types@endlink.
      typedef _Category  iterator_category;
      /// The type "pointed to" by the iterator.
      typedef _Tp        value_type;
      /// Distance between iterators is represented as this type.
      typedef _Distance  difference_type;
      /// This type represents a pointer-to-value_type.
      typedef _Pointer   pointer;
      /// This type represents a reference-to-value_type.
      typedef _Reference reference;
    };

// bits/stl_iterator.h

  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator>		__traits_type;

    public:
      typedef _Iterator					iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type  	value_type;
      typedef typename __traits_type::difference_type 	difference_type;
      typedef typename __traits_type::reference 	reference;
      typedef typename __traits_type::pointer   	pointer;
      ...
    };

// bits/stl_vector.h

  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
      // Concept requirements.
      typedef typename _Alloc::value_type                _Alloc_value_type;
      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
      
      typedef _Vector_base<_Tp, _Alloc>			 _Base;
      typedef typename _Base::_Tp_alloc_type		 _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>  _Alloc_traits;

    public:
      typedef _Tp					 value_type;
      typedef typename _Base::pointer                    pointer;
      typedef typename _Alloc_traits::const_pointer      const_pointer;
      typedef typename _Alloc_traits::reference          reference;
      typedef typename _Alloc_traits::const_reference    const_reference;

      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      ...
    };


{cpp-iter-range}
[begin, end) notation and `off-the-end` iterator which is one past the last.
This notation applies to subrange as well in use of algorithm. A half-open
range has two advantages:

* You have a simple end criterion for loops that iterate over the elements:
  They simply continue as long as end() is not reached.

* It avoids special handling for empty ranges. For empty ranges, begin() is
  equal to end().

*cpp-remember* EXC++ 01
*end() is always a programming error since end() returns invalid iterator.


<generic-programming> <cpp-loop>
C++ uses != as a matter of habit rather than < in loops. They do so for the
same reason that they use iterators rather than subscripts because it applies
to various kinds of containers provided by the library: 

  "since not all containers are sequencial."

The internal 'behavior' of iterators depends on the data structure over which
they iterate. For example iterator of `associative-containers` would do
`inorder-traversal` internally. 

Hence, each container type supplies `its own kind of iterator` which knows how
to iterate over. As a result, iterators share the same interface but have
different types.


while(begin != end) {
  *begin  = val;
  ++begin;
}


template< class T>
T* find( T* begin, T* end, const T& value )
{
  while( begin != end && *begin != value ) 
    ++begin;

  return begin;
}


map<string,T> mapT::iterator iter = mapT.begin();

while( iter != mapT.end() )
{
  cout << *iter << ...; // use iter
  ++iter;
}


for( iter = mapT.begin(); iter != mapT.end(); ++iter )
{
  cout << *iter << ...; // use iter
}

note:
The `for-loop` is useful for iterator since you would never need to worry about
not increasing the iterator with it.


<not-specific-to-iterator-category>
Iterator has different categories according to the abilities of iterator and
this 'affect' how to code. To write generic code that is as independent of the
container type as possible, you should 'not' use special operations that only
works for random-access iterators.

for (auto pos = coll.begin(); pos != coll.end(); ++pos) {
}

for (auto pos = coll.begin(); pos < coll.end(); ++pos) {
}

note:
The second loop does not work with lists, sets, and maps. Because operator <
is provided only for 'random' access iterators.

This shows that it is difficult to write generic code that works on all
container types.


{pre-and-post}
The prefix operator (++pos) might have 'better' performance than the postfix
operator. The latter internally involves a temporary object because it must
return the old position of the iterator.


{cbegin-cend}

for (list<char>::const_iterator pos = coll.begin(); pos != coll.end(); ++pos) 
{
  cout << *pos << ’ ’;
}

for (auto pos = coll.begin(); pos != coll.end(); ++pos) {
  cout << *pos << ’ ’;
}

for (auto pos = `coll.cbegin()`; pos != coll.cend(); ++pos) {
  cout << *pos << ’ ’;
}


={============================================================================
*kt_dev_cpp_0000* cpp-iter-array

SLR 7.10.2

You can use ordinary C-style arrays as STL containers. However, ordinary
C-style arrays are not classes, so they don't provide member functions such as
begin() and end(). Here, either the noninvasive approach or the wrapper
approach must be used.

Using the `noninvasive-approach` is simple. You need only objects that are
able to iterate over the elements of an array by using the `iterator
interface.` Such iterators already exist: ordinary pointers. 

An STL design decision was to use the `pointer-interface` for iterators so
that you could use ordinary pointers as iterators. This again shows the
'generic' concept of 'pure' abstraction: Anything that `behaves-like` an
iterator is an iterator. In fact, pointers are `random-access` iterators.

<ex> std-begin std-end
Said defined in iterator header but do not need to include to use and easy to
write C++ loop.

int* pbeg = begin(arr), *pend = end(arr);

for( pbeg; pbeg != pend && *pbeg >= 0; ++pbeg )
  ...;


<ex>
These are also 'overloaded', so you can use STL containers or all classes that
provide begin() and end() as member functions.

note: Before C++11, you had to pass the raw pointers to the algorithms because
begin() and end() were 'not' globally provided.

#include <iostream>
#include <iterator>
#include <vector>

void t_iter_03()
{
    int values[] = { 33, 67, -4, 13, 5, 2 };
    vector<int> vec(begin(values), end(values));

    copy(vec.begin(), vec.end(), ostream_iterator<int>(cout, " "));
    cout << endl;

    // on ordinary array
    copy(begin(values), end(values), ostream_iterator<int>(cout, " "));
    cout << endl;

    // on container
    copy(begin(vec), end(vec), ostream_iterator<int>(cout, " "));
    cout << endl;
}


={============================================================================
*kt_dev_cpp_0000* cpp-iter-adapters

These are several predefined special iterators, called iterator adapters:
insert, stream, reverse, and move iterators


{cpp-inserter}
`insert-iterator`, or inserters, are used to let algorithms operate in
'insert' mode rather than in overwrite mode by transforming an assignment of
an new value into an insertion. (for overwrite example, algorithms using
    multiple range) 

They fall under the category of 'output' iterators, which are able to
write/assign values only 'while' iterating forward.

The inserters calls a container operation to add and must use front_inserter
only if the container has push_front and use back_inserter only if it has
push_back. These are `back_inserter`, `front_inserter`, `inserter` which bind
iterator to container operations.

Consider *algo-copy* :

namespace std {
  template <typename InputIterator, typename OutputIterator>
    OutputIterator copy (InputIterator from_pos,  // beginning of source
        InputIterator from_end,                   // end of source
        OutputIterator to_pos)                    // beginning of dest.
    {
      while (from_pos != from_end) {
        *to_pos = *from_pos;  // copy values
        ++from_pos;           // increment iterators
        ++to_pos;
      }
      return to_pos;
    }
}

The interesting part is the assignment of the new value:

*to_pos = value

An `insert-iterator` transforms an assignment into an insertion. However, two
operations are involved: First, operator * returns the `current-element` of the
iterator; second, operator = assigns the new value. Implementations of insert
iterators usually use the following two-step trick:

* Operator * is implemented as a no-op that simply returns *this. Thus, for
  insert iterators, *pos is equivalent to pos.

  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
      /// Simply returns *this.
      insert_iterator&
      operator*()
      { return *this; }

    };

* The assignment operator is implemented so that it gets transferred into an
  insertion. In fact, the insert iterator calls the push_back(), push_front(),
  or insert() member function of the container.

Each kind of insert iterator has a convenience function for its creation and
initialization.

note:
* Need to care about underlying container.

// TBD
// <why-useful>
// * There is 'no' need to increase or decrease iter but still need to care about
//   underlying container. note: Seems less convincing.
// 
// * Less 'generic' since need to know about element type. However, it's
//   convenient. note: Can use usual interator interface in code while doing
//   insertion. How? increment operator is no-op as i the CLR 9.4.2.


{cpp-insert-member-function}
Calls `insert(pos, val)` member and insert elements directly in front of the
position that is passed as the argument of its initialization and as the start
to insert. For all containers except array and forward_list.

Passing a position(iterator) to insert doesn't sound useful? So for
associative and unordered containers, the position is taken as a 'hint' to
start the search for the correct position. However, containers are free to
ignore it.

<ex> *ex-algo-copy*
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <list>
#include <deque>

using namespace std;

template<typename T>
void PRINT_ELEMENTS( T& coll, const std::string& mesg = "" )
{
  cout << mesg << ": {";

  for( const auto &elem : coll )
    cout << elem << ",";

  cout << "}" << endl;
}

int main()
{
  list<int> coll1{ 1, 2, 3, 4, 5, 6, 7, 8, 9 };

  // copy the elements of coll1 into coll2 by appending them
  vector<int> coll2;
  copy (coll1.cbegin(), coll1.cend(),  // source
      back_inserter(coll2));           // destination

  PRINT_ELEMENTS( coll2, "vector" );

  // copy the elements of coll1 into coll3 by inserting them at the front
  // *cpp-reverse* reverses the order of the elements
  deque<int> coll3;
  copy (coll1.cbegin(), coll1.cend(),  // source
      front_inserter(coll3));          // destination

  PRINT_ELEMENTS( coll3, "deque " );

  // copy elements of coll1 into coll4
  set<int> coll4;
  copy (coll1.cbegin(), coll1.cend(), // source
      inserter(coll4,coll4.begin())); // destination

  PRINT_ELEMENTS( coll4, "set   " );

  vector<int> coll5;
  copy (coll1.cbegin(), coll1.cend(),  // source
      inserter(coll5, coll5.begin())); // destination

  PRINT_ELEMENTS( coll5, "vector" );
}

vector: {1,2,3,4,5,6,7,8,9,}
deque : {9,8,7,6,5,4,3,2,1,}
set   : {1,2,3,4,5,6,7,8,9,}
vector: {1,2,3,4,5,6,7,8,9,}

note: 
see that uses 'collection' in inserter template as a argument without type.

<why-the-order-maintained-in-inserter>
The general inserter does followings; update and increase pos.

pos = container.insert(pos,value);
++pos;

<ex>
#include <iostream>
#include <list>
#include <iterator>     // note:

using namespace std;

template<typename T>
void PRINT_ELEMENTS( T& coll, const std::string& mesg = "" )
{
  cout << mesg << ": {";

  for( const auto &elem : coll )
    cout << elem << ",";

  cout << "}" << endl;
}

int main()
{
  list<int> coll1, coll2;

  // `inconvenient-way` to create `inserter`
  insert_iterator<list<int>> iter( coll1, coll1.begin() );

  // use usual iterator interface which has the same result
  // *iter = 1; iter++;
  // *iter = 2; iter++;
  // *iter = 3; iter++;

  *iter = 1; *iter = 2; *iter = 3; *iter = 44; *iter = 55;
  PRINT_ELEMENTS( coll1, "list1: " );

  coll2.push_back(1); coll2.push_back(2); coll2.push_back(3);
  coll2.push_back(44); coll2.push_back(55);
  PRINT_ELEMENTS( coll2, "list2: " );

  list<int> coll3;
  // convenient way to create inserter
  copy( coll1.begin(), coll1.end(), inserter( coll3, coll3.begin()) );
  PRINT_ELEMENTS( coll3, "list3: " );

  copy( coll1.begin(), coll1.end(), inserter( coll3, ++coll3.begin()) );
  PRINT_ELEMENTS( coll3, "list3: " );
}

list1: : {1,2,3,44,55,}
list2: : {1,2,3,44,55,}
list3: : {1,2,3,44,55,}
list3: : {1,1,2,3,44,55,2,3,44,55,}


{back-inserter}
Calls push_back so back inserters can be used 'only' for containers that
provide push_back() as a member function: vector, deque, list, and strings.

<code>
// c++/4.7/bits/stl_iterator.h

  // 24.4.2.2.1 back_insert_iterator
  /**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator appends it to the container using
   *  push_back.
   *
   *  Tip:  Using the back_inserter function to create these iterators can
   *  save typing.
  */
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:
      /// A nested typedef for the type of whatever container you used.
      typedef _Container          container_type;

      /// The only way to create this %iterator is with a container.
      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }

      /**
       *  @param  __value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator doesn't really have a @a position in the
       *  container (you can think of the position as being permanently at
       *  the end, if you like).  Assigning a value to the %iterator will
       *  always append the value to the end of the container.
      */
#ifndef __GXX_EXPERIMENTAL_CXX0X__
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
        container->push_back(__value);
        return *this;
      }
#else
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
        container->push_back(__value);
        return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
        container->push_back(std::move(__value));
        return *this;
      }
#endif
    }
};


<ex>
#include <iostream>
#include <vector>
#include <iterator>

using namespace std;

template<typename T>
void PRINT_ELEMENTS( T& coll, const std::string& mesg = "" )
{
  cout << mesg << ": {";

  for( const auto &elem : coll )
    cout << elem << ",";

  cout << "}" << endl;
}

int main()
{
  vector<int> coll;

  back_insert_iterator<vector<int>> iter( coll );

  // use usual iterator interface
  *iter = 1; iter++;
  *iter = 2; iter++;
  *iter = 3; iter++;
  *iter = 44; iter++;
  *iter = 45; iter++;

  // *iter = 1; *iter = 2; *iter = 3; *iter = 44; *iter = 55;
  PRINT_ELEMENTS( coll, "coll: " );

  coll.reserve( 2*coll.size() );
  copy( coll.begin(), coll.end(), back_inserter(coll) );
  PRINT_ELEMENTS( coll, "coll: " );
}

note: 
you 'must' not forget to reserve enough space before calling copy(). The reason
is that the back inserter inserts elements, which might cause relocation;
invalidate all other iterators referring to the same vector. Thus, the algorithm
invalidates the passed source iterators while running.


{front-inserter}
Calls push_front so back inserters can be used 'only' for containers that
provide push_front() as a member function: deque, list, and forward_list.


{cpp-iter-stream}

  "see(treat) stream as a sequence of elements(container) so use iterators"

A stream is an object that represent I/O channel. Treat stream as a sequence
of elements of a specified 'type' that should have input/output op
defined(>>/<<) and bind iterator to a stream. In other words, see a stream as
a sequence of user provided speficified type. Why need this? To use stream
with algorithms.

Need to specify which stream will be used and the type of objects written to it.

<ex> istream_iterator
Input iterators are used in pairs representing a sequence, so we must provide
an istream_iterator to indicate the end of input.

string word;

while( cin >> word )
  vec.push_back(word);


istream_iterator<string> in_iter(cin), eof;

while( in_iter != eof )
  vec.push_back(*in_iter++);

or

istream_iterator<string> in_iter(cin), eof;
vector<string> vec(in_iter, eof);   // vector ctor which use iter range


<ex>
vector<Data> e;
copy( istream_iterator<Date>( cin ), 
    istream_iterator<Date>(), back_inserter(e) );


<ex> ostream_iterator

template <class T, class charT=char, class traits=char_traits< charT>>
class ostream_iterator;

ostream_iterator (ostream_type& s, const char_type* delimiter);

std::ostream_iterator<int> out_iter( std::cout, " " );
for( auto e : vec )
  *out_iter++ = e;
cout << endl;

or

copy( vec.begin(), vec.end(), out_iter );
cout << endl;


<ex>
{
    ostream_iterator<string> oo{cout};

    *oo = "Hello, ";
    ++oo;
    *oo = "world!\n";
}

Hello, world!

With/without "++oo", the result is the same. The ++oo is done to mimic writing
into an array through a pointer.


<ex> how stream-iterator can make code neat

class Sales_item {
// these declarations are explained section 7.2.1, p. 270 
// and in chapter 14, pages 557, 558, 561
friend std::istream& operator>>(std::istream&, Sales_item&);
friend std::ostream& operator<<(std::ostream&, const Sales_item&);
...
};

int main()
{
  Sales_item total;

  // read the first transaction
  if( std::cin >> total )
  {
    Sales_item trans;   // variable to hold the running sum

    while(std::cin >> trans )
    {
      // if we're still processing the same book, then update the running total
      if( total.isbn() == trans.isbn() )
        total += trans;
      // print results for the previous book
      else
      {
        std::cout << total << std::endl;
        total = trans;
      }
    }
    // print the last transaction
    std::cout << total << std::endl;
  } 
  // no input and return failure
  else
  {
    std::cerr << "No data?" << std::endl;
    return -1;
  }

  return 0;
}


This can be re-written as:

int main()
{
  istream_iterator<Sales_item> item_iter(cin), eof;
  ostream_iterator<Sales_item> out_iter(cout, "\n");

  // store first transaction in sum and read the next record
  Sales_item sum = *item_iter++;

  while( item_iter != eof )
  {
    if( item_iter->isbn() == sum.isbn() )
      sum += *item_iter++;    // add it to sum and read the next record
    else
    {
      out_iter = sum;         // print result
      sum = *item_iter++;     // read the next record
    }
  }

  // print the last transaction
  out_iter = sum;
}


<ex>
Typically, istream_iterators and ostream_iterators are not used directly.
Instead, they are provided as arguments to algorithms. For example, we can
write a simple program to read a file, sort the words read, eliminate
duplicates, and write the result to another file:

int main()
{
  string from, to;
  cin >> from >> to;                      // get source and target file names

  ifstream is {from};                     // input stream for file "from"
  istream_iterator<string> ii {is};       // input iterator for stream
  istream_iterator<string> eos {};        // input sentinel

  ofstream os {to};                       // output stream for file "to"
  ostream_iterator<string> oo {os,"\n"};  // output iterator for stream

  vector<string> b {ii,eos};              // b is a vector initialized from input
  sort(b.begin(),b.end());                // sort the buffer
  unique_copy(b.begin(),b.end(),oo);      // copy buffer to output, discard replicated values

  return !is.eof() || !os;                // return error state (§2.2.1, §38.3)
}

Actually, this program is longer than it needs to be. We read the strings into
a vector, then we sort() them, and then we write them out, eliminating
duplicates. A more elegant solution is not to store duplicates at all.

We used the names ii, eos, and oo only once, so we could further reduce the
size of the program

{
  string from, to;
  cin >> from >> to;                      // get source and target file names

  ifstream is {from};                     // input stream for file "from"
  ofstream os {to};                       // output stream for file "to"

  set<string> b {istream_iterator<string>{is}, ostream_iterator<string>{}};
  copy(b.begin(),b.end(), ostream_iterator<string>{os, "\n"});

  return !is.eof() || !os;                // return error state (§2.2.1, §38.3)
}


<ex> *ex-algo-accumulate*

template <class InputIterator, class T>
T accumulate (InputIterator first, InputIterator last, T init)

#include <numeric>

istream_iterator<int> in_iter(cin), eof;
cout << std::accumulate(in_iter, eof, 0) << endl;


<ex> *ex-algo-unique-copy*
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

using namespace std;

int main()
{
  vector<string> coll;

  // read all words from stdin
  // istream_iterator<string>() is "end of stream" iterator
  copy( istream_iterator<string>(cin), istream_iterator<string>(),
      back_inserter(coll));

  cout << "===========" << endl;

  sort( coll.begin(), coll.end() );

  // print all without duplicates
  unique_copy( coll.begin(), coll.end(), ostream_iterator<string>(cout, "\n"));
}


{reverse-iterator}
Allow algorithms operate backward by switching the call of an increment operator
internally into a call of the decrement operator, and vice versa. The advantage
of using `reverse-iterator` is that all algorithms are able to operate in the
opposite direction without special code.

sort( vec.begin(), vec.end() );     // sort in normal, ascending order
sort( vec.rbegin(), vec.rend() );   // sort in reverse, decending order

   .cbegin()              .cend()
  [ ] [ ] [ ] [ ] ... [ ]
.crend()               .crbegin() 

All containers with 'bidirectional' iterators or random-access iterators can create reverse
interator. That is all containers as well as string except forward_list and unordered, supports
ability to use reverse iterators.

note: 
CPR read "The containers, aside from forward_list, all have reverse iterators". 

So container shall support ++/-- operator and rbegin/rend/crbegin/crend().

See *kt_dev_quiz_004* and *kt_dev_quiz_005* for more use cases

<ex>
#include <iostream>
#include <string>

using std::cout;
using std::endl;
using std::string;

void reverse_cpp_two(char* str)
{
  if(!str) return;
  string istr(str);

  string::reverse_iterator it = istr.rbegin();
  while( it != istr.rend() )
  {
    cout << *it << endl;
    ++it;
  }
}

int main () {
  cout << "=====" << endl;
  reverse_cpp_two("KEITEE PARK");
  return 0;
}


<ex>
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

using namespace std;

int main()
{
  vector<int> coll;

  for(int i = 1; i <= 9; ++i )
    coll.push_back(i);

  // print all without duplicates note: WHY without duplicates?
  copy( coll.crbegin(), coll.crend(), ostream_iterator<int>(cout, " "));

  cout << endl;
}


<difference-between-reverse-and-other-iterators> conversion between them
As the sort example shown above, then use reverse iterator as a range, don't
need to care about this difference but see the difference when use it as a
single iterator.

<ex> CPR p408

string line("FIRST,MIDDLE,LAST");

// print the first word, "FIRST"
auto comma = find(line.cbegin(), line.cend(), ',');
cout << string(line.cbegin(), comma ) << endl;

// print the last word, "LAST"?
auto rcomma = find(line.crbegin(), line.crend(), ',');
cout << string(line.crbegin(), rcomma ) << endl;

The result is "TSAL" since iterator goes backward and means [crbegin(), rcomma
). To get the expected result, shall use instead [rcomma.base(), cend() ) which
converts reverse iterator to normal interator.

cout << string(rcomma.base(), line.cend() ) << endl;

   rcomma.base()   
           cend()
 |       |
 , L A S T
 |       |
 rcomma  crbegin()

There is the difference when converting reverse to and from since the resulting
iterator does 'not' refer to the same element. This is a consequence of the fact
that ranges are half open.

Thus, rbegin() is simply:
container::reverse_iterator(end())

and rend() is simply:
container::reverse_iterator(begin())


<ex> shows the difference and to convert interators
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
  // create list with elements from 1 to 9
  vector<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

  // find position of element with value 5
  vector<int>::const_iterator pos;

  pos = find (coll.cbegin(), coll.cend(), 5);

  // print value to which iterator pos refers
  cout << "pos : " << *pos << endl;

  // convert iterator to reverse iterator rpos
  vector<int>::const_reverse_iterator rpos(pos);

  // print value to which reverse iterator rpos refers
  cout << "rpos: " << *rpos << endl;
}

pos : 5
rpos: 4

<example> when use it as a range
#include <iostream>
#include <deque>
#include <algorithm>

using namespace std;

void print(int elem)
{
  cout << elem << ' ';
}

int main()
{
  // create deque with elements from 1 to 9
  deque<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

  // find position of element with value 2
  deque<int>::const_iterator pos1;
  pos1 = find (coll.cbegin(), coll.cend(), 2);

  // find position of element with value 7
  deque<int>::const_iterator pos2;
  pos2 = find (coll.cbegin(), coll.cend(), 7);

  // print all elements in range [pos1,pos2)
  for_each (pos1, pos2, print);
  cout << endl;

  // convert iterators to reverse iterators
  deque<int>::const_reverse_iterator rpos1(pos1);
  deque<int>::const_reverse_iterator rpos2(pos2);

  // print all elements in range [pos1,pos2) in reverse order
  for_each (rpos2, rpos1, print); 
  cout << endl;
}

2 3 4 5 6 
6 5 4 3 2 


={============================================================================
*kt_dev_cpp_0000* cpp-iter-external-and-internal

*ex-interview* asked in phone screening. 

http://gafter.blogspot.co.uk/2007/07/internal-versus-external-iterators.html

In the "Gang Of Four" Patterns book's discussion of the Iterator pattern, we
read (page 260):

Who controls the iteration? A fundamental issue is deciding which party
  controls the iteration, the iterator or the 'client' that uses the iterator. 
  
When the client controls the iteration, the iterator is called an
`external-iterator` (C++ and Java), and when the iterator controls it, the
iterator is an `internal-iterator` (Lisp and functional languages). 

Clients that use an external iterator must advance the traversal and request
the next element explicitly from the iterator. In contrast, the client hands
an internal iterator an operation to perform, and the iterator applies that
operation to every element in the aggregate.

`external-iterator` are more 'flexible' than internal iterators. It's easy to
compare two collections for equality with an external iterator, for example,
  but it's practically impossible with internal iterators. Internal iterators
    are especially weak in a language like C++ that does not provide anonymous
    functions, closures, or continuations like Smalltalk and CLOS. But on the
    other hand, internal iterators are easier to use, because they define the
    iteration logic for you.


={============================================================================
*kt_dev_stl_063* cpp-fobj cpp-function-object cpp-functor

CPR 14.8 p571

* The function object is an object and can 'call' this object. Calling an
  object runs its overloaded call operator.

* The function call operator must be member.

* May define multiple versions of the call operator, each of which must differ
  as to the number or types of parameters.


struct absInt {
  int operator() (int val) const {
    return val < 0 ? -val : val;
  }
};

int i = -42;
absInt absObj;
int ui = absObj(i);     // absObj.operator()(i)


*cpp-fobj-has-state*
1. Has state

Can be 'smart' functions because may have other member functions and data
members which means function objects have a 'state'.

In fact, the same functionality, represented by two 'different' function
objects instances of the same class, may have different 'states' at the same
time. This is not possible for ordinary functions. Another advantage of
function objects is that you can initialize them at 'runtime' before you
use/call them.

<ex> CPR 14.8
Allows users provide a different stream and different separator.

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class PrintString {
  public:
    PrintString( ostream& o = cout, char c = ' ') : os(o), sep(c) {}

    // const member func. works well. Q: why const as os may change its state?
    // As with "bitwise-const", emits errors only when "assignment" is used on
    // members.

    void operator()(const string &s) const { os << s << sep; }

  private:
    ostream& os; 
    char sep;
};

int main()
{
  PrintString printer;
  printer("printer");

  PrintString errors( cerr, '\n' );
  errors("errors");
}


<ex>
With this technique, two different function objects can solve the problem of
having a function with two 'states' at the same time. For example, you could
simply declare `two function objects and use them independently`:

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class AddValue
{
  private:
    int theValue;

  public:
    AddValue( int v ) : theValue(v)
    { cout << "ctor is called: " << theValue << endl; }

    AddValue(const AddValue& rhs)
    { cout << "copy ctor is called: " << theValue << endl; }

    // note: What might be the result when use this form? 
    // there is no changes to container.
    //
    // void operator() (int elem) const

    void operator() (int &elem) const
    { elem += theValue; }
};

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  AddValue addx(10);
  AddValue addy(20);

  PRINT_ELEMENTS(coll, "initialized: " );

  for_each (coll.begin(), coll.end(), addx);
  cout << "-----------------------------" << endl;

  PRINT_ELEMENTS(coll, "added 10   : " );

  for_each (coll.begin(), coll.end(), addy); 
  cout << "-----------------------------" << endl;

  PRINT_ELEMENTS(coll, "added first: " );
}

ctor is called: 10
ctor is called: 20
initialized: 1 2 3 4 5 6 7 8 9 
copy ctor is called: 0
copy ctor is called: -1218374876
-----------------------------
added 10   : 1 2 3 4 5 6 7 8 9 
copy ctor is called: 134519579
copy ctor is called: -1218374876
-----------------------------
added first: 134519580 134519581 134519582 134519583 ... 134519587 134519588 

note: Wrong result? since copy ctor is wrong and should be like this. The
reason for that if user defines copy ctor must do it right. So if do not
define copy ctor and then compiler would make it and this example works fine.
Here problem is that when defines copy ctor to print message and missed out
memberwise copy.

class AddValue
{
  AddValue(const AddValue& rhs)
  {
    cout << "copy ctor is called: " << rhs.theValue << endl;
    theValue = rhs.theValue;
  }
};

ctor is called: 10
ctor is called: 20
initialized: 1 2 3 4 5 6 7 8 9 
copy ctor is called: 10
copy ctor is called: 10
-----------------------------
added 10   : 11 12 13 14 15 16 17 18 19 
copy ctor is called: 20
copy ctor is called: 20
-----------------------------
added first: 31 32 33 34 35 36 37 38 39 


note: Why is copy ctor called two times? since for_each<> *algo-for-each*
returns _Function and confirms that there is one copy ctor when changes its
definition in stl_algo.h


*algo-for-each*
for_each (coll.cbegin(), coll.cend(), PrintInt());

Creates a temporary object of this class, which is passed to the for_each() as
an argument. The for_each() uses the temporary function object op to call
op(*act) for each element act. If op is an ordinary function, for_each() simply
calls it with *act as an argument. If op is a function object, for_each() calls
its operator () with *act as an argument.

namespace std {
  template <typename Iterator, typename Operation>
    Operation for_each (Iterator act, Iterator end, Operation op)
    {
      while (act != end) {    // as long as not reached the end
        op(*act);             // call op() on an element
        ++act;                // move iterator to the next element
      }
      return op;              // note:
    }
}

The code from bits/stl_algo.h:

/**
*  @brief Apply a function to every element of a sequence.
*  @ingroup non_mutating_algorithms
*  @param  __first  An input iterator.
*  @param  __last   An input iterator.
*  @param  __f      A unary function object.          // note: 'unary'
*  @return   @p __f (std::move(@p __f) in C++0x).
*
*  Applies the function object @p __f to each element in the range
*  @p [first,last).  @p __f must not modify the order of the sequence.
*  If @p __f has a return value it is ignored.
*/
template<typename _InputIterator, typename _Function>
_Function
for_each(_InputIterator __first, _InputIterator __last, _Function __f)
{
    // concept requirements
    __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
        __glibcxx_requires_valid_range(__first, __last);

    for (; __first != __last; ++__first)
        __f(*__first);

    return _GLIBCXX_MOVE(__f);
}


2. Each function object has its own type. 

Ordinary functions have different types 'only' when their signatures differ.
However, function objects can have different types even when their signatures
are the same. See *cpp-function-adaptor* function<> example below. In fact,
    each functional behavior defined by a function object has its own type. 

This is a significant improvement for generic programming using 'templates'
because you can `pass functional behavior as a template parameter.` 

Doing so enables containers of different types to use the same kind of
function object as a sorting criterion, ensuring that you don't assign,
         combine, or compare collections that have different sorting criteria. 

You can even design hierarchies of function objects so that you can, for
example, have different, special kinds of one general criterion.

// create a set with special sorting criterion
set<Person, PersonSortCriterion> coll;

Note that the sorting criterion PersonSortCriterion is a 'type'. Thus, you can
use it as a template argument for the set. This would not be possible if you
implement the sorting criterion as a plain function.


3. Function objects are usually 'faster' than ordinary functions; function
pointer. The concept of templates usually allows better optimization because
more details are defined at 'compile' time. Thus passing function objects
instead of ordinary functions often results in better performance.


={============================================================================
*kt_dev_stl_063* cpp-fobj-predicate

To increase their 'flexibility' and power, 'several' algorithms allow the
passing of user-defined functions. This is 'callables' to change a default
operator of algorithms. For example,

  The sort() uses "operator<()" on element type to sort but want to use
  different order? If sort() was written to simply use "<" then cannot able to
  change its sort order regardless of whether element type supports the
  operator for that order. So the supported operator of element type is
  different matter.


<ex> *algo-for-each*
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void print(int elem)
{ cout << elem << ' '; }

int main()
{
  vector<int> coll{1,2,3,4,5,6,7,8,9};

  for_each( coll.cbegin(), coll.cend(), print );
  cout << endl;
}

<ex> *algo-transform* 
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int square(int value)
{ return value*value; }

int main()
{
  set<int> coll1{1,2,3,4,5,6,7,8,9};
  vector<int> coll2;

  PRINT_ELEMENTS(coll1, "initialized: ");

  transform( coll1.cbegin(), coll1.cend(), back_inserter(coll2), square );

  PRINT_ELEMENTS(coll2, "squared    : ");
}


{predicate}
A predicate is a special kind of auxiliary function. Predicates return a
'boolean' value and are often used to specify a sorting or a search criterion.
Depending on their purpose, predicates are 'unary' or 'binary'.

Not every unary or binary function that returns a boolean value is a valid
predicate. In addition, the STL requires that predicates be 'stateless',
  meaning that they should always yield the same result for the same value.

<code> *algo-sort*
template< class RandomIt>
void sort( RandomIt first, RandomIt last );

  The first forms of sort() and stable_sort() sort all elements in the range
  [beg,end) with operator <. This means that have to provide operator<() for
  a user type.

template< class RandomIt, class Compare>
void sort( RandomIt first, RandomIt last, Compare comp );

// c++/4.7/bits/stl_algo.h, @5484

  /**
   *  @brief Sort the elements of a sequence using a predicate for comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that @p __comp(*(i+1),*i) is false for every iterator @e i in the
   *  range @p [__first,__last-1).
   *
   *  The relative ordering of equivalent elements is not preserved, use
   *  @p stable_sort() if this is needed.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
	 _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
        _ValueType;

      // note: _BinaryPredicateConcept
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
          _RandomAccessIterator>)
        __glibcxx_function_requires(_BinaryPredicateConcept<_Compare, _ValueType,
            _ValueType>)
        __glibcxx_requires_valid_range(__first, __last);

      if (__first != __last)
      {
        std::__introsort_loop(__first, __last,
            std::__lg(__last - __first) * 2, __comp);
        std::__final_insertion_sort(__first, __last, __comp);
      }
    }


<ex> *algo-find-if*
#include <iostream>
#include <list>
#include <string>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

bool isPrime(int number)
{
  number = abs(number);
  
  // 0 and 1 are no prime numbers
  if( number == 0 || number == 1 )
    return false;

  int divisor;

  // find divisor that divides without a remainder
  for( divisor = number/2; number % divisor != 0; --divisor )
    ;

  // if no divisor greater than 1 is found, it is a prime number
  return divisor == 1;
}

int main()
{
  list<int> coll;

  for( int i = 24; i <= 30; i++ )
    coll.push_back(i);

  PRINT_ELEMENTS(coll, "initialized  : ");

  // is used to search for the 'first' element of the given range for which the
  // passed unary predicate yields true. If it does not find any element that
  // matches the predicate, the algorithm returns the end of the range (its
  // 'second' argument).

  auto pos = find_if( coll.cbegin(), coll.cend(), isPrime );
  if( pos != coll.end() )
    cout << *pos << " is first prime number found" << endl;
  else
    cout << "no prime number found" << endl;
}


<ex-stable-sort> *algo-stable-sort* *algo-unique*
Sort by length and also want to keep the order among the 'equal' elements.

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

// binary predicate and sort by size
bool isShorter(const string &s1, const string &s2)
{
  return s1.size() < s2.size();
}

// sort by alphabet and remove dups. unique() also move elements.
void elimDups(vector<string> &words)
{
  // sort( words.begin(), words.end(), isShorter );
  sort( words.begin(), words.end() );

  PRINT_ELEMENTS(words, "sorted       : ");

  auto end_unique = unique( words.begin(), words.end() );

  words.erase( end_unique, words.end() );
}

int main()
{
  vector<string> coll{"over", "quick", "red", "fox", "jumps", "red", "the", 
    "slow", "turtle", "the"};

  PRINT_ELEMENTS(coll, "initialized  : ");

  elimDups(coll);

  PRINT_ELEMENTS(coll, "eliminated   : ");

  stable_sort( coll.begin(), coll.end(), isShorter );

  PRINT_ELEMENTS(coll, "stable sorted: ");
}

initialized  : over quick red fox jumps red the slow turtle the 
sorted       : fox jumps over quick red red slow the the turtle // by alphabet
eliminated   : fox jumps over quick red slow the turtle 
stable sorted: fox red the over slow jumps quick turtle         // by size


<predicate-is-limited>
Depending on algorithms to use, can use only unary or binary since the
predicate only supports unary or binary which means must have one or two
parameters. How to support more arguments?


{predicate-must-stateless} CLR 10.1.4
Predicates are functions or function objects that return a boolean value or a
value that is convertible into bool. However, 'not' every function that
returns a Boolean value is a valid predicate for the STL. This may lead to
surprising behavior.

#include <iostream>
#include <list>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

// function object that returns true for the nth call
class Nth {
  private:
    int nth;    // call for which to return true
    int count;  // call counter
  public:
    Nth (int n) : nth(n), count(0) { }

    bool operator() (int) {
      return ++count == nth;
    }
};

int main()
{
  list<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

  PRINT_ELEMENTS(coll, "coll       : ");

  // remove third element
  list<int>::iterator pos;
  pos = remove_if(coll.begin(), coll.end(),   // range
      Nth(3));                                // remove criterion

  coll.erase(pos, coll.end());

  PRINT_ELEMENTS(coll,"3rd removed: ");
}

// run under GCC 4.7.2
coll       : 1 2 3 4 5 6 7 8 9 10 
3rd removed: 1 2 4 5 7 8 9 10 

Two elements, 3 and 6 elements, are removed. This happens because the usual
implementation of the algorithm copies the predicate internally during the
algorithm:

*algo-remove-if*
Both algorithms return the logical `new end of the modified sequence.` the
position after the last element not removed. See CLR 11.7.1 

note: 
The way that makes copy is interesting which uses !bool and copies element to
the same position when it is not equal.

{
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {
      // ...

      // uses the copied pred
      __first = _GLIBCXX_STD_A::find_if(__first, __last, __pred);

      if(__first == __last)
        return __first;

      _ForwardIterator __result = __first;

      ++__first;

      // uses the pred which is count is 0. if not copyed in the first then
      // count would be 3
      for(; __first != __last; ++__first)
        if(!bool(__pred(*__first)))
          {
            *__result = _GLIBCXX_MOVE(*__first);
            ++__result;
          }
      return __result;
    }
}


However, the algorithm then uses a copy of the passed predicate op to process
the remaining elements, if any. Here, Nth in its original state is used again
and also removes the third element of the remaining elements, which is in fact
the 'sixth' element: starting from the previous 3th. 

note: Nth class do not have copy ctor and use one that compiler make and do
memberwise copy blindly. So set count to 0 again.

The standard does not specify how often a predicate might be copied internally
by an algorithm. Thus, to get the guaranteed behavior of the C++ standard
library, you should not pass a function object for which the behavior
'depends' on how often it is copied or called. In other words: A predicate
should always be 'stateless'.

note: As seen, function object is flexible since it has state but as seen
here, must be careful when use it as 'predicate' but not general function
object.


<to-resolve>
To ensure that you can't change the state of a predicate due to a function
call, you should declare operator () as a constant member function. 

Or possible to avoid this surprising behavior and to guarantee that this
algorithm works as expected even for a function object such as Nth, without
any performance penalties. You could implement remove_if() in such a way that
the call of find_if() is replaced by its contents:

template <typename ForwIter, typename Predicate>
ForwIter std::remove_if(ForwIter beg, ForwIter end, Predicate op)
{
  while (beg != end && !op(*beg)) {
    ++beg;
  }
  if (beg == end) {
    return beg;
  }
  else {
    ForwIter next = beg;
    return remove_copy_if(++next, end, beg, op);
  }
}

To my knowledge, this problem arises in current implementations 'only' with
the remove_if() algorithm. If you use remove_copy_if(), all works as expected. 

However, for portability, you should never rely on this implementation detail.
You should always declare the function call operator of predicates as being a
constant member function.


<ex-stable-sort-contd>
Revise the above stable-sort example to report how many words are of a given
size or greater. From CPR 10.3.2. The sketch is:

void biggies( vector<string> &words, vector<string>::size_type sz )
{
  elimDups( words );
  stable_sort( words.begin(), words.end(), isShorter );

  // stable sorted: fox red the over slow jumps quick turtle         // by size
  //
  // 1. get an iterator to the first element whose size is >= sz
  // 2. print the number of elements with size >= sz
  // 3. print words of the given size or longer
}

The problem:
Can use find_if to find the first whose size is >= sz? However, find_if takes
'unary' predicate so cannot use f(elem, size_type). How to solve this?


={============================================================================
*kt_dev_stl_063* cpp-fobj-lambda cpp-lambda C++11

Lambdas, introduced with *C++11* , define a way to specify functional behavior
'inside' an expression or statement. You can define 'objects' that represent
functional behavior and pass these objects as `unnamed inline function` to
algorithms to be used as predicates or for other purposes.

Like any other function, lambda has return, parameter, and function body but
unlike function, be defined inside a function.

<form>
[capture list] (parameter list) -> return type { body }

The capture list is a list of 'local' variables in the 'enclosing' function.
The parameter and return are 'optional'. If omits them, will be void for
parameter or return. When return used in the body, has an 'inferred' return
type. 

<ex>
#include<iostream>

using namespace std;

int main()
{
  auto f = [] { return 42; };

  cout << f() << endl;
}


<ex-stable-sort-contd>
Revise the example with lambda:

// stable_sort( coll.begin(), coll.end(), isShorter );

stable_sort( coll.begin(), coll.end(), 
    [](const string &a, const string &b)
    { return a.size() < b.size(); } );


To solve the above problem, can use lambda. Here the lambda is 'temporary'
function object.

auto wc = find_if( words.begin(), words.end(),
               [sz](const string &a)
               { return a.size() >= sz; } );

Here [sz] is used to capture a variable from enclosing function and also can
use one parameter; one from capture and one from parameter and return bool.


#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include<functional>

using namespace std;
using namespace std::placeholders;

template<typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &opt = "")
{
  std::cout << opt;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

void elimDups( vector<string> &words)
{
  sort( words.begin(), words.end() );

  PRINT_ELEMENTS( words, "sorted       : ");

  auto end_unique = unique( words.begin(), words.end() );

  words.erase( end_unique, words.end() );
}

// note: "return ctr>1 ? word + ending : word;" works.
//
string make_plural( size_t ctr, const string &word, const string &ending )
{
  return (ctr>1) ? word + ending : word;
}

bool check_size( const string &s, string::size_type sz )
{
  return s.size() >= sz;
}

void biggies( vector<string> &words, vector<string>::size_type sz )
{
  elimDups( words );

  PRINT_ELEMENTS(words, "eliminated   : ");

  stable_sort( words.begin(), words.end(), 
      [](const string &a, const string &b)
      { return a.size() < b.size(); } );

  PRINT_ELEMENTS(words, "stable sorted: ");

  // 1. get an iterator to the first element whose size is >= sz

  // lambda version
  // auto wc = find_if( words.begin(), words.end(),
  //                [sz](const string &a)
  //                { return a.size() >= sz; } );

  // bind version
  auto wc = find_if( words.begin(), words.end(),
                 bind( check_size, _1, sz ));

  // 2. compute the number of elements with size >= sz. use
  // *iterator-arithmetic* since vector

  auto count = words.end() - wc;          

  cout << count << " " << make_plural( count, "word", "s" ) 
    << " of length " << sz << " or longer" << endl;

  PRINT_ELEMENTS(words, "for_each     : ");

  // 3. print words of the given size or longer

  for_each( wc, words.end(), [](const string &s) { cout << s << " "; });

  cout << endl;
}

int main()
{
  vector<string> coll{"over", "quick", "red", 
    "fox", "jumps", "red", "the", "slow", "turtle", "the"};

  PRINT_ELEMENTS( coll, "initialized  : ");

  biggies( coll, 5 );
}

// both lambda and bind version

initialized  : over quick red fox jumps red the slow turtle the 
sorted       : fox jumps over quick red red slow the the turtle 
eliminated   : fox jumps over quick red slow the turtle 
stable sorted: fox red the over slow jumps quick turtle 
3 words of length 5 or longer
for_each     : fox red the over slow jumps quick turtle 
jumps quick turtle 


<lambda-capture>
When define lambda, compiler generates a new unnamed class so when pass it to
a function, defines both a new type and an object of that type. So the data
member of a lambda are initialized when a lambda object is created. That means
that the variable captured by a lambda is 'local' to a lambda.


<capture-by-value-or-reference>
v1 = 42;
auto f = [v1] { return v1; };
v1 = 0;
auto j = f();     // j is 42. f is callable

v1 = 42;
auto f = [&v1] { return v1; };
v1 = 0;
auto j = f();     // j is 0.

Unlike parameters, the value of captured variable is copied when the lambda is
'created', not when it is called (executed). When pass lambda such as return a
lambda, careful for the same reason that a function must not return a
reference to a local variable. If possible, avoid capturing pointers or
reference.


<implicit-capture>
Let the compiler 'infer' variables we use from the code in the lambda body.
Use an & or = in the capture list. The revised is:

// get an iterator to the first element whose size is >= sz
auto wc = find_if( words.begin(), words.end(),
               [=](const string &a)
               { return a.size() >= sz; } );

// C++PL
The [&] is a capture list specifying that local names used (such as x) will be
accessed through references. Had we wanted to “capture” only x, we could have
said so: [&x]. Had we wanted to give the generated object a copy of x, we
could have said so: [=x]. Capture nothing is [], capture all local names used
by reference is [&], and capture all local names used by value is [=].


<limits-of-lambda>
Cannot be used sorting-criterion for associative containers and have state as
function object does.


<lambda-vs-bind>
Suppose that you search in a collection for the first element with a value that
is between x and y.

If need to use in more than one or two places, use function than a lambda.
However, it is not easy to write function to replace a lambda that captures
local variables. For example, find_if takes unary predicate and see how to pass
more than one as this example.

#include <algorithm>
#include <deque>
#include <iostream>

using namespace std;

int main()
{
  deque<int> coll = { 1, 3, 19, 5, 13, 7, 11, 2, 17 };

  int x = 5;
  int y = 12;

  auto pos = find_if (coll.cbegin(), coll.cend(),  // range
      [=](int i) {                                 // search criterion
         return i > x && i < y;
      });

  cout << "first elem >5 and <12: " << *pos << endl;
}


Now compare this way to search for "the first element >5 and <12" with the
'other' approaches provided by C++ before lambdas were introduced

1. handwritten loop

// find first element > x and < y

vector<int>::iterator pos;

for (pos = coll.begin() ; pos != coll.end(); ++pos) 
{
  if (*pos > x && *pos < y) {
    break; // the loop
  }
}

2. predicate, function object

class Pred
{
    private:
        int x;
        int y;
    public:
        Pred (int xx, int yy) : x(xx), y(yy) {
        }
        bool operator() (int i) const {
            return i > x && i < y;
        }
};

pos = find_if(coll.begin(), coll.end(), Pred(x,y) );     // note T()

note: 
1. You have to scroll up to find out what find_if() exactly is looking for
2. C++ compilers 'optimize' lambdas better than they do ordinary functions.
3. What's more, access to x and y becomes really ugly in this scenario.

3. bind

pos = find_if (coll.begin(), coll.end(),  // range
            bind(logical_and<bool>(),     // search criterion
               bind(greater<int>(),_1,x), // _1 > x
               bind(less<int>(),_1,y)));  // _1 < y

C++SLR 6.10.4

Lambdas are a kind of implicitly defined function object. Thus lambdas usually
provide the more intuitive approach to defining functional behavior of STL
algorithms. In addition, lambdas should be as fast as function objects.

However, there are also some drawbacks to lambdas:

* You can't have a hidden internal state of such a function object. Instead, all
data that defines a state is defined by the caller and passed as a capture.

* The advantage of specifying the functional behavior where it is needed
partially goes away when it is needed at 'multiple' places. You can define a
lambda and assign it to an auto object then, but whether this is more readable
than directly defining a function object is probably a matter of taste.


={============================================================================
*kt_dev_stl_063* cpp-fobj-as-argument

Functor are 'most' often used as argument to the algorithms.

<ex> 
Will print each element in vs to cerr followed by a newline.

for_each(vs.begin(), vs.end(), PrintString(cerr, '\n'));

CLR 6.10

Functional arguments for algorithms don't have to be functions and can be any
'callables'. 

*cpp-callables*

Since C++11, the standard uses the term function object for every object that
can be used as a function call. Thus, function pointers, objects of classes
with operator () or with a conversion to a pointer to function, and lambdas
are function objects. Here in this book, however, I use the term for objects
of classes with operator() defined.


<ex> use function object

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class PrintInt
{
  public:
    void operator()(int elem) const
    {
      cout << elem << ' ';
    }
};

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  // print all elements
  for_each (coll.cbegin(), coll.cend(), // range
      PrintInt());                      // operation. T() is temporary

  cout << endl;
}


<ex> use a usual function

void print(int elem)
{ cout << elem << ' '; }

int main()
{
  vector<int> coll{1,2,3,4,5,6,7,8,9};

  for_each( coll.cbegin(), coll.cend(), print );
  cout << endl;
}


{compile-runtime-change}
Suppose that want to add a 'certain' value to all elements of a collection.
Shows that functor with state is useful.

<ex>
When know the value to add at 'compile' time, can use an ordinary function
predicate.

void add10 (int& elem)
{
  elem += 10;
}

for_each(coll.begin(), coll.end(), add10);


<ex>
When know the 'different' values to add at 'compile' time, could use template.

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

template <int theValue>       // *cpp-template-explicit-argument*
void add( int& elem )
{
  elem += theValue;
}

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  PRINT_ELEMENTS(coll, "initialized: " );

  // note: When use cbegin() instead, causes compile error. However, works in
  // previous examples?
  //
  // : error: invalid initialization of reference of type "int&" from
  // expression of type "const int"
  //
  // The reason is that 
  //
  // 1. from for_each code: __f(*__first);
  //
  // 2. from operation code: void add( int& elem )
  //
  // Therefore, add(*__first) and this is "int& elem <- const int". For
  // previous examples, the argument type was int so no problem.

  for_each (coll.begin(), coll.end(),   // range
      add<10>);                         // operation. or add<20>

  PRINT_ELEMENTS(coll, "added      : " );
}

initialized: 1 2 3 4 5 6 7 8 9 
added      : 11 12 13 14 15 16 17 18 19 


<ex>
When know the value to add at 'runtime', then things get complicated. 

This normally results in a global variable that is used both by the function
that calls the algorithm and by the function that is called by the algorithm.
Did you ever copy the definition of a function because it had a static variable
to keep its state(the value to add) and you needed the same function with
another state at the same time? This is exactly the same type of problem. You
can't achieve this with one ordinary function. The below solves it by using two
different function object but same type and functionality.

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class AddValue
{
  private:
    int theValue;

  public:
    AddValue( int v ) : theValue(v) { }

    void operator() (int &elem) const
    { elem += theValue; }
};

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  PRINT_ELEMENTS(coll, "initialized: " );

  for_each (coll.begin(), coll.end(),   // range
      AddValue(10));                    // operation

  PRINT_ELEMENTS(coll, "added 10   : " );

  for_each (coll.begin(), coll.end(),   // range
      AddValue(*coll.begin()));         // operation. 'runtime'

  PRINT_ELEMENTS(coll, "added first: " );
}

initialized: 1 2 3 4 5 6 7 8 9 
added 10   : 11 12 13 14 15 16 17 18 19 
added first: 22 23 24 25 26 27 28 29 30 


{as-sorting-criteria} CLR 10.1.1
Need a sorted collection of elements that have a class for example, a
collection of Persons. However, can't use the usual operator < to sort the
objects. How?

note: WHY? How about operaor<()?

class Person {
  public:
    string firstname() const;
    string lastname() const;
    ...
};

// class for function predicate
// operator () returns whether a person is less than another person
class PersonSortCriterion {
  public:
    bool operator() (const Person& p1, const Person& p2) const {

      // a person is less than another person
      // if the last name is less
      // if the last name is equal and the first name is less
      return p1.lastname()<p2.lastname() ||
        (p1.lastname()==p2.lastname() &&
         p1.firstname()<p2.firstname());
    }
};

// create a set with special sorting criterion
set<Person, PersonSortCriterion> coll;

Note that the sorting criterion PersonSortCriterion is a 'type'. Thus, you can
use it as a template argument for the set and can design function objects that
represent different sorting criteria with the same type. This would not be
possible if you implement the sorting criterion as a plain function


<as-template-argument>

template <typename T>   // '<typename T>' is template param list
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

This is function template and is useful. However, only supports '<' on type.
How about others such as '>'? If write a template supporting function object,
    then supports whatever operations user selects.

See <template-default-argument> for more.

template <typename T, typename F = less<T>>
int compare( const T &v1, const T &v2, F f = F())
{
  if( f(v1, v2) ) return -1;
  if( f(v2, v1) ) return 1;
  return 0;
}


={============================================================================
*kt_dev_stl_063* cpp-fobj-pass-by-reference

{function-object-passed-by-value} CLR 10.1.2, 3
A function that may have more than one state at the same time.

The function objects are copied or passed by value rather than by reference.
Thus, the algorithm does not change the state of the function object.

Passing function objects by 'value' instead of by reference has the advantage
that you can pass constant and 'temporary' expressions.

The disadvantage of passing the function object by value is that you can't
benefit from modifications of the state of the function objects when access to
the 'final' state might be necessary.

There are three ways to get a "result" from function objects passed to
algorithms:

1. You can keep the state externally and let the function object refer to it.
2. You can pass the function objects by reference.
3. You can use the return value of the for_each() *algo-for-each*


<pass-by-reference>
To pass a function object by reference, you simply have to qualify the call of
the algorithm so that the function object type is a reference.

class IntSequence {
  private:
    int value;

  public:

    IntSequence (int initialValue)
      : value(initialValue) { }

    int operator() () 
    {
      return ++value;
    }
};

int main()
{
  list<int> coll;

  IntSequence seq(1); // integral sequence starting with 1

  // insert values from 1 to 4
  // pass function object by reference so that it will continue with 5 
  // note: see reference in "IntSequence&"

  generate_n<back_insert_iterator<list<int>>, int, `IntSequence&`>(
      back_inserter(coll),    // start
      4,                      // number of elements
      seq);                   // generates values

  PRINT_ELEMENTS(coll);

  // insert values from 42 to 45
  generate_n(
      back_inserter(coll),  // start
      4,                    // number of elements
      IntSequence(42));     // generates values

  PRINT_ELEMENTS(coll);

  // continue with first sequence
  // pass function object by value but it will continue with 5 again
  generate_n(
      back_inserter(coll),  // start
      4,                    // number of elements
      seq);                 // generates values

  PRINT_ELEMENTS(coll);

  // continue with first sequence again
  generate_n(
      back_inserter(coll),  // start
      4,                    // number of elements
      seq);                 // generates values

  PRINT_ELEMENTS(coll);
}

2 3 4 5
2 3 4 5 43 44 45 46
2 3 4 5 43 44 45 46 6 7 8 9             // maintain the state, value
2 3 4 5 43 44 45 46 6 7 8 9 6 7 8 9     // not maintain


<return-function-object>
The passing a functor by reference in order to access its `final state` is not
necessary if you use the `algo-for-each` which has the 'unique' ability to
return its function object (no other algorithm can do this). 

Thus, you can query the state of your function object by checking the return
value of `for_each()`.

The following program is a nice example of the use of the return value of
for_each() and shows how to process the mean value of a sequence:

// function object to process the mean value
class MeanValue {
  private:
    long num; // number of elements
    long sum; // sum of all element values

  public:
    MeanValue () : num(0), sum(0) {
    }

    void operator() (int elem) {
      ++num; // increment count
      sum += elem; // add value
    }

    // return mean value
    double value () {
      return static_cast<double>(sum) / static_cast<double>(num);
    }
};

int main()
{
  vector<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8 };

  // process and print mean value
  MeanValue mv = for_each (coll.begin(), coll.end(),  // range
      MeanValue());                                   // operation

  cout << "mean value: " << mv.value() << endl;
}

mean value: 4.5


{arg-type-on-function-object}
As with "arg-type-on-bind", should be a match between the element type of
container and the element type of function-object. 

<ex>
class PrintInt
{
  public:
    void operator() (string elem) const   // note: string
    {
      cout << elem << ' ';
    }
};

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  // print all elements
  for_each (coll.cbegin(), coll.cend(), // range
      PrintInt());                      // operation

  cout << endl;
}

$ ./cppbl.sh sample.cpp 
In file included from /usr/include/c++/4.7/algorithm:63:0,
                 from sample.cpp:3:
/usr/include/c++/4.7/bits/stl_algo.h: 
In instantiation of 
'_Funct std::for_each(_IIter, _IIter, _Funct) [with _IIter 
  = __gnu_cxx::__normal_iterator<const int*, std::vector<int> >; _Funct = PrintInt]':

sample.cpp:27:17:   required from here
/usr/include/c++/4.7/bits/stl_algo.h:4442:2: error: invalid conversion 
  from ‘int’ to ‘const char*’ [-fpermissive]


{support-for-pointers}
any real case which is useful?

p575. Recall that comparing two unrelated pointers is undefined. However,
  might want to sort a vector of pointers. Although it would be undefined for
  us to do directly, can do through library function object. 

vector<string *> nameTable;
sort(nameTable.begin(), nameTable.end(), less<string *>());


={============================================================================
*kt_dev_stl_063* cpp-fobj-predefined

<cpp-less>
#include <functional> defines library-defined function objects:

negate<type>()          - param
plus<type>()            param1 + param2
minus<type>()           param1 - param2
multiplies<type>()      param1 * param2
divides<type>()         param1 / param2
modulus<type>()         param1 % param2
equal_to<type>()        param1 == param2
not_equal_to<type>()    param1 != param2
less<type>()            param1 < param2
greater<type>()         param1 > param2
less_equal<type>()      param1 <= param2
greater_equal<type>()   param1 >= param2
logical_not<type>()     ! param
logical_and<type>()     param1 && param2
logical_or<type>()      param1 || param2
bit_and<type>()         param1 & param2
bit_or<type>()          param1 | param2
bit_xor<type>()         param1 ^ param2


set<int, less<int>> coll;      // == set<int> coll. sort with operator<
set<int, greater<int>> coll;   // sort with operator> 

sort(svec.begin(), svec.end(), greater<string>());    // temporary object


<code-less> template-less from bits/stl_function.h

namespace std {

  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };

  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };

  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };

  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };

  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };

  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };

  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
};


<ex>
{
    std::plus<int> pl;
    cout << "plus(10, 20) : " << pl(10, 20) << endl;
}

plus(10, 20) : 30


// *algo-transform* 
//
// CLR 11.6.3 Transforming and Combining Elements
//
// The first form has four arguments. It transforms elements from a source to a
// destination range. Thus, this form copies and modifies elements in one step.
//
// The second form has five arguments. It combines elements from two source
// sequences and writes the results to a destination range.

// from bits/stl_algo.h
namespace std {

  /**
   *  @brief Perform an operation on a sequence.
   *  @ingroup 'mutating'_algorithms
   *  @param  __first     An input iterator.
   *  @param  __last      An input iterator.
   *  @param  __result    An output iterator.
   *  @param  __unary_op  A 'unary' operator.
   *  @return   An output iterator equal to @p __result+(__last-__first).
   *
   *  Applies the operator to each element in the input range and assigns
   *  the results to successive elements of the output sequence.
   *
   *  Evaluates @p *(__result+N)=unary_op(*(__first+N)) for each @c N in the
   *  range @p [0,__last-__first).
   *
   *  @p unary_op must not alter its argument.
  */
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>

    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result, _UnaryOperation __unary_op)
    {
      // ...
      for (; __first != __last; ++__first, ++__result)
         *__result = __unary_op(*__first); // note: write to output and unary
      return __result;
    }

  /**
   *  @brief Perform an operation on corresponding elements of two sequences.
   *  @ingroup mutating_algorithms
   *  @param  __first1     An input iterator.
   *  @param  __last1      An input iterator.
   *  @param  __first2     An input iterator.
   *  @param  __result     An output iterator.
   *  @param  __binary_op  A 'binary' operator.
   *  @return   An output iterator equal to @p result+(last-first).
   *
   *  Applies the operator to the corresponding elements in the two
   *  input ranges and assigns the results to successive elements of the
   *  output sequence.
   *
   *  Evaluates @p
   *  *(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each
   *  @c N in the range @p [0,__last1-__first1).
   *
   *  @p binary_op must not alter either of its arguments.
  */
  template<typename _InputIterator1, typename _InputIterator2, 
      typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _OutputIterator __result,
         _BinaryOperation __binary_op)
    {
      // ...
      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
         *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
}


// Q: automatic type conversion when use glbal usual function?
// {function-automatic-conversion} As with "function-type", involves automatic
// conversion to function type(pointer). When use a usual function, compiler
// converts it to function type and a function call is a operator() on this
// function pointer. 


={============================================================================
*kt_dev_stl_064* cpp-fobj-function-type

{function-type}
Assume to build a simple desk calculator and to define a function table to
store pointers to these callables since all have the same call signature. 

// ordinary function
int add(int i, int j) { return i+j;}

// lambda
auto mod = [](int i, int j) { return i%j; };

// function object
struct divide {
  int operator () (int denominator, int divisor) {
    return denominator/divisor;
  }
};

map<string, int(*)(int, int)> binops;

binops.insert( {"+", add} );
binops.insert( {"%", mod} );  // error since mod is 'not' a pointer to function

The second is in error since like any other object, a callable object has a
type and lambda type does not match the type of the values in the map.

However, callables with different types may 'share' the same call signature. A
call signature corresponds to a function type.

*cpp-function-adaptor*
Solve this using library 'type' named 'function' defined in functional header.
This represent 'any' callables that has the same call signature. This is
additional information for a template.

function<int(int,int)>

function<int(int,int)> f1 = add;
function<int(int,int)> f2 = divide();
function<int(int,int)> f3 = [](int i, int j) { return i%j; };

cout << f1(4,2) << endl;
cout << f2(4,2) << endl;
cout << f3(4,2) << endl;

Can redefine a map to build a calculator.

map<string, function<int(int, int)>> binops = {
  {"+", add},
  {"-", std::minus<int>()},
  {"/", divide()},
  ...
};

And when index a map, get a reference to an object of type `function`. The
`function` type overloads the call operator which takes its own arguments and
passes them along to its stored callable objects.

binops["+"](10,5);   // adds(10,5)
binops["-"](10,5);   // minus<int>(10,5)
...


={============================================================================
*kt_dev_stl_064* cpp-fobj-type cpp-function-pointer

{functions-type}
The function pointer points a particular 'type', function's type.

bool (const string &, const string &);        // function's type
bool (*pf)(const string &, const string &);   // pointer to function's type

The () around *pf are necessary. Otherwise, declare pf as a function that
returns a pointer to bool.

bool *pf(const string &, const string &);


When use the name of a function as a 'value', the function is automatically
converted to a pointer.

pf = lengthCompare;                               // automatic conversion
pf = &lengthCompare;

bool b1 = pf( "hello", "goodbye" );               // no need to dereference
bool b1 = *pf( "hello", "goodbye" );
bool b1 = lengthCompare( "hello", "goodbye" );


<function-pointer-parameter>
The third parameter is "function type" and when use function directly, it is
'automatically' converted to function pointer. 

void useBigger( const string &s1, const string &s2, 
    bool pf( const string &, const string & ) );

useBigger( s1, s2, lengthCompare );

  "this is why stl algorithm can take opeartion as typename."


The equivalent declaration but 'explicit'.

void useBigger( const string &s1, const string &s2, 
    bool (*pf)( const string &, const string & ) );

Can use type alias and see that decltype() returns function type.

typedef bool Func( const string &, const string & );
typedef decltype( lengthCompare ) Func;                       // same

typedef bool (*FuncP)( const string &, const string & );
typedef decltype( lengthCompare ) *FuncP;                     // same

void useBigger( const string &s1, const string &s2, Func );
void useBigger( const string &s1, const string &s2, FuncP );  // same

note: 
function's type will be treated as a pointer but only when used as parameter.
Not automatically treated in return type.

CPR 249 for more.


={============================================================================
*kt_dev_stl_065* cpp-fobj-bind cpp-bind

note:
The functions ref, cref, and bind are accepted to the C++11 standard and are
defined in the <functional> header in the std:: namespace. 

#include <functional>
using namespace std::placeholders;

$ g++ -std=c++0x t_boost.cpp -L/usr/local/lib


CLR 10.2.2

A function 'adapter' is a function object that enables the 'composition' of
function objects with each other, with certain values, or with special
functions. (according to the composite pattern in GOF)

auto new_callable = bind(callable, args...);

'binds' callable and args and makes new callable


The `bind()` allows you to:

* Adapt and compose new function objects out of existing or predefined
  function objects

* Call global functions

* Call member functions for objects, 'pointers' to objects, and 'smart' pointers
  to objects

<code>
// functional

  /**
   *  @brief Function template for std::bind.
   *  @ingroup binders
   */
  template<typename _Func, typename... _BoundArgs>
    inline typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    `bind`(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
        std::forward<_BoundArgs>(__args)...);
    }


#3  0x73ea9934 in call<nickel::system::GstMediaRouter* const> (this=0x5dbac0, u=<optimized out>) 
    at /boost/bind/mem_fn_template.hpp:105

#4  operator()<nickel::system::GstMediaRouter*> (this=0x5dbac0, u=<optimized out>) 
    at /boost/bind/mem_fn_template.hpp:115

#5  operator()<Zinc::Media::Position, boost::_mfi::cmf0<Zinc::Media::Position, nickel::system::GstMediaRouter>, boost::_bi::list0> (f=..., this=0x5dbac8, a=<optimized out>) 
    at /boost/bind/bind.hpp:243

#6  operator() (this=0x5dbac0) at boost/bind/bind_template.hpp:20

#7  apply (promise=..., functor=...) at /include/zinc-common/async/detail/async-helpers_Impl.h:53


<placeholder-namespace>
Thus, if a function, member function, function object, or lambda requires some
parameters, you can bind 'them' to specific or passed arguments. Specific
arguments you simply name. For passed arguments, you can use the predefined
placeholders _1, _2, ... defined in namespace std::placeholders.

To avoid the tedious repetition of the namespace placeholders, you can use a
corresponding using directive.

using namespace std;
using namespace std::placeholders;

Otherwise, would get:

:20:25: error: "_1" was not declared in this scope


{nested-bind}
This kind of programming results in functional 'composition'. What is
interesting is that all these function objects are usually declared 'inline'.
Thus, use a function-like notation or abstraction but you get good performance.

<ex>
// A typical application of binders is to specify parameters when using the
// predefined function objects

#include <functional>
#include <iostream>

int main()
{
  // represents a function object, which 'internally' calls plus<>, with a
  // placeholder _1 as first parameter/operand and 10 as second
  // parameter/operand.

  // plus<int>(7, 10);

  auto plus10 = std::bind(std::plus<int>(),
      std::placeholders::_1,
      10);


  std::cout << "+10: " << plus10(7) << std::endl;

  // multiplies<int>( plus<int>(7, 10), 2);

  auto plus10times2 = std::bind(std::multiplies<int>(),
      std::bind(std::plus<int>(),
        std::placeholders::_1,
        10),
      2);

  // multiplies<int>( multiplies<int>(7, 7), 7);

  std::cout << "+10 *2: " << plus10times2(7) << std::endl;

  auto pow3 = std::bind(std::multiplies<int>(),
      std::bind(std::multiplies<int>(),
        std::placeholders::_1,
        std::placeholders::_1),
      std::placeholders::_1);

  std::cout << "x*x*x: " << pow3(7) << std::endl;

  // divides<double>(7, 49);

  auto inversDivide = std::bind(std::divides<double>(),
      std::placeholders::_2,
      std::placeholders::_1);

  std::cout << "invdiv: " << inversDivide(49,7) << std::endl;
}

+10: 17
+10 *2: 34
x*x*x: 343
invdiv: 0.142857


<ex>
#include<iostream>
#include<set>
#include<deque>
#include<string>
#include<algorithm>
#include<functional>

using namespace std;
using namespace std::placeholders;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

bool check_size( const string &s, string::size_type sz )
{
  return s.size() >= sz;
}

int main()
{
  set<int, greater<int>> coll1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
  deque<int> coll2;

  PRINT_ELEMENTS( coll1, "initialized: " );

  // *algo-transform*
  transform( coll1.cbegin(), coll1.cend(),    // source
      back_inserter( coll2 ),                 // destination
      bind( multiplies<int>(), _1, 10 ));     // unary operation

  PRINT_ELEMENTS( coll2, "transformed: " );

  // algo-replace-if
  replace_if( coll2.begin(), coll2.end(),   // range
      bind( equal_to<int>(), _1, 70 ),      // criterion
      42 );                                 // new value

  PRINT_ELEMENTS( coll2, "replaced   : " );

  // *algo-remove-if*
  coll2.erase(remove_if( coll2.begin(), coll2.end(),
        bind(
          logical_and<bool>(),
          bind(greater_equal<int>(), _1, 50),
          bind(less_equal<int>(), _1, 80)
          ) 
        ),
      coll2.end());

  PRINT_ELEMENTS( coll2, "removed    : " );
}

initialized: 9 8 7 6 5 4 3 2 1 
transformed: 90 80 70 60 50 40 30 20 10 
replaced   : 90 80 42 60 50 40 30 20 10 
removed    : 90 42 40 30 20 10 


// 1. See "x>=50 && x<=80" used in logical_and<>.
// 
// 2. The expressions are evaluated 'from' the 'inside' to the outside. So inner
// callable "returns 'bool' type" and outer callable uses that as element type. No
// function call involved. That's why logical_and<bool>().
// 
// template<typename _Tp>
// struct logical_and : public binary_function<_Tp, _Tp, bool>
// {
//   bool
//   operator()(const _Tp& __x, const _Tp& __y) const
//   { return __x && __y; }
// };
// 
// return bind(greater_equal<int>(), _1, 50) && bind(less_equal<int>(), _1, 80);
// 
// __x is not "bind(greater_equal<int>(), _1, 50)" and is return value.


{arg-num-on-bind}
How does the new callable know the number of arguments to use with?

<ex>
int main()
{
  cout << bind(plus<int>(), _1, 10)(30) << endl;
  cout << bind(plus<int>(), _1, 10)(30, 40) << endl;
  cout << bind(plus<int>(), _1, 10)(30, 40, 50) << endl;
  cout << bind(plus<int>(), _1, 10)(30, 40, 50, 60) << endl;
}

$ ./a.out 
40
40
40
40


<ex>
int main()
{
  multiplies<int> mt;

  cout << mt(10,20) << endl;
  cout << mt(20,10) << endl;

  cout << bind(multiplies<int>(), _1, 10)(20) << endl;

  cout << mt(10,40) << endl;

  // note on error
  cout << mt(10) << endl;
}

:17:18: error: no match for call to ‘(std::multiplies<int>) (int)’

/usr/include/c++/4.7/bits/stl_function.h:160:12: 
      note: candidate is:
/usr/include/c++/4.7/bits/stl_function.h:163:7: 
      note: _Tp std::multiplies<_Tp>::operator()(const _Tp&, const _Tp&)
              const [with _Tp = int]
/usr/include/c++/4.7/bits/stl_function.h:163:7: 
      note:   candidate expects 2 arguments, 1 provided


{arg-type-on-bind}
Always have to specify the argument type of the predefined function object
used. If the type doesn't match, a type conversion is forced, or the
expression results in a compile-time error.

int main()
{
  cout << bind(plus<int>(), _1, 10)(30) << endl;      // 40
  cout << bind(plus<int>(), _1, 10)(30.0) << endl;    // 40
  cout << bind(plus<string>(), _1, 10)(30) << endl;   // error
}

:31:42: error: no match for call to '(std::_Bind_helper<false,
  std::plus<std::basic_string<char> >, const std::_Placeholder<1>&, int>::type
  {aka std::_Bind<std::plus<std::basic_string<char> >(std::_Placeholder<1>,int)>}) (int)'

In file included from /usr/include/c++/4.7/bits/stl_algo.h:68:0,
                 from /usr/include/c++/4.7/algorithm:63,
                 from t_bind.cpp:5:
/usr/include/c++/4.7/functional:1140:11: note: candidates are:
...


<case-when-bind-useful>

<ex> different number of arguments

This is an example to show that bind solves different number of argument since
find_if requires `unary predicate` but want to use more complicated predicate.

*algo-find-if* *algo-find*

// bits/predefined_ops.h

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      _Iter_equals_val(_Value& __value)
	: _M_value(__value)
      { }

      // shows to use operator==()
      template<typename _Iterator>
	bool
	operator()(_Iterator __it)
	{ return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }


// bits/stl_algo.h

  /**
   *  @brief Find the first occurrence of a value in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __val    The value to find.
   *  @return   The first iterator @c i in the range @p [__first,__last)
   *  such that @c *i == @p __val, or @p __last if no such iterator exists.
  */
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
	 const _Tp& __val)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_EqualOpConcept<
		typename iterator_traits<_InputIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);
      return std::__find_if(__first, __last,
			    __gnu_cxx::__ops::__iter_equals_val(__val));
    }

  /**
   *  @brief Find the first element in a sequence for which a
   *         predicate is true.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return   The first iterator @c i in the range @p [__first,__last)
   *  such that @p __pred(*i) is true, or @p __last if no such iterator exists.
  */
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
	    _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	      typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__find_if(__first, __last,
			    __gnu_cxx::__ops::__pred_iter(__pred));
    }

// This is an overload used by find_if() for the Input Iterator case.

template<typename _InputIterator, typename _Predicate>
  inline _InputIterator
  __find_if(_InputIterator __first, _InputIterator __last,
      _Predicate __pred, input_iterator_tag)
  {
    while (__first != __last && !bool(__pred(*__first)))
      ++__first;
    return __first;
  }

bool check_size( const string &s, string::size_type sz )
{
  return s.size() >= sz;
}

auto check6 = bind( check_size, _1, 6 );

string s = "hello";
bool b1 = check6(s);    // bool check_size(s, 6)

auto wc = find_if( words.begin(), words.end(), 
                     [sz] (const string &a)
                     { return a.size() >= sz; } );

auto wc = find_if( words.begin(), words.end(), 
                     bind(check_size, _1, 6) );

<ex>
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include<functional>

using namespace std;
using namespace std::placeholders;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

bool check_size( const string &s, string::size_type sz )
{
  return s.size() >= sz;
}

int main()
{
  vector<string> coll{"over", "quick", "red", 
    "fox", "jumps", "red", "the", "slow", "turtle", "the"};

  sort( coll.begin(), coll.end() );

  PRINT_ELEMENTS( coll, "sorted: " );

  auto wc = find_if( coll.begin(), coll.end(),
      bind( check_size, _1, 4 ));

  cout << "wc = " << *wc << endl;
}

sorted: fox jumps over quick red red slow the the turtle 
wc = jumps


<ex> rearrange-arguments

Use bind() to rearrange the parameters in the given collable.

auto g = bind( f, a, b, _2, c, _1 );      
g(X, Y); // f( a, b, Y, c, X );

As an example, invert the meaning of isShorter.

bool isShorter(const string &s1, const string &s2)
{
  return s1.size() < s2.size();
}

sort( words.begin(), words.end(), isShorter );
sort( words.begin(), words.end(), bind( isShorter, _2, _1 ));


<ex> not-use-arguments

Possible not to use arguments at all. If changes the example above as:

auto wc = find_if( coll.begin(), coll.end(),
   bind( check_size, "bind", 4 ));


sorted: fox jumps over quick red red slow the the turtle 
wc = fox


{bind-copy-arguments} *cpp-ref* *cpp-cref*
The bind() internally 'copies' passed arguments. To let the function object
use a reference to a passed argument, use ref() or cref(). 

See Section 5.4.3, page 132. For example:

void incr (int& i)
{
  ++i;
}

int i=0;

bind(incr, i)();            // increments a copy of i, no effect for i
bind(incr, ref(i))();       // increments i


<bind-use-global-function>
// The bind() can be used to call global functions.

#include <iostream>
#include <algorithm>
#include <functional>
#include <locale>
#include <string>

using namespace std;
using namespace std::placeholders;

// when case sensitivity doesn't matter.
char myToupper (char c)
{
  // *cpp-toupper*
  std::locale loc;
  return std::use_facet<std::ctype<char>>(loc).toupper(c);
}

int main()
{
  string s("Internationalization");
  string sub("Nation");

  // search substring case insensitive
  string::iterator pos;

  // *algo-search*
  //
  // ForwardIterator1
  // search (ForwardIterator1 beg, ForwardIterator1 end,
  //    ForwardIterator2 searchBeg, ForwardIterator2 searchEnd,
  //    BinaryPredicate op)
  //
  // Both forms return the position of the first element of the first subrange
  // matching the range [searchBeg,searchEnd) in the range [beg,end).
  //
  // In the second form, for every comparison between elements, the call of the
  // binary predicate op(elem,searchElem) has to yield true.

  pos = search (s.begin(),s.end(),  // string to search in
      sub.begin(),sub.end(),        // substring to search
      bind(equal_to<char>(),        // compare criterion
        bind(myToupper,_1),
        bind(myToupper,_2)));

  if (pos != s.end()) {
    cout << "\"" << sub << "\" is part of \"" << s << "\""
      << endl;
  }
}


={============================================================================
*kt_dev_stl_066* cpp-fobj-bind-member-function

The bind() works with member function, modifying member function, and 'virtual'
function. The first argument is a member function and the next argument defines
the 'object' for which this member function gets called.


Have to bind the pointer to a specific object so a pointer to member is 'not'
a callable 'object'; do not support the function-call operator. Therefore,
cannot directly pass a pointer to member function to an algorithm.

auto fp = &string::empty;
find_if(svec.begin(), svec.end(), fp);    // error. won't compile

Because the code inside find_if executes something like:

if (fp(*it))    // error. must use ->* to call through a pointer to member
                // see *algo-find-if*


HOW to slove?

<1> *cpp-function-adaptor*
The first solution is to use the library function type:

The `function` creates a callable for a member function and knows that it must
use the appropriate pointer-to-member operator to make the call.

* the signature's first parameter must represent the (normally implicit) object
  on which the member will be run. done by `find_if` inside in this case.

* the signature to `function` must speficy whether the object will be passed as
  a pointer or reference.


// when use reference
function<bool (const string&)> fcn = &string::empty;
find_if(svec.begin(), svec.end(), fcn);

// when use pointer
vector<string *> pvec;
function<bool (const string*)> fp = &string::empty;

// fp uses the ->* to call empty
find_if(pvec.begin(), pvec.end(), fp);

CLR 5.4.4

The std::function<>, declared in <functional>, provides 'polymorphic' wrappers
that 'generalize' the notion of a function pointer.

When member functions are used, the object they are called for 'has' to be the
first argument:

class C {
  public:
    void memfunc (int x, int y) const;
};

std::function<void(const C&, int, int)> mf;
mf = &C::memfunc;
mf(C(),42,77);                      // speficy the target

note:
that performing a function call without having a 'target' to call throws an
exception of type std::bad_function_call (see Section 4.3.1, page 43):

std::function<void(int,int)> f;
f(33,66);                           // throws std::bad_function_call


<2>
mem_fn
Calls op() as a member function for an object or pointer to object

Use `mem_fn` to let the compiler deduce the member's type and to generate a
callable object.

// function<bool (const string&)> fcn = &string::empty;
// find_if(svec.begin(), svec.end(), fcn);

find_if(svec.begin(), svec.end(), mem_fn(&string::empty));

The callable generated by `mem_fn` can be called on either an object or a
pointer.

auto f = mem_fn(&string::empty);
f(*svec.begin());     // object; f uses .*
f(&svec[0]);          // pointer; f uses ->*


<3>
Use `bind` to generate callable from a member function.

auto it = find_if (svec.begin(), sven.end(),
    bind(&string::empty, _1));

As with `function`, must make 'explicit' the 'object' on which the member
function will operate and which is normally implicit parameter.

As with `mem_fn`, the 'first' argument to the callable can be either a pointer
or a reference. *cpp-this*

auto f = bind(&string::empty, _1);
f(*svec.begin());     // object; f uses .*
f(&svec[0]);          // pointer; f uses ->*


<ex>
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include<functional>

using namespace std;
using namespace std::placeholders;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr << endl;

  for( const auto &elem : coll )
    elem.print();
}

class Person {
  private:
    string name;

  public:
    Person (const string& n) : name(n) {}

    void print () const
    {
      cout << ":" << name << endl;
    }

    void print2 (const string& prefix) const
    {
      cout << prefix << name << endl;
    }

    void setName (const std::string& n)
    {
      name = n;
    }
};

int main()
{
  vector<Person> coll1 = { Person("one"), Person("two"), Person("three") };

  PRINT_ELEMENTS( coll1, "initialized: " );

  // call member function print() for each person.
  //
  // This requires two things: how for_each() calls 'op' and every member
  // function is called with this `as the first argument.` *cpp-this*
  //
  // Operation for_each (Iterator act, Iterator end, Operation op)
  // {
  //   while (act != end) {    // as long as not reached the end
  //     op(*act);             // call op() on an element
  //     ++act;                // move iterator to the next element
  //   }
  //   return op;
  // }

  // *algo-for-each*
  for_each( coll1.begin(), coll1.end(), 
      bind(`&Person::print`, _1));

  // call member function print2() with additional argument for each person
  for_each( coll1.begin(), coll1.end(), 
      bind(`&Person::print2`, _1, ">" ));

  // call modifying member function setName()
  for_each( coll1.begin(), coll1.end(), 
      bind(`&Person::setName`, _1, "Paul" ));

  PRINT_ELEMENTS( coll1, "modified   : " );
}

initialized: 
:one
:two
:three

:one
:two
:three

>one
>two
>three
>
modified   : 
:Paul
:Paul
:Paul


<cpp-member-function-address>
CPR 19.4 835

When initialize a pointer to member, that pointer does 'not' yet point to any
data. Supply the object when we dereference that pointer. Analogous to the
member access operators, . and ->, 

`two pointer-to-member access operators`, .* and ->*, to supply an object and
to dereference the pointer. 

auto pmf = &Screen::get_cursor;

When the member is overloaded, must distinguish which function we want:

char (Screen::*pmf2)(Screen::pos, Screen::pos) const;
pmf2 = &Screen::get;

Unlike ordinary function pointer, no automatic conversion between a member
funtion and a pointer to that function.

pmf = &Screen::get;     // must explicitly use address-of operator
pmf = Screen::get;      // error

To call member function through a pointer: 

Screen myScreen, *pScreen = &myScreen;

char c1 = (pScreen->*pmf)();
char c2 = (myScreen.*pmf2)(0,0);

<ex>
#include<iostream>
#include<string>
#include<functional>

using namespace std;
using namespace std::placeholders;

class TestClass
{
    public:
        TestClass(std::string _mesg): mesg(_mesg) {}
        ~TestClass() {}
        void func1(std::string &)
        {
            cout << "this is func1.." << endl;
        }

    private:
        std::string mesg;
};

// typedef void (*FUNCPTR)(std::string &);
typedef void (TestClass::*FUNCP)(std::string &);
//typedef void TestClass::FUNCP(std::string &);

class Foo
{
    public:
        Foo() {}
        ~Foo() {}

        template<typename T, typename S>
            void printMember( void(T::*funcp)(S&), T& obj )
            {
                cout << "Foo1: mem address " << (void*)funcp << 
                    " | obj address: " << (void*)&obj << endl;
            }
};

int main()
{
    Foo x;
    TestClass tc1(string("tc 1"));
    TestClass tc2(string("tc 2"));

    cout << "main: tc1: mem address " << (void*)&TestClass::func1 << 
        " | obj address: " << (void*)&tc1 << endl;

    cout << "main: tc2: mem address " << (void*)TestClass::func1 << 
        " | obj address: " << (void*)&tc2 << endl;

    // warning on conversion to void*
    // $ ./a.out 
    // main: tc1: mem address 0x8048c58 | obj address: 0xbf82e1e8
    // main: tc2: mem address 0x8048c58 | obj address: 0xbf82e1e4
    // Foo1: mem address 0x8048c58 | obj address: 0xbf82e1e8
    // Foo1: mem address 0x8048c58 | obj address: 0xbf82e1e4

    // the following is an error:
    // error: invalid use of non-static member function 
    // 'void TestClass::func1(std::string&)'
    // 
    // since this is a function call which is member function.
    //
    // cout << "main: mem address " << (void*)TestClass::func1 << 
    //    " | obj address: " << (void*)&tc << endl;

    x.printMember( &TestClass::func1, tc1 );
    x.printMember( &TestClass::func1, tc2 );

    // However, it is okay when uses it as parameter and the following is okay.
    // x.printMember( TestClass::func1, tc );

    // error: ISO C++ forbids taking the address of a bound member function 
    // to form a pointer to member function.  
    // Say ‘&TestClass::func1’ [-fpermissive]
    //
    // x.printMember( &tc1.func1, tc1 );
    // x.printMember( &tc2.func1, tc2 );
}


<bind-with-virtual>
Calling virtual member functions also works. If a method of the base class is
bound and the object is of a derived class, the correct virtual function of the
derived class gets called.


<bind-with-pointer>
The bind() works with pointers.

std::vector<Person*> cp;
for_each (cp.begin(), cp.end(), bind(&Person::print, _1));

std::vector<std::shared_ptr<Person>> sp;
for_each (sp.begin(), sp.end(), bind(&Person::print, _1));


<cpp-bind-ex> CLR 4.4

int main()
{
  C c;
  std::shared_ptr<C> sp(new C);

  // bind() uses callable objects to bind arguments:
  std::bind(func, 77,33)();             // calls: func(77,33)
  std::bind(l, 77,33)();                // calls: l(77,33)
  std::bind(C(), 77,33)();              // calls: C::operator()(77,33)
  std::bind(&C::memfunc, c, 77,33)();   // calls: c.memfunc(77,33)
  std::bind(&C::memfunc, sp, 77,33)();  // calls: sp->memfunc(77,33)

  // *cpp-async* async() uses callable objects to start (background) tasks:
  std::async(func, 42,77);              // calls: func(42,77)
  std::async(l, 42,77);                 // calls: l(42,77)
  std::async(c, 42,77);                 // calls: c.operator()(42,77)
  std::async(&C::memfunc, &c, 42,77);   // calls: c.memfunc(42,77)
  std::async(&C::memfunc, sp, 42,77);   // calls: sp->memfunc(42,77)
}


<ex> from boost bind

struct X
{
    bool f(int a);
};

X x;

shared_ptr<X> p(new X);

int i = 5;

bind(&X::f, ref(x), _1)(i);     // x.f(i)
bind(&X::f, &x, _1)(i);         // (&x)->f(i)
bind(&X::f, x, _1)(i);          // (internal copy of x).f(i)
bind(&X::f, p, _1)(i);          // (internal copy of p)->f(i)

The last two examples are interesting in that they produce "self-contained"
function objects. 

bind(&X::f, x, _1) `stores a 'copy of x`  *cpp-this*
bind(&X::f, p, _1) stores a copy of p, and since p is a boost::shared_ptr, the
function object 'retains' a reference to its instance of X and will remain
valid 'even' when p goes out of scope or is reset(). 


<ex> *cpp-fobj-has-state*
The idea is that function object keep state, playspeed, in this case and use
that state when is asked to raise an event.

class SpeedChangeSender
{
public:
    SpeedChangeSender(const boost::shared_ptr<MockMediaRouter>& mock)
        : mock(mock),
        playSpeed(std::numeric_limits<double>::quiet_NaN())
    {}

    void sendSpeedChangeEvent(double newPlaySpeed)
    {
        if(newPlaySpeed != playSpeed)
        {
            VANADIUM_TRACE("Sending SpeedChangeEvent old speed: " << playSpeed
                    << " newPlaySpeed " << newPlaySpeed);
            mock->emitSpeedChangeEvent();
            playSpeed = newPlaySpeed;
        }
    }

private:
    boost::shared_ptr<MockMediaRouter> mock;
    double playSpeed;
};


void registerMockForCanPlayAndPauseVideo()
{
    Sequence s;

    // create a mock object
    boost::shared_ptr<MockMediaRouter> mock = makeMock("http://bb.mpd");

    // create a object
    boost::shared_ptr<SpeedChangeSender> speedChangeSender
        = boost::make_shared<SpeedChangeSender>(mock);

    // first play call and will update function object
    // NS_ZINC::Future<void> GstMediaRouter::setPlaySpeed(const double speed);
    // _1 is "1.0"

    EXPECT_CALL(*mock, setPlaySpeed(1.0)).InSequence(s).WillOnce(
                DoAll(Invoke(boost::bind(&SpeedChangeSender::sendSpeedChangeEvent,
                            speedChangeSender, _1)),
                    Return(makeCompletedFuture())));

    EXPECT_CALL(*mock, start()).WillOnce(
            Return(makeCompletedFuture()));

    // pause and will update function object
    EXPECT_CALL(*mock, setPlaySpeed(0.0)).InSequence(s).WillOnce(
                DoAll(Invoke(boost::bind(&SpeedChangeSender::sendSpeedChangeEvent,
                            speedChangeSender, _1)),
                    Return(makeCompletedFuture())));

    // second play call and will update function object
    EXPECT_CALL(*mock, setPlaySpeed(1.0)).InSequence(s).WillOnce(
                DoAll(Invoke(boost::bind(&SpeedChangeSender::sendSpeedChangeEvent,
                            speedChangeSender, _1)),
                    Return(makeCompletedFuture())));
}


<ex> member-function see *cpp-member-function-address*

void SystemClientEventRepository::eventsReceived(
  boost::shared_ptr<X> command, const NS_ZINC::FutureValue<Y>& eventsFV)
{}


// defines a function pointer to a member function and set it

void (SystemClientEventRepository::*masCallback)
   (boost::shared_ptr<X>, const NS_ZINC::FutureValue<Y> &) = 
   &SystemClientEventRepository::eventsReceived;


bar.addWithCallback(fMASEvents, boost::bind(masCallback, `this`, sharedCmd, _1));


<ex>
{
    const std::vector<std::string> v{"We", "are", " the champions!"};

    const std::size_t count0 = std::count_if(v.cbegin(), v.cend(),
            [](const std::string &s) { return s.empty(); });

    // string's empty member function
    const std::size_t count1 = std::count_if(v.cbegin(), v.cend(),
            boost::bind(&std::string::empty, _1));

    cout << "count0: " << count0 << ", count1: " << count1 << endl;
}


<ex>
not use passed parameter but instead use 'this' pointer.

VirtualBinSrc::VirtualBinSrc()
{
  // note: here bind() do some magic

  elementFactory["application/dash+xml"] =
    boost::bind(&VirtualBinSrc::makeAndSetupDecodebin, `this`,
        "video/quicktime; audio/x-m4a; text/x-raw");
}

typedef std::map<std::string,
    boost::function<RefObj<GstElement>()> > FactoryContainer;

RefObj<GstElement> 
    VirtualBinSrc::makeAndSetupDecodebin(const char* const outputCaps);

Use:

FactoryContainer elementFactory;

FactoryContainer::iterator it = elementFactory.find(mediaType);

RefObj<GstElement> upstream = it->second();

The "it->second" is callable and "it->second()" calls with no argument with
returns RefObj<GstElement>.

RefObj<GstElement> 
    VirtualBinSrc::makeAndSetupDecodebin
        ("video/quicktime; audio/x-m4a; text/x-raw");


<ex>
// uses

NS_ZINC::Future< int32_t > ProxyMediaRouter::getMediaDuration() const {

    scoped_lock lock(mutex);

    return deferForwardOrDefault(
            boost::bind(&MediaRouter::getMediaDuration, _1),
            properties.mediaDuration.get_value_or(0));
}

NS_ZINC::Future< Position > ProxyMediaRouter::getPosition() const {
    return deferForwardOrDefault(
            boost::bind(&MediaRouter::getPosition, _1), 
            Position());
}


// deferred

template <typename T>
struct future_type;

template <typename T>
struct future_type<NS_ZINC::Future<T> > {
    typedef T type;
};

template<typename Functor>
struct returned_future_type {
    typedef typename future_type<typename Functor::result_type>::type type;
};

// 

struct AbstractDeferredCall {
    virtual ~AbstractDeferredCall() {}

    virtual void operator()(const MediaRouter* mediaRouter) = 0;
};

template<typename Functor, typename T>
class DeferredCall : public AbstractDeferredCall {

    public:

        DeferredCall(boost::shared_ptr<NS_ZINC::Dispatcher> dispatcher, Functor method_) :
            promise(*dispatcher),
            method(method_) {
            }

        NS_ZINC::Future<T> getFuture() {
            return promise.getFuture();
        }

        void operator()(const MediaRouter* mediaRouter) {
            method(const_cast<MediaRouter*>(mediaRouter))
                .then(boost::bind(&chainedComplete<T>, promise, _1));
        }

    private:

        NS_ZINC::Promise<T> promise;
        Functor method;
};


class ZINC_LOCAL ProxyMediaRouter : public MediaRouter
{
    mutable boost::ptr_deque<AbstractDeferredCall> deferredCalls;
};


template<typename Functor>
typename Functor::result_type ProxyMediaRouter::deferCall(Functor f) const {

    typedef typename returned_future_type<Functor>::type T;

    std::auto_ptr<DeferredCall<Functor, T> > deferred
        (new DeferredCall<Functor, T>(dispatcher, f));

    NS_ZINC::Future<T> future(deferred->getFuture());
    deferredCalls.push_back(deferred);
    return future;
}


// mmeber-template

template<typename Functor> typename Functor::result_type 
    ProxyMediaRouter::deferForwardOrDefault(Functor f,
    const typename returned_future_type<Functor>::type& defaultValue) const
{
    typedef typename returned_future_type<Functor>::type T;

    scoped_lock lock(mutex);

    // flag if sourcing is completed or not and ture when it's not completed.
    if (sourcing) {
        // the sourcing is ongoing and defer a call.
        return deferCall(f);
    }

    // return default
    //
    // lastSource is a string and is set when sourcing is completed. isSourced
    // return 
    //  true when the string is not empty.
    //  false when the string is empty
    if (!isSourced())
    {
        // 
        return NS_ZINC::completedFuture<T>(*dispatcher, defaultValue);
    }

    // forward to impl
    return f(impl.get());
}


// This is called by SetSourceContinuation::complete(). The idea is to contain
// all the state manipulation in one place.
//
// That is when continuation which has many calles in chain completes and defer
// any calls to be handled when complete() is called an this when the object is
// in right state.

void ProxyMediaRouter::setSourceComplete
{
    scoped_lock lock(mutex);

    ...

    // Some calls may have been deferred whilst we were setting the source.
    // process those now, but stop if one of them is a call to setSource().
    // FIXME Does not check for setSource() - should it?

    while (!deferredCalls.empty() && !sourcing) {
        deferredCalls.front()(this);
        deferredCalls.pop_front();
    }
}


={============================================================================
*kt_dev_stl_060* cpp-algo

Algorithms are not member functions of the container classes and do not work
directly on a container. All in all, this concept reduces the amount of code
and increases the power and the flexibility of the library. 

Operates in terms of iterators and container independent but element type
dependent; means that do not use container's operations (don't add/remove
    items but write/move items) but use operations on element such as '==',
'<', or '+'. 

This is not an object-oriented programming paradigm; it is a generic
functional programming paradigm. However, this concept also has its price: 

First, the usage is not intuitive. 

Second, some combinations of data structures and algorithms might not work.
Even worse, a combination of a container type and an algorithm might be
possible but not useful (for example, it may lead to bad performance).

<key>
Thus, it is important to learn the 'concepts' and the 'pitfalls' of the STL to
benefit from it without abusing it.

<ex> algo-max-element algo-min-element algo-find algo-sort algo-reverse
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
  vector<int> coll{2,5,4,1,6,3};

  // find and print min and max. 
  // If there is more than one minimum element, the algorithm returns the first.
  auto minpos = min_element( coll.cbegin(), coll.cend() );
  cout << "min: " << *minpos << endl;

  auto maxpos = max_element( coll.cbegin(), coll.cend() );
  cout << "max: " << *maxpos << endl;

  // sort
  sort( coll.begin(), coll.end() );

  // find the first with value 3
  // no cbegin since used in reverse() later. otherwise, compile error in reverse
  auto pos3 = find( coll.begin(), coll.end(), 3 );

  // reverse the order of the found and all following elements
  reverse( pos3, coll.end() );

  for( const auto &elem : coll )
    cout << elem << ' ';
  
  cout << endl;
}

min: 1
max: 6
1 2 6 5 4 3 


{algorithm-category}
There is architecture or the unifying principles that categorise 100+
algorithms: according to what do on container or required arguments. Be
careful since algorithms have assumtions and use right iter for a algo
according to iter category since compilers will 'not' complain.

According to parameter patterns:

alg( beg, end, other args );

// assumes dest is big enough as with range one to 'overwrite'
alg( beg, end, dest, other args );     

// assumes beg2 is big enough as with range one
alg( beg, end, beg2, other args );     

alg( beg, end, beg2, end2, other args );


<ex> algorithm-accumulate
The third argument determines which addition operator is used and the type of
return. Seems clever.

int sum = accumulate( vec.cbegin(), vec.cend(), 0 );
string sum = accumulate( vec.cbegin(), vec.cend(), string(""));


{assumption-on-ranges}
<single-range>
To be able to handle subsets of container elements, you pass the beginning and
the end of the range as two separate arguments rather than the whole
collection. This interface is flexible but dangerous.

The caller must ensure that the first and second arguments define a valid
range. Otherwise, the behavior is 'undefined', and endless loops or forbidden
memory access may result. This means that it is up to the programmer to ensure
that.

Two things about 'valid' range when [beg, end) use with algorithm:

1. The range do not include end.

2. `The beg must come 'first' in order.` Othewise, it is not valid range and
   'undefined'.

3. The range shall exist.

// fill_n( dest, size, value ) and assumes that vec is 10 size at least. so if
// there is no 10 elements before calling fill_n then undefined.

vector<int> vec;
fill_n( vec.begin(), 10, 0 );

<multiple-range>
Assumption on the second range is it as big as the first since the number of
elements of the second is 'deduced' from the first range. If not, undefined.
For example, copy algorithm 'overwrite' rather then 'insert'.

This is for only sequence containers with algorithms because associative and
unordered containers cannot be used as a destination for overwriting
algorithms.

// reads

equal( one.cbegin(), one.cend(), two.cbegin() );   // assumes two >= one

// write, 'destination'

// coll2 must have enough room to copy
copy (coll1.cbegin(), coll1.cend(), coll2.begin()); // destination


{copy-version} algo-replace, algo-reverse
Independent-between-sequences/containers. The element types need not be the
exactly same as long as can use element operators or compatible between them.
This is also an example of copying version in algorithm.

replace( ilst.begin(), ilst.end(), 0, 42 );
// replace any element with 0 with 42

replace_copy( ilst.begin(), ilst.end(), back_inserter(ivec), 0, 42 );
// to leave the original sequence unchanged. in this case, copy list to vector.

// copy version
reverse( beg, end );
reverse_copy( beg, end, dest );


{if-version} algo-find
Algorithm that takes an element value typically have a second named version
that takes a predicate in place of the value. Compared to overloaded version.

// if version
// If there is a match, returns an iterator to the first element and if not,
// return end iterator.

find( beg, end, val );
find_if( beg, end, pred );

// overloaded version
unique( beg, end );
uniqie( beg, end, comp );


={============================================================================
*kt_dev_stl_069* cpp-algo-nonmodifying

<algo-equal> determines whether two sequences are equal
bool equal (InputIterator1 beg, InputIterator1 end, InputIterator2 cmpBeg)
bool equal (InputIterator1 beg, InputIterator1 end, InputIterator2 cmpBeg, BinaryPredicate op)

The caller must ensure that the range starting with cmpBeg contains enough
elements. 

Complexity: 
linear (at most, numElems comparisons or calls of op(), respectively).

#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

using namespace std;

// note: no half-open range
template<typename T>
inline void INSERT_ELEMENTS( T& coll, int first, int last )
{
  for( int i = first; i <= last; i++ )
    coll.insert( coll.end(), i );
}

template<typename T>
inline void PRINT_ELEMENTS( T& coll, const std::string& optcstr="")
{
  cout << optcstr;

  for( auto &elem : coll )
    cout << elem << ' ';

  cout << endl;
}
bool bothEvenOrOdd( int elem1, int elem2 )
{
  return elem1 %2 == elem2 %2;
}

int main()
{
  vector<int> coll1;
  list<int> coll2;
  list<int> coll3;

  INSERT_ELEMENTS( coll1, 1, 7 );
  INSERT_ELEMENTS( coll2, 3, 9 );
  INSERT_ELEMENTS( coll3, 1, 7 );

  PRINT_ELEMENTS( coll1, "coll1(vector): " );
  PRINT_ELEMENTS( coll2, "coll2(list)  : " );
  PRINT_ELEMENTS( coll3, "coll3(list)  : " );

  cout << endl;

  if( equal( coll1.begin(), coll1.end(),  // first range
        coll2.begin()))                   // second range
  {
    cout << "coll1 == coll2" << endl;
  }
  else 
    cout << "coll1 != coll2" << endl;

  cout << endl;

  if( equal( coll1.begin(), coll1.end(),  // first range
        coll3.begin()))                   // second range
  {
    cout << "coll1 == coll3" << endl;
  }
  else 
    cout << "coll1 != coll2" << endl;

  cout << endl;

  // check for corresponding even and odd elements
  if( equal( coll1.begin(), coll1.end(),  
        coll2.begin(),
        bothEvenOrOdd ))                // comparison criterion
  {
    cout << "coll1 and coll2, even and odd elements correspond" << endl;
  }
  else
    cout << "coll1 and coll2, even and odd elements do not correspond" << endl;
}

coll1(vector): 1 2 3 4 5 6 7 
coll2(list)  : 3 4 5 6 7 8 9 
coll3(list)  : 1 2 3 4 5 6 7 

coll1 != coll2

coll1 == coll3

coll1 and coll2, even and odd elements correspond


<algo-is-permutation> testing for unordered equality
bool is_permutation (ForwardIterator1 beg1, ForwardIterator1 end1, ForwardIterator2 beg2)
bool is_permutation (ForwardIterator1 beg1, ForwardIterator1 end1, ForwardIterator2 beg2, CompFunc op)

1. These algorithms are available since C++11.

2. The first form compares the elements by using operator ==.

3. The second form compares the elements by using the binary predicate
   op(elem1,elem2) which should return true when elem1 is equal to elem2.

4. Complexity: at worst quadratic (numElems1 comparisons or calls of op(), if
   all elements are equal and have the same order).

#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <algorithm>

using namespace std;

// note: no half-open range
template<typename T>
inline void INSERT_ELEMENTS( T& coll, int first, int last )
{
  for( int i = first; i <= last; i++ )
    coll.insert( coll.end(), i );
}

template<typename T>
inline void PRINT_ELEMENTS( T& coll, const std::string& optcstr="")
{
  cout << optcstr;

  for( auto &elem : coll )
    cout << elem << ' ';

  cout << endl;
}
bool bothEvenOrOdd( int elem1, int elem2 )
{
  return elem1 %2 == elem2 %2;
}

int main()
{
  vector<int> coll1 = { 1, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
  list<int> coll2 = { 1, 9, 8, 7, 6, 5, 4, 3, 2, 1 };
  deque<int> coll3 = { 11, 12, 13, 19, 18, 17, 16, 15, 14, 11 };

  PRINT_ELEMENTS( coll1, "coll1(vector): " );
  PRINT_ELEMENTS( coll2, "coll2(list)  : " );
  PRINT_ELEMENTS( coll3, "coll3(deque) : " );

  cout << endl;

  if( is_permutation( coll1.cbegin(), coll1.cend(), // first range
        coll2.cbegin()))                            // second range
  {
    cout << "coll1 == coll2" << endl;
  }
  else 
    cout << "coll1 != coll2" << endl;

  cout << endl;

  if( equal( coll1.cbegin(), coll1.cend(),  // first range
        coll2.cbegin()))
  {
    cout << "coll1 == coll2" << endl;
  }
  else 
    cout << "coll1 != coll2" << endl;

  cout << endl;

  // check for corresponding even and odd elements
  if( is_permutation( coll1.cbegin(), coll1.cend(),  
        coll3.cbegin(),
        bothEvenOrOdd ))                // comparison criterion
  {
    cout << "coll1 and coll3, even and odd elements correspond" << endl;
  }
  else
    cout << "coll1 and coll3, even and odd elements do not correspond" << endl;
}

coll1(vector): 1 1 2 3 4 5 6 7 8 9 
coll2(list)  : 1 9 8 7 6 5 4 3 2 1 
coll3(deque) : 11 12 13 19 18 17 16 15 14 11 

coll1 == coll2

coll1 != coll2

coll1 and coll3, even and odd elements correspond


<algo-count-if> count elements
difference_type count (InputIterator beg, InputIterator end, const T& value)
difference_type count_if (InputIterator beg, InputIterator end, UnaryPredicate op)

1. The first form counts the elements in the range [beg,end) that are equal to
value value.  

2. Complexity: linear (numElems comparisons or calls of op(), respectively).  

3. Associative and unordered containers provide a similar member function,
count(), to count the number of elements that have a certain value as key

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

template<typename T>
inline void INSERT_ELEMENTS( T& coll, int first, int last )
{
  for( int i = first; i <= last; i++ )
    coll.insert( coll.end(), i );
}

template<typename T>
inline void PRINT_ELEMENTS( T& coll, const std::string& optcstr="")
{
  cout << optcstr;

  for( auto &elem : coll )
    cout << elem << ' ';

  cout << endl;
}

int main()
{
  vector<int> coll;
  int num;

  INSERT_ELEMENTS( coll, 1, 9 );
  PRINT_ELEMENTS( coll, "coll: " );

  // count elements with value 4
  num = count( coll.cbegin(), coll.cend(), 4 );
  cout << "number of elements equal to 4:      " << num << endl;

  // count elements with even value
  num = count_if( coll.cbegin(), coll.cend(), 
              [] (int elem) {
                return elem%2==0;
                });
  cout << "number of elememts with even value: " << num << endl;

  // count elements that are greater than 4
  num = count_if( coll.cbegin(), coll.cend(), 
              [] (int elem) {
                return elem > 4;
                });
  cout << "number of elememts than 4         : " << num << endl;

  return 0;
}

coll: 1 2 3 4 5 6 7 8 9 
number of elements equal to 4:      1
number of elememts with even value: 4
number of elememts than 4         : 5


<ex>
template<typename C, typename P>
int count (const C& c, P pred)
{
  int cnt = 0;

  for (const auto &x : c)
    if (pred(x))
      ++cnt;

  return cnt;
}


={============================================================================
*kt_dev_stl_070* cpp-algo-copy

CLR 11.6

There are two ways to modify elements:

1. Modify them directly while iterating through a sequence.
2. Modify them while copying them from a source range to a destination range.

Can't use an associative or unordered container as a destination range, because
the elements in these containers are constant. 

All algorithms that have a separate destination range return the position after
the last copied element of that (destination) range.


{algo-copy}

OutputIterator
copy (InputIterator sourceBeg, InputIterator sourceEnd,
      OutputIterator destBeg)


<ex> *algo-copy*
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

using namespace std;

int main()
{
  vector<int> coll;

  for(int i=1; i <= 6; i++)
    coll.push_back(i);

  for(int i=0; i < coll.size(); i++)
     cout << coll[i] << ' ';

  cout << endl;
  cout << "-----------" << endl;

  auto first = find( coll.begin(), coll.end(), 300 );
  auto last = find( coll.begin(), coll.end(), 3 );

  copy (first, last, ostream_iterator<int>( cout, ","));

  cout << "-----------" << endl;
}

The copy() statement is illegal because [first, last) not a vaild range; indeed
first may actually be after last.

The first is coll.end() and the last is dereferencible iterator. The copy
requires that first 'must' be a valid range. The likely symptom will be a
difficult-to-diagnose core dump during or sometime after the copy.

The real result is that it works fine with release and emits errors with debug
build:

$ ./a.out 
1 2 3 4 5 6 
-----------
/usr/include/c++/4.7/bits/stl_algobase.h:450:error: function requires a 
    valid iterator range [__first, __last).

Objects involved in the operation:
iterator "__first" @ 0x0xbfd49b18 {
type = N11__gnu_debug14_Safe_iteratorIN9__gnu_cxx17__normal_iteratorIPiNSt9
       __cxx19986vectorIiSaIiEEEEENSt7__debug6vectorIiS6_EEEE (mutable iterator);
  state = past-the-end;
  references sequence with type `NSt7__debug6vectorIiSaIiEEE' @ 0x0xbfd49b18
}
iterator "__last" @ 0x0xbfd49b04 {
type = N11__gnu_debug14_Safe_iteratorIN9__gnu_cxx17__normal_iteratorIPiNSt9
  __cxx19986vectorIiSaIiEEEEENSt7__debug6vectorIiS6_EEEE (mutable iterator);
  state = dereferenceable;
  references sequence with type `NSt7__debug6vectorIiSaIiEEE' @ 0x0xbfd49b04
}
Aborted


<ex>
From EXPC++ 05. Snippet to show the queston: How does algo-copy work when the
type of source and dest is differen? That is when T and O different?

template<typename T, size_t size>
class fixed_vector
{
  private:
    T v_[size];

  public:
    fixed_vector() {}

    template<typename O, size_t osize>
      fixed_vector( const fixed_vecto<O, osize>& other )
      {
        copy( other.begin(),
              other.begin()+min(size, osize),
              begin() );
      }
};

Why? As all example of algo-copy uses the same element type, so the assignment
is built-in assignment.

        *to_pos = *from_pos;  // copy values

When tries different types, shows the error:

#include <iostream>
#include <vector>
#include <list>
#include <string>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  vector<int> coll{1,2,3,4,5,6};

  PRINT_ELEMENTS(coll, "initialized: " );

  // list<int> coll1;
  list<string> coll1;
  copy( coll.begin(), coll.end(), inserter(coll1, coll1.begin()));

  PRINT_ELEMENTS(coll1, "list       : " );
}


t_algo_copy.cpp:28:65:   required from here
/usr/include/c++/4.7/bits/stl_algobase.h:329:8: error: invalid user-defined
conversion from ‘int’ to ‘std::list<std::basic_string<char> >::value_type&& {aka
  std::basic_string<char>&&}’ [-fpermissive]


={============================================================================
*kt_dev_cpp_000* cpp-stream cpp-cout cpp-cin

C++LR 15.1.2 Stream Classes

Just as there are different kinds of I/O  for example, input, output, and file
access  there are different classes depending on the type of I/O. The
following are the most important stream classes:

o Class istream defines input streams that can be used to read data.
o Class ostream defines output streams that can be used to write data.

Both classes are instantiations of the class templates basic_istream<> or
basic_ostream<>, respectively, using char as the character type.


15.3.2 Input Operator >>

The class basic_istreamand thus also the classes istream and wistream defines
>> as an input operator. Similar to basic_ostream, this operator is overloaded
for `almost all fundamental types`, excluding void and nullptr_t, as well as
  for char* and void*.

To make this possible, `leading whitespace is skipped by default` However,
   this automatic skipping of whitespace can be turned off (see Section
       15.7.7, page 789).

15.7.7 General Formatting Definitions

By default, ios::skipws is set, which means that leading whitespaces are
skipped by operator >>. 

Often, it is useful to have this flag set. For example, with it set, reading
the separating spaces between numbers explicitly is not necessary. However,
this implies that reading space characters using operator >> is not possible
  because leading whitespaces are always skipped.  
  
<ex>
{
    int a, b;
    cout << "={ t_stream_02 = " << endl;

    while (cin >> a >> b) 
    {
        cout << "a: " << a << ", b: " << b << std::endl;
    }

    cout << "=} t_stream_02 = " << endl;
}

$ ./a.out
={ t_stream_02 =
123 456
a: 123, b: 456
123456







                    // press ctrl-d
=} t_stream_02 =


o By default, operator >> skips whitespace (that is, spaces, tabs, newlines,
  etc.). ch==0 indicates end-of-input, ctrl-d.

The `whitespace` is used as a separator.

<ex>
#include <iostream>
#include <string>
#include <map>

using namespace std;

// C++PL, 10.2. A DESK CALCULATOR
//
// usage ex:
//
// (input) r = 2.5
// 2.5
// 
// (input) area = pi * r * r
// (pi is predefined) the calculator program will write
// 19.635
//
// The calculator consists of four main parts: a parser, an input function, a
// symbol table, and a driver. Actually, it is a miniature compiler in which the
// parser does the syntactic analysis, the input function handles input and
// lexical analysis, the symbol table holds permanent information, and the
// driver handles initialization, output, and errors.
//
// Terminal symbols (for example, end(eoi), number, +, and - ) are recognized by
// a lexical analyzer and 
//
// nonterminal symbols are recognized by the syntax analyzer functions, expr(),
// term(), and prim().
//
// As soon as both operands of a (sub)expression are known, the expression is
// evaluated; in a real compiler, code could be generated at this point.


// symbol table
map<string, double> table;

int no_of_errors;

double error(const string &s)
{
    no_of_errors++;

    cerr << "error: " << s << endl;
    return 1;
}

// token and tokenizer
enum class Kind: char
{
    name, number, end,
    plus = '+', minus = '-', mul = '*', div = '/', print = ';',
    assign = '=', lp = '(', rp = ')'
};

struct Token
{
    Kind kind;
    string string_value;
    double number_value;
};

// to determine what kind of lexical token
class Token_stream
{
    public:

        // note
        // Token_stream implements the convention that it owns (and eventually
        // deletes; §3.2.1.2, §11.2) an istream passed as a pointer, but not an
        // istream passed as a reference.
        Token_stream(istream &s): ip{&s}, owns{false} {}
        Token_stream(istream *p): ip{p}, owns{true} {}

        ~Token_stream() { close(); }

        // read and return next token
        Token get();

        // most recently read token
        Token &current() { return ct; }

        void set_input(istream &s) { close(); ip = &s; owns = false; }
        void set_input(istream *p) { close(); ip = p; owns = true; }

    private:
        void close() { if (owns) delete ip; }

        // pointer to an input stream
        istream *ip;

        // does the Token_stream own the istream?
        bool owns;

        // current token
        //
        // note
        // gave ct a default value because it seemed sloppy not to. People
        // should not call current() before get(), but if they do, they get a
        // well-defined Token. I chose Kind::end as the initial value for ct so
        // that a program that misuses current() will not get a value that
        // wasn’t on the input stream.
        //
        // note
        // a complete object
        Token ct{Kind::end};
};


Token Token_stream::get()
{
    char ch = 0;

    // read a char at a time
    *ip >> ch;

#ifdef SOLVE_PROBLEMS
	do {	// skip whitespace except '\n' and return when see null(eoi)
		if(!ip->get(ch)) return ct = {Kind::end};
	} while (ch!='\n' && isspace(ch));
#endif

    switch (ch)
    {
        // handle end of input
        //
        // By default, operator >> skips whitespace (that is, spaces, tabs,
        // newlines, etc.), ch==0 indicates end-of-input.
        case 0:

            // assign and return
            // 
            // note that assigning a complete object {Kind::end} is clearer than
            // dealing with individual members of ct. The {Kind::end} is
            // equivalent to {Kind::end,0,0}.
            cout << "token: eol" << endl;
            return ct = {Kind::end};

        // handle operators
        case ';':   // end of expression; print

#ifdef SOLVE_PROBLEMS
// problem #1
//
// It is tedious to remember to add a semicolon after an expression in order to
// get its value printed
//
        case '\n':
            return ct = {Kind::print};
#endif
        case '*':
        case '/':
        case '+':
        case '-':
        case '(':
        case ')':
        case '=':
            return ct = {static_cast<Kind>(ch)};

        case '0': case '1': case '2': case '3': case '4': case '5': 
        case '6': case '7': case '8': case '9': case '.':
            ip->putback(ch);
            *ip >> ct.number_value;
            ct.kind = Kind::number;
            return ct;

        // If the token is not the end of input, an operator, a punctuation
        // character, or a number, it must be a name.
        default:

#ifndef SOLVE_PROBLEMS
            if (isalpha(ch)) {
                ip->putback(ch);
                *ip >> ct.string_value;
                ct.kind = Kind::name;

                return ct;
            }
#endif

#ifdef SOLVE_PROBLEMS

// problem #2
//
// The problem caused by >> reading into a string until whitespace is
// encountered is solved by reading one character at a time until a character
// that is not a letter or a digit is found:
//
// x=7 is an identifier  rather than the identifier x followed by the operator =
// and the number 7. To get what we (usually) want, we would have to add
// whitespace after x: x =7. 
//
// (input) r=25; 
// r=25
//
// (input) r =25; 
// 25

            if (isalpha(ch)) { ct.string_value = ch;

                while (ip->get(ch))
                {
                    if (isalnum(ch))
                        ct.string_value += ch;
                    else
                    {
                        ip->putback(ch);
                        break;
                    }
                }

                ct.kind = Kind::name;

                return ct;
            }

#endif

            // Finally, we may simply have an error.
            error("bad token");
            return ct = {Kind::print};
    }
}


// user input from cin
Token_stream ts{cin};

double expr (bool get);


// handle primaries
//
// Note that prim() always reads one more Token than it uses to analyze its
// primary expression.


double prim (bool get)
{
    // read next token
    if (get) ts.get();

    switch (ts.current().kind)
    {
        case Kind::number:
            {
                double v = ts.current().number_value;

                // problem #1
                // It is tedious to remember to add a semicolon after an expression in order to
                // get its value printed
                ts.get();

                return v;
            }
        case Kind::name:
            {
                double &v = table[ts.current().string_value];


                // Before doing anything to a name, the calculator must first
                // look ahead to see if it is being assigned to or simply read.
                if (ts.get().kind == Kind::assign) v = expr(true);
                return v;
            }
        case Kind::minus:
            {
                return -prim(true);
            }
        default:
            return error("primary expected");
    }
}

// handle multiplication and division
double term (bool get)
{
    double left = prim (get);

    for (;;)
    {
        switch (ts.current().kind)
        {
            case Kind::mul:
                left *= prim (true);
                break;
            case Kind::div:

                // The variable d is introduced into the program exactly where
                // it is needed and initialized immediately. 
                if (auto d = prim(true))
                {
                    left /= d;
                    break;
                }

                return error("divide by 0");

            default:
                return left;
        }
    }
}


// handles addition and substraction
double expr (bool get)
{
    double left = term (get);

    for (;;) 
    {
        switch (ts.current().kind) 
        {
            case Kind::plus:
                left += term (true);
                break;

            case Kind::minus:
                left -= term (true);
                break;
            default:
                return left;
        }
    }
}


//////////////////////////////////////////////////////////////////////////////
// The Driver

void calculate()
{
    for (;;)
    {
        ts.get();

        if (ts.current().kind == Kind::end) break;
        if (ts.current().kind == Kind::print) continue;
        cout << expr (false) << '\n';
    }
}

int main()
{
    table["pi"] = 3.1415926535897932385;   // insert predefined names
    table["e"] = 2.7182818284590452354;

    calculate();

    return no_of_errors;
}


={============================================================================
*kt_dev_stl_070* cpp-string

C++ SLR 13.

The string classes of the C++ standard library enable you to use strings as
normal types that cause no problems for the user. Thus, you can copy, assign,
and compare strings as fundamental types without worrying about whether there
  is enough memory or how long the internal memory is valid.

Note that since C++11, reference counted implementations are not permitted any
longer. The reason is that an implementation that lets strings share internal
buffers doesn't work in multithreaded contexts.

The string classes are an example of the 'invasive' approach of writing STL
containers. Strings can be considered containers of characters. The characters
inside the string build a sequence over which you can iterate to process the
individual characters. Thus, the standard string classes provide the container
interface of the STL.


{string-vs-vector}
This is no surprise because both are containers that are typically implemented
as dynamic arrays. Thus, you could consider a string as a special kind of a
vector that has characters as elements.

However, considering a string as a special kind of vector is dangerous because
there are many fundamental differences between the two. Chief among these are
their two primary goals:

1. The primary goal of vectors is to handle and to manipulate the 'elements'
of the container, not the container as a whole. Thus, vector implementations
are optimized to operate on elements inside the container.

2. The primary goal of strings is to handle and to manipulate the container,
  the string, as a whole. Thus, strings are optimized to reduce the costs of
  assigning and passing the whole container.

These different goals typically result in completely different
implementations.


{sting-size-type-and-npos}
All these find functions return an index of the first matching position. the
return value is an `integer and not an iterator.` The usual interface for
strings is not based on the concept of the STL. However, some iterator support
for strings is provided

*cpp-size-t*
The return type of all find functions is `string::size_type`, which is machine
independent. Although don't know the precise type of it, do know it's
'unsigned' integral type. So careful not to mix signed and unsigned data. For
example, s.size() < n.


{string-element-access}
Accessing a single character of the string is done with operator[]. All these
operations return a reference to the character

1. An argument specifying the index must have a 'valid' value. That value must
be less than the number of characters of the string. As usual, the first
character has index 0, and the last character has index length()-1. 

In addition, the index of the position after the last character could be used
to specify the end.

string s[s.length()];      // OK
string s.at(s.length());   // ERROR. the # of characters is 'not' a valid index.

The operator[] does 'not' check whether the index of the string is valid. Thus
a safer way to access a character is to use the at() member since at() throws
an out_of_range exception. 

However, such a check costs runtime, so the check is 'not' provided for the
usual accessing of characters of a string. A good way is to aviod subscripting
altogether by using a range-for whenever possible. However not all compiler
supports. *cpp-range-for*

*cpp-string-npos*
note: However, all functions that search for a character or a position allow
any index. If the index exceeds the number of characters, these functions
simply return `string::npos` ("not found").

2. An argument specifying the number of characters could have 'any' value. If
the size is greater than the remaining number of characters, all remaining
characters are used. string::npos always works as a 'synonym' for "all
remaining characters." or "until the end of the string". 

Why? -1, which because size_t is an unsigned integral type, it is the largest
possible representable value for this type.

Thus, the following expression throws an exception if the period is not found:
note: no exception under gcc 4.6.3.


<front-and-back>
Since C++11, front() and back() are provided to also access the first or last
character, respectively. When called for an empty string, back() results in
undefined behavior.


<ex> cpp-string-find cpp-string-substr cpp-string-replace

13.1.1 A First Example: Extracting a Temporary Filename

#include <iostream>
#include <string>

using namespace std;

int main(int argc, char* argv[])
{
  string filename, basename, extname, tmpname;

  const string suffix{"tmp"};

  // for each command line args
  while( --argc > 0 )
  // for( int i = 1; i < argc; i++ )
  {
    // filename = argv[i];
    filename = *++argv;

    // search period in filename note: searches for the 'first' occurrence of a
    // period inside the string filename and return position. If the search
    // fails, a special value is needed to return the failure. That value is
    // npos.

    string::size_type idx = filename.find('.');
    if( idx == string::npos )
    {
      // filename does not contain any period
      tmpname = filename + '.' + suffix;
    }
    else
    {
      // split filename into basename(before period) and extension(after period)
      //
      // note: The first parameter of the substr() function is the 'starting'
      // index. The `optional second argument` is the 'number' of characters, not
      // the end index. If the second argument is not used, all remaining
      // characters of the string are returned as a substring.

      basename  = filename.substr(0, idx);
      extname   = filename.substr(idx+1);

      if( extname.empty() )
      {
        // contains period but no extension
        tmpname = filename + suffix;
      }
      else if( extname == suffix )
      {
        // replace tmp with xxx
        tmpname = filename;
        tmpname.replace( idx+1, extname.size(), "xxx" );
      }
      else
      {
        // replace any with tmp
        tmpname = filename;
        tmpname.replace( idx+1, string::npos, suffix ); 
      }
    }

    // print filename and temporary name
    cout << filename << " => " << tmpname << endl;
  }
}

$ string1 prog.dat mydir hello. oops.tmp end.dat
prog.dat => prog.tmp
mydir => mydir.tmp
hello. => hello.tmp
oops.tmp => oops.xxx
end.dat => end.tmp


={============================================================================
*kt_dev_stl_071* cpp-string-code

{string-type}

// bits/stringfwd.h

namespace std {
  template <typename charT,
           typename traits = char_traits<charT>,
           typename Allocator = allocator<charT> >
             class basic_string;

  typedef basic_string<char> string;
}

// bits/ allocator.h

  /**
   * @brief  The @a standard allocator, as per [20.4].
   *
   *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt04ch11.html
   *  for further details.
   *
   *  @tparam  _Tp  Type of allocated object.
   */
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      // *cpp-size-t*
      typedef size_t     size_type;
    };

// bits/basic_string.h

  // 21.3  Template class basic_string
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;

      // Types:
      public:
      typedef _Traits                                 traits_type;
      typedef typename _Traits::char_type             value_type;
      typedef typename _CharT_alloc_type::size_type   size_type;

      /**
       *  @brief  Construct string as copy of a C string.
       *  @param  __s  Source C string.
       *  @param  __a  Allocator to use (default is default allocator).
       */
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());

      /**
       *  @brief  Compare to a string.
       *  @param __str  String to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Returns an integer < 0 if this string is ordered before @a
       *  __str, 0 if their values are equivalent, or > 0 if this
       *  string is ordered after @a __str.  Determines the effective
       *  length rlen of the strings to compare as the smallest of
       *  size() and str.size().  The function then compares the two
       *  strings by calling traits::compare(data(), str.data(),rlen).
       *  If the result of the comparison is nonzero returns it,
       *  otherwise the shorter one is ordered first.
       */
      int
        compare(const basic_string& __str) const
        {
          const size_type __size = this->size();
          const size_type __osize = __str.size();
          const size_type __len = std::min(__size, __osize);

          // note:
          int __r = traits_type::compare(_M_data(), __str.data(), __len);
          if (!__r)
            __r = _S_compare(__size, __osize);
          return __r;
        }
    };

// bits/char_traits.h

  /**
   *  @brief  Base class used to implement std::char_traits.
   *
   *  @note For any given actual character type, this definition is
   *  probably wrong.  (Most of the member functions are likely to be
   *  right, but the int_type and state_type typedefs, and the eof()
   *  member function, are likely to be wrong.)  The reason this class
   *  exists is so users can specialize it.  Classes in namespace std
   *  may not be specialized for fundamental types, but classes in
   *  namespace __gnu_cxx may be.
   *
   *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt05ch13s03.html
   *  for advice on how to make use of this class for @a unusual character
   *  types. Also, check out include/ext/pod_char_traits.h.  
   */
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT                                    char_type;

      static _GLIBCXX_CONSTEXPR bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static _GLIBCXX_CONSTEXPR bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

    };

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (lt(__s1[__i], __s2[__i]))
          return -1;
        else if (lt(__s2[__i], __s1[__i]))
          return 1;
      return 0;
    }


={============================================================================
*kt_dev_stl_071* cpp-string-operations

C++ SLR 13.2

{operations}

<initialization> operation-arg-scheme
The operations that manipulate the value of a string have several overloaded
versions that use the argument scheme:

const string & str 
   The whole string str

const string & str, size_type idx, size_type num 
   At most, the first num characters of str starting with index idx

const char* cstr 
   The whole C-string cstr

const char* chars, size_type len 
   len characters of the character array chars

char c 
   The character c

size_type num, char c 
   num occurrences of character c

const_iterator beg, const_iterator end 
   All characters in range [beg,end) 

initlist 
   All characters in initlist (since C++11)


{string-and-c-string}
In standard C++, the type of string literals was changed from char* to const
char*. 

1. There is an automatic type conversion from const char* into strings.

*cpp-remember*
  `strings` do not provide a special meaning for the character ’\0’, which is
  used as a special character in an ordinary C-string to mark the end of the
  string. The character '\0' may be part of a string just like every other
  character.

string s(cstr);
Creates a string s that is initialized by the C-string cstr

string s(chars,charslen);
Creates a string s that is initialized by charslen characters of the character
array chars

std::string s1("nico");    // initializes s1 with: ’n’ ’i’ ’c’ ’o’
std::string s2("nico",5);  // initializes s2 with: ’n’ ’i’ ’c’ ’o’ ’\0’
std::string s3(5,’\0’);    // initializes s3 with: ’\0’ ’\0’ ’\0’ ’\0’ ’\0’

s1.length();               // yields 4
s2.length();               // yields 5
s3.length();               // yields 5

string s1;                 // default initialzation. empty

string s2( s1 );           // direct form of initialzation.
string s2 = s1;            // copy form of initialzation.

string s4( n, 'c' );


{string-nullptr} <caution>
If you use an old-style null pointer (NULL) instead of nullptr or a char*
parameter, strange behavior results. The reason is that NULL has an integral
type and is interpreted as the number 0 or the character with value 0 if the
operation is overloaded for a single integral type. So you should always use
nullptr or char* pointers.

<no-null> TODO: needs more to clarify

string s3( "value" );      // 'not' including the null

This end-of-string character is initialized by the default constructor of the character type (’\0’
for class string):

string s;
s[s.length()] // yields ’\0’

note: that only the single-argument version const char* handles the character ’\0’ as a special
character that terminates the string. In all other cases, ’\0’ is not a special character: 


{string-to-cstring} *cpp-string-cstring* 13.2.4 Strings and C-Strings
const CharT* c_str() const;

copy()            Copies or writes the contents to a character array
data(), c_str()   Returns the value as C-string or character array

data() and c_str() return the contents of the string as an array of characters.
The array 'includes' the end-of-string character at position [size()]. 

note: use c_str() since before C++11, the return type of data() was not a valid
C-string, because 'no' ’\0’ character was guaranteed to get appended.

copy() copies the contents of the string 'into' a character array provided by
the caller. An ’\0’ character is 'not' appended.

note: data() and c_str() return an array that is 'owned' by the string. Thus,
  the caller must 'not' modify or free the memory. note: seems not possible
  since it is const?


{can-be-invalidated}
Convert string into C-strings or character arrays only immediately before you
need the contents as type char*. Since the return value of c_str() and data() is
valid 'only' until the next call of a nonconstant member function for the same
string. note: As with invalidated iterators.

const char* p;
p = s.c_str();    // p refers to the contents of s as a C-string
foo(p);           // OK (p is still valid)
s += "ext";       // invalidates p
foo(p);           // ERROR: argument p is not valid


{string-capacity} 13.2.5 Size and Capacity
As with vector, string has the same interfaces: size(), length(), max_size(),
   capacity(), and reserve().

1. empty() checks whether the string is empty. Because it might be faster, you
should use empty() instead of length() or size().

2. capacity() returns the number of characters a string could contain without
having to reallocate its internal memory.

The concept of capacity for strings is, in principle, the same as for vector
containers. But one big difference: Unlike with vectors, calling reserve() for
strings might be a call to shrink the capacity. If the argument is less than the
current number of characters, it is a 'nonbinding' shrink-to-fit request meaning
"no guarantee to happen".

So, a call of reserve() without any argument is always a nonbinding
shrink-to-fit request:

// would like to shrink capacity to fit the current size
s.reserve();

Since C++11, shrink_to_fit() provides the same effect:

// would like to shrink capacity to fit the current size (C++11)
s.shrink_to_fit();


{string-reallocation}
std::string s("abcde");    // s contains: ’a’ ’b’ ’c’ ’d’ ’e’

char& r = s[2];            // reference to third character
char* p = &s[3];           // pointer to fourth character

r = ’X’;                   // OK, s contains: ’a’ ’b’ ’X’ ’d’ ’e’
*p = ’Y’;                  // OK, s contains: ’a’ ’b’ ’X’ ’Y’ ’e’

s = "new long value";      // 'reallocation' invalidates r and p

r = ’X’;                   // ERROR: undefined behavior
*p = ’Y’;                  // ERROR: undefined behavior


{sting-comparison}
tquery.cpp:128: error: no match for 'operator==' in 's == 'q''

shoule be:

string s;
if( !(cin >> s) || s == "q" ) break;


{string-modify}
You can modify strings by using different member functions and operators.

<assign>
The assign() member functions provide more than operator=().

const std::string aString("othello");

s.assign(aString);                     // assign "othello" (equivalent to operator =)
s.assign(aString,1,3);                 // assign "the"
s.assign(aString,2,std::string::npos); // assign "hello"

s.assign("two\nlines");                // assign a C-string (equivalent to operator =)
s.assign("nico",5);                    // assign the character array: ’n’ ’i’ ’c’ ’o’ ’\0’
s.assign(5,’x’);                       // assign five characters: ’x’ ’x’ ’x’ ’x’ ’x’

<insert-and-remove>
To append characters, you can use operator +=, append(), and push_back().

s += ’\n’; // append single character

s.append(aString);                     // append "othello" (equivalent to operator +=)
s.append(aString,1,3);                 // append "the"
s.append(aString,2,std::string::npos); // append "hello"
s.append("two\nlines");                // append C-string (equivalent to operator +=)
s.append("nico",5);                    // append character array: ’n’ ’i’ ’c’ ’o’ ’\0’
s.append(5,’x’);                       // append five characters: ’x’ ’x’ ’x’ ’x’ ’x’

Several insert() member functions enable you to insert characters.

const std::string aString("age");
std::string s("p");
s.insert(1,aString);    // s: page
s.insert(1,"ersifl");   // s: persiflage

Several erase() functions and pop_back() (since C++11) remove characters, and
several replace() functions replace characters.

std::string s = "i18n";                // s: i18n
s.replace(1,2,"nternationalizatio");   // s: internationalization. note: change of size
s.erase(13);                           // s: international. note: from 13
s.erase(7,5);                          // s: internal
s.pop_back();                          // s: interna (since C++11)
s.replace(0,2,"ex");                   // s: externa

// note that the replacement string need not be the same size as the substring
// that it is replacing. cpp-string-replace

string name = "Niels Stroustrup";
name.replace(0,5,"nicholas");         // name becomes "nicholas Stroustrup"


Use resize() to change the number of characters. If the new size that is passed
as an argument is less than the current number of characters, characters are
removed from the end. If the new size is greater than the current number of
characters, characters are appended at the end. You can pass the character that
is appended if the size of the string grows. If don't, the default constructor
for the character type is used which is the ’\0’ character for type char.


{string-swap}
The specialization of swap() for strings guarantees constant complexity, so you
should use it to swap the value of strings and to assign strings if you don't
need the assigned string after the assignment.


{string-empty}
To remove all characters in a string:

s = "";     // assign the empty string
s.clear();  // clear contents
s.erase();  // erase all characters


{substring-and-concatenation}
Extract a substring from any string by using the substr() member function.

string substr (size_t pos = 0, size_t len = npos) const;

std::string s("interchangeability");

s.substr();             // returns a copy of s
s.substr(11);           // returns string("ability")
s.substr(5,6);          // returns string("change")
s.substr(s.find(’c’));  // returns string("changeability")

Use operator + to concatenate two strings or C-strings or one of those with
single characters.


<example>
If filename does not have '.' then find() returns string::npos and substr(npos)
returns std::out_of_range exception.

filename.substr(filename.find('.'))

However, the following does not throw an exception since substr(0, npos);
returns the whole string. 

filename.substr(0, filename.find('.'))


<inefficient-concatenation>
In JAVA, the following shows inefficient concatenation. Assume that strings are
all the same length, x and there are n strings. Just think about concatenation.
For the first iteration, x copies char by char. Next iteration, 2x and so on.
This reduces to O(xn^2) but not O((xn)^2)

String sentence = "";

for( String w : words )
   sentence = sentence + w;

This add string to sentence and copy the temp result to sentence for each loop.
note: that there is no append() member in String class. Should be written

StringBuffer sentence = new StringBuffer();

for( String w : words )
   sentence.append(w);


How minimize this in C++?

1. Use append
As for the above, use append since string has append member function.

2. Use move()
Since C++11, operator + is also overloaded for strings that are rvalue
references to support the move semantics. If a string argument passed to
operator + is no longer needed afterward.

string foo()
{
  std::string s1("international");
  std::string s2("ization");

  std::string s = std::move(s1) + std::move(s2); // OK
  // s1 and s2 have valid state with unspecified value

  return s;
}


{io-operators}
<getline>
This comes from string class but do not need to qualify std:: due to argument
dependent lookup.

This function reads all characters, including leading whitespaces, until the
line delimiter or end-of-file is reached. The line delimiter is extracted but
'not' appended. Means that not include a new line character.

while (getline(std::cin,s)) {       // for each line from cin
...
}


// can set delimiter. Note that if you read token by token, the newline
// character is not a special character. In this case, the tokens might contain
// a newline character.

while (getline(std::cin,s,’:’)) {   // for each token separated by ’:’
...
}

// note: if useful, do further reading.
// can use stringstream. Note also that since C++11, getline() is overloaded for
// both lvalue and rvalue stream references, which allows using temporary string
// streams. See Section 15.10, page 802, for details about string streams.

void process (const std::string& filecontents)
{
  // process first line of passed string:
  std::string firstLine;
  std::getline(std::stringstream(filecontents), // OK since C++11
      firstLine);
  ...
}


={============================================================================
*kt_dev_stl_072* string-find

{search} 13.2.11 Searching and Finding
There are three ways to search: by using member functions, the regex, and
algorithms.

All search functions return the index of the first character of the character
sequence that matches the search. If the search fails, they return npos.

1. The first argument is always the value that is searched for.

2. The optional second value indicates an index at which to start the search in
the string.

3. The optional third argument is the number of characters of the value to
search.

Unfortunately, search argument scheme differs from that of the other string
functions. With the other string functions, the starting index is the first
argument, and the value and its length are adjacent arguments. 

Each search function is overloaded with the following set of arguments

Finds the first occurrence of value, char or substring

size_type string::find (const string& str) const
size_type string::find (const string& str, size_type idx) const
size_type string::rfind (const string& str) const
size_type string::rfind (const string& str, size_type idx) const

* These functions search for the first/last substring str. starting at idx.
* The find() functions search forward and return the first substring.
* The rfind() functions search backward and return the last substring.
* These functions return the index of the first character of the substring when
* successful or string::npos if they fail.

Finds the first 'character' that is 'part' of value

size_type string::find_first_of (const string& str) const
size_type string::find_first_of (const string& str, size_type idx) const
size_type string::find_first_not_of (const string& str) const
size_type string::find_first_not_of (const string& str, size_type idx) const

* These functions search for the first character that is or is not also an
element of the string str. starting at idx.
* These functions return the index of that character or substring when
* successful or string::npos if they fail.


{string-npos}
If the search fails, a special value is needed to return the failure. The type
and value of npos are a big pitfall for the use of strings. Be very 'careful'
that you always use string::size_type, not int or unsigned, for the return type
when you want to check the return value of a find function. Otherwise, the
comparison with string::npos might not work.

The reason is the result of the design decision that npos is defined as -1:

namespace std {
  class basic_string {
    public:
      // note: allocator's type
      typedef typename Allocator::size_type size_type;
      ...
      static const size_type npos = -1;
      ...
  };
}


<problem> string-find_first_of

13.1.2 A Second Example: Extracting Words and Printing Them Backward

#include <iostream>
#include <string>

using namespace std;

// This example extracts single words from standard input and prints the
// characters of each word in reverse order. The words are separated by the
// usual whitespaces (newline, space, and tab) and by commas, periods, or
// semicolons:

int main(int argc, char* argv[])
{
  // note: The newline character is also used as a delimiter. However, no
  // special processing is necessary for it because the program reads line by
  // line.

  const string delims(" \t,.;");
  string line;

  while( getline( cin, line ) )
  {
    string::size_type begi, endi;

    // The find_first_not_of() function returns the 'first' index of a character
    // that is not part of the passed string argument.

    begi = line.find_first_not_of(delims);

    // while beginning of a word found
    while( begi != string::npos )
    {
      // searches for the end of the current word. an optional second argument
      // is used that specifies where to 'start' the search in the string.

      endi = line.find_first_of( delims, begi ); 
      if( endi == string::npos )
      {
        // end of word is end of line
        endi = line.length();
      }

      // print characters in reverse
      // 
      // "pots & pans"
      //  ^   ^
      //      endi
      //  begi
      
      // note:
      for( int i = endi-1; i >= static_cast<int>(begi); --i )
        cout << line[i];

      cout << ' ';

      // search beginning of the next word
      begi = line.find_first_not_of( delims, endi );
    }

    // to have next input on next getline
    cout << endl;
  }
}

pots & pans
stop & snap 
I saw a reed
I was a deer 
deliver no pets
reviled on step 
nametag on diaper
gateman no repaid 


note: implicit conversion
If you omit the cast of begIdx to int, this program might run in an endless loop
or might crash. The problem is that string::size_type is an 'unsigned' integral
type. Without the cast, the signed value i is converted automatically into an
unsigned value because it is compared with a unsigned type. 

In this case, the following expression always yields true if the current word
starts at the beginning of the line: 

i>=begIdx 

The reason is that begIdx is then 0, and any unsigned value is greater than or
equal to 0. For example, when i == -1. So, an endless loop results that might
get stopped by a crash due to an illegal memory access. For this reason, I don't
like the concept of string::size_type and string::npos.

The size_type, which is defined by the allocator of the string, must be an
unsigned integral type.  The default allocator, allocator, uses type size_t as
size_type. Because -1 is converted into an unsigned integral type, npos is the
'maximum' unsigned value of its type. 

However, the exact value 'depends' on the exact definition of 'type' size_type:
(unsigned long)-1 differs from (unsigned short)-1 if the size of the types
differs. so maximum values differ.

int idx = s.find("xx");
if (idx == std::string::npos) {
  ...
}

Might yield false if idx has the value -1 and idx and string::npos have
'different' types.


<solution>
One way to avoid this error is to check whether the search fails directly:

if (s.find("hi") == std::string::npos) {
...
}

However, often you need the index of the matching character position. Thus
another simple solution is to define your own signed value for npos:

const int NPOS = -1;

if (idx == NPOS) { // works almost always
...
}

Unfortunately, this solution is not perfect, because the comparison fails if
either idx has type unsigned short or the index is greater than the maximum
value of int. Because of these problems, the standard did not define it that
way. 

However, because both might happen very 'rarely', the solution works in most
situations. To write portable code, however, you should always use
string::size_type for any index of your string type.  For a perfect solution,
    you'd need some overloaded functions that consider the exact type of
    string::size_type. I still hope the standard will provide a better solution
    in the future although with C++11 nothing changed.

note: Q?

for( string::size_t i = endi-1; i >= begi; --i )


={============================================================================
*kt_dev_stl_073* cpp-string-numeric-conversion cpp-boost-lexical-cast

Converting strings to numbers in C++ makes a lot of people depressed because
of their inefficiency and user unfriendliness. See how string 100 can be
converted to int:

<ex> *cpp-istringstream-conversion*
#include <sstream> 
 
void sample1() {
    std::istringstream iss("100");
    int i;
    iss >> i;

    // ...
}


http://www.boost.org/doc/libs/1_58_0/doc/html/boost_lexical_cast.html

Motivation

Sometimes a value must be converted to a literal text form, such as an int
represented as a std::string, or vice-versa, when a std::string is interpreted
as an int. Such examples are common when converting between data types
internal to a program and representation external to a program, such as
windows and configuration files.

The standard C and C++ libraries offer a number of facilities for performing
such conversions. However, they vary with their ease of use, extensibility,
     and safety.

For instance, there are a number of limitations with the family of standard C
functions typified by 'atoi':

* Conversion is supported in one direction only: from text to internal data
  type. Converting the other way using the C library requires either the
  inconvenience and compromised safety of the sprintf function, or the loss of
  portability associated with `non-standard functions such as itoa`

* The range of types supported is only a subset of the built-in numeric types,
  namely int, long, and double.

* The range of types cannot be extended in a uniform manner. For instance,
  conversion from string representation to complex or rational.

The standard C functions typified by `strtol` have the same basic limitations,
    but offer finer control over the conversion process. However, for the
    common case such control is often either not required or not used. The
    scanf family of functions offer even greater control, but also lack safety
    and ease of use.

The standard C++ library offers `stringstream` for the kind of in-core
formatting being discussed. It offers a great deal of control over the
formatting and conversion of I/O to and from arbitrary types through text.
However, for simple conversions direct use of stringstream can be either
clumsy (with the introduction of extra local variables and the loss of
    infix-expression convenience) or obscure (where stringstream objects are
      created as temporary objects in an expression). Facets provide a
    comprehensive concept and facility for controlling textual representation,
    but their perceived complexity and high entry level requires an extreme
    degree of involvement for simple conversions, and excludes all but a few
    programmers.

The lexical_cast function template offers a convenient and consistent form for
supporting common conversions to and from arbitrary types when they are
represented as text. The simplification it offers is in expression-level
convenience for such conversions. For more involved conversions, such as where
precision or formatting need tighter control than is offered by the default
behavior of lexical_cast, the conventional std::stringstream approach is
recommended. Where the conversions are numeric to numeric, boost::numeric_cast
may offer more reasonable behavior than lexical_cast.


* The boost::lexical_cast function will even check bounds for you:

#include <boost/lexical_cast.hpp>
#include <cassert>

void sample4()
{
    try {
        const short s = boost::lexical_cast<short>("1000000");
        assert(false);
    } catch (const boost::bad_lexical_cast &e) {
        std::cout << e.what() << std::endl;
    }
}


* Since Boost 1.56, there is a boost::conversion::try_lexical_convert function
  that reports errors by return code. It could be useful in performance
  critical places where bad input could often occur:

#include <boost/lexical_cast.hpp>
#include <cassert>

void sample7() 
{    
  int i = 0;    
  const bool ok = boost::conversion::try_lexical_convert("Bad stuff", i);    
  assert(!ok);
}


<ex> convert-to-string *cpp-to-string*

C++11 has std::to_string and std::to_wstring functions that are declared in
the <string> header. Those functions use locales and have behavior very close
to boost::lexical_cast<std::string> and boost::lexical_cast<std::wstring>,
   respectively.


std::map<std::string, std::string> si;

static uint64_t fake_outputs = 0;

si["POST_REPAIR_OUTPUTS"] =
  boost::lexical_cast<std::string>(fake_outputs++);


<ex> convert-to-number

int EnvironmentAppIdStrategy::getAppId() const
{
    ApplicationRuntimeInstanceId appRuntimeInstanceId = 0;

    char* appIdFromEnv = getenv(APP_RUNTIME_INSTANCE_ID_ENV_VAR_NAME);

    // note: use stringstring to convert
 
    const std::string appIdAsString(appIdFromEnv);
    std::istringstream is(appIdAsString);
    is >> appRuntimeInstanceId;

    return appRuntimeInstanceId;
}

int EnvironmentAppIdStrategy::getAppId() const
{
    ApplicationRuntimeInstanceId appRuntimeInstanceId = 0;

    char* appIdFromEnv = getenv(APP_RUNTIME_INSTANCE_ID_ENV_VAR_NAME);

    return boost::lexical_cast<int>(appIdFromEnv);
}


{lexical-cast-peformance}
While we weren't looking Boost.Lexical_cast became "in most cases
boost::lexical_cast is faster than scanf, printf, std::stringstream". Yay for
upgrades - now there's no reason to use scanf for performance reasons.

http://www.boost.org/doc/libs/1_58_0/doc/html/boost_lexical_cast/
  performance.html#boost_lexical_cast.performance.tests_description

#include "PerfCounter.h"

#include <iostream>
#include <sstream>
#include <boost/lexical_cast.hpp>

int main(int argc,char** argv)
{
    PerfCounter counter;
    
    for(int i=0;i<10000;++i)
    {
        int out;
        sscanf("42","%d",&out);
    }
    counter.snap("scanf int");

    for(int i=0;i<10000;++i)
    {
        int out;
        std::stringstream ss("42");
        ss >> out;
    }
    counter.snap("stringstream int");

    for(int i=0;i<10000;++i)
    {
        int out = boost::lexical_cast<int>("42");
    }
    counter.snap("boost::lexical_cast<int>");
    std::cout << counter.dump() << std::endl;
}

// on debian

$ ./a.out 
Start -> scanf int took 2112us
scanf int -> stringstream int took 27859us
stringstream int -> boost::lexical_cast<int> took 910us
boost::lexical_cast<int> -> end took 0us


// about the above code

> you're transforming the same value on every iteration, source of which is a
> const - might this be a subject of some optimisation / cache related thing?

Yeah, I was just thinking the same thing. I wouldn't be too surprised if the
compiler replaces the lexical_cast call with a constant result. Try with a
random number converted to a string.

// on the host

Start -> scanf int took 22us
scanf int -> stringstream int took 45us
stringstream int -> boost::lexical_cast<int> took 3us
boost::lexical_cast<int> -> end took 0us

// on the device

Start -> scanf int took 46us
scanf int -> stringstream int took 392us
stringstream int -> boost::lexical_cast<int> took 11us
boost::lexical_cast<int> -> end took 4us

// on debian VM
snap: 1: start -> scanf int took 1050us
snap: 2: scanf int -> stringstream int took 7130us
snap: 3: stringstream int -> boost::lexical_cast<int> took 1922us
delete start
delete scanf int
delete stringstream int
delete boost::lexical_cast<int>

// on build host
snap: 1: start -> scanf int took 1917us
snap: 2: scanf int -> stringstream int took 7663us
snap: 3: stringstream int -> boost::lexical_cast<int> took 1488us
delete start
delete scanf int
delete stringstream int
delete boost::lexical_cast<int>


{numeric-conversion}
Since C++11, the C++ standard library provides convenience functions to convert
strings into numeric values or to convert numeric values to strings. Only for
types string and wstring, not u16string and u32string.

stoi(str,idxRet=nullptr, base=10)      Converts str to an int
stol(str,idxRet=nullptr, base=10)      Converts str to a long
stoul(str,idxRet=nullptr, base=10)     Converts str to an unsigned long
stoll(str,idxRet=nullptr, base=10)     Converts str to a long long
stoull(str,idxRet=nullptr, base=10)    Converts str to an unsigned long long
stof(str,idxRet=nullptr)               Converts str to a float
stod(str,idxRet=nullptr)               Converts str to a double
stold(str,idxRet=nullptr)              Converts str to a long double

// 4.4.5 do not support this
to_string(val)                         Converts val to a string
to_wstring(val)                        Converts val to a wstring


<ex>
#include <iostream>
#include <string>
#include <exception>
#include <limits>

using namespace std;

int main(int argc, char* argv[])
{
    try {
        // convert to numeric
        cout << std::stoi("  77") << endl;
        cout << std::stoi("  77.7") << endl;

        // std::stoi("-0x77") yields 0 because it parses only -0, interpreting
        // the x as the end of the numeric value found.

        cout << std::stoi("-0x77") << endl;

        // use index of chars not processed

        size_t idx;

        cout << std::stoi("  42 is the truth", &idx ) << endl;
        cout << " idx of first unprocessed char: " << idx << endl;

        // use base 16 and 8

        cout << std::stoi("  42", nullptr, 16 ) << endl;

        // std::stol("789",&idx,8) parses only the first character of the string
        // because 8 is not a valid character for octal numbers.

        cout << std::stoi("789", &idx, 8 ) << endl;
        cout << " idx of first unprocessed char: " << idx << endl;

        // *cpp-to-string* convert numeric to string
        long long ll = std::numeric_limits<long long>::max();
        string s = std::to_string(ll);
        cout << s << endl;

        // try to convert back and throws out_of_range
        cout << std::stoi(s) << endl;
    }
    catch( const std::exception& e ) {
        cout << e.what() << endl;
    }
}

77
77
0
42
 idx of first unprocessed char: 4
66
7
 idx of first unprocessed char: 1
9223372036854775807
stoi


={============================================================================
*kt_dev_stl_074* string: iterator support

{iterator-support}
A string is an ordered collection of characters. As a consequence, the C++
standard library provides an interface for strings that lets you use them as STL
containers. 

String iterators are random-access iterators. The exact type is implementation
defined, but string iterators are often defined simply as ordinary pointers.

<example> algorithm-search, algorithm-transform
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int main(int argc, char* argv[])
{
    // create a string
    string s("The zip code of Braunschweig in Germany is 38100");
    cout << "original: " << s << endl;

    // to lowercase
    transform( s.cbegin(), s.cend(), s.begin(),
            [] (char c) {
            return tolower(c);
            });
    cout << "lowered : " << s << endl;

    // to uppercase
    transform( s.cbegin(), s.cend(), s.begin(),
            [] (char c) {
            return toupper(c);
            });
    cout << "uppered : " << s << endl;

    // search case-insensitive
    string g{"Germany"};
    string::const_iterator pos;

    pos = search( s.cbegin(), s.cend(),   // source string
            g.cbegin(), g.cend(),         // string to search
            [](char c1, char c2) {
            return toupper(c1) == toupper(c2);
            });
    if( pos != s.cend() )
    {
        cout << "substring \"" << g << "\" found at index "
            << pos - s.cbegin() << endl;
    }
}

original: The zip code of Braunschweig in Germany is 38100
lowered : the zip code of braunschweig in germany is 38100
uppered : THE ZIP CODE OF BRAUNSCHWEIG IN GERMANY IS 38100
substring "Germany" found at index 32


<example> algorithm-unique
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int main(int argc, char* argv[])
{
    // create constant string
    const string hello("Hello, how are you?");

    string s( hello.cbegin(), hello.cend() );

    for( char c : s )
        cout << c;

    cout << endl;

    // reverse a string
    reverse( s.begin(), s.end() );
    cout << "reversed     : " << s << endl;

    // sort
    sort( s.begin(), s.end() );
    cout << "sorted       : " << s << endl;

    // remove duplicates
    s.erase( unique( s.begin(), s.end() ), s.end() );
    cout << "no duplicates: " << s << endl;
}

Hello, how are you?
reversed     : ?uoy era woh ,olleH
sorted       :    ,?Haeehlloooruwy
no duplicates:  ,?Haehloruwy


<example> algorithm-unique:

ForwardIterator unique (ForwardIterator beg, ForwardIterator end) 
ForwardIterator unique (ForwardIterator beg, ForwardIterator end, BinaryPredicate op)

The first form removes from the range [beg,end) all elements that are equal to
the previous elements. Thus, only when the elements in the sequence are
'sorted', or at least when all elements of the same value are adjacent, does it
remove all duplicates.

The second form removes all elements(elem) that follow an element e and for
which the binary predicate op(e,elem) yields true. 

#include <iostream>
#include <list>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main(int argc, char* argv[])
{
  // source data
  list<int> coll{ 1, 4, 4, 6, 1, 2, 2, 3, 1, 6, 6, 6, 5, 7, 5, 4, 4 };

  PRINT_ELEMENTS(coll);

  // remove elements if there was a previous greater element
  coll.erase (unique (coll.begin(), coll.end(), greater<int>()),
      coll.end());
  PRINT_ELEMENTS(coll);
}

1 4 4 6 1 2 2 3 1 6 6 6 5 7 5 4 4
1 4 4 6 6 6 6 7
      ^

The first 6(e) is greater than the following(elms) 1, 2, 2, 3, and 1, so all
these elements are removed.

In other words, the predicate is not used to compare an element with its
predecessor; the element is compared with the previous element(e) that was not
removed

<example>
Uses back inserters to read the standard input into a string:

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include <locale>

using namespace std;

int main(int argc, char* argv[])
{
  string input;

  // do not skip whitespaces
  cin.unsetf(ios::skipws);

  // read all chars while compressing whitespaces
  const locale &loc(cin.getloc());
  unique_copy( istream_iterator<char>(cin), istream_iterator<char>(),
      back_inserter(input),
      [=] ( char c1, char c2 ) {
        return isspace(c1, loc) && isspace(c2, loc);
        });

  cout << input;
}


   ,?Haeehlloooruwy
 ,?Haeehlloooruwy

<Q> why still duplicates?


={============================================================================
*kt_dev_stl_075* cpp-stringstream

CLR 15.10

The mechanisms of stream classes can also be used to read from strings or to
write to strings. `stringstream` provide a `buffer` but don't have an I/O
channel. This buffer/string can be manipulated with special functions. 

<use>
A major use of this capability is the processing of I/O independent of the
actual I/O. For example, text for output can be formatted in a string and then
sent to an output channel sometime `later`. Another use is reading input line
by line and processing each line by using string streams.

  "see(treat) string as a stream so use stream ops"

Supports in-memory IO. Use stream operation such as read(>>) and write(<<) but
they are really to read from or write to a string since use it as if the
string were IO stream. 

The following stream classes - corresponding to the stream classes for files -
are defined for strings:

  * The class template basic_istringstream<> with the specializations
    istringstream and wistringstream for reading from strings 
    ("input string stream")

  * The class template basic_ostringstream<> with the specializations
    ostringstream and wostringstream for writing to strings 
    ("output string stream")

  * The class template basic_stringstream<> with the specializations
    stringstream and wstringstream for reading from and writing to strings

  * The class template basic_stringbuf<> with the specializations stringbuf
    and wstringbuf, used by the other string stream classes to perform the
    reading and writing of characters


<members>
#include <sstream>

sstream strm(string);   
strm is an sstream that holds a copy of the string s.

strm.str();             
return a copy of the string that strm holds. Returns the buffer as a string

strm.str(string);       
copies the string s into strm. Sets the contents of the buffer to string and
  remove the current contents from the stream. Can use the function str() to
  assign new contents to the buffer.


<ex>
// g++ -g -std=c++0x -c a.c

#include<iostream>
#include<string>
#include<sstream>
#include<bitset>
#include<fstream>   // for ifstream

using namespace std;

//////////////////////////////////////////////////////////////////////////////
// o. To see that stringstream is a buffer and use stream operations.

// = 01 ======
// dec: 15 hex: f
// -------
// dec: 15 hex: f
// float: 4.67 bitset: 001011010011101

void t_sstream_01()
{
  ostringstream os;

  // use stream operations and endl remains in os as a new line.
  os << "dec: " << 15 << hex << " hex: " << 15 << endl;
  cout << os.str();

  // see that os has all outputs. 
  cout << "-------" << endl;
  bitset<15> b(5789);
  os << "float: " << 4.67 << " bitset: " << b << endl;
  cout << os.str();
}

// = 02 ======
// dec: 15 hex: f
// -------
// oct: 17 hex: f
// float: 4.67 bitset: 001011010011101

void t_sstream_02()
{
    ostringstream os;

    // use stream operations and endl remains in os as a new line.
    os << "dec: " << 15 << hex << " hex: " << 15 << endl;
    cout << os.str();

    // see that os has all outputs. 
    cout << "-------" << endl;
    bitset<15> b(5789);
    os << "float: " << 4.67 << " bitset: " << b << endl;

    // Using seekp(), the write position is moved to the beginning of the
    // stream. The following call of operator << writes at the beginning of the
    // string, thus overwriting the beginning of the existing string stream.
    // However, the characters that are not overwritten remain valid. 
    os.seekp(0); 
    os << "oct: " << oct << 15; 
    cout << os.str(); 
}


//////////////////////////////////////////////////////////////////////////////
// o. To see that stringstream do `string to number` conversion.
// o. file parsing example

// input.txt
//
// VOD.L 1 100 184.0 183.7
// VOD.X 2 100 189.0 183.8
// VOD.L 3 100 185.0 183.9
// VOD.X 4 100 186.0 184.0
// VOD.L 5 100 187.0 183.1
//

struct StockData
{
    string  name;
    int     time;
    int     volume;
    float   high;
    float   low;
};

// = 03 ======
// { VOD.L, 1, 100, 184.000, 183.700 }
// { VOD.X, 2, 100, 189.000, 183.800 }
// { VOD.L, 3, 100, 185.000, 183.900 }
// { VOD.X, 4, 100, 186.000, 184.000 }
// { VOD.L, 5, 100, 187.000, 183.100 }

void t_sstream_03()
{
    string line{};
    StockData sdata{};

    ifstream ifs("input.txt", std::ifstream::in);

    while (getline(ifs, line))
    {
        istringstream iss(line);

        // o. do string to number conversion.
        iss >> sdata.name; 
        iss >> sdata.time;
        iss >> sdata.volume;
        iss >> sdata.high;
        iss >> sdata.low;

        cout << "{ " 
            << sdata.name << ", "
            << sdata.time << ", "
            << sdata.volume << ", "
            << showpoint 
            << sdata.high << ", "
            << sdata.low << " }" << endl;
    }

    ifs.close();
}

// = 04 ======
// x: 3, f: 0.7

void t_sstream_04()
{
    int x{}; float f{};
    istringstream is{"3.7"};

    // Input string streams are used mainly for formatted reading from existing
    // strings. For example, it is often easier to read data line by line and
    // then analyze each line individually. The following lines read the integer
    // x with the value 3 and the floating-point f with the value 0.7 from the
    // string s:

    is >> x >> f;
    cout << "x: " << x << ", f: " << f << endl;
}

int main()
{
    cout << "= 04 ======" << endl;
    t_sstream_04();

    cout << "= 03 ======" << endl;
    t_sstream_03();

    cout << "= 02 ======" << endl;
    t_sstream_02();

    cout << "= 01 ======" << endl;
    t_sstream_01();
}


<ex> ostrringstream ex
ostringstream is useful when need to `build up` our output a little at a time
but do not want to print the output until later.

void PerfCounter::dump()
{
    std::stringstream ss{};
    uint32_t countSnap{1};

    // only when there are two nodes to use
    for (CounterData *pstart = phead; 
            pstart && pstart->pnext; pstart = pstart->pnext)
    {
        ss << "snap: " << countSnap << ": ";
        ss << pstart->name << " -> " << pstart->pnext->name << " took ";

        // time diff in us from current to next
        uint64_t timeDiff = 
            (pstart->pnext->ts.tv_sec*1000000 + pstart->pnext->ts.tv_nsec/1000)-
            (pstart->ts.tv_sec*1000000 + pstart->ts.tv_nsec/1000);

        ss << timeDiff << "us" << std::endl;
        ++countSnap;
    }

    std::cout << ss.str();
}


={============================================================================
*kt_dev_stl_075* stl-string: seg fault

{
  char* pnull = NULL;

  std::string mesg2{"string mesg: "};

  // note: this causes seg fault
  mesg2 += pnull;

  cout << "mesg2: " << mesg2 << endl;
}


(gdb) bt
#0  0x00007fa0652318cf in ?? () from /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007fa0659fab9c in std::string::operator+=(char const*) () from 
        /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#2  0x0000000000400c95 in main ()


From /4.4.5/bits/basic_string.h

      /**
       *  @brief  Append a C string.
       *  @param s  The C string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }


      /**
       *  @brief  Append a C substring.
       *  @param s  The C string to append.
       *  @param n  The number of characters to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(const _CharT* __s, size_type __n);

      /**
       *  @brief  Append a C string.
       *  @param s  The C string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(const _CharT* __s)
      {
        __glibcxx_requires_string(__s);
        return this->append(__s, traits_type::length(__s));
      }

TODO: see further to find out more.


={============================================================================
*kt_dev_stl_080* cpp-bitset

The bitset is a class template and is defined in bitset header. Like array
class, has a 'fixed' size. This is a exmple of a `non-type template parameter`
and this is then considered part of the type.


{why-bitset}
Mostly to reduce space complexity. bitset < vector<bool> < bool array

#include <iostream>
#include <vector>
#include <bitset>

using namespace std;

int main()
{
  vector<bool> boolvec(32,1);
  bitset<32> bitvec(1U);
  bool bitbool[32];

  cout << "size: " << boolvec.size() << " sizeof : " << sizeof(boolvec) << endl;
  cout << "size: " << bitvec.size() << " sizeof : " << sizeof(bitvec) << endl;
  cout << "size: " << sizeof(bitbool) << endl;
}

size: 32 sizeof : 20
size: 32 sizeof : 4
size: 32

note: can use variable to set size of bitset.
const int x = 40;
bitset<x> bitvec(1U);


{cpp-bitset-ctors}

bitset<n> b;   
b has n bits; each bit is 0.

bitset<n> b(u);   
b is a copy of the n low-order bits of unsigned long long(ULL) value u.

<init-from-unsigned>
If the size of bitset > the number of bits in ULL, the remaining high-order are set to 0.
If the size of bitset < the number of bits in ULL, the only low-order bits are used. 

<init-from-string>
bitset<n> b(s, pos, m);
'b' is a copy of the 'm' characters from the 'string' starting at position
'pos'. s may contain only 0 and 1 and if contains any other characters, throws
invalid_argument.

The characters with the lowest indices in the string correspond to the
high-order bits and vice versa.

bitset<n> b(cp, pos, m);
same as the above but copies from the character array to which cp points.


{bitset-operations}
<about-the-state-of-the-entire-bitset>
b.any();       is any bit in b on?           <DN> Do not use is?? style although returns a bool.
b.all();       are all the bits on?
b.none();      are no bits on?
b.count();     number of bits that are on.
b.size();      return the number of bits in b.

<change-the-bitset>
b.test(pos);   return true if bit at position is on.
b.set(pos, v); set the bit at pos to the bool value v.
b.set();       set all bits.
b.reset(pos);  turn off the bit at pos.
b.reset();     turn off all bits.
b.flip(pos);   change the state of the bit at pos.
b.flip();      flip all bits.

<subsctipt>
When read, that is const version, return a bool true if it's on. When write,
     which is non-const return special type that let us change bit at pos.

bool ret = b[pos];
b[31] = 0;
b[0].flip();

<retrive-the-value>
These return a value that holds the same bit pattern. Can use ONLY IF the size
of the bitset is less than or equal to the corresponding size; UL or ULL.
Otherwise, throw overflow_error exception.

b.to_ulong();
b.to_ullong();

<io-operations>
This read into a temp string and read until it has read as many as the size of
bitset.

os << b;
is >> b;


<ex>
// with GCC 4.6.3.

#include <iostream>
#include <bitset>

using std::cout;
using std::endl;
using std::bitset;

int main()
{
  bitset<32> bitvec(1U);

  bool is_set = bitvec.any();
  bool is_not_set = bitvec.none();
  bool all_set = bitvec.all();
  size_t on_bits = bitvec.count();
  size_t size = bitvec.size();

  cout << "is_set: " << is_set << ", is_not_set: " << is_not_set 
    << ", all_set: " << all_set << ", on_bits: " << on_bits
    << ", size: " << size << endl;

  bitvec.flip();
  bitvec.reset();
  bitvec.set();

  bitset<16> bitvec2("01011001011");
  cout << bitvec2 << endl;             <DN>

  return 0;
}

<ex>
// see the use of bitset and bitset only supports fixed size.  

#include <iostream>
#include <bitset>
using namespace std;

int main() {
  unsigned short short11 = 1024;
  bitset<16> bitset11{short11};
  cout << bitset11 << endl;     // 0000010000000000

  unsigned short short12 = short11 >> 1;  // 512
  bitset<16> bitset12{short12};
  cout << bitset12 << endl;      // 0000010000000000

  unsigned short short13 = short11 >> 10;  // 1
  bitset<16> bitset13{short13};
  cout << bitset13 << endl;      // 0000000000000001

  unsigned short short14 = short11 >> 11;  // 0
  bitset<16> bitset14{short14};
  cout << bitset14 << endl;      // 0000000000000000
}


note:
How can use bitset with dynamic size since the size is constant expression?
Options are:

o. vector<bool>
o. boost has a dynamic_bitset you can use.


={============================================================================
*kt_dev_stl_100* cpp-sp-raii cpp-raii

{resource-acquisition-is-initialization} {resource-managing-class}
EC++13. Why RAII? When use dynamic resource, client is fully resposible for
releasing it after use but it is very difficult to do 'bookkeeping' and
problems are:

* Very tricky to ensure that reference lifetime and the lifetime of the objects
  they refer to match, especially when multiple pointers refer to the same
  object.

    * When the objects outlives, means "resource leak". 

    * When the references outlives, means "dangling reference". 

        * "double free" that means to try to release what it do not own. For
          example, passing pointers via function calls or between components. 

        * "invalid access" to objects which are released already. 

* Interrupted code path due to exception. the usual path is interrupted and
  may cannot release it as expected.

With RAII, such as smart poitners, good things are: 

* Make resource bookkeeping easier.
* Can minimize client's burden to use resource properly. For example, raii
  with deleter.

// * Support sharing resources. note that this is from smart pointers but not
// from RAII.


<exception-problem>

void f()
{
  // createInvestment() is `factory-function` that returns a pointer to
  // dynamically created resource or derived class. client must delete it after
  // use

  Investment* pInv = createInvestment();

  // The problem is code that throws an exception that is not caught inside f.
  // may not reach to delete statement

  delete pInv;
}

How about using catch? 

void f()
{
  try {
    Investment* pInv = createInvestment();
  }
  catch( ... ) {
    delete pInv;
    throw;           // propagate exception to caller of f. rethrow.
  }

  delete pInv;
}

This approach has duplicated clean-up code. How to improve this? 


{raii} <raii-auto-ptr-approach> unique_ptr
Approaches to implement raii.

void f()
{
  std::auto_ptr<Investment> pInv( createInvestment() );

  // NO need to concern about freeing resource regardless of how control leaves
  // a block 
}

*cpp-raii*
  Use resource managing class by putting reference(resource) 'inside' object
  and use the fact that dtor is called automatically when object is destroyed;
  use resource-managing-class object lifetime. As soon as get resource,
  initialize a object. How? In a 'constructor' and hence called raii.

  C++PL

  RAII, allows us to eliminate “naked new operations,” that is, to avoid
  allocations in general code and keep them buried inside the implementation
  of well-behaved abstractions. Similarly, “naked delete operations” should be
  avoided. Avoiding naked new and naked delete makes code far less error-prone
  and far easier to keep free of resource leaks


Acquire and initialize a resource-managing-class in the same statement. In
other words, reference should be 'encapsulated' in a object,
      resouce-managing-class, but raii do not exist to encapsulate resource
      but to 'prevent' leak.

However, auto_ptr is not the best way to manage all dyn resources since
containers of auto_ptr aren't allowed. Use `unique_ptr` instead.


<raii-shared-ptr-approach>
Returning `shared_ptr` from a `factory-function` is a better way that supports
normal copying than auto_ptr. 

// use the fixed type, Foo that's the underlying object.

std::shared_ptr<Foo> factory(T arg)
{
  return make_shared<Foo>(arg);
}

void use_factory(T arg)
{
  shared_ptr<Foo> p = factory(arg);
  // use p and deleted automatically.
}


{raii-for-resource-using-own-interface}
EC++14. There should be 'own' raii class for resource that uses own interface
to create and delete it because cannot use delete operator on it.

<ex> `cpp-auto-lock` 
void lock(Mutex* pm);      // int pthread_mutex_lock( pthread_mutex_t *mptr); 
void unlock(Mutex* pm);

class Lock {
  public:
    'explicit' Lock( Mutex* pm ) : mutexPtr(pm) 
      { lock( mutexPtr ); }

    ~Lock() { unlock( mutexPtr ); }

  private:
    Mutex* mutexPtr;
};


// client use

Mutex m;    // pthread_mutex_t m;
...
function()
{
  Lock ml(&m);
  ...
}

<ex> 
AUTOLOCK example. This is a case example seen in the code:

class CCAutoLock
{
  private:
    PCMutex* m_mutex;
  public:
    CCAutoLock(PCMutex* mutex) { m_mutex = mutex; m_mutex->Lock(); };
    ~CCAutoLock() { m_mutex->Unlock(); };
};

static PCMutex* g_debug_mutex;
#define AUTOLOCK() CCAutoLock lock(&g_debug_mutex)

void func()
{ 
  AUTOLOCK();
  ...
}


<ex>
When there is a nested call tree used AUTOLOCK, will the value of lock be
maintained? That is the lock of func1 in the below example will BE
VALID/LOCKED when func3 gets run? Will do. However, all three uses the same
mutex then deadlock.

#include <iostream>

using std::cout; using std::endl;

class ALOCK {
  private:
    int m_num;
  public:
    ALOCK(int val):m_num(val) { cout << "ctor: ALOCK" << m_num << endl; }
    ~ALOCK() { cout << "dtor: ALOCK: " << m_num << endl; }
};

int func3()
{
  ALOCK LOCK(3);

  std::cout << "func 3" << std::endl;

  return 1;
}

int func2()
{
  ALOCK LOCK(2);

  std::cout << "func 2" << std::endl;

  return func3();
}

int func1()
{
  ALOCK LOCK(1);

  std::cout << "func 1" << std::endl;

  return func2();
}

int main()
{
  std::cout << "--{ main " << std::endl;

  func1();

  std::cout << "--} main " << std::endl;
}

Expected output?

--{ main
ctor: ALOCK1
func 1
ctor: ALOCK2
func 2
ctor: ALOCK3
func 3
dtor: ALOCK: 3
dtor: ALOCK: 2
dtor: ALOCK: 1
--} main 


<ex-window-handle> MEC++09.
void displayInfo(const Information& info)
{
  WINDOW_HANDLE w ( createWindow() );

  // display info in window w and exception can happen.

  destoryWindow(w);
}

class WindowHandle {
  public:
    WindowHandle( WINDOW_HANDLE handle ) : w(handle) {}
    ~WindowHandle() { destoryWindow(w); }

    // conversion-op
    operator WINDOW_HANDLE() { return w; }

  private:
    WINDOW_HANDLE w;

    // `preventing-copies`
    WindowHandle( const WindowHandle& );
    WindowHandle& operator=( const WindowHandle& );
};

void displayInfo(const Information& info)
{
  WindowHandle w(createWindow());

  // display info in window w and exception can happen.

  // displayWindow(w); coversion-op runs to convert WindowHandle to WINDOW_HANDLE

  // destoryWindow(w);
}


<ex>
For example, if your object is an array allocated with new[], you have to
define that the cleanup performs a delete[]. This show that smart pointer is
useful to lessen client's burden since this can be done in smart pointer so
client no need to know; unique_ptr supports delete[] but shared_ptr don't so
need to provide a deleter. CPR 479


{raii-and-two-cautions}
The raii is great but there are two cautions when use raii.

* When use resources which has own interface such as mutex and db connection, it
  can raise exception in destructor. Since raii uses destructor, it can cause
  the problem is described in {problem-of-exception-in-dtor}.

* Acquire and initialize a raii in the same statement. In other words, use
  constructor. If not, can be a problem as described in EC++17.
  `evaluation-order`

processWidget( std::shared_ptr<Widget>( new Widget ), priority() );

The problem is that there is no order in evaluating the arguments between new,
    shared_ptr constructor, and priority() call. 
    
  shared_ptr ctor is also under evaluation order here. So if complier reorder
  calls as new, priority, and shared_ptr and priority raise exception then
  raii is broken. Means newed pointer will be lost. The better way is:

std::shared_ptr<Widget> pw( new Widget );
processWidget( pw, priority() );


{raii-and-copy-support}
EC++14. What should happen when a Lock object, more generally raii object, is
'copied' or 'assigned'? There are four approaches depending on the type of
resource.

* No copying
 
Likely to be true for Lock. See `preventing-copies` So,

class Lock: private Uncopyable {
  ...
};


* Reference counting underlying resources

By using shared_ptr with delete, do not need to concern about clean up. 

<raii-vs-shared-pointer>
This is a decision point; use own raii and concern about copy or use
shared_ptr with deleter and don't concern about copy. Here, use 'deleter' to
use unlock instead of default delete.

class Lock {
  public:
    explicit Lock( Mutex* pm ) : mutexPtr(pm) 
      { lock( mutexPtr ); }

    ~Lock() { unlock( mutexPtr ); }

  private:
    Mutex* mutexPtr;
};

To:

class Lock {
  public:
    explicit Lock( Mutex* pm )
      :mutexPtr( pm, unlock )    // note: deleter
      {  
          // to get law pointer assuming this is C interface
          lock( mutexPtr.get() );
      }

  private:
    std::shared_ptr<Mutex> mutexPtr;
};

Set deleter using shared_ptr ctor in ctor init list. No longer declares a
destructor.


* Copy the underlying resource

This is {valuelike} in *kt_dev_cpp_004* Such as string class which uses heap
for characters. Copying the resource managing object should also copy the
resource it wraps. deep-copy.

* Transfer ownership of underlying resource

This is unique_ptr. Only one raii refers to a raw resource and when raii is
copied ownership of the resource is transfered. 


={============================================================================
*kt_dev_stl_101* cpp-sp-shared

This implements the concept of `shared-ownership` so that the object and its
associated resources get released whenever the last reference to it gets
destroyed. To perform this task in more complicated scenarios, helper classes,
such as `weak_ptr`, `bad_weak_ptr`, and `enable_shared_from_this` are provided.

  * Defined in the <memory> 
  * The default initialized holds a nullptr. 
  * The template and use "T" but not "T*".

shared_ptr<T> plist;
shared_ptr<list<int>> plist;


{cpp-sp-operations}

// Use args to initialize the object of type T
make_shared<T>(args);

// Decrements p's reference count and increments q's count
p = q;          

// Return true if p.use_count() is 1
p.unique();

// May be slow operation, intended for debugging purpose
p.use_count();

// Swap pointers in p and q
swap(p, q);
p.swap(q);


<ex>

SLR 5.2 Smart Pointers

#include <iostream>
#include <memory>
#include <string>
#include <vector>

using namespace std;

int main()
{
  shared_ptr<string> pNico(new string("nico"));
  shared_ptr<string> pJutta(new string("jutta"));

  // capitalize the first char
  (*pNico)[0] = 'N';
  pJutta->replace(0,1,"J");

  // put them multiple times in a container
  vector<shared_ptr<string>> whoMadeCoffee;
  whoMadeCoffee.push_back(pJutta);
  whoMadeCoffee.push_back(pJutta);
  whoMadeCoffee.push_back(pNico);
  whoMadeCoffee.push_back(pJutta);
  whoMadeCoffee.push_back(pNico);

  // print all
  for( auto ptr : whoMadeCoffee )
    cout << "*ptr: " << *ptr << endl; 

  // overwrite a name
  *pNico = "Nicolai";

  cout << "------------" << endl;

  // print all again
  for( auto ptr : whoMadeCoffee )
    cout << "*ptr: " << *ptr << endl; 

  // what's the use_count of pJutta?
  cout << "use_count: " << whoMadeCoffee[0].use_count() << endl;
}

Here use_count is 4.


{sp-init} {cxx-make-shared}
shared_ptr<string> pNico(new string("nico"));           // OK
shared_ptr<string> pNico{new string("nico")};           // OK
shared_ptr<string> pNico = make_shared<string>("nico"); // OK
shared_ptr<string> pNico = new string("nico");          // NO

// NO since requires converting-ctor but shared ptr's ctor are explicit 
shared_ptr<int> clone(int p) {
  return new int(p);
}

// points to '9999999999'
shard_prt<string> p4 = make_shared<string>(10, '9');

// points to empty vector<string>
auto p6 = make_shared<vector<sting>>();


<safer-and-faster>
shared_ptr<T> sp(new X(...)) performs two allocations: one for X and one for
the control block used, for example, by the shared pointer to manage its use
count. 
  
Using make_shared<T>(...) instead is considerably faster, performing only one
allocation, and safer because a situation where the allocation of X succeeds
but the allocation of the control block fails cannot occur: do alloc and bind
at the same time.

<use-count-on-make-shared>
What's the use_count when creates make_shared?

int main()
{
  shared_ptr<string> spstr = make_shared<string>("this is string");

  cout << "spstr.count() : " << spstr.use_count() << endl;
}

spstr.count() : 1

This question comes from:

bsk.add_item( make_shared<Quote>("123", 45) );
// void add_item( const std::shared_ptr<Quote>& sale);



{cpp-sp-reset}
Why not assignment instead of using reset when assign a shared pointer with a
new resource? 

  // * Think that operator=() is to decrease a reference counter of left and to
  //   increase the one of right. However, cannot increase a count of new
  //   objects. 

  * This is when set shared pointer with new resource and assignment works
    between shared pointers.


p.reset();
p.reset(q);
p.reset(q, d);

If p is the only `shared_ptr` pointing at its object, reset frees p's existing
object. If the optional built-in pointer q is passed, makes p points to q,
  otherwise makes p null. If d is supplied, will call d to free q otherwise
  use delete to free q.

After all, `reset()` decrease count of left and set shared pointer with the
given pointer or `nullptr`.

The reset can be used to bind a pointer with shared pointer later.

shared_ptr<string> pNico4;
pNico4.reset(new string("nico"));

However, cannot use `copy-form-init` since shared pointer ctors that takes
pointers `are explicit` but copy-from reuires implicit conversion.

shared_ptr<int> p (new int(42));
p = new int(1024);                  // ERROR

shared_ptr<int> p = new int(42);    // ERROR


<access-to-pointee>
The `shared_ptr` provide 'only' operators * and ->. Pointer arithmetic and
operator[] are not provided. 

When shared_ptr points to memory block as shm example above, to access the
memory, you have to use get(), which yields the internal pointer wrapped by
shared_ptr to provide the full pointer semantics:

smp.get()[i] = i*42;

Thus, get() provides an alternative of calling:

(&*smp)[i] = i*42;

shared_ptr<vector<T>> pvec;
T var = (*pvec)[index];          // () is necessary since [] is higher than *


{sp-check-users} do not rely on use_count()
To check how many users are. Return bool on whether there is the only user of
this sp.

sp.unique();

Often to check whether we are the only user before changing the underlying
object:

if( !p.unique() )
   p.reset( new string(*p) );    // we are not alone. allocate a new copy
*p += newValue;                  // we are the only pointer, okay to change

note: 
Like example in when-deletion-happens, use_count() may not be reliable since
C++P 453 reads "may be a slow operation, intended primarily for debugging
purpose"


<copy-shared-ptr>
auto p = make_shared<int>(42);

// p.use++
auto q(p);

// all prints 2
cout << "q: " << q.use_count() << ", p: " << p.use_count() << endl;

auto r = make_shared<int>(52);

// q.use++ and r.use--. destroies a object which r pointed. 
r = q;

// all prints 3
cout << "q: " << q.use_count() << ", p: " << p.use_count() 
      << ", r: " << r.use_count() << endl;


<sp-cast>
CLR Table 5.4

static_pointer_cast(sp)     static_cast<> semantic for sp
dynamic_pointer_cast(sp)    dynamic_cast<> semantic for sp
const_pointer_cast(sp)      const_cast<> semantic for sp

The cast operators allow casting a pointer to a different type. The semantic is
the same as the corresponding operators, and the result is another shared
pointer of a different type. Note that using the ordinary cast operators is not
possible, because it results in undefined behavior:

shared_ptr<void> sp(new int);                 // shared pointer holds a void*
                                              // internally
...
shared_ptr<int>(static_cast<int*>(sp.get()))  // ERROR: undefined behavior
static_pointer_cast<int*>(sp)                 // OK


<ex> <cpp-op-member-access> <cpp-ex-strblob>
The deference(*) and arrow(->) operator used in classes that represent
iterators and in smart pointer.

The arrow must be a member.

// std::string &StrBlobPtr::deref() const
// {
//   auto p = check( curr, "dereference past end");
//   return (*p)[curr];    // () is necessary since [] is higher than *
// }

class StrBlobPtr {
  public:
    std::string &operator*() const
    {
      // p is shared_ptr of underlying shared vector
      auto p = check( curr, "dereference past end");
      return (*p)[curr];    // () is necessary since [] is higher than *
    }
    std::string *operator->() const
    {
      return & this->operator*();
    }
};

The arrow operator delegate the real work by calling the deference operator and
returning the 'address' of the element returned by that operator.

See that both are `const` member and return a reference or pointer to `nonconst`
string since StrBlobPtr only be bound to a `nonconst` StrBlob.

shared_ptr<> p;

p->mem is synonym for (*p).mem

<ex>
item is iterator(pointer) and *item is itself is shared_ptr. Hence to access
member (*item)->mem.

    multiset<std::shared_ptr<Quote>, comp> items;

    for (auto item = items.cbegin(); item != items.cend();
            item = items.upper_bound(*item))
    {
        os << (*item)->isbn() << " occurs, "
            << endl;
    }

<ex>
For array:

*(parray+1) is synomym for parray[1]

the same hold for shared_ptr? No. array is special and not vector.

    shared_ptr<vector<string>> sp(new vector<string>{"one", "two", "three"});

    // OK
    cout << "0: " << (*sp)[0] << endl;
    
    // OK
    cout << "0: " << *(sp->begin()+0) << endl;

    // ERROR
    cout << "0: " << *(*sp+0) << endl;


={============================================================================
*kt_dev_stl_102* cpp-sp-weak

The weak pointer is `checked pointer class.` Two points:

  * The weak_ptr `do not participate in the reference count` of shared_ptr and
    won't affect the lifetime of the object. 

  * Because the object might no longer exist, cannot use a weak_ptr to access
    its object directly.

auto p = make_shared<int>(42);
weak_ptr<int> wp(p);

if (shared_ptr<int> np = wp.lock()) {
  // inside the if, np shares its object with p
}


<use-case>
The shared_ptrs are provided to automatically release resources associated
with objects no longer needed. However, under certain circumstances, this
behavior doesn't work or is not what is intended:

  * One example is 'cyclic' references. If two objects refer to each other
    using shared_ptrs, and you want to release the objects and their
    associated resource if no other references to these objects exist,
    shared_ptr won't release the data, because the use_count() of each object
    is still 1. You might want to use ordinary pointers in this situation, but
    doing so requires explicitly caring for and managing the release of
    associated resources.

  * Another example occurs when you explicitly want to share but not 'own' an
    object. Thus, you have the semantics that the lifetime of a reference to
    an object 'outlives' the object it refers to. Here, shared_ptrs would
    never release the object, and ordinary pointers might not notice that the
    object they refer to is not valid anymore, which introduces the 'risk' of
    accessing released data.


<operations>
* This class requires a shared pointer to get created.

// * Whenever the last shared pointer owning the object loses its ownership, any
// weak pointer automatically becomes empty. note: It this is the case, then no
// need to use lock() so seems not.

* Besides default and copy constructors, class weak_ptr provides 'only' a
  constructor taking a shared_ptr.

* Cannot use operators * and -> to access a referenced object of a weak_ptr
  directly. Instead, you `have to create a shared pointer out of it.`

  * Creating a shared pointer out of a weak pointer checks whether there is
  * (still) an associated object. If not, create an 'empty' shared pointer.
  // If not, this operation will throw an exception or create an 'empty' shared
  // pointer; what exactly happens depends on the operation used.

  * While dealing with the referenced object, the shared pointer can't get
    released since shared pointer was created out of weak pointer.

As a consequence, class weak_ptr provides only a small number of operations:

weak_ptr<T> w(sp);
w.reset();
w.use_count();
w.expired();
w.lock();


<ex>
// cyclic reference. none of the Persons gets released, because each still has
// at least one shared pointer referring to it.

#include <iostream>
#include <string>
#include <vector>
#include <memory>

using namespace std;

class Person {
  public:
    string name;
    shared_ptr<Person> mother;
    shared_ptr<Person> father;
    vector<shared_ptr<Person>> kids;

    Person (const string& n,
        shared_ptr<Person> m = nullptr, shared_ptr<Person> f = nullptr)
      : name(n), mother(m), father(f) 
    {}

    ~Person() {
      cout << "delete " << name << endl;
    }
};

shared_ptr<Person> initFamily (const string& name)
{
  shared_ptr<Person> mom(new Person(name + "'s mom"));
  shared_ptr<Person> dad(new Person(name + "'s dad"));
  shared_ptr<Person> kid(new Person(name, mom, dad));
  mom->kids.push_back(kid);
  dad->kids.push_back(kid);
  return kid;                                 // return kid
}

int main()
{
  shared_ptr<Person> p = initFamily("nico");

  cout << "nico's family exists" << endl;
  cout << "- nico is shared " << p.use_count() << " times" << endl;
  cout << "- name of 1st kid of nico's mom: " 
    << p->mother->kids[0]->name << endl;

  // note: this is when expect dtor happens but not.
  p = initFamily("jim");

  cout << "jim's family exists" << endl;
  cout << "- jim is shared " << p.use_count() << " times" << endl;
  cout << "- name of 1st kid of jim's mom: " 
    << p->mother->kids[0]->name << endl;
}

nico's family exists
- nico is shared 3 times
- name of 1st kid of nico's mom: nico

jim's family exists
- jim is shared 3 times
- name of 1st kid of jim's mom: jim

                                     mom, dad <---
                                               \  \
mom [ 0, 0, kids ]   dad [ 0, 0, kids ]   kid [ m, f, kids ]
               \ (shared or weak)   \
                -> kid               -> kid

Why there is no dtor for two family at all? When assign jim to p, lost nico
family and even if p hold jim family, no dtor since p's(kid) count is not 0.


Solution?

class Person {
  public:
    string name;
    shared_ptr<Person> mother;
    shared_ptr<Person> father;
    vector<weak_ptr<Person>> kids;           // note: weak pointer

    Person (const string& n,
        shared_ptr<Person> m = nullptr, shared_ptr<Person> f = nullptr)
      : name(n), mother(m), father(f) 
    {}

    ~Person() {
      cout << "delete " << name << endl;
    }
};


<check-on-weak-pointer>
To use weak pointer approach, instead of calling

p->mother->kids[0]->name

we now have to insert lock() into the expression

p->mother->kids[0].lock()->name

This lock() yields a shared_ptr out of the weak_ptr the vector of kids
contains.  If this modification is not possible, lock() yields an empty
shared_ptr. 

note:
// In that case, calling operator * or -> would cause 'undefined' behavior.
// Using lock() is 'optional' since still can use directly.

In g++ (Debian 4.7.2-5) 4.7.2, this emits an error:

p->mother->kids[0]->name << endl;

error: base operand of ‘->’ has non-pointer type 
'__gnu_cxx::__alloc_traits<std::allocator<std::weak_ptr<Person> > >::value_type 
{aka std::weak_ptr<Person>}'


Have several options to check that the object still exist: 

  * Can call expired(), which returns true if use_count() is zero, false
    otherwise. This option is equivalent to checking whether use_count()
    is equal to 0 but might be 'faster'.

  * Can explicitly convert a weak_ptr into a shared_ptr by using a
    corresponding shared_ptr constructor. If there is no valid referenced
    object, this constructor will throw a bad_weak_ptr exception. note: or use
    lock().

  * Use use_count(). Not recommended since it is slow and not reliable.


By doing so, we can break the cycle of shared pointers. The output:

nico's family exists
- nico shared 1 times
- name of 1st kid of nicos mom: nico
delete nico
delete nico's dad
delete nico's mom
jim's family exists
delete jim
delete jim's dad
delete jim's mom


As soon as we lose our handle into a kid created - either by assigning a new
value to p or by leaving main() - the kid's object of the family loses its
last owner, which has the effect that both parents lose their last owner. So
'all' objects, initially created by new, are deleted now so that their
destructors get called since weak pointer don't increase count.


={============================================================================
*kt_dev_stl_102* cpp-sp-exception

As with STL, boost do not raise exception when dereferencing.

namespace boost {
  template<class T> class shared_ptr {
    public:
      // never throws; only valid when T is not an array type
      T & operator*() const; 
      // never throws; only valid when T is not an array type
      T * operator->() const; 
  };
};


={============================================================================
*kt_dev_stl_103* cpp-sp-unique cpp-auto-ptr

`no copy or assign support` A pointer that implements the concept of
'exclusive' ownership.

This was `auto_ptr` before C++11 and it has only one user because
`no-ordinary-copy-and-assign-supported`. Only 'one' `unique_ptr` at a time can
point to a given object. So limit the use and transfer ownerships.

  In contrast to shared pointers, a 'minimum' space and time overhead is the
  focus of this class.


<code> *cpp-delete*
/usr/include/c++/4.9/bits/unique_ptr.h
  /// 20.7.12.2 unique_ptr for single objects.

  template <typename _Tp, typename _Dp = default_delete<_Tp>>
    class unique_ptr
    {
      //...

      *cpp-sp-unique-no-copy-support*
      // Disable copy from lvalue.
      unique_ptr(const unique_ptr&) = delete;             // @262
      unique_ptr& operator=(const unique_ptr&) = delete;  // @263

      *cpp-sp-unique-move*
      /// Move constructor.
      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }

      /** @brief Move assignment operator.
       *
       * @param __u  The object to transfer ownership from.
       *
       * Invokes the deleter first if this object owns a pointer.
       */
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
        /* */
      }

      /// Reset the %unique_ptr to empty, invoking the deleter if necessary.
      unique_ptr&
      operator=(nullptr_t) noexcept
      {
        reset();
        return *this;
      }

      /** @brief Replace the stored pointer.
       *
       * @param __p  The new pointer to store.
       *
       * The deleter will be invoked if a pointer is already owned.
       */
      void
      reset(pointer __p = pointer()) noexcept
      {
        using std::swap;
        swap(std::get<0>(_M_t), __p);
        if (__p != pointer())
          get_deleter()(__p);
      }
    };


#include <iostream>
#include <string>
#include <memory>

using namespace std;

int main()
{
  unique_ptr<std::string> p1(new std::string("nico"));
  unique_ptr<string> p2(p1);      // 10: error
  unique_ptr<string> p3;
  p3 = p2;                        // 12: error
}

:10:27: error: use of deleted function ‘std::unique_ptr<_Tp,
  _Dp>::unique_ptr(const std::unique_ptr<_Tp, _Dp>&) [with _Tp =
  std::basic_string<char>; _Dp = std::default_delete<std::basic_string<char> >;
  std::unique_ptr<_Tp, _Dp> = std::unique_ptr<std::basic_string<char> >]’

In file included from /usr/include/c++/4.7/memory:86:0,
                 from t_sp_uni.cpp:3:
/usr/include/c++/4.7/bits/unique_ptr.h:262:7: error: declared here

:12:8: error: use of deleted function ‘std::unique_ptr<_Tp, _Dp>&
std::unique_ptr<_Tp, _Dp>::operator=(const std::unique_ptr<_Tp, _Dp>&) [with _Tp
= std::basic_string<char>; _Dp = std::default_delete<std::basic_string<char> >;
std::unique_ptr<_Tp, _Dp> = std::unique_ptr<std::basic_string<char> >]’

In file included from /usr/include/c++/4.7/memory:86:0,
                 from t_sp_uni.cpp:3:
/usr/include/c++/4.7/bits/unique_ptr.h:263:19: error: declared here


<check> TODO: need to check and confirm
You can check whether a unique_ptr owns an object by calling operator bool():

if (up) {   // if up is not empty
   std::cout << *up << std::endl;
}


{sp-unique-ownership} <unique-transfer-ownership>
The `unique_ptr` do not support copy so `have-to transfer ownership.` Two
options:

u.release() 

relinquishes control of the pointer u has held; returns the pointer u has held
and makes u null.

  "there is no such a thing in shared_ptr"


1. Use release() and reset() pair

The release() return the pointer it held and make the unique ptr null so using
reset/release pair to transfer ownerships.

unique_ptr<string> p2(p1.release());  // 'transfer' ownership. up loses it
std::string* sp = up.release();       // 'transfer' ownership. up loses it
sp.reset(up.release());               // 'transfer' ownership. up loses it


2. Use move semantics.

// initialize a unique_ptr with a new object
std::unique_ptr<ClassA> up1(new ClassA);

// error in compile since no copy support
std::unique_ptr<ClassA> up2(up1);            

// copy the unique_ptr. transfer ownership of the unique_ptr
std::unique_ptr<ClassA> up3(std::move(up1)); 


// initialize a unique_ptr with a new object
std::unique_ptr<ClassA> up1(new ClassA);

// create another unique_ptr
std::unique_ptr<ClassA> up2; 

// *error* since no copy support
up2 = up1;              

// assign the unique_ptr since supports `rvalue` assign. transfers ownership
// from up1 to up2
up2 = std::move(up1);   


<return-unique-ptr> *cpp-move* *cpp-return*
One exception to the rule that cannot copy a unique_ptr; that according to the
language rules of C++11, the compiler will try a 'move' automatically. Can
copy or assign a unique_ptr that is about to be destoryed.

unique_ptr<int> clone(int p) {
  ...
  // explicitly create a pointer
  return unique_ptr<int>( new int(p) );
}

unique_ptr<int> clone(int p) {
  unique_ptr<int> ret( new int(p) );
  ...
  // can return a copy of local object
  return ret;
}


<cpp-pattern-source-and-sink>
http://www.gotw.ca/gotw/025.htm
https://eli.thegreenplace.net/2012/06/20/c11-using-unique_ptr-with-standard-library-containers

struct FooX 
{
    FooX() { cerr << "Foo [" << this << "] constructed\n"; }
    virtual ~FooX() { cerr << "Foo [" << this << "] destructed\n";}
};

void sink(unique_ptr<FooX> p) 
{
    cerr << "Sink owns Foo[" << p.get() << "]\n";
}

unique_ptr<FooX> source() 
{
    cerr << "Creating Foo in source\n";
    // *cpp-return* transfer ownership to calling function
    return unique_ptr<FooX>(new FooX);
}

void main()
{   
    cerr << "Calling source\n";
    unique_ptr<FooX> pmain = source();  // Can also be written as
    // auto pmain = source();

    cerr << "Now pmain owns Foo [" << pmain.get() << "]\n";
    cerr << "Passing it to sink\n";

    // sink(pmain);                    // ERROR! can't copy unique_ptr
    
    // why okay since sink() do not have rvalue parameter? because unique_ptr
    // has move ctor and sink() will have move constructed parameter.
    sink(move(pmain));              // OK: can move it!

    cerr << "Main done\n";
}


void g()
{
    std::unique_ptr<ClassA> p;

    for (int i=0; i<10; ++i) {

        // p gets ownership of the returned object since no copy support
        p = source(); 
        // (previously returned object of f() gets deleted)
        ...
    }
} // last-owned object of p gets deleted

'no' resource leak is possible. Even if an exception is thrown, any unique_ptr
that owns data ensures that this data is deleted.


<misuse-unique-pointer>
// lost pointer
// ERROR. p2 won't free the memory and have lost the pointer.
p2.release();

// OK. but must remember to delete(p).
auto p = p2.release();


<use-as-members> exception-in-ctor
A unique_ptr helps to avoid resource leaks caused by exceptions thrown during
the initialization of an object. Note that destructors are called 'only' if
any construction is completed. 

So, if an exception occurs inside a constructor, destructors are called 'only'
for objects that have been fully constructed. This can result in resource
leaks for classes with multiple raw pointers if during the construction the
first new was successful but the second was not.

class ClassB {
  private:
    ClassA* ptr1; // pointer members
    ClassA* ptr2;

  public:
    // constructor that initializes the pointers - will cause resource leak if
    // second new throws
    ClassB (int val1, int val2)
      : ptr1(new ClassA(val1)), ptr2(new ClassA(val2)) {
      }

    // copy constructor - might cause resource leak if second new throws
    ClassB (const ClassB& x)
      : ptr1(new ClassA(*x.ptr1)), ptr2(new ClassA(*x.ptr2)) {
      }

    ~ClassB () {
      delete ptr1;
      delete ptr2;
    }
};

To avoid such a 'possible' resource leak,

class ClassB {
  private:
    std::unique_ptr<ClassA> ptr1; // unique_ptr members
    std::unique_ptr<ClassA> ptr2;

  public:
    // constructor that initializes the unique_ptrs - no resource leak possible
    ClassB (int val1, int val2)
      : ptr1(new ClassA(val1)), ptr2(new ClassA(val2)) {
      }

    // copy constructor - no resource leak possible
    ClassB (const ClassB& x)
      : ptr1(new ClassA(*x.ptr1)), ptr2(new ClassA(*x.ptr2)) {
      }

    // no destructor necessary
    // (default destructor lets ptr1 and ptr2 delete their objects)
};


note: 
* Can skip the destructor now because unique_ptr does the job for you. 

* Also have to implement the copy constructor and assignment operator. By
  default, both would try to copy or assign the members, which isn't possible.
  If you don't provide them, ClassB also would provide only move semantics.
  <Q> by compiler? Here valuelike used.

  note: TODO more about copy ctor and assign when used as a member.


<use-with-containers>
`auto_ptr` is not possible to store an auto_ptr in a container, nor could we
return one from a function. How about `unique_ptr`?


={============================================================================
*kt_dev_stl_103* cpp-sp-delete

{sp-nullptr} {when-deletion-happens}
Such a deletion does not necessarily have to happen at the end of the scope.
For example, assigning the nullptr to pNico or resizing the vector so that it
contains only the first two elements and would delete when the last owner of
the string set to nullptr.

See that underlying refered-to object is different from shared pointer.

u.reset() 
delete the object to which u points. same as u = nullptr.

u = nullptr
delete the object to which u points only for unique_ptr; makes u null


<ex>
#include <iostream>
#include <memory>
#include <string>
#include <vector>

using namespace std;

void delete_mesg( string *str )
{
  cout << "deleter called: " << *str << endl;
}

int main()
{
  shared_ptr<string> pNico(new string("nico"), delete_mesg );
  shared_ptr<string> pJutta(new string("jutta"), delete_mesg);

  // *cpp-lambda*
  // shared_ptr<string> pJutta(new string("jutta"), 
  //     [](string *p) {
  //     cout << "delete " << *p << endl; 
  //     delete p;
  //     });

  // capitalize the first char
  (*pNico)[0] = 'N';
  pJutta->replace(0,1,"J");

  // put them multiple times in a container
  vector<shared_ptr<string>> whoMadeCoffee;
  whoMadeCoffee.push_back(pJutta);
  whoMadeCoffee.push_back(pJutta);
  whoMadeCoffee.push_back(pNico);
  whoMadeCoffee.push_back(pJutta);
  whoMadeCoffee.push_back(pNico);

  // print all
  for( auto ptr : whoMadeCoffee )
    cout << "*ptr: " << *ptr << "    "; 

  // overwrite a name
  *pNico = "Nicolai";

  cout << endl << "------------" << endl;

  // print all again
  for( auto ptr : whoMadeCoffee )
    cout << "*ptr: " << *ptr << "    "; 

  cout << endl;
  cout << "use_count(jutta): " << whoMadeCoffee[0].use_count() << endl;

  pJutta = nullptr;

  cout << "use_count(jutta): " << whoMadeCoffee[0].use_count() << endl;
  cout << "use_count(nico ): " << whoMadeCoffee[2].use_count() << endl;

  whoMadeCoffee.resize(2);
  cout << "resize to 2 " << endl;

  pNico = nullptr;

  cout << "use_count(jutta): " << pJutta.use_count() << endl;
  cout << "use_count(nico ): " << pNico.use_count() << endl;
}


kt@kt-ub-vb:~/work$ ./a.out 
*ptr: Jutta    *ptr: Jutta    *ptr: Nico    *ptr: Jutta    *ptr: Nico    
------------
*ptr: Jutta    *ptr: Jutta    *ptr: Nicolai    *ptr: Jutta    *ptr: Nicolai    
use_count(jutta): 4
use_count(jutta): 3              // after set nullptr
use_count(nico ): 3
resize to 2 
deleter called: Nicolai          // when set nullptr
use_count(jutta): 0              // why? see *sp-check-users*
use_count(nico ): 0
deleter called: Jutta


<ex>
#include <iostream>
#include <memory>

// g++ -g -std=c++0x t_override.cpp

using namespace std;

class Foo 
{
  private:
    int id;
  public:
    Foo(int val):id(val) { cout << "Foo ctor(" << id << ")" << endl; }
    ~Foo() { cout << "Foo dtor(" << id << ")" << endl; }
};

int main()
{
    shared_ptr<Foo> p1(new Foo(1));
    shared_ptr<Foo> p2(p1);

    cout << "p1.use_count: " << p1.use_count() << endl;
    cout << "p2.use_count: " << p2.use_count() << endl;

    p1 = nullptr;
    cout << "p1.use_count: " << p1.use_count() << endl;
    cout << "p2.use_count: " << p2.use_count() << endl;

    p1 = nullptr;
    cout << "p1.use_count: " << p1.use_count() << endl;
    cout << "p2.use_count: " << p2.use_count() << endl;

    p1 = nullptr;
    cout << "p1.use_count: " << p1.use_count() << endl;
    cout << "p2.use_count: " << p2.use_count() << endl;

    cout << "-----------" << endl;

    cout << "p1.use_count: " << p1.use_count() << endl;
    cout << "p2.use_count: " << p2.use_count() << endl;

    p2 = nullptr;
    cout << "p1.use_count: " << p1.use_count() << endl;
    cout << "p2.use_count: " << p2.use_count() << endl;

    p2 = nullptr;
    cout << "p1.use_count: " << p1.use_count() << endl;
    cout << "p2.use_count: " << p2.use_count() << endl;

    p2 = nullptr;
    cout << "p1.use_count: " << p1.use_count() << endl;
    cout << "p2.use_count: " << p2.use_count() << endl;

    cout << "end of main" << endl;
}

// shares use_count() but dtor is not called until when set null to p2. shared
// pointers are different entities from the referred-to 

Foo ctor(1)
p1.use_count: 2
p2.use_count: 2
p1.use_count: 0
p2.use_count: 1
p1.use_count: 0
p2.use_count: 1
p1.use_count: 0
p2.use_count: 1
-----------
p1.use_count: 0
p2.use_count: 1
Foo dtor(1)           // when set null to p2
p1.use_count: 0
p2.use_count: 0
p1.use_count: 0
p2.use_count: 0
p1.use_count: 0
p2.use_count: 0
end of main

<ex>
#include <iostream>
#include <memory>

using namespace std;

class Foo 
{
  private:
    int id;
  public:
    Foo(int val):id(val) { cout << "Foo ctor(" << id << ")" << endl; }
    ~Foo() { cout << "Foo dtor(" << id << ")" << endl; }
};

int main()
{
  unique_ptr<Foo> p1(new Foo(1));
  unique_ptr<Foo> p2(new Foo(2));
  unique_ptr<Foo> p3(new Foo(3));

  p2.reset(p3.release());
  cout << "-----------" << endl;

  p3.reset(p1.release());
  cout << "-----------" << endl;

  p3.reset(p1.release());
  cout << "-----------" << endl;

  cout << "end of main" << endl;
}

Foo ctor(1)
Foo ctor(2)
Foo ctor(3)
Foo dtor(2)     // p2.reset frees 2
-----------
-----------     // free nothing and changes the referred-tos
Foo dtor(1)     // p3.reset(null) frees 1
-----------
end of main
Foo dtor(3)


{sp-default-deleter}
The deleter is callable and is called when is needed. Here the excerpt from stl
unique_ptr.h. See default_delete is overload operator().

/// Primary template, default_delete.
template<typename _Tp>
struct default_delete
{
    constexpr default_delete() noexcept = default;

    template<typename _Up, typename = typename
        std::enable_if<std::is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }

    void
        operator()(_Tp* __ptr) const
        {
          *cpp-static-assert*
          static_assert(sizeof(_Tp)>0, "can't delete pointer to incomplete type");

          `delete __ptr;`
        }
};

/// 20.7.12.2 unique_ptr for single objects.
template <typename _Tp, typename _Dp = default_delete<_Tp> >
class unique_ptr
{
    class _Pointer 
    { 

    };

    typedef std::tuple<typename _Pointer::type, _Dp>  __tuple_type;
    __tuple_type                                      _M_t;

      typedef typename _Pointer::type   pointer;
      typedef _Dp                       deleter_type;

    explicit
        unique_ptr(pointer __p) noexcept

        // *cpp-stl-tuple* set tuple with pointer and a default created
        // deleter

        : _M_t(__p, deleter_type())
        { static_assert(!std::is_pointer<deleter_type>::value,
                "constructed with null function pointer deleter"); }

    // Destructor.
    ~unique_ptr() noexcept
    {
        // get first of tuple which is pointer and 
        // if not null, call deleter() which has `single argument`
        
        auto& __ptr = std::get<0>(_M_t);
        if (__ptr != nullptr)
            get_deleter()(__ptr);
        __ptr = pointer();
    }

    deleter_type&
        get_deleter() noexcept
        { return std::get<1>(_M_t); }
}


{set-own-deleter}

shared_ptr<T> p(q, d);      // built-in pointer q
shared_ptr<T> p(p2, d);     // shared_ptr p2

However, how can we make it sense when using resources which have own
interfaces since default deleter uses delete operator.

void f()
{
  shared_ptr<int> sp(new int(42));
  // use sp
  // exception occur and no catch
}

void f()
{
  connection c = connect(&d);
  // use connection
  // if exception occur, no way to close conn
}

User can set deleter of shared_ptr rather than the default deleter, delete.
This deleter must take a 'single' argument of type T*. otherwise, compile
error void end_connection( connection *p ) { disconnect(*p); }

void f()
{
  connection c = connect(&d);
  shared_ptr<connection> p(&c, end_connection);
  // use connection
  // if exception occur
}


unique_ptr<T, D> u2;
unique_ptr<T, D> u(d);

void f(destination &d)
{
  connection c = connect(&d);
  unique_ptr<connection, decltype(end_connection)*> p(&c, end_connection);
  // use connection
  // if exception occur
}


# delete with array (p80, revisit when necessary)


# delete with other destruction policy 
When resource cleaning up is more complicated than a single function call,
needs destruction policy.

note: this examples shows how function object is useful.
note: the passed deleter is not allowed to throw exceptions.

<ex> 
// to ensure that a temporary file gets removed when the last reference to it
// gets destroyed. see the way that handles more than a single argument passed
// in deleter via member.

#include <string>
#include <fstream>   // for ofstream
#include <memory>    // for shared_ptr
#include <cstdio>    // for remove()

class FileDeleter
{
  private:
    std::string filename;
  public:
    FileDeleter (const std::string& fn)
      : filename(fn) {
      }
    void operator () (std::ofstream* fp) {      // T is ofstream and T*
      fp->close();                              // close.file
      std::remove(filename.c_str());            // delete file
    }
};

int main()
{
  // create and open temporary file:
  std::shared_ptr<std::ofstream> fp(new std::ofstream("tmpfile.txt"),
      FileDeleter("tmpfile.txt"));
  ...
}

<ex> // to use shared_ptrs to deal with shm

#include <memory> // for shared_ptr
#include <sys/mman.h> // for shared memory
#include <fcntl.h>
#include <unistd.h>
#include <cstring> // for strerror()
#include <cerrno> // for errno
#include <string>
#include <iostream>

class SharedMemoryDetacher
{
  public:
    void operator () (int* p) {
      std::cout << "unlink /tmp1234" << std::endl;
      if (shm_unlink("/tmp1234") != 0) {
        std::cerr << "OOPS: shm_unlink() failed" << std::endl;
      }
    }
};

std::shared_ptr<int> getSharedIntMemory (int num)
{
  void* mem;
  int shmfd = shm_open("/tmp1234", O_CREAT|O_RDWR, S_IRWXU|S_IRWXG);
  if (shmfd < 0) {
    throw std::string(strerror(errno));
  }
  if (ftruncate(shmfd, num*sizeof(int)) == -1) {
    throw std::string(strerror(errno));
  }
  mem = mmap(nullptr, num*sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, 0);
  if (mem == MAP_FAILED) {
    throw std::string(strerror(errno));
  }

  // note: here
  return std::shared_ptr<int>(static_cast<int*>(mem), SharedMemoryDetacher());
}

int main()
{
  // get and attach shared memory for 100 ints:
  std::shared_ptr<int> smp(getSharedIntMemory(100));

  // init the shared memory
  for (int i=0; i<100; ++i) {
    smp.get()[i] = i*42;               // see get
  }
  // deal with shared memory somewhere else:
  ...

  std::cout << "<return>" << std::endl;
  std::cin.get();

  // release shared memory here:
  smp.reset();
  ...
}


={============================================================================
*kt_dev_stl_103* cpp-sp-unique: can store unique_ptr in a container?

For unique-ptr, no copy support and has to transfer ownership. For containers,
the element to store had to be `copyable`.

<try>
#include <iostream>
#include <memory>
#include <vector>

using namespace std;

class Foo 
{
  private:
    int id;
  public:
    Foo(int val):id(val) { cout << "Foo ctor(" << id << ")" << endl; }
    ~Foo() { cout << "Foo dtor(" << id << ")" << endl; }
};

int main()
{
  unique_ptr<Foo> p1( new Foo(1) );
  unique_ptr<Foo> p2( new Foo(2) );
  unique_ptr<Foo> p3( new Foo(3) );
  unique_ptr<Foo> p4( new Foo(4) );

  // put them into a container
  vector< unique_ptr<Foo>> pvec;
  pvec.push_back(p1);
}

error: use of deleted function ‘std::unique_ptr<_Tp, _Dp>::unique_ptr(const
           std::unique_ptr<_Tp, _Dp>&) [with _Tp = Foo, _Dp =
std::default_delete<Foo>, std::unique_ptr<_Tp, _Dp> = std::unique_ptr<Foo>]’

This error means that there is no copy ctor since unique_ptr do not support
copy. Hence deleted. So cannot store unique_ptr in a container? NO, can since
C++11 since not copyable but moveable.

note: Even if unique_ptr is copyable, it's difficult to get the expected result
right. For example, when get a pointer from a container and use it which means
pointer in a container is no longer vaild. What will happen when container
destructor runs?

http://eli.thegreenplace.net/2012/06/20/c11-using-unique_ptr-with-standard-library-containers/

C++11: using unique_ptr with standard library containers
June 20th, 2012 at 8:46 pm

Before C++11, the only "smart" pointer available in the standard C++ library was
auto_ptr. Alas, auto_ptr isn't very smart. It has very problematic copy
semantics that make it difficult to use in several important scenarios. In
particular, auto_ptr can not be used with standard containers and algorithms!

To quote from Herb Sutter:

auto_ptr is most charitably characterized as a valiant attempt to create a
unique_ptr before C++ had move semantics. auto_ptr is now deprecated, and should
not be used in new code. When you get a chance, try doing a global
search-and-replace of auto_ptr to unique_ptr in your code base

So what is this unique_ptr thing, and what can it be used for?

Basic capabilities

To put it simply, `unique_ptr` 'should' be the 'default' smart pointer used by
new C++ code, replacing "raw" pointers as much as possible. unique_ptr cleanly
represents the single ownership idiom - it cannot be copied and assigned, and it
cleans up the pointed object when it's destructed.

Here's some code to demonstrate this [1]:

#include <iostream>
#include <cstdlib>
#include <memory>          // note header

using namespace std;

struct Foo {
    // note use of `this` to get address 
    Foo() {cerr << "Foo [" << this << "] constructed\n";}
    virtual ~Foo() {cerr << "Foo [" << this << "] destructed\n";}
};

int main(int argc, char** argv) 
{
  // .. some code
  {
    unique_ptr<Foo> fp(new Foo());

    unique_ptr<Foo> fp2(fp);    // ERROR! can't copy unique_ptr
    unique_ptr<Foo> fp3;
    fp3 = fp;                   // ERROR! can't assign unique_ptr

    cerr << "Exiting scope\n";
  } // fp will be destroyed, and will destruct the pointed object

  return 0;
}

The lines marked with the ERROR! comment won't actually compile. The compiler
will complain saying something like:

error: use of deleted function
 'std::unique_ptr<_Tp, _Dp>::unique_ptr(const std::unique_ptr<_Tp, _Dp>&)

If these two lines are commented out, the code will print:

Foo [0x845010] constructed
Exiting scope
Foo [0x845010] destructed

In addition to managing the pointed object's lifetime, unique_ptr provides the
other expected capabilities of a smart pointer: it overloads operator* and
operator->, provides a means to obtain the raw pointer (get), to relinquish
control of the pointed object (release), and to replace the object it manages
(reset). It also lets you customize the way the pointed object is deleted (if
    you don't want it to be the default delete operator), and has some other
niceties - just consult your favorite C++ reference.

What about sources and sinks?

In this article I want to focus not on the grocery list of unique_ptr's
features, but its interesting move semantics. Specifically, given that
unique_ptr forbids copying and assignment, one may wonder how it can fit in the
`source-and-sink-idiom` which is so useful for smart pointers.

In other words, we'd like this to work:

// source creates a Foo object, wraps it in a smart pointer for safety and
// provides the result to the caller, giving it the ownership of the object in
// the process.

unique_ptr<Foo> source();

// sink gets a Foo object wrapped in a smart pointer for safety. It also assumes
// ownership of the provided object.

void sink(unique_ptr<Foo> p);

And in C++11, it does! Even though unique_ptr can't be copied, it can be
'moved'. Move semantics are a perfect match for unique_ptr - the two concepts
reinforce each other. With move semantics, unique_ptr is both safe and
efficient. Here's some code to demonstrate this:

#include <iostream>
#include <cstdlib>
#include <memory>

using namespace std;

struct Foo {
  Foo() {cerr << "Foo [" << this << "] constructed\n";}
  virtual ~Foo() {cerr << "Foo [" << this << "] destructed\n";}
};

void sink(unique_ptr<Foo> p) {
  cerr << "Sink owns Foo [" << p.get() << "]\n";
}

unique_ptr<Foo> source() {
  cerr << "Creating Foo in source\n";
  return unique_ptr<Foo>(new Foo);
}

int main(int argc, char** argv) {
  cerr << "Calling source\n";
  unique_ptr<Foo> pmain = source();  // Can be written as auto pmain = source();

  cerr << "Now pmain owns Foo [" << pmain.get() << "]\n";
  cerr << "Passing it to sink\n";
  sink(pmain);                    // ERROR! can't copy unique_ptr
  sink(move(pmain));              // OK: can move it!    // meant std::move

  cerr << "Main done\n";
  return 0;
}

Again, there's a line marked with ERROR! here - it demonstrates once again that
a unique_ptr can't be copied. However, it can be explicitly moved, as the next
line shows [2]. When the erroneous line is commented out, this code prints:

[2] It can also be taken from an rvalue: sink(unique_ptr<Foo>(new Foo)) would
work, because rvalue references can be moved directly. note: here again temp
object hence rvalue

Calling source
Creating Foo in source
Foo [0x1767010] constructed
Now pmain owns Foo [0x1767010]
Passing it to sink
Sink owns Foo [0x1767010]
Foo [0x1767010] destructed
Main done

Note how cleanly the ownership is being passed between the functions in this
code. At each point in time, only a single unique_ptr owns the pointed Foo
object. Moreover, this is efficient - the actual pointed object only gets
constructed once and destructed once.


Containers - motivation

So unique_ptr is a useful single-ownership smart pointer. But what makes it
really shine (especially when compared to auto_ptr) is that it can be used in
standard containers.

Why is it so important to be able to place smart pointers into containers?
Because holding objects by value is sometimes very expensive. 

Containers, especially when coupled with algorithms, tend to move objects
around. Large objects are expensive to copy, hence we'd like to keep pointers to
objects inside containers instead.

What follows is a very simplistic example that demonstrates this. It shows how
much more expensive it is to sort a vector of large objects that are stored
`by-value`, than it is when they're stored by pointer [3].

Also, I explicitly said to take the container example with a grain of salt as it
was synthetically built to demonstrate the point. Yes, it is best to avoid huge
objects, but that's not always possible.

First, let's create a synthetic "large" object that has well defined ordering
properties by some numeric ID:

struct SomeLargeData {
    SomeLargeData(int id_)
        : id(id_)
    {}
    int id;
    int arr[100];
};

We also need a function to compare two such objects. Actually, we need two - one
for a container that holds object by value, and another for the by pointer
version:

bool compare_by_value(const SomeLargeData& a, const SomeLargeData& b) {
    return a.id < b.id;
}

bool compare_by_ptr(const SomeLargeData* a, const SomeLargeData* b) {
    return a->id < b->id;
}

Let's now create two vectors and populate them with random objects:

vector<SomeLargeData> vec_byval;
vector<SomeLargeData*> vec_byptr;

for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    vec_byval.push_back(SomeLargeData(id));
    vec_byptr.push_back(new SomeLargeData(id));
}

Finally, we'll sort the two vectors with the standard sort algorithm, and
measure the runtime for some large n:

sort(vec_byval.begin(), vec_byval.end(), compare_by_value);
sort(vec_byptr.begin(), vec_byptr.end(), compare_by_ptr);

The timing results I get are quite consistent - the by-pointer sorting is 2-3x
faster than the by-value sorting [4]. That's a very significant difference, and
it's all due to the copying sort has to do for moving the objects around inside
the container.

[4] The speedup grows as the size of the object grows. Increasing the arr member
to hold 1000 integers makes the speedup 10x.

So holding objects of non-trivial size inside standard containers is not a good
idea in terms of performance. But holding raw pointers to them is also not so
great, because of all the safety issues that come with raw pointers. The
container can't own the pointed objects because its destructor will just
"destruct" the pointer(note not pointed object), which does nothing. So the
calling code(note client) has to own the actual objects which are being shuffled
around by the container. Add exceptions and/or early returns to the mix, and
this is a recipe for memory leaks or even worse problems.

What we'd really like to do is let our objects be managed by a smart pointer and
put that into a container. This would guarantee a clean ownership strategy - the
container destroys its contents when it gets destroyed itself - just the way it
should be. This is why unique_ptr is so exciting.


Containers of unique_ptr

note:
Why cannot use `auto_ptr` with containers? The auto_ptr supports copy but copies
of auto_ptr are not equivalent since it transfers owenrship. Containers assumes
that copies are the same and after finishing internal works involving make
copies, would have use auto_ptr object which do not own real object. So
undefined. Now `uniqur_ptr` do copy explicitly.

Adapting the by-pointer version of the code above to hold unique_ptr is very
simple. First, we need another comparison function:

bool compare_by_uniqptr(const unique_ptr<SomeLargeData>& a,
                        const unique_ptr<SomeLargeData>& b) {
    return a->id < b->id;
}

And then we just need to create the vector, populate it and then sort it,
    similarly to the way we've done for the other vectors:

vector<unique_ptr<SomeLargeData>> vec_byuniqptr;

for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    // ...
    vec_byuniqptr.push_back(
        unique_ptr<SomeLargeData>(new SomeLargeData(id)));  
    // note `temporty-unique-ptr` object. shall be this form since no copy
    // supported or use std::move
}

sort(vec_byuniqptr.begin(), vec_byuniqptr.end(), compare_by_uniqptr);

That's it! And the performance? 'almost' identical to the by-pointer version (I
    measured differences of 1-5%, depending on the data).


What about shared pointers?

Another smart pointer C++11 brings with it is the shared_ptr/weak_ptr pair,
        implementing a reference-counted approach to shared ownership. While
        much more flexible than unique_ptr, shared_ptr is slower and consumes
        more memory; managing the reference count is not free [5].

[5] For the sorting benchmark demonstrated in this article shared_ptr is about
10% slower than unique_ptr. As for size, while the size of unique_ptr is exactly
the size of a raw pointer, shared_ptr is about twice as large.

Which one to use depends on your exact needs, but I agree with Herb Sutter's
proposal of using unique_ptr by default and switching to shared_ptr if the need
arises.

In addition, it is my personal opinion that preferring unique_ptr imposes a
certain memory management discipline on the code, since you know at each point
exactly who owns what. Shared pointers give you a sense of security you can over
use and end up with reference leaks, which are tricky to debug (just like when
    writing Python C extension code). 

Moreover, shared pointers signal the intention of APIs less clearly than owning
pointers. When some factory returns a shared pointer, does it mean it keeps a
reference to the object too? With an owning pointer, the API is self documenting
(source returns a unique_ptr? then source is for sure giving away ownership).
With a shared pointer, it does not, and need external documentation to clarify.

Conclusion

I have mentioned how rvalue references and move semantics can make code more
efficient with C++11. unique_ptr is another great example that makes me want to
use a C++11-capable compiler as soon as possible.

unique_ptr provides an excellent mix of efficiency and safe memory management.
IMHO it's a great example of how several ideas in language design interact to
create a whole that is larger than its parts.

Replies:

<1>
fanNo Gravatar Says:
June 25th, 2012 at 14:48

Can't we get the best of all worlds, by doing this:

vector<SomeLargeData> vec_byval;
vector<SomeLargeData*> vec_byptr;

for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    vec_byval.push_back(SomeLargeData(id));
    vec_byptr.push_back(&vec_byval.back());   // saves up the inserted entry
}

sort(vec_byptr.begin(), vec_byptr.end(), compare_by_ptr);

This gives us fast by-pointer sorting AND ownership of the pointed objects. So I
don't get the excitement about unique_ptr.

<2>
westforkNo Gravatar Says:
November 5th, 2012 at 12:22

Nice article. But my results are different from what you wrote.  I implemented
your code using gcc 4.7 (g++ (Ubuntu/Linaro 4.7.2-4precise1) 4.7.2) on my
desktop (OS xubuntu 12.04, Intel(R) Core(TM)2 Duo CPU, E8400 @ 3.00GHz).  I
build a vector of 2010000 containing SomeLargeData objects, raw pointers to
SomeLargeData objects and unique-pointers to SomeLargeData objects. The results
are that raw pointer container is the faster to sort (as expected) but the
container with the unique pointers is the slower!!!  Here a dump of my tests

By value test
TIMESTAMP-START 11:18:23:127277 (ms ~ 40703127)
TIMESTAMP-END 11:18:27:378556 (ms ~ 40707378)
ELAPSED TIME (ms) 4251

By pointer test
TIMESTAMP-START 11:18:27:378658 (ms ~ 40707378)
TIMESTAMP-END 11:18:29:841735 (ms ~ 40709841)
ELAPSED TIME (ms) 2463

By unique_pointer test
TIMESTAMP-START 11:18:29:841816 (ms ~ 40709841)
TIMESTAMP-END 11:18:35:674064 (ms ~ 40715674)
ELAPSED TIME (ms) 5833

What do you think? The overhead of the unique-ptr over the raw pointer is so
heavy?


<3>
SqeakyNo Gravatar Says:
March 19th, 2013 at 11:58

@Fan The first time the value vector grows it will invalidate all the pointers
in the pointer vector. Since it never tells you when this happens, but can
happen on any insertion, you have to assume that the pointer is invalid after
the next insertion.

@Westfork I would guess that the implementation just hasn't had enough time to
mature yet. There must be at least as much over with the unique_ptr as raw
pointers, but double does seem excessive.  Did you remember to delete in the raw
pointer example?


<4>
This is my result on the VM in a laptop.

#include <iostream>
#include <memory>
#include <vector>
#include <sys/time.h>
#include <algorithm>

using namespace std;

typedef uint64_t u64;

static u64 nsec() {
  struct timeval tv;
  if(gettimeofday(&tv, 0) < 0)
    return -1;
  return (u64)tv.tv_sec*1000*1000*1000 + tv.tv_usec*1000;
}

struct SomeLargeData {
  SomeLargeData(int id_)
    : id(id_)
  {}

  // SomeLargeData(int id_)
  //   : id(id_)
  // { cout << "Foo[" << this << "] ctor(" << id << ")" << endl; }
  // ~SomeLargeData() { cout << "Foo[" << this << "] dtor(" << id << ")" << endl; }

  int id;
  int arr[100];
};

bool compare_by_value(const SomeLargeData& a, const SomeLargeData& b) {
  return a.id < b.id;
}

bool compare_by_ptr(const SomeLargeData* a, const SomeLargeData* b) {
  return a->id < b->id;
}

bool compare_by_uniqptr(const unique_ptr<SomeLargeData>& a, const unique_ptr<SomeLargeData>& b) {
  return a->id < b->id;
}

int main()
{
  uint64_t be, af;
  int n = 400;

  vector<SomeLargeData> vec_byval;
  vector<SomeLargeData*> vec_byptr;
  vector<unique_ptr<SomeLargeData>> vec_byuniqptr;

  for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    vec_byval.push_back(SomeLargeData(id));
    vec_byptr.push_back(new SomeLargeData(id));    // note. shall be deleted later
    vec_byuniqptr.push_back(unique_ptr<SomeLargeData>(new SomeLargeData(id)));
  }  

  be = nsec();
  sort(vec_byval.begin(), vec_byval.end(), compare_by_value);
  af = nsec();
  cout << "by value: diff(ns): " << af-be << endl;
  cout << "by value: diff(ms): " << (af-be)/(1000) << endl;

  be = nsec();
  sort(vec_byptr.begin(), vec_byptr.end(), compare_by_ptr);
  af = nsec();
  cout << "by ptr: diff(ns): " << af-be << endl;
  cout << "by ptr: diff(ms): " << (af-be)/(1000) << endl;

  be = nsec();
  sort(vec_byuniqptr.begin(), vec_byuniqptr.end(), compare_by_uniqptr);
  af = nsec();
  cout << "by uptr: diff(ns): " << af-be << endl;
  cout << "by uptr: diff(ms): " << (af-be)/(1000) << endl;
}

$ ./a.out 
by value: diff(ns): 302000
by value: diff(ms): 302
by ptr: diff(ns): 127000
by ptr: diff(ms): 127
by uptr: diff(ns): 585000
by uptr: diff(ms): 585


={============================================================================
*kt_dev_stl_104* cpp-sp-misuse

CLR 5.2.3

1. Cyclic reference shown above.


2. Double delete. 
Have to ensure that only one 'group' of shared pointers owns an object.

int* p = new int;
shared_ptr<int> sp1(p);
shared_ptr<int> sp2(p);   // no compile error but error in double delete.

For this reason, you should always directly initialize a smart pointer the
moment you create the object with its associated resource:

shared_ptr<int> sp1(new int);
shared_ptr<int> sp2(sp1);  // OK


3. Indirect double delete.
Suppose that we want to introduce a member function for a Person that creates
both the reference from a kid to the parent and a corresponding reference back:

// shared_ptr<Person> initFamily (const string& name)
// {
//   shared_ptr<Person> mom(new Person(name+"'s mom"));
//   shared_ptr<Person> dad(new Person(name+"'s dad"));
//   shared_ptr<Person> kid(new Person(name,mom,dad));
//   mom->kids.push_back(kid);
//   dad->kids.push_back(kid);
//   return kid;                                 // return kid
// }

shared_ptr<Person> initFamily (const string& name)
{
  shared_ptr<Person> mom(new Person(name+"'s mom"));
  shared_ptr<Person> dad(new Person(name+"'s dad"));
  shared_ptr<Person> kid(new Person(name));
  kid->setParentsAndTheirKids(mom,dad);
  return kid;                                 // return kid
}

void setParentsAndTheirKids (shared_ptr<Person> m = nullptr, 
    shared_ptr<Person> f = nullptr) 
{
  mother = m;
  father = f;
  if (m != nullptr) {
    m->kids.push_back(shared_ptr<Person>(this)); // ERROR 
  }
  if (f != nullptr) {
    f->kids.push_back(shared_ptr<Person>(this)); // ERROR
  }
}

The problem is the creation of a shared pointer out of `this` pointer. 

Want to pass kid's shared pointer to mother and father but to do that, need a
shared pointer to the kid, which we don't have at hand since this pointer is not
shared pointer. So this creates temporary shared pointer from this which is
'new' group of shared pointer. Two shared pointer group to the kid and when mom
and dad go free, will do double delete.

One way to deal with this problem is to pass the shared pointer to the kid as a
third argument. But the C++ standard library provides another option: class
std::enable_shared_from_this<>.


={============================================================================
*kt_dev_stl_104* sp-shared-from-this

Can use class std::enable_shared_from_this<> to derive your class, representing
objects managed by shared pointers, with your class name passed as template
argument. Doing so allows you to use a derived member function
`shared_from_this()` to create a correct shared_ptr out of `this`

class Person : public std::enable_shared_from_this<Person> {
  public:
    ...
      void setParentsAndTheirKids (shared_ptr<Person> m = nullptr,
          shared_ptr<Person> f = nullptr) {
        mother = m;
        father = f;
        if (m != nullptr) {
          m->kids.push_back(shared_from_this()); // OK
        }
        if (f != nullptr) {
          f->kids.push_back(shared_from_this()); // OK
        }
      }
    ...
};

class GstM: public MediaRouterAsync,
    public boost::enable_shared_from_this<GstM>
{};


{code}

//bits/shared_ptr.h

  /** 
   *  @brief Base class allowing use of member function shared_from_this.
   */
  template<typename _Tp>
    class enable_shared_from_this
    {
    protected:
      enable_shared_from_this() { }

    public:
      shared_ptr<_Tp>
      shared_from_this()
      { return shared_ptr<_Tp>(this->_M_weak_this); }

      shared_ptr<const _Tp>
      shared_from_this() const
      { return shared_ptr<const _Tp>(this->_M_weak_this); }
    };


={============================================================================
*kt_dev_stl_105* smart pointer: gotw #102: exception safety

GotW #102: Exception-Safe Function Calls (Difficulty: 7/10)

3. As you continue to root through the archives, you see that someone must not
have liked Example 2 because later versions of the files in question were
changed as follows:

// Example 3
 
// In some header file:
void f( std::unique_ptr<T1>, std::unique_ptr<T2> );
 
// At some call site:
f( std::unique_ptr<T1>{ new T1 }, std::unique_ptr<T2>{ new T2 } );

What improvements does this version offer over Example 2, if any? Do any
  exception safety problems remain? Explain.

This code attempts to “throw unique_ptr at the problem.” Many people believe
that a smart pointer is an exception-safety panacea, a touchstone or amulet that
by its mere presence somewhere nearby can help ward off compiler indigestion.

It is not. Nothing has changed. Example 3 is still not exception-safe, for
exactly the same reasons as before.

Specifically, the problem is that the resources are safe only if they really
make it into a managing unique_ptr, but the same problems already noted can
still occur before either unique_ptr constructor is ever 'reached'. This is
because both of the two problematic execution orders mentioned earlier are still
possible, but now with the unique_ptr constructors tacked onto the end before
invoking f. For one example:

    allocate memory for the T1
    construct the T1
    allocate memory for the T2
    construct the T2
    construct the unique_ptr<T1>
    construct the unique_ptr<T2>
    call f

In the above case, the same problems are still present if either of steps 3 or 4
throws. Similarly with:

    allocate memory for the T1
    allocate memory for the T2
    construct the T1
    construct the T2
    construct the unique_ptr<T1>
    construct the unique_ptr<T2>
    call f

Again, the same problems are present if either of steps 3 or 4 throws.

Fortunately, though, this is not a problem with unique_ptr; it’s just being used
the wrong way, that’s all. Let’s see how to use it better.


Enter make_unique

4. Demonstrate how to write a make_unique facility that solves the safety
problems in Example 3 and can be invoked as follows:

// Example 4
 
// In some header file:
void f( std::unique_ptr<T1>, std::unique_ptr<T2> );
 
// At some call site:
f( make_unique<T1>(), make_unique<T2>() );

The basic idea is:

    We want to leverage the fact that functions called from the same thread
    won't interleave, so we want to provide a function that does the work of
    allocation and construction of the object and construction of the
    unique_ptr.

    Because the function should be able to work with any type, we want to
    express it as a function template.

    Because the caller will want to pass constructor parameters from outside
    make_unique, we’ll use the C++11 perfect forwarding style to pass those
    along to the new-expression inside make_unique.

    Because shared_ptr already has an analogous std::make_shared, for
    consistency we’ll call this one make_unique. (That C++11 doesn’t include
        make_unique is partly an oversight, and it will almost certainly be
        added in the future. In the meantime, use the one provided below.)

Putting the ingredients together, we get:

template<typename T, typename ...Args>
std::unique_ptr<T> make_unique( Args&& ...args )
{
    return std::unique_ptr<T>( new T( std::forward<Args>(args)... ) );
}

This solves the exception safety problems. No sequence of generated code can
cause resources to be leaked, because now all we have is two functions, and we
know that one must be executed entirely before the other. Consider the following
evaluation order:

    call make_unique<T1>
    call make_unique<T2>
    call f

If step 1 throws, there are no leaks because make_unique is itself strongly
exception-safe.

If step 2 throws, then is the temporary unique_ptr<T1> created by step 1
guaranteed to be cleaned up? Yes, it is. One might wonder: Isn't this pretty
much the same as the new T1 object created in the corresponding case in Example
2, which isn't correctly cleaned up? No, this time it's not quite the same,
  because here the unique_ptr<T1> is actually a temporary object, and cleanup of
  temporary objects is correctly specified in the standard. From the standard,
  in 12.2/3 (unchanged from C++98):

  "" Temporary objects are destroyed as the last step in evaluating the
  full-expression that (lexically) contains the point where they were created.
  This is true even if that evaluation ends in throwing an exception.

Guidelines:

    Prefer to allocate objects to be managed by a shared_ptr using make_shared,
    and objects to be managed by a unique_ptr with make_unique.

    Although Standard C++ does not yet have make_unique, this is mostly an
    oversight and it will almost certainly eventually be added. In the meantime,
    use the version shown above, and your code will be forward-compatible with
    the likely direction of the C++ standard.

    Avoid using plain new or other raw unmanaged allocation directly. Instead,
    use a factory like make_unique that wraps the raw allocation and immediately
    passes it to another object that will own the resource. Often that owning
    object will be a smart pointer, but it can be a scope guard or any other
    kind of owning object whose destructor will deallocate the resource safely.


={============================================================================
*kt_dev_stl_102* smart pointers internal

{auto-ptr}
MEC++28 that is about auto_ptr. The typical implementation is:

template<class T>
class SmartPtr {
  public:
    // create a smart ptr to an obj given a dumb ptr to it. uninitialized ptr default to 0.
    SmartPtr( T* realPtr = 0 );

    // copy and assign a smart ptr
    SmartPtr( const SmartPtr& rhs );
    SmartPtr& operator=( cont SmartPtr& rhs );

    ~SmartPtr();

    // const. though it may lead to modification of what the pointer points to
    T* operator->() const;
    T& operator*() const;

  private:
    // dump(real) pointer
    T* pointee;
};

note: here copy and assign are public and if not allow those, should be private.

<encapsulation>
This smart pointer is testimony to the effectiveness of encapsulation:

1. Allow us to treat smart pointer as built-in pointer. Hide difference.
2. Other example. Handle local and remote DB access as if it is in the same place. Hide.

// template for smart ptrs to objects in a distributed DB
template<class T>
class DBPtr {
  public:
    // create a smart ptr to DB object given a local dumb pointer to it
    DBPtr(T *realPtr = 0);
    DBPtr(DataBaseID id);
    ...
};

class Tuple {
  ...
};

void editTuple(DBPtr<Tuple>& pt)
{
  do {
    pt->displayEditDialog();
  } while (pt->isValid() == false);
}

The tuple to be edited inside editTuple may be physically located on a remote machine, but the
programmer writing editTuple need not be concerned with such matters.

<copy-and-assign> ownership
How support copy semantics? Here implements ownership.

// the book said it has taken from stl
template<class T>
class auto_ptr {
  public:
    auto_ptr(T *ptr = 0): pointee(ptr) {}
    ~auto_ptr() { delete pointee; }

    auto_ptr(auto_ptr<T> &rhs)
    {
      // transfer ownership
      pointee = rhs.pointee;

      // no longer owns anything
      rhs.pointee = 0;
    }

    auto_ptr<T>& operator=( auto_ptr<T> &rhs )
    {
      // self-assign guard
      if( this == &rhs )
        return *this;

      // delete currently owned objects
      delete pointee;

      // transfer ownership
      pointee = rhs.pointee;
      rhs.pointee = 0;

      return *this;
    }

  private:
    T *pointee;
};

note: unconventional copy and assign operator since do not use const on parameters. These have to
change rhs so not use const.

<pass-by-value>
note: this is only for auto_ptr since compile error for unique_ptr for the same code.

Since ownership is transferred, passing auto_ptr by value is often a bad idea. Why?

void printNode( ostream& s, auto_ptr<TreeNode> p ) { s << *p; }

int main()
{
  auto_ptr<TreeNode> ptr( new TreeNode );
  ...
  printNode( cout, ptr );
  ...
}

In printNode call, call copy-ctor and means transfer ownership. When returns, dtor runs and delete
pointee. When main ends, dtor runs again and do double-free. So use reference:

void printNode( ostream& s, auto_ptr<TreeNode>& p ) { s << *p; }

See {the-rule-of-three} for <double-free> example.


<dereferencing-operators>

template< class T>
T& SmartPtr<T>::operator*() const
{
  // perform "smart pointer" processing
  return *pointee;
}

See return as reference because:

1. *pointee can be derived class in inheritance. To avoid sliced-off.
2. More efficient. No temp object.

For operator->(), the statement is interpreted by as:

pt->displayEditDialog(); -> (pt.operator->())->DisplayEditDialog();

So operator-> return either pointer or another smart pointer because can use -> on it.

template< class T>
T* SmartPtr<T>::operator->() const
{
  // perform "smart pointer" processing
  return pointee;
}

Both returns pointer and reference, virtual call through it works as supposed to. This will be fine
for most applications.

<nullness-of-smart-pointer>
If you want to push your smart pointers further, however, you must know more about dumb pointer
behavior and how smart pointers can and cannot emulate it. The followings are for this.

One of the things we cannot do is find out if a smart pointer is null:

SmartPtr<T> ptr;
...
if( ptr == 0 ) ...
if( ptr ) ...
if(!ptr) ...


How to solve? Add isNull member function? Not a solution since do not act like usual pointers.
Typical approach is to use conversion operators.

<approach-one> conversion-to-void
Use implicit conversion operator which is traditional. This is the way iostream uses so it is
possible:

ifstream inputFile("datafile.dat");
if(ifstream) ...

template< class T>
class SmartPtr {
  public:
    operator void*(); // return 0 if smart pointer is null, non-zero otherwise.
    ...
};

note: Q: why void*? how it works?

This approach has a problem since it allows following: 

SmartPtr<Apple> pa; SmartPtr<Orange> po;

if( pa == po ) ...

Even if there is no operator== taking a SmartPtr<Apple> and a SmartPtr<Orange>, this compiles,
because both smart pointers can be implicitly converted into void* pointers, and there is a built-in
comparison function for built-in pointers.

<approach-two>
There are many variations and the other is:

template< class T>
class SmartPtr {
  public:
    bool operator!() const; // return true only if smart pointer is null
    ...
};

However, still not complete.

if(!ptn) {           // OK
  ...
}

if( ptn == 0 ) ...   // ERROR
if( ptn) ...


note: How about STL?

<get-dumb-pointer>
TODO: converting smart pointers to dumb pointers.

<smart-pointer-in-inheritance>
class MusicProduct {
  public:
    MusicProduct( const string& title );
    virtual void play() const = 0;
    virtual void displayTitle() const = 0;
    ...
};

class Cassette: public MusicProduct {
  ...
};

class CD: public MusicProduct {
  ...
};

void displayAndPlay( const MusicProduct* pmp, int numTimes )
{
  for( int i=1; i <= numTimes; ++i )
  {
    pmp->displayTitle();
    pmp->play();
  }
}

Cassette *funMusic = new Cassette("Jazz");
CD *nightmareMusic = new CD("Disco Hits of the 70s");

displayAndPlay( funMusic, 10 );
displayAndPlay( nightmareMusic, 0 );

No surprise here but if replace it with smart pointers, then compile errors:

void displayAndPlay( const SmartPtr<MusicProduct> &pmp, int numTimes );

SmartPtr<Cassette> funMusic(new Cassette("Jazz"));
SmartPtr<CD> nightmareMusic(new CD("Disco Hits of the 70s"));

displayAndPlay( funMusic, 10 );
displayAndPlay( nightmareMusic, 0 );

Why won't these compile? Template make a new class so inheritance no longer exist. Is it useful to
maintain inheritance when use template? If so, do further reading.


<smart-pointer-and-const>
For built-in:

const T* const ptr = ...;

For smart pointer:

const SmartPtr< T> ptr = &goodCD;  // const pointer
SmartPtr< const CD> ptr = &goodCD;

Unlike built-in, there is no conversion from non-const to ptr-to-const.

const CD* pConstCD = pCD;

Because template create new classes. If need more, see further.

<example>
#include <iostream>
#include <memory>

using namespace std;

class Foo {  
  public:
    void whoami() { cout << "this is foo" << endl; }
};

template<typename T>
class mauto_ptr {
  public:
    mauto_ptr(T* arg=nullptr) : pointee(arg) { cout << "ctor on :" << arg << endl; }
    ~mauto_ptr() { cout << "dtor on :" << pointee << endl; delete pointee; }

    // * operator
    mauto_ptr<T>& operator*() { return *pointee; }

    // -> operator
    T* operator->() { return pointee; }

    // copy ctor: transfer ownership
    mauto_ptr( mauto_ptr<T>& rhs )
    {
      pointee = rhs.pointee;
      rhs.pointee = nullptr;
    }

    // copy assign:
    mauto_ptr<T>& operator=( mauto_ptr<T>& rhs )
    {
      // self-assign guard
      if( this == &rhs )
        return *this;

      delete pointee;

      pointee = rhs.pointee;
      rhs.pointee = nullptr;

      return *this;
    }

  private:
    T* pointee;
};

void printptr( auto_ptr<int> p )
{
  cout << "value is: " << *p << endl;
}

int main()
{
  {
    cout << "{ start block: " << endl;
    mauto_ptr<Foo> p(new Foo());
    p->whoami();
    cout << "} end block: " << endl;
  }
}

{ start block: 
ctor on :0x9fdf008
this is foo
} end block: 
dtor on :0x9fdf008


={============================================================================
*kt_dev_stl_103* sp-shared-implement

MEC++29.

Once an object is allocated by calling new, it's crucial to keep track of who
owns that object because the owner - and only the owner - is responsible for
calling delete on it. But ownership can be transferred from object to object as
a program runs by passing pointers as parameters, for example, so keeping track
of an object's ownership is hard work. Classes like auto_ptr can help with this
task, but experience has shown that most programs still fail to get it right. 

Reference counting eliminates the burden of tracking object ownership, because
when an object employs reference counting, it owns itself. When nobody is using
it any longer, it destroys itself automatically. Thus, reference counting
constitutes a simple form of garbage collection.

The bookkeeping is "who is allowed to delete what". 


<problem>

class String {
  public:
    String( const char *value="" );
    String& operator=( const String& rhs );
    ...
  private:
      char* data;
};

// handles self-assign but not exception safe
String& String::operator=( const String& rhs )
{
  if( this == &rhs ) return *this;

  delete[] data;
  data = new char[ strlen(rhs.dat) +1 ];
  strcpy( data, rhs.data );
  return *this;
}

With this implementation, use:

String a, b, c, d;
a = b = c = d = "Hello";

This means:

a -> "Hello"
b -> "Hello"
c -> "Hello"
d -> "Hello"

How can we make those share one copy of Hello?


<approach>
Need one reference count per string 'value', not one reference count per string
object. That implies a coupling between values and reference counts, so we'll
create a class to store reference counts and the values they track; StringValue.
Since this is only to help implement String, nest it inside in private and as a
struct to give full access to String members but nothing else.

class String {
  public:
    String( const char *initValue = "" );
    String( const String& rhs );

    String& operator=( const String& rhs );
    ...
  private:
      struct StringValue {
        size_t refCount;
        char* data;
        StringValue( const char* initValue );
        ~StringValue();
      };

      StringValue* value;
};

// StringValue implementation and default value of refCount
String::StringValue::StringValue( const char* initValue ) : refCount(1)
{
  data = new char[ strlen(initValue) +1 ];
  strcpy( data, initValue );
}

String::StringValue::~StringValue()
{
  delete [] data;
}


<implementation>

// String s("Hello");   // s -> 1 -> "Hello"

String::String( const char* initValue ) 
  : value( 'new' StringValue( initValue )) {}

But cannot avoid duplication:

String s1("Hello");
String s2("Hello");

s1 -> 1 -> "Hello"
s2 -> 1 -> "Hello"

The solution is to create new one only when it is unique string and leave it as
exercise. Does it need for shared pointer?


// String S1(S2);

String::String( const String& rhs ) : value( rhs.value )
{
  ++value->refCount;
}

String::~String()
{
  if( --value->refCount == 0 ) delete value;
}

// S1 = S2; reference count of S1 is decreased by 1 and S2 is increased by 1

String& String::operator=( const String& rhs )
{
  if( value == rhs.value ) return *this;

  if( --value->refCount == 0 ) delete value;

  value = rhs.value;
  ++value->refCount;

  return *this;
}

See efficiency here since there is no alloc, free, and copy.


<ex> From pointerlike again.

class HasPtr {
  public:
    // see default arg and new size_t
    HasPtr(const std::string& s = std::string() ) : 
      ps( new std::string(s)), i(0), use( new std::size_t(1) ) {}

    HasPtr(const HasPtr& p): ps( p.ps ), use( p.use ) { ++*use; };

    HasPtr& operator=(const HasPtr& p);
    ~HasPtr();
      
  private:
    std::string* ps;
    std::size_t* use; 
};

HasPtr::~HasPtr()
{
   if( --*use == 0 )             // --*use but not --use
   {
      delete ps; delete use;
   }
}

// Combine dtor and copy ctor. handle self-assign so no need to have if check.
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  ++*rhs.use;

  // lhs
  if( --*use == 0 )
  {
    delete ps; delete use;
  }

  ps = rhs.ps;
  use = rhs.use;

  return *this;
}


{reference-implementation}

#include <iostream>
#include <memory>

using namespace std;

class Foo {  
  public:
    void whoami() { cout << "this is foo" << endl; }
};

template<typename T>
class mshared_ptr {
  public:
    mshared_ptr( T* arg = nullptr )
      : pointee(arg), prefcount( new size_t(1)) 
    { cout << "mshared ctor: " << endl; }

    ~mshared_ptr()
    { 
      if(--*prefcount == 0)
      {
        cout << "mshared dtor: " << endl; 
        delete pointee; delete prefcount;
      }
    }

    // copy ctor
    mshared_ptr( const mshared_ptr<T> & rhs )
    {
      pointee = rhs.pointee;
      prefcount = rhs.prefcount;
      ++*prefcount;
    }

    // copy assign
    mshared_ptr<T> & operator=( const mshared_ptr<T> & rhs )
    {
      // note: no need to have this for correctness but seems better to have for
      // efficiency 

      if( this == &rhs ) return *this;

      ++*rhs.prefcount;

      if( --*prefcount == 0 )
      {
        delete pointee; delete prefcount;
      }

      pointee = rhs.pointee;
      prefcount = rhs.prefcount;

      return *this;
    }

    // * operator
    T& operator*() { return *pointee; }

    // -> operator
    T* operator->() { return pointee; }

    operator void*() { return pointee === nullptr ? (void*)0 : 1; }

    size_t use_count() { return *prefcount; };

  private:
    T* pointee;
    size_t* prefcount;
};

int main()
{
  {
    cout << "{ start block: " << endl;
    mshared_ptr<Foo> p(new Foo());
    cout << "  use_count: " << p.use_count() << ", p->whoami: ";
    p->whoami();

    {
      mshared_ptr<Foo> q(p);
      cout << "  use_count: " << q.use_count() << ", q->whoami: ";
      q->whoami();
    }

    cout << "  use_count: " << p.use_count() << ", p->whoami: " << endl;

    cout << "} end block: " << endl;
  }

  cout << "} end main: " << endl;
}

{ start block: 
mshared ctor: 
  use_count: 1, p->whoami: this is foo
  use_count: 2, q->whoami: this is foo
  use_count: 1, p->whoami: 
} end block: 
mshared dtor: 
} end main: 


{reference-implementation}
Revised based on std::shared_ptr code.

#include <iostream>
#include <memory>

using namespace std;

class Foo {  
  public:
    void whoami() { cout << "this is foo" << endl; }
};

template<typename T>
class mshared_ptr {
  private:
    T *ptr_;
    size_t *prefcount_;

  public:
    // default ctor
    mshared_ptr() 
      : ptr_(0), prefcount_(new size_t(0)) {}

    // ctor
    explicit mshared_ptr(T *p_)
      : ptr_(p_), prefcount_(new size_t(1)) {}

    // dtor
    ~mshared_ptr()
    {
      if(--*prefcount_ == 0)
      {
        delete ptr_; delete prefcount_;
      }
    }

    // copy ctor
    mshared_ptr(const mshared_ptr<T> &rhs) noexcept
    {
      ptr_ = rhs.ptr_;
      prefcount_ = rhs.prefcount_;
      ++*prefcount_;
    }

    // copy assign
    const mshared_ptr<T> &
      operator=(const mshared_ptr<T> &rhs)
      {
        if(this == &rhs)
          return *this;

        if(--*prefcount_ == 0)
        {
          delete ptr_; delete prefcount_;
        }

        ++*rhs.prefcount_;

        ptr_ = rhs.ptr_;
        prefcount_ = rhs.prefcount_;

        return *this;
      }

    // swap
    void swap(mshared_ptr<T> &other)
    {
      std::swap(ptr_, other.ptr_);
      std::swap(prefcount_, other.prefcount_);
    }

    // reset
    void reset() noexcept
    {
      mshared_ptr<T>().swap(*this);
    }

    // reset
    void reset(T* p_) noexcept
    {
      mshared_ptr<T>(p_).swap(*this);
    }

    // operator*
    T& operator*() const noexcept
    {
      return *ptr_;
    }

    // operator->
    T* operator->() const noexcept
    {
      return ptr_;
    }

    // get()
    T* get() const noexcept
    {
      return ptr_;
    }

    explicit operator bool() const
    {
      return ptr_ == 0 ? false : true; 
    }

    size_t use_count() const noexcept
    {
      return *prefcount_;
    }
};

int main()
{
  {
    cout << "{ start block: " << endl;
    mshared_ptr<Foo> p(new Foo());
    cout << "  use_count: " << p.use_count() << ", p->whoami: ";
    p->whoami();

    if(p)
    {
      cout << "  p is not null" << endl; 
    }

    {
      mshared_ptr<Foo> q(p);
      cout << "  use_count: " << q.use_count() << ", q->whoami: ";
      q->whoami();
    }

    cout << "  use_count: " << p.use_count() << ", p->whoami: " << endl;

    cout << "} end block: " << endl;
  }

  cout << "} end main: " << endl;
}


={============================================================================
*kt_dev_stl_101* sp-shared-code

// bits/shared_ptr_base.h @759

  template<_Lock_policy _Lp>  // @442
    class __shared_count
    {
      public:
        constexpr __shared_count() noexcept : _M_pi(0)
        { }

        template<typename _Ptr>
          explicit
          __shared_count(_Ptr __p) : _M_pi(0)
          {
            __try
            {
              _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
            }
            __catch(...)
            {
              delete __p;
              __throw_exception_again;
            }
          }

        ~__shared_count() noexcept
        {
          if (_M_pi != 0)
            _M_pi->_M_release();
        }

        __shared_count(const __shared_count& __r) noexcept
          : _M_pi(__r._M_pi)
          {
            if (_M_pi != 0)
              _M_pi->_M_add_ref_copy();
          }

        __shared_count&
          operator=(const __shared_count& __r) noexcept
          {
            _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
            if (__tmp != _M_pi)
            {
              if (__tmp != 0)
                __tmp->_M_add_ref_copy();
              if (_M_pi != 0)
                _M_pi->_M_release();
              _M_pi = __tmp;
            }
            return *this;
          }

        void
          _M_swap(__shared_count& __r) noexcept
          {
            _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
            __r._M_pi = _M_pi;
            _M_pi = __tmp;
          }

        long
          _M_get_use_count() const noexcept
          { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }

        bool
          _M_unique() const noexcept
          { return this->_M_get_use_count() == 1; }

        // Friend function injected into enclosing namespace and found by ADL
        friend inline bool
          operator==(const __shared_count& __a, const __shared_count& __b) noexcept
          { return __a._M_pi == __b._M_pi; }

      private:
        _Sp_counted_base<_Lp>*  _M_pi;
    };

  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
    {
      public:
        typedef _Tp   element_type;

        constexpr __shared_ptr() noexcept
          : _M_ptr(0), _M_refcount()
          { }

        template<typename _Tp1>
          explicit __shared_ptr(_Tp1* __p)
          : _M_ptr(__p), _M_refcount(__p)
          {
            __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)
              static_assert( sizeof(_Tp1) > 0, "incomplete type" );
            __enable_shared_from_this_helper(_M_refcount, __p, __p);
          }

        __shared_ptr(const __shared_ptr&) noexcept = default;
        __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
        ~__shared_ptr() = default;

        template<typename _Tp1>
          __shared_ptr&
          operator=(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
          {
            _M_ptr = __r._M_ptr;
            _M_refcount = __r._M_refcount; // __shared_count::op= doesn't throw
            return *this;
          }

        void
          reset() noexcept
          { __shared_ptr().swap(*this); }

        template<typename _Tp1>
          void
          reset(_Tp1* __p) // _Tp1 must be complete.
          {
            // Catch self-reset errors.
            _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr);
            __shared_ptr(__p).swap(*this);
          }

        // Allow class instantiation when _Tp is [cv-qual] void.
        typename std::add_lvalue_reference<_Tp>::type
          operator*() const noexcept
          {
            _GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);
            return *_M_ptr;
          }

        _Tp*
          operator->() const noexcept
          {
            _GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);
            return _M_ptr;
          }

        _Tp*
          get() const noexcept
          { return _M_ptr; }

        explicit operator bool() const // never throws
        { return _M_ptr == 0 ? false : true; }

        bool
          unique() const noexcept
          { return _M_refcount._M_unique(); }

        long
          use_count() const noexcept
          { return _M_refcount._M_get_use_count(); }

        void
          swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
          {
            std::swap(_M_ptr, __other._M_ptr);
            _M_refcount._M_swap(__other._M_refcount);
          }

        _Tp*                  _M_ptr;         // Contained pointer.
        __shared_count<_Lp>   _M_refcount;    // Reference counter.
    };


// bits/shared_ptr.h @92

namespace std {

  // note: 
  // no other operators so use operators in bits/shared_ptr_base.h
  // no member data, no dtor

  /**
   *  @brief  A smart pointer with reference-counted copy semantics.
   *
   *  The object pointed to is deleted when the last shared_ptr pointing to
   *  it is destroyed or reset.
  */
  template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp>
  {
    public:
      /**
       *  @brief  Construct an empty %shared_ptr.
       *  @post   use_count()==0 && get()==0
       */
      constexpr shared_ptr() noexcept
        : __shared_ptr<_Tp>() { }

      shared_ptr(const shared_ptr&) noexcept = default;

      /**
       *  @brief  Construct a %shared_ptr that owns the pointer @a __p.
       *  @param  __p  A pointer that is convertible to element_type*.
       *  @post   use_count() == 1 && get() == __p
       *  @throw  std::bad_alloc, in which case @c delete @a __p is called.
       */
      template<typename _Tp1>
        explicit shared_ptr(_Tp1* __p)
        : __shared_ptr<_Tp>(__p) { }

      /**
       *  @brief  Construct an empty %shared_ptr.
       *  @param  __p  A null pointer constant.
       *  @post   use_count() == 0 && get() == nullptr
       */
      constexpr shared_ptr(nullptr_t __p) noexcept
        : __shared_ptr<_Tp>(__p) { }

      shared_ptr& operator=(const shared_ptr&) noexcept = default;

      template<typename _Tp1>
        shared_ptr&
        operator=(const shared_ptr<_Tp1>& __r) noexcept
        {
          this->__shared_ptr<_Tp>::operator=(__r);
          return *this;
        }
  };

  /**
   *  @brief  Create an object that is owned by a shared_ptr.
   *  @param  __args  Arguments for the @a _Tp object's constructor.
   *  @return A shared_ptr that owns the newly created object.
   *  @throw  std::bad_alloc, or an exception thrown from the
   *          constructor of @a _Tp.
   */
  template<typename _Tp, typename... _Args>
    inline shared_ptr<_Tp>
    make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
              std::forward<_Args>(__args)...);
    }
}


={============================================================================
*kt_dev_stl_104* sp-thread-safety

https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#shared_ptr.thread

Thread Safety

The Thread Safety section of the Boost shared_ptr documentation says
"shared_ptr objects offer the same level of thread safety as built-in types."
The implementation must ensure that concurrent updates to separate shared_ptr
instances are correct even when those instances share a reference count e.g.

shared_ptr<A> a(new A);
shared_ptr<A> b(a);

// Thread 1     // Thread 2
   a.reset();      b.reset();

The dynamically-allocated object must be destroyed by exactly one of the
  threads. Weak references make things even more interesting. The shared state
  used to implement shared_ptr must be transparent to the user and invariants
  must be preserved at all times. 
  
The key pieces of shared state are the strong and weak `reference counts`

Updates to these `need to be atomic` and visible to all threads to ensure
correct cleanup of the managed resource (which is, after all, shared_ptr's
    job!) 

On multi-processor systems memory synchronisation may be needed so that
reference-count updates and the destruction of the managed resource are
race-free.

The function _Sp_counted_base::_M_add_ref_lock(), called when obtaining a
shared_ptr from a weak_ptr, has to test if the managed resource still exists
and either increment the reference count or throw bad_weak_ptr. 

In a multi-threaded program there is a potential race condition if the last
reference is dropped (and the managed resource destroyed) between testing the
reference count and incrementing it, which could result in a shared_ptr
pointing to invalid memory.

The Boost shared_ptr (as used in GCC) features a clever lock-free algorithm to
avoid the race condition, but this relies on the processor supporting an
atomic Compare-And-Swap instruction. 

For other platforms there are fall-backs using mutex locks. Boost (as of
    version 1.35) includes several different implementations and the
preprocessor selects one based on the compiler, standard library, platform
etc. 

For the version of shared_ptr in libstdc++ the compiler and library are fixed,
    which makes things much simpler: we have an atomic CAS or we don't, see
      Lock Policy below for details. 


={============================================================================
*kt_dev_stl_104* smart pointers examples

If you want reference semantics in STL containers - whether because copying elements is expensive or
because identical elements will be shared by different collections - you should use a smart pointer
class that avoids possible errors. In addition, using a reference wrapper is possible.

<ex> *ex-algo-find-if*
#include <iostream>
#include <iterator>
#include <set>
#include <deque>
#include <string>
#include <memory>
#include <algorithm>

using namespace std;

template <typename T>
inline void printItems( const std::string &msg, const T& coll )
{
  std::cout << msg;

  for( const auto &elem : coll )
    std::cout << ' ' << elem->getName() << ": " << elem->getPrice() << std::endl;
}

class Item 
{
  private: 
    string name;
    float price;

  public:
    Item( const string &n, float p = 0 ) : name(n), price(p) { }

    string getName() const { return name; }
    void setName( const string & n ) { name = n; }
    float getPrice() const { return price; }
    float setPrice( float p ) { price = p; }
};

int main()
{
  typedef shared_ptr<Item> ItemPtr;

  set<ItemPtr> allItems;
  deque<ItemPtr> bestsellers;

  // insert objects into collections
  bestsellers = { ItemPtr(new Item("Kong Yize",20.10)),
    ItemPtr(new Item("A Midsummer Night’s Dream",14.99)),
    ItemPtr(new Item("The Maltese Falcon",9.88)) };

  allItems = { ItemPtr(new Item("Water",0.44)),
    ItemPtr(new Item("Pizza",2.22)) };

  allItems.insert(bestsellers.begin(),bestsellers.end());

  // print
  printItems( "best sellers: ", bestsellers );
  printItems( "all         : ", allItems );

  cout << endl;

  // double price of bestsellers
  for_each( bestsellers.begin(), bestsellers.end(),
      [] (shared_ptr<Item> &elem) {
        elem->setPrice(elem->getPrice()*2);
        });

  // replace 2nd bestseller by 1st item with name "Pizza"
  //
  // The following causes compile error. why?
  //      [] (shared_ptr<Item> &elem) {
  // <key> Adding 'const' solves.
  bestsellers[1] = *(find_if( allItems.begin(), allItems.end(),
        [] (const shared_ptr<Item> &elem) {
          return elem->getName() == "Pizza";
          }));

  bestsellers[0]->setPrice(44.77);

  // print
  printItems( "best sellers: ", bestsellers );
  printItems( "all         : ", allItems );
}

best sellers:  Kong Yize: 20.1
 A Midsummer Night’s Dream: 14.99
 The Maltese Falcon: 9.88
all         :  Kong Yize: 20.1
 A Midsummer Night’s Dream: 14.99
 The Maltese Falcon: 9.88
 Water: 0.44
 Pizza: 2.22

best sellers:  Kong Yize: 44.77
 Pizza: 2.22
 The Maltese Falcon: 19.76
all         :  Kong Yize: 44.77
 A Midsummer Night’s Dream: 29.98
 The Maltese Falcon: 19.76
 Water: 0.44
 Pizza: 2.22


={============================================================================
*kt_dev_stl_104* smart pointers examples

boost::make_shared<VirtualBinIPCSrc>(dispatcher,
        binImplFactory->create());

boost::shared_ptr<VirtualBin> create()
{ return bin; }

Here "binImplFactory->create()" returns a shared pointer, then ctor gets a
reference of it, and set its member shared pointer with that. So uses a temporty
shared pointer which is return from a call and copies it into member shared
pointer. Now shared pointer is in a safe hand.

class ZINC_EXPORT VirtualBinIPCSrc
{
    VirtualBinIPCSrc::VirtualBinIPCSrc(
            const boost::shared_ptr<NS_ZINC::Dispatcher>& dispatcher,
            const boost::shared_ptr<VirtualBin>& binImpl)
        : binImpl(binImpl)
    {
    }

    boost::shared_ptr<VirtualBin> binImpl;
};


={============================================================================
*kt_dev_stl_106* when to use which container

However, it contains 'general' statements that might not fit in reality. For example, if you manage
only a few elements, you can ignore the complexity because short element processing with linear
complexity is better than long element processing with logarithmic complexity (in practice, "few"
might become very large here).  

As a supplement to the table, the following rules of thumb might help:

1. By 'default', you should use a 'vector'. It has the simplest internal data structure and provides
random access. Thus, data access is convenient and flexible, and data processing is often fast
enough.

2. If you insert and/or remove elements often at the beginning and the end of a sequence, you should
use a 'deque'. You should also use a deque if it is important that the amount of internal memory used
by the container shrinks when elements are removed. Also, because a vector usually uses one block of
memory for its elements, a deque might be able to contain more elements because it uses several
blocks. <TODO> does deque do memory shrink better than vector?

3. If you insert, remove, and move elements often in the middle of a container, consider using a
'list'. Lists provide special member functions to move elements from one container to another
in constant time. Note, however, that because a list provides no random access, you might
suffer significant performance penalties on access to elements inside the list if you have only the
beginning of the list.

Like all node-based containers, a list doesn't invalidate iterators that refer to elements, as long
as those elements are part of the container. Vectors invalidate all their iterators, pointers, and
references whenever they exceed their capacity and part of their iterators, pointers, and references
on insertions and deletions. Deques invalidate iterators, pointers, and references when they change
their size, respectively.

4. If you need a container that handles 'exceptions' so that each operation either succeeds or has no
effect, you should use either a list or an associative/unordered container. note: all node-based

5. If you often need to 'search' for elements according to a certain criterion, use an 'unordered'
set or multiset that hashes according to this criterion. However, hash containers have no ordering,
so if you need to rely on element order, you should use a set or a multiset that sorts elements
according to the search criterion.

6. To process key/value 'pairs', use an unordered (multi)map or, if the element order matters, a
(multi)map.

7. If you need an 'associative' array, use an unordered map or, if the element order matters, a map.

8. If you need a 'dictionary', use an unordered multimap or, if the element order matters, a multimap.


{problem}
A problem that is 'not' easy to solve is how to sort objects according to two different sorting
criteria.

The automatic sorting of associative containers does 'not' mean that these containers perform better
when sorting is needed. This is because an associative container sorts 'each' time a new element
gets inserted. An often 'faster' way is to use a sequence container and to sort 'all' elements
'after' they are all inserted, by using one of the several sort algorithms

<set-version>
#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include <set>

using namespace std;

int main()
{
  // create a string set - initialized by all words from standard input
  set<string> coll((istream_iterator<string>(cin)), istream_iterator<string>());

  // print all elements
  copy (coll.cbegin(), coll.cend(), ostream_iterator<string>(cout, "\n"));
}

<vector-version> algorithm-unique_copy
#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include <vector>

using namespace std;

int main()
{
  // create a string vector - initialized by all words from standard input
  vector<string> coll((istream_iterator<string>(cin)), istream_iterator<string>());

  // sort elements
  sort (coll.begin(), coll.end());

  // print all elements ignoring subsequent duplicates
  copy (coll.cbegin(), coll.cend(), ostream_iterator<string>(cout, "\n"));
  // unique_copy (coll.cbegin(), coll.cend(), ostream_iterator<string>(cout, "\n"));
}

<result>
When I tried both programs with about 350,000 strings on one system, the 'vector' version was
approximately 10% 'faster'. Inserting a call of reserve() made the vector version 5% faster. 

Allowing duplicates - using a multiset instead of a set and calling copy() instead of unique_copy(),
respectively - changed things dramatically: The vector version was more than 40% faster. 
note: make both run fast

However, on 'another' system, the vector versions were up to 50% slower. These measurements are not
representative, but they show that it is often 'worth' trying 'different' ways of processing
elements.

In practice, predicting which container type is the best is often difficult. 

The big 'advantage' of the STL is that you can try different versions 'without' much effort. The
major work - implementing the different data structures and algorithms - is done. You have only to
combine them in a way that is best for you.


={============================================================================
*kt_dev_stl_110* cpp-allocator

(From Primus?)
This is analogous to allocator.construct() but one important difference:
allocator.construct() must use memory allocated by the 'same' allocator but need
not point to memory by operator new and refer to dynamic memory.


{allocator}
The C++ standard library uses special objects to handle the allocation and
deallocation of memory. Such 'objects' are called allocators. They represent a
special "memory model" and are used as an abstraction to translate the need to
use memory into a raw call for memory. The use of different allocator objects at
the same time allows you to use different memory models in a program.

Originally, allocators were introduced as part of the STL to handle the nasty
problem of different pointer types on PCs (such as near, far, and huge
    pointers). Now, allocators serve as a base for technical solutions that use
certain memory models, such as shared memory, garbage collection, and
object-oriented databases, without changing the interfaces.

The 'default' allocator is used as the default value everywhere an allocator can
be used as an argument.

#include <memory>

template<class T>
struct allocator;

template<>
struct allocator<void>;

Provides a way to decouple alloc/dealloc and construction/destruction and allows
finer control. For example, allocate big memory and pay the overhead of
construction 'only' when needed.

note: The allocator provides 'type-aware' allocation and returns 'unconstructed'
memory while operator-new uses only 'size'. Be careful since using unconstructed
memory is 'undefined'.

allocator<string> alloc;
auto const p = alloc.allocator(n);

// calls ctor. From C++11, supports many ctors of the 'type'. The first argument
// to construct() must be a pointer to unconstructed space allocated by
// allocate(). The second and subsequent argument determine ctor to use.

alloc.construct(p++);
alloc.construct(p++, 10, 'c');
alloc.construct(p++, "hi");

// calls dtor
alloc.destory(p);

// size must match
alloc.deallocate(p, n);


<companion-algorithms>
The library defines two that calls `construct()` on each element in
unconstructed memory.

uninitialized_copy(b, e, b2);

copies elements from the input range by iterator b and e into 'unconstructed'
memory by iterator b2. Like copy, return its incremented destination iterator.

uninitialized_copy_n(b, n, b2);
copies n elements from b to b2.

uninitialized_fill(b, e, t);
construct objects in raw memory denoted by b and e as a copy of t.

uninitialized_fill_n(b, n, t);

auto p = alloc.allocate( vi.size()*2 );
auto q = uninitialized_copy( vi.begin(), vi.end(), p );
uninitialized_fill_n( q, vi.size(), 42 );


={============================================================================
*kt_dev_stl_111* gcc stl impl files

/usr/include/c++/4.4.4

algorithm        cinttypes           cstddef          exception            iostream  queue         thread
array            ciso646             cstdint          exception_defines.h  istream   random        tr1
backward         climits             cstdio           exception_ptr.h      iterator  ratio         tr1_impl
bits             clocale             cstdlib          ext                  limits    regex         tuple
bitset           cmath               cstring          fenv.h               list      set           typeinfo
c++0x_warning.h  complex             ctgmath          forward_list         locale    sstream       type_traits
cassert          complex.h           ctime            fstream              map       stack         unordered_map
ccomplex         condition_variable  cwchar           functional           memory    stdatomic.h   unordered_set
cctype           csetjmp             cwctype          i686-redhat-linux    mutex     stdexcept     utility
cerrno           csignal             cxxabi-forced.h  initializer_list     new       streambuf     valarray
cfenv            cstdarg             cxxabi.h         iomanip              numeric   string        vector
cfloat           cstdatomic          debug            ios                  ostream   system_error  x86_64-redhat-linux
chrono           cstdbool            deque            iosfwd               parallel  tgmath.h

bits dir has actual STL files.


==============================================================================
*kt_dev_sys_012*	dump_stack

This function can be amended to print any failed capabilities checks using printk, and a
call to the kernel function dump_stack() should give you a pretty good idea of what the
middleware was attempting at the time of the failure. A little guesswork is still required
though, as this will only show you the stack in kernel space, not in the middleware
itself.

only for glibc?


==============================================================================
*kt_dev_sys_014*	newlines between dos and linux

Q: what is it about?

Systems based on ASCII or a compatible character set use either LF (Line feed, '\n', 0x0A, 10 in
decimal) or CR (Carriage return, '\r', 0x0D, 13 in decimal) individually, or CR followed by LF
(CR+LF, '\r\n', 0x0D0A).  These characters are based on printer commands: The line feed indicated
that one line of paper should feed out of the printer, and a carriage return indicated that the
printer carriage should return to the beginning of the current line. 

CR+LF: Microsoft Windows, DEC TOPS-10, RT-11 and most other early non-Unix and non-IBM OSes, CP/M,
MP/M, DOS (MS-DOS, PC-DOS, etc.) 

LF   : Multics, Unix and Unix-like systems (GNU/Linux, AIX, Xenix, Mac OS X, FreeBSD, etc.), BeOS,
Amiga, RISC OS, and others.

fgets() reads in at most one less than size characters from stream and stores them into the buffer
pointed to by s.  Reading stops after an EOF or a newline. If a newline is read, it is stored into
the buffer.  A '\0' is stored after the last character in the buffer. 

can check as below

[ktpark@cdilinux build_mlu]$ file platform.mk (for dos)
platform.mk: ASCII English text, with CRLF line terminators

[ktpark@cdilinux build_mlu]$ file platform.mk.kt (for unix)
platform.mk.kt: ASCII English text


# ============================================================================
#{
={============================================================================
*kt_dev_mecpp_001* 16: 80-20 rule and profiler

Think about characteristics of your app such as IO-bound or CPU-bound. If a profiler tells you about
only the number of statments and func calls, then these can give you some insight but not enough.
The important thing is the time to wait. The input to profiler should represent 20%, called
<representative>, and use as many data set as possible. 


==============================================================================
*kt_dev_mecpp_002* 17: lazy evaluation

When you employ lazy evaluation, you write your classes in such a way that they defer computations
until the results of those computations are required. If the results are never required, the
computations are never performed.

Nevertheless, it's not always a good idea.  Lazy evaluation is only useful when there's a reasonable
chance your software will be asked to perform computations that can be avoided.

Yet C++ is particularly suitable as a vehicle for user-implemented lazy evaluation, because its
support for <encapsulation> makes it possible to add lazy evaluation to a class without clients of
that class knowing it's been done. 

That means it's possible to implement a class using a straightforward eager evaluation strategy, but
then, if your profiling investigations (see Item 16) show that class's implementation is a
performance bottleneck, you can replace its implementation with one based on lazy evaluation.


Four examples and one in *kt_dev_ecpp_006*	

{reference-counting}

class String { ... };

String s1 = "Hello";
String s2 = s1;

Such a copy constructor would incur a relatively large expense, because it would have to make a copy
of s1's value to give to s2, and that would typically entail allocating heap memory via the new
operator and calling strcpy to copy the data in s1 into the memory allocated by s2. This is eager
evaluation.

But s2 hasn't been used yet.

The lazy approach is a lot less work. Instead of giving s2 a copy of s1's value, we have s2 share
s1's value. Need some book-keeping and is transparent to clients: do not know difference.

Because they only read values, not write them. 

cout << s1;            // read s1's value
cout << s1 + s2;       // read s1's and s2's values

In fact, the only time the sharing of values makes a difference is when one or the other string is
modified;

s2.convertToUpperCase();

Inside convertToUpperCase, we can be lazy no longer: we have to make a copy of s2's (shared) value
for s2's private use.


{distinguish-read-and-write}

By using lazy evaluation and proxy classes as described in Item 30, however, we can defer the
decision on whether to take read actions or write actions until we can determine which is correct.


{lazy-fetching}

Imagine large objects containing many constituent fields which can be expensive to get from
database, even worse remote database. To restore a LargeObject is quite expensive.

class LargeObject {                   // large persistent objects
public:
	 LargeObject(ObjectID id);         // restore object from disk
	 const string& field1() const;     // value of field 1
	 int field2() const;               // value of field 2
	 double field3() const;            // ...
	 const string& field4() const;
	 const string& field5() const;
...
};

If need few fields like below,

void restoreAndProcessObject(ObjectID id)
{
	LargeObject object(id);

	if (object.field2() == 0) 
	{
	 	cout << "Object " << id << ": null field2.\n";
	}
}

Data is retrieved from the database only when that particular data is needed inside the object.
Here's one way to implement this kind of <demand-paged-object-initialization>

class LargeObject {
public:
	 LargeObject(ObjectID id);
	 const string& field1() const;
	 int field2() const;
	 double field3() const;
	 const string& field4() const;
	 ...
	 private:
	 ObjectID oid;
	 mutable string *field1Value;  // see below for a
	 mutable int *field2Value;     // discussion of "mutable"
	 mutable double *field3Value;
	 mutable string *field4Value;
	 ...
};

LargeObject::LargeObject(ObjectID id)
: oid(id), field1Value(0), field2Value(0), field3Value(0), ...
{}

const string& LargeObject::field1() const
{
	 if (field1Value == 0) {
		  read the data for field 1 from the database and make
		  field1Value point to it;
	 }
	 return *field1Value;
}

Null pointers signify fields that have not yet been read from the database. Each LargeObject member
function must check the state of a field's pointer before accessing the data it points to.


The problem that null pointers may need to be initialized to point to real data from inside any
member function. So need mutable keyword. <mutable-example>

NOTE: can use smart-pointer in item28

Refer to <lazy-initialisation>.



{lazy-expression-evaluation}

For numerical application.

template<class T>
class Matrix { ... }; // for homogeneous matrices

Matrix< int> m1(1000, 1000); // a 1000 by 1000 matrix
Matrix< int> m2(1000, 1000); // ditto
...

Matrix< int> m3 = m1 + m2; // add m1 and m2

Lazy evaluation strategy: Instead, it sets up a data structure inside m3 that indicates that m3's
value is the sum of m1 and m2. Such a data structure might consist of nothing more than a pointer to
each of m1 and m2, plus an enum indicating that the operation on them is addition.

Matrix< int> m4(1000, 1000);
... // give m4 some values
m3 = m4 * m1;

We can forget all about m3 being the sum of m1 and m2 (and thereby save the cost of the
computation),

A more common scenario is that we need only part of a computation. For example, suppose we use m3 as
follows after initializing it to the sum of m1 and m2:

cout << m3[4]; // print the 4th row of m3

Clearly we can be completely lazy no longer. But there's no reason we have to compute any more than
the fourth row of m3; the remainder of m3 can remain uncomputed until it's actually needed.

To be fair, laziness sometimes fails to pay off.

m3 = m1 + m2;  // remember that m3 is the sum of m1 and m2
m1 = m4;       // now m3 is the sum of m2 and the OLD value of m1!


Because of the need to store dependencies between values; to maintain data structures that can store
values, dependencies, or a combination of the two; and to overload operators like assignment,
copying, and addition, lazy evaluation in a numerical domain is a lot of work. 

KT. Need to understand expression like a compiler and need to see if it pays off.


==============================================================================
*kt_dev_mecpp_003* 18: over-eager evaluation

The idea behind over-eager evaluation is that if you expect a computation to be requested
frequently, you can lower the average cost per request by designing your data structures to handle
the requests especially efficiently.

<caching> and <prefetching> are examples. 

{space-and-time-trade-off}

that's that greater speed can often be purchased at a cost of increased memory usage.


{lazy-or-eager}

Lazy and eager are not contradictory to each other.

Lazy evaluation is a technique for improving the efficiency of programs when you must support
operations whose results are not always needed. Over-eager evaluation is a technique for improving
the efficiency of programs when you must support operations whose results are almost always needed
or whose results are often needed more than once.

both can yield significant performance improvements in programs whose behavioral characteristics
justify the extra programming effort.


={============================================================================
*kt_dev_mecpp_004* 


={============================================================================
*kt_dev_mecpp_005* 29: reference-counting

See {own-reference-counting} for simple example. This chapter is about how to implement sharing
underlying object like stl string class.

Two motivations:




{summary}

This is optimization technique. When useful because reference-counting costs more moeny, code,
complex and work.

o For cases when objects are big and there are many sharings. More memory to save.
o For cases when there are many copy and assign between objects. More time to save.

Need profiling. However, there is a case which cannot use this technique: data structures using
self-reference which causes isolated collection of objects and reference count never drops to zero.
Therfore, industrial garbage collectors use special technique to find these.


{approach-one}

{{copy-on-write}}

class String {
	 const char& operator[] (int index) const;
	 char& operator[] (int index);
	 ...
};

const version is read-only so that is okay. If want to separate read and write for non-const, that
is to create new object only when writing. How?

cout << s[3];     // read 
s[5] = 'x';       // write

Not possible to separate. This separation could be done using proxy class, MEC++ 30, so now assume
all non-const as write.

char* String::operator[] (int index)
{
	if( value->refCount > 1 ) {
		  --value->refCount;
		  value = new StringValue( value->data );
	}

	return value->data[index];
}

This if-block works only when there is sharing before and create new one only when writing happens.
So this is copy-on-write and the example of {lazy-evaluation}


{{sharable}}

However, there are cases not covered:

String s1 = "Hello";
char* p = &s1[1];

String s2 = s1;
*p = 'x';                // change s1 and s2 as well


s1 -> 2 -> "Hello"
s2 -> 

note: how about stl string class? possible?


The problem is to change underlying object not through String interface. See *kt_dev_ecpp_007* for
returning handles to internal objects.

How to solve?

o Ignore this problem
o Hava a shareable flag in which to create new object when tries to change from outside. This is
waht stl string uses. This is ON by default, operator[] turn it OFF, and cannot change it once it is
OFF. Kind of dirty flag.

class String {
	 public:
	 	String& operator=( const String& rhs );
		...
	private:
		struct StringValue {
			 >
			 bool sharable;
<
			 size_t refCount;
			 char* data;
			 StringValue( const char* initValue );
			 ~StringValue();
		};

		StringValue* value;
};

String::StringValue::StringValue( const char* initValue ) : refCount(1), sharable(true) # <default>
{
	 data = new char[ strlen(initValue) +1 ];
	 strcpy( data, initValue );
}

There should be a check in member funcs.

String::String( const String& rhs )
{ >
	 if( rhs.value->sharable ) {
<		  value = rhs.value;
		  ++value->refCount;
	 }
	 else {
		  value = new StringValue( rhs.value->data );
	 }
}

Assume that returning from this call means someone outside will have a reference to internal so make
it non-sharable always.

char* String::operator[] (int index)
{
	if( value->refCount > 1 ) {
		  --value->refCount;
		  value = new StringValue( value->data );
	}
>
	value->sharable = false;
<
	return value->data[index];
}

For example:

String s1 = s2 = s3 = "Hello";

s1 -> 3 -> "Hello"
s2 -> 
s3 ->

s3[3] = 'x';

s1 -> 2 -> "Hello"
s2 -> 
s3 -> 1 -> "Hello"

String s4(s3);

s1 -> 2 -> "Hello"
s2 -> 
s3 -> 1 -> "Hello"
s4 -> 1 -> "Hello"


{{make-base-class-for-reference-counting}}

To make this reference counting available to any other class, so make it base class. note there is
no data in this class.

class RCObject {
	 public:
	 	RCObject();
		RCObject( const RCObject& rhs );
		virtual ~RCObject() = 0;

		RCObject& operator= ( const RCObject& rhs );

		... public interface
		addReference();

	private:
		size_t refCount;
		bool sharable;
};


The pure virtual means it must be used as a base class.

See ctor and copy ctor in setting refCount as 0 because it simplfies thing for the client to set
refCount to 1. copy ctor always set refCount to 0 because creating a new value and new value are
always unshared and referenced only by their creator.

RCObject::RCObject(): refCount(0), sharable(true) {}
RCObject::RCObject(const RCObject&): refCount(0), sharable(true) {}

RCObject::~RCObject() {}     # see {pure-virtual-dtor}

Copy assign do nothing and will not be used in reality because it is a base class for a shared value
object(StringValue) which are not assigned to one another. Only String do. {{why-need}} It said it
is for future use but seems not useful to consider since do nothing about refCount.

RCObject& RCObject::operator=( const RCObject& )
{ return *this;}

note: Really need copy ctor and copy assign?

<delete-this> is safe only if *this is a heap object.

void RCObject::removeReference()
{
	 if(--refCount == 0 ) delete this;   # <delete-this>
}

void RCObject::addReference() { ++refCount; }


class String {
	 private:
	 	struct StringValue : public RCObject {    # <public-inheritance>
			 char* data;                           # <data>
			 StringValue( const char* initValue );
			 ~StringValue();
		};
		...
};

String::StringValue::StringValue(const char *initValue)
{
	 data = new char[strlen(initValue) + 1];
	 strcpy(data, initValue);
}

String::StringValue::~StringValue()
{
	 delete [] data;
}


          RCObject: has reference-counting feature
			 |
String -> StringValue -> data

StringValue is almost the same but now StringValue do not manipulate refCount and RCObject has. But
String should call explicitly interfaces to manage refCount. It is clumsy because String must call
these to manage reference counting. can we make it done automatically? move it out of user class?

If can detect access to StringValue through pointer, it could. This is objcet which acts like a
pointer such as smart pointer and which support member selection(->) and dereferencing(*). 


This template gives smart pointer objects control over what happens during their construction,
assignment, and destruction. When such <events> occur, this object can automatically perform the
appropriate manipulations of the refCount field in the objects to which they point.


template<class T>
class RCPtr {
public:
	RCPtr(T* realPtr = 0);
	RCPtr(const RCPtr& rhs);
	~RCPtr();
	RCPtr& operator=(const RCPtr& rhs);
	T* operator->() const; // see Item 28
	T& operator*() const;  // see Item 28
private:
	T *pointee;  // dumb pointer this object is emulating
	void init(); // common initialization code
}; 

template<class T>
RCPtr< T>::RCPtr(T* realPtr): pointee(realPtr)
{
	init();
}

template<class T>
RCPtr< T>::RCPtr(const RCPtr& rhs): pointee(rhs.pointee)
{
	init();
}

template<class T>
void RCPtr< T>::init()
{
	// if the dumb pointer is null, so is the smart one
	if (pointee == 0) { 
		return;         
	}
	// if the value is not shareable, copy it
	if (pointee->isShareable() == false) { 
		pointee = new T(*pointee); 
	} 
	// note that there is now a new reference to the value
	pointee->addReference(); 
} 

The problem is when T is StringValue and the following happens:

pointee = new T(*pointee);

There is no copy ctor of StringValue and syn version will be used. So memberwise copy but not a deep
copy. Therefore, needs String::StringValue::StringValue( const StringValue& rhs ) 


{{putting-it-all-together}}

Sting is reference counted string class.

                        RCObject
			               |
String               -> StringValue -> data
+RCPtr
+nested StringValue


/*
** RCObject : base class for reference counted objects
*/
class RCObject { 
public:
	 RCObject();
	 RCObject(const RCObject& rhs);
	 RCObject& operator=(const RCObject& rhs);
	 virtual ~RCObject() = 0;
	 void addReference();
	 void removeReference();
	 void markUnshareable();
	 bool isShareable() const;
	 bool isShared() const;
private:
	 size_t refCount;
	 bool shareable;
};

RCObject::RCObject() : refCount(0), shareable(true) {}
RCObject::RCObject(const RCObject&) : refCount(0), shareable(true) {}
RCObject& RCObject::operator=(const RCObject&) { return *this; }
RCObject::~RCObject() {}
void RCObject::addReference() { ++refCount; }

void RCObject::removeReference()
{ if (--refCount == 0) delete this; }

void RCObject::markUnshareable()
{ shareable = false; }
bool RCObject::isShareable() const
{ return shareable; }
bool RCObject::isShared() const
{ return refCount > 1; }


/*
 * RCPtr
 */
template<class T> 
class RCPtr { 
public: 
	 RCPtr(T* realPtr = 0);
	 RCPtr(const RCPtr& rhs);
	 ~RCPtr();
	 RCPtr& operator=(const RCPtr& rhs);
	 T* operator->() const;
	 T& operator*() const;
private:
	 T *pointee;
	 void init();
};

template<class T>
void RCPtr<T>::init()
{
	// if the dump pointer is null, so is the smart one
	if (pointee == 0) return;

	// if is not sharable, create new one
	if (pointee->isShareable() == false) {
		pointee = new T(*pointee);
	}
	
	// new reference
	pointee->addReference();
}

template<class T>
RCPtr<T>::RCPtr(T* realPtr) : pointee(realPtr)
{ init(); }

template<class T>
RCPtr<T>::RCPtr(const RCPtr& rhs) : pointee(rhs.pointee)
{ init(); }

template<class T>
RCPtr<T>::~RCPtr()
{ if (pointee) pointee->removeReference(); }    # <delete-this-in-removeReference>

template<class T>
RCPtr<T>& RCPtr<T>::operator=(const RCPtr& rhs)
{
	 // skip when the value does not change
	 if (pointee != rhs.pointee) {

		  T *oldPointee = pointee;
		  pointee = rhs.pointee;

		  // if possible share it, else make own copy
		  init();

		  // decrease reference
		  if (oldPointee) oldPointee->removeReference();
	 }

	 return *this;
}

template<class T>
T* RCPtr<T>::operator->() const { return pointee; }

template<class T>
T& RCPtr<T>::operator*() const { return *pointee; }


/*
 * String : class to be used by users
 */
class String { 
public: 
	 String(const char *value = "");
	 const char& operator[](int index) const;
	 char& operator[](int index);

private:
	 // class representing string values
	 struct StringValue: public RCObject {
		  char *data;
		  StringValue(const char *initValue);
		  StringValue(const StringValue& rhs);
		  void init(const char *initValue);
		  ~StringValue();
	};

	RCPtr<StringValue> value;
};


void String::StringValue::init(const char *initValue)
{
	 data = new char[strlen(initValue) + 1];
	 strcpy(data, initValue);
}
String::StringValue::StringValue(const char *initValue)
{ init(initValue); }
String::StringValue::StringValue(const StringValue& rhs)
{ init(rhs.data); }
String::StringValue::~StringValue()
{ delete [] data; }


String::String(const char *initValue)
: value( new StringValue(initValue) ) {}        # <set-rcptr>

const char& String::operator[](int index) const
{ return value->data[index]; }

char& String::operator[](int index)
{
	if (value->isShared()) {
		value = new StringValue(value->data);
	}
	value->markUnshareable();
	return value->data[index];
}

<assumption>

RCPtr< T> has:

o deep-copying copy constructor
o T inherit from RCObject, or at least that T provide all the functionality that RCObject does. T
must support the RCObject interface and it menas RCPtr and RCObject is tightly coupled.


<note-one> <difference-in-interface-of-sting>
Now there is no need to have String copy ctor, assign, and dtor because syn version doing memberwise
will call matching one of RCPtr which doing work of managing refCount. That is smart.

note: This is an example of using syn version compiler made.

Our original goal was to move the unreusable reference-counting code out of our hand-written String
class and into context-independent classes where it would be available for use with any class. Now
we've done it (in the form of the RCObject and RCPtr classes),

note: Also there is nearly no changes to String interface. encapsulation.


{{add-reference-counting-to-existing-classes}} {wrapper}

How to add this reference-counting feature, RCObject, to a class which is in libary and do not
have source? Here Widget is library class:

            RCObject
			    |
RCWidget -> Widget
+RCPtr

>
 Use that most problems in Computer Science can be solved with an additional level of indirection.
 See how to forward and how to get around the problem.
<

                  RCObject
			          |
RCWidget       -> CounterHolder    -> Widget
+RCIPtr
  (counter)->      (pointee)->

Here Widget or CounterHolder is <reference-counted-object>


template<class T>
class RCIPtr {
	 public:
		  RCIPtr(T* realPtr = 0);
		  ...
		  RCObject& getRCObject() // give clients access to
		  { return *counter; } // isShared, etc.

	 private:
		  struct CountHolder: public RCObject {
				~CountHolder() { delete pointee; }
				T *pointee;
		  };

		  CountHolder *counter;
		  void init();
};

template<class T>
void RCIPtr<T>::init()
{
	 if (counter->isShareable() == false) {
		  T *oldValue = counter->pointee;
		  counter = new CountHolder;
		  counter->pointee = oldValue ? new T(*oldValue) : 0;
	 }
	 counter->addReference();
}

template<class T>
RCIPtr<T>::RCIPtr(T* realPtr) : counter( 'new' CountHolder)
{
	 counter->pointee = realPtr;
	 init();
}

class RCWidget {
	 public:
		  # <see-how-to-pass-widget> 
		  RCWidget(int size): value( 'new' Widget(size)) {} 

        # <forwarding> [see-how-to-forward]
		  void doThis()
		  {
				if (value.getRCObject().isShared()) { 
					 value = new Widget(*value); 
				}
				value->doThis();
		  }

		  int showThat() const { return value->showThat(); }

	 private:
		  RCIPtr<Widget> value;
};


={============================================================================
*kt_dev_mecpp_006* 28: log entry

Class template for making log entries whenever a T object is modified; see below for details

template<class T>
class LogEntry {
  public:
    LogEntry(const T& objectToBeModified);
    ~LogEntry();
};

void editTuple(DBPtr<Tuple>& pt)
{
  LogEntry< Tuple> entry(*pt); // make log entry for this operation

  do {
    pt->displayEditDialog();
  } while (pt->isValid() == false);
}


The LogEntry's constructor begins the log entry and its destructor ends the log entry. Two pros:

1. handles exception case
2. easier to create a single LogEntry object than to add separate calls to start and stop an entry 

#include <iostream>

using namespace std;

template<typename T>
class LogEntry {
  public:
  LogEntry( const T& obj ) { cout << "{ modifed: " << obj << endl; }
  ~LogEntry() { cout << "}" << endl; }
};

void a_function(int arg)
{
  LogEntry<int> log(arg);

  cout << "this is a function" << endl;
}

int main()
{
  cout << "this is main { " << endl;

  a_function(5);

  cout << "this is main } " << endl;
}

this is main { 
{ modifed: 5
this is a function
}
this is main } 


={============================================================================
*kt_dev_mecpp_007* link-combine C and C++

There are things to know when use both together in a program.

{name-mangling}
This is the process which C++ compiler give each function a unique name
because supports overloading. There is a directive to tell compiler not to
mangle func name. This is called `linkage directive`


{extern-keyword}
The GCC compiles files based on extension. When compiles cpp files meaning cpp
mangles names, you can make sure that functions are c functions (not to
    mangle) :

extern "C" void drawLine(int x1, int y1, int x2, int y2);

extern "C" {
	 ...
}

extern "C" {
	 #include <string.h>
}

If you want to build a function as a c function, then can do: 

extern "C" double calc( double dparam )
{
	 ...
}

To allow source or header to be compiled under either C or C++.

#ifdef __cplusplus
extern "C"
{
#endif

int strcmp( const char*, const char* );
...

#ifdef __cplusplus
}
#endif


<extern-on-typedef>
Not only for function but also for function pointer typedef.

extern "C" typedef Plugin* createFunction_t(const char *);


<case-example> <wrapper-from-cpp-to-c>
Suppose the case when main written in c uses some features written in cpp. If
there is no extern guard, then:

[   15s] /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/pfmosa.h:170:1: error: previous
declaration of 'pfmerr_t pfmThreadCreate(SPfmThreadParams*, void (*)(void*), void*)' with 'C++'
linkage 
[   15s] /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/pfmthread.cpp:80:80: error:
conflicts with new declaration with 'C' linkage


Why? Since the cpp file uses typedefs from it and when compiles the cpp file,
  compiler thinks func defs are C++ linkage from wrapper header since there is
  no extern guard and then see wrapper_func in C linkage from cpp file. So
  conflict.

C source(.c and gcc)        wrapper header(.h)        wrapper class(.cpp and g++)

#include "wrapper.h"                                  #include "wrapper.h" 
                            extern "C"                extern "C"
                            {   typdefs               {
										  int wrapper_func();       int wrapper_func()
										  ...                       {
									 }                                ....
                                                          }
																			 ...
																		}


C source(.c and gcc)        wrapper header(.h)        wrapper class(.cpp and g++)

#include "wrapper.h"                                 	extern "C"
                               typdefs                {
                                                          #include "wrapper.h" 
										  int wrapper_func();       int wrapper_func()
										  ...                       {
									                                 ....
                                                          }
																			 ...
																		}

This can be avoided if design header and source files carefully. For example,
     if need some c functions that can be used in c file and this function
     creates cpp objects and use it then simply create a header which has
     normal declarations and no externs and only have externs in cpp. The
     point is that the same header is used for both C and CPP.

// ususal c
#include "wrapper.h"
{
	wrapper_func();
}

// usual.h or wrapper.h
int wrapper_func();

// usual cpp or wrapper.cpp
extern "C"
{
  int wrapper_func()
  {
     ClassX* pclass = new Class( params );

     pclass->func();
     ...
  }
}

If usual cpp header or wrapper.h have other cpp headers, will work cpp
compiles such as usual cpp and others but when used in c compile, emits loads
of errors since these cpp files have cpp things.  So better to have single
header file which have all c functions from cpp land. Otherwise, will get
errors shown in *kt_dev_gcc_007* 

<extern-linkage>
Using extern to Specify Linkage
http://msdn.microsoft.com/en-us/library/0603949d.aspx

extern string-literal { declaration-list }
extern string-literal declaration

The extern keyword declares a variable or function and specifies that it has external linkage (its
    name is visible from files other than the one in which it's defined). When modifying a variable,
    extern specifies that the variable has static duration (it is allocated when the program begins
        and deallocated when the program ends). The variable or function may be defined in another
    source file, or later in the same file. Declarations of variables and functions at file scope
    are external by default.

In C++, when used with a string, extern specifies that the linkage conventions of another language
are being used for the declarator(s). C functions and data can be accessed only if they are
previously declared as having C linkage. However, they must be defined in a separately compiled
translation unit.

Microsoft C++ supports the strings "C" and "C++" in the string-literal field. All of the standard
include files use the extern "C" syntax to allow the run-time library functions to be used in C++
programs.

The following example shows alternative ways to declare names that have C linkage:

// specifying_linkage2.cpp
// compile with: /c
// Declare printf with C linkage.
extern "C" int printf( const char *fmt, ... );

//  Cause everything in the specified header files
//   to have C linkage.
extern "C" {
   // add your #include statements here
   #include <stdio.h>
}

//  Declare the two functions ShowChar and GetChar
//   with C linkage.
extern "C" {
   char ShowChar( char ch );
   char GetChar( void );
}

//  Define the two functions ShowChar and GetChar
//   with C linkage.
extern "C" char ShowChar( char ch ) {
   putchar( ch );
   return ch;
}

extern "C" char GetChar( void ) {
   char ch;

   ch = getchar();
   return ch;
}

// Declare a global variable, errno, with C linkage.
extern "C" int errno;


{example-from-code}
/* Define C declaration macros for C++ compatibility. */                                
#if !defined(BEGIN_C_DECLS) && !defined(END_C_DECLS)
#if defined(__cplusplus) || defined(c_plusplus)
# define BEGIN_C_DECLS extern "C" {
# define END_C_DECLS   }
#else /* !__cplusplus */
# define BEGIN_C_DECLS
# define END_C_DECLS
#endif /* __cplusplus */
#endif /* BEGIN_C_DECLS && END_C_DECLS */


{function-pointer-between}
If use function-pointer or function-pointer as arg between them, see Primus p859 for more.


{cpp-main}
The cpp-main has three stages: static-initialisation, main, and static-destruction. So if not use
cpp-main when use both, will not work as expected and shall use cpp-main.

extern "C" int realMain(...);

int main( ... )
{
	 return realMain( ... );
}

This is dependent on compiler and shall check with it.

KT: is it still ture? ture for gcc?


{new-delete-and-malloc-free}
Do not mix between new/delete and malloc/free. For example, char* strdup(char
    *ps), which is not standard in C/C++. Need to free or delete? It depends
on system and compiler so recommends that do not use funcs which is not
standard.

<Q> not standard? The ansic book do not have strdup in string.h in appendix.
This is what was said it's not standard. Now seems it's part of string.h in
GCC.

https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-strdup

Function: char * strdup (const char *s)

    Preliminary: | MT-Safe | AS-Unsafe heap | AC-Unsafe mem | See POSIX Safety
    Concepts.

    This function copies the string s into a newly allocated string. The
    string is allocated using malloc; see Unconstrained Allocation. If malloc
    cannot allocate space for the new string, strdup returns a null pointer.
    Otherwise it returns a pointer to the new string. 


<online>
strdup is not a standard C++ function. but it is apparently a `Posix` function,
       and anyway it's a well known function which has been there since K&R C.
       so if you absolutely must use it, do not fret about any possible name
       collision, and just write strdup for maximum portability.

Why is strdup considered to be evil? Two reasons I can think of:

Not strictly ANSI C, but rather POSIX. Consequently, some compilers (e.g.
    MSVC) discourage use (MSVC prefers _strdup), and technically the C
standard could define its own strdup with different semantics since str is a
reserved prefix. So, there are some potential portability concerns with its
use. 

It hides its memory allocation. Most other str functions don't allocate
memory, so users might be misled (as you say) into believing the returned
string doesn't need to be freed.

But, aside from these points, I think that careful use of strdup is justified,
  as it can reduce code duplication and provides a nice implementation for
  common idioms (such as strdup("constant string") to get a mutable,
      returnable copy of a literal string).


{data-structure-in-between}
The objects that have virtual and inheritance are not compatible with C. This affects when calling
funcs with return or args between them.


==============================================================================
*kt_dev_mecpp_008*	32: program in the future tense

To be prepared for the change. How?

{one}

Express design decision in code instead of comments or documents. For example,
preventing-derivation.


{two}

Design code so that when changes are necessary, the impact is localized. Asks how the class is
designed to be used. See future thense and this is a example of virtual dtor. Encapsulation.


# ============================================================================
#{
={============================================================================
*kt_dev_estl_001*	02: illusion of container-independent code

STL is based on generalizaiton: container is array generalization, iterator is pointer, and
algorithm is function. but do not mean that can write container-independent code because each
container has different interface and characteristics. To minimize impcats of changing containers,
use <encapsulation> using typedef and class.

{no-encapsulation}

class Widget { ... };
vector< Widget > vw;
Widget bestWidget;
...
vector< Widget >::iterator i = find( vw.begin(), vw.end(), bestWidget );


{first-improvement}

class Widget { ... };
>
 typedef vector< Widget > WidgetContainer;
 WidgetContainer vw;
<
Widget bestWidget;
...
>
 WidgetContainer::iterator i = find( vw.begin(), vw.end(), bestWidget );

Also, save you some typing as think about:

map< sting, vector< Widget >::iterator, CIStingCompare>;

Want to sell out the below?

map< sting, vector< Widget >::iterator, CIStingCompare>::const_iterator;


{second-improvement}
Using typdef is not enough to separate client so use class:

class CustomerList {
	 private:
	 >
	 typedef list< Customer > CustomerContainer;
	 typedef CustomerContainer::iterator CCIterator;
	 CustomerContainer customers;
<
	 public:
	 // limit the list-specific detail visible through this interface
	 ...
};


={============================================================================
*kt_dev_ccon_000* cpp-chrono cpp-time

#include <chrono>

using namespace std::chrono;  // see §35.2

// used measures nanoseconds
auto t0 = high_resolution_clock::now();

this_thread::sleep_for(milliseconds{20});

auto t1 = high_resolution_clock::now();

cout << duration_cast<nanoseconds>(t1t0).count() << " nanoseconds passed\n";
cout << duration_cast<milliseconds>(t1t0).count() << " milliseconds passed\n";


# ============================================================================
#{ c++ concurrent in action
={============================================================================
*kt_dev_ccon_000* cpp-con-thread

<cpp-thread-build>

#include <iostream>
#include <thread>

using namespace std;

void hello()
{
    std::cout << "Hello concurrent world\n";
}

int main(int argc, char** argv)
{
    std::thread t(hello);
    t.join();
}

$ g++ -g -std=c++0x tthread.cpp 
$ ./a.out 
terminate called after throwing an instance of 'std::system_error'
  what():  Operation not permitted
Aborted

$ g++ -g -std=c++0x -pthread tthread.cpp 
$ ./a.out 
Hello concurrent world


={============================================================================
*kt_dev_ccon_001* std-thread: copy callables and arguments. lifetime issue

The std::thread object must be self-contained and this means initial function
and its arguments `should be copied` into a thread object.

The compiler checks that the first argument can be invoked given the following
arguments and `builds the necessary function object` to pass to the thread.

class background_task
{
  public:
    void operator()() const
    {
      do_something();
      do_something_else();
    }
};

background_task f;

std::thread my_thread(f);

If use callable object, it is 'copied' into the storage belonging to the newly
created thread of execution and invoked from there. It's therefore essential
that the copy is *self-contained* or the result may not be what's expected.

note: std::bind uses the same mechanism.

If not, can cause lifefime issue. For stl algorithms and predicates, use
either usual function or temporary functional object and passes it as
argument. Since the temporty object is self-contained and it is okay to use
with stl algorithms. 

When thread object is self-contained and is detached, no need to worry about
lifetime issue.

<lifetime-issue>
<1> when not self-contained since has a reference to external

void f( int i, std::string const& s );

std::thread t( f, 3, "hello" );

This creates a new thread which calls f( 3, "hello" ) and the second argument is
passed as a "char const *" and converted to a std::string. This is particularly
important when the argument supplied is a pointer to an automatic variable, as
follows:

void f( int i, std::string const& s );

void oops( int some_param )
{
  char buffer[1024];

  sprintf( buffer, "%i", some_param );
  std::thread t( f, 3, buffer );
  t.detach();
}

The problem is that there is a significance chance that the function oops will
exit 'before' the buffer has been 'converted' to a std::string on the new
thread. Thus leading to undefined behavior because it relies on implicit
conversion and a pointer of buffer is copied, no guarantee that buffer is
available 'when' a thread runs f() which requires a conversion from char* to
string.

The solution is to do it explicitly before passing the buffer to the std::thread
constructor:

void oops( int some_param )
{
  char buffer[1024];

  sprintf( buffer, "%i", some_param );
  std::thread t( f, 3, std::string(buffer) );
  t.detach();
}

note: is it okay if use t.join() instead? seems okay since t.join() will be
blocked and opps() will not be exited.


<2> always a copy is made

void update_data_for_widget( widget_id w, widget_data& data );

void oops_again( widget_id w )
{
  widget_data data;

  std::thread t( update_data_for_widget, w, data );

  display_status();
  t.join();
  process_widget_data(data);
}

'although' passed by reference, 'still' copied and has internal copy. The
problem is that process_widget_data will be passed an unchanged data rather than
a correctly updated version.

The solution is to use:

// *cpp-ref*
std::thread t( update_data_for_widget, w, std::ref(data) );

Since it uses t.join() it is safe to use reference to local variable.


<member-function-pointer>

class X
{
    public:
        void do_lengthy_work();
};

X my_x;

std::thread t( &X::do_lengthy_work, &my_x );


<noncopyable-arguments>
Since unique_ptr is only moveable and not a temporary but named object, must be
requested explicitly by std::move().

void process_big_object( std::unique_ptr<big_object> );

std::unique_ptr<big_object> p( new big_object );
p->prepare_data(42);
std::thread t( process_big_object, std::move(p) );


<thread-movable>
This means that std::thread is movable to ensure that only one thread object is
associated with a particular thread of execution at any one time.

/// thread note: <from-stl-code>
class thread
{
    template<typename _Callable>
        struct _Impl : public _Impl_base
    {
        _Callable    _M_func;          // note:

        _Impl(_Callable&& __f) : _M_func(std::forward<_Callable>(__f))
        { }

        void
            _M_run() { _M_func(); }
    };

    private:
    void _M_start_thread(__shared_base_type);

    public:

    thread() noexcept = default;
    thread(thread&) = delete;
    thread(const thread&) = delete;

    thread(thread&& __t) noexcept
    { swap(__t); }
    template<typename _Callable, typename... _Args>
        explicit 
        thread(_Callable&& __f, _Args&&... __args)
        {
            _M_start_thread(_M_make_routine(std::__bind_simple(
                            std::forward<_Callable>(__f),
                            std::forward<_Args>(__args)...)));
        }

    template<typename _Callable> 
        shared_ptr<_Impl<_Callable>> _M_make_routine(_Callable&& __f)
    {
        // Create and allocate full data structure, not base.
        return std::make_shared<_Impl<_Callable>>(std::forward<_Callable>(__f));
    }
};


<user-is-reponsible>
When provide callable to thread whether it is global function, member function
or callable via bind, it is different problem to make sure that this callable is
self-contained that is there is no external reference. That is a user to make
sure that when use thread object.


={============================================================================
*kt_dev_ccon_002* std-thread: join and detach

Once started a thread, need to explicitly decide whether to wait for it to
finish by joining or leave it to run on its own by detaching.

If don't decide before thread object is destoryed, then your program is
terminated. the std::thread destructor calls std::terminate().

If don't wait for a thread to finish, lifetime issues can happen and that's why
must use self-contained approach.

struct func
{
    int i;

    func( int & i_ ): i(i_) {}

    void operator()()
    {
        ...
    }
};

void oops()
{
    int some_local_state = 0;

    func my_func( some_local_state );

    // new thread might still be running after oops()
    std::thread my_thread( my_func );  

    // should be my_thread.join();
    my_thread.detach();                
}


={============================================================================
*kt_dev_ccon_003* cpp-con-race-condition cpp-data-race

{broken-invariant}
There are problems with sharing data between threads due to the consequences
of modifying data. The concept used is 'invariant' that is statement always
true about a particular data structures.  The problem is when the invariants
of the system cannot be maintained. Broken invariants.

{race-conditions}
A race condition is anything where the outcome depends on the relative
ordering of execution of operations on two or more threads. It is when the
race condition leads to broken invariants that there is a problem.

Such problems will show up at the most inconvenient time since the race
conditions are "timing sensitive" and hard to find and duplicate because the
window of opportunity is small.

<data-race>
The C++ Standard also defines the term data race to mean the specific type of
race condition that arises because of concurrent modification to a single
'object'. uncontrolled concurrent access to a variable

<approaches-to-solve>
o The simplest option is to wrap your data structure with a protection
  mechanism

o lock-free programming

o software transactional memory (STM)


={============================================================================
*kt_dev_ccon_004* cpp-con-mutex cpp-con-lock-guard cpp-race-condition thread-safe stack

{cpp-mutex}
Mutexes are the most general of the data-protection mechanisms. But they're
not a silver bullet; it's important to structure your code to protect the
right data and avoid race conditions inherent in your interfaces. Mutexes also
come with their own problems, in the form of a deadlock and protecting either
too much or too little data.

<cpp-lock-guard>
Not recommended practice to call the member functions, lock() and unlock(),
    directly, because this means that you have to remember to call unlock() on
    every code path out of a function, including those due to exceptions.

std::lock_guard class template, which implements that RAII idiom for a mutex;

#include <mutex>

std::list<int> some_list;
std::mutex some_mutex;

void add_to_list(int new_value)
{
    std::lock_guard<std::mutex> guard(some_mutex);
    some_list.push_back(new_value);
}

bool list_contains(int value_to_find)
{
    std::lock_guard<std::mutex> guard(some_mutex);
    return std::find(some_list.begin(),some_list.end(),value_to_find) 
      != some_list.end();
}

Can encapsulate the functionality and enforce the protection and it's common
to group the mutex and the protected data together in a class rather than use
global variables.


{not-silver-bullet} {design-considerations}
If all the member functions of the class lock the mutex before accessing any
other data members and unlock it when done, the data is nicely protected from
all comers.

Really?

Well, that’s not quite true. If one of the member functions returns a pointer
or reference to the protected data? doesn't matter that the member functions
all lock the mutex

Protecting data with a mutex therefore requires careful interface design, to
ensure that the mutex is locked before there's any access to the protected
data and that there are no backdoors.


<do-not-pass-protected-data>
If do careful design, the data is safe now? No. If you dig a little deeper,
it's not that straightforward. Nothing ever is.

As well as checking that the member functions don't pass out pointers or
references to their callers. also to check that they don't pass such pointers
or references in to functions they call that aren't under your control;
functions that are supplied at runtime via a function argument or other means

Accidentally passing out a reference to protected data

class some_data
{
  int a;
  std::string b;

  public:
    void do_something();
};

class data_wrapper
{
  private:
    some_data data;
    std::mutex m;
  public:
    template<typename Function> void process_data(Function func)
    {
      std::lock_guard<std::mutex> l(m);

      // pass "protected" data to user-supplied function
      func(data);
    }
};

some_data* unprotected;

void malicious_function(some_data& protected_data)
{
    unprotected=&protected_data;
}

data_wrapper x;

void foo()
{
    x.process_data(malicious_function);

    // unprotected access to protected data
    unprotected->do_something();
}


{cpp-race-condition-inherent-in-interface}
Consider the doubly linked list example again. In order for a thread to safely
delete a node, you need to ensure that you're preventing concurrent accesses
to `three nodes:` the node being deleted and the nodes on either side. If you
protected accesses to the pointers of each node individually, you'd be no
better off than with code that used no mutexes, because the race condition
could still happen:

it's not the individual nodes that need protecting for the individual steps
but the whole data structure, for the whole delete operation. The easiest
solution in this case is to have a single mutex that protects the entire list.

Just because individual operations on the list are safe, you can still get
race conditions, even with a really simple interface since interface is not
well designed. Consider std::stack<>.

template< typename T, typename Container=std::deque<T> >
class stack
{
    public:

        // ...
        
        bool empty() const;
        size_t size() const;
        
        T& top();
        T const& top() const;

        void push(const T& );
        void push(T &&);

        void pop();
};

The problem is not about mutex-based implementation. it's an interface problem
so the race condition would still occur with a lock-free implementation. this
interface is inherently subject to race.

The problem is that the result of empty() and size() can't be relied on. 

stack<int> s;

if(!s.empty())                            <-
{
    int const value = s.top();      <-    <-
    s.pop();                        <-
    do_something(value);
}

1. empty-and-top sequence
Calling top() on an empty stack is undefined. classic race.

2. top-and-pop sequence
One of the two values on the stack is discarded without ever having been read,
    whereas the other is processed twice. another race and far more
    'insidious'. there's never anything obviously wrong going on and the
    consequence of the bug are far from the cause although depends on exactly
    what do_something really dose.

<option-1> note: this is a discusssion in Exceptional C++
one that combine the calls to top() and pop() under the mutex. that is pop()
  return the value as well as remove it from the stack. However, can leads to
  issue if the copy constructor for the objects on the stack can throw an
  exception.

Consider stack<vector<int>>. Now, a vector is a dynamically sized container,
         so when you copy a vector the library has to allocate some more
         memory from the heap in order to copy the contents. If the system is
         heavily loaded, or there are significant resource constraints, this
         memory allocation can fail, so the copy constructor for vector might
         throw a std::bad_alloc exception. This is especially likely if the
         vector contains a lot of elements. If the pop() function was defined
         to return the value popped, as well as remove it from the stack, you
         have a potential problem: the value being popped is returned to the
         caller 'only' after the stack has been modified, but the process of
         copying the data to return to the caller might throw an exception. If
         this happens, the data just popped is lost; it has been removed from
         the stack, but the copy was unsuccessful! 
    
The designers of the std::stack interface helpfully split the operation in
two: get the top element (top()) and then remove it from the stack (pop()), so
that if you can't safely copy the data, it stays on the stack. If the problem
was lack of heap memory, maybe the application can free some memory and try
again. Unfortunately, it's precisely this split that you're trying to avoid in
eliminating the race condition!

<option-2>
Pass a reference to receive the popped value.

std::vector<int> result;
some_stack.pop(result);

Has the distinct disadvantage; the stored type is assignable which is
restriction since many user type do not support it.

<option-3>
Use no-throw copy or move constructor. Limited since restrict the use of this
thread-safe stack to those types that can safely be returned by value without
an exception. note: may change as more type supports move semantics. 

<option-4>
Return a pointer to the popped item. That is to use dynamically allocated item
and pass its pointer.  The advantage here is that pointers can be freely
copied without throwing an exception, so you've avoided Cargill’s exception
problem.

However, requiring that each object in the stack be allocated separately with
new would impose quite an overhead compared to the original non-thread-safe
version.

<option-5>
Provide both option 2 and either option 3 or 4. Flexibility should never be
ruled out.

<thread-safe-stack>
This implements option 2 and 4.

#include <exception>
#include <memory>
#include <mutex>
#include <stack>

struct empty_stack: std::exception
{
    const char* what() const throw();
};

template<typename T>
class threadsafe_stack
{
    private:
        std::stack<T> data;
        mutable std::mutex m;             // <mutable>
    public:
        threadsafe_stack(){}
        threadsafe_stack(const threadsafe_stack& other)
        {
            std::lock_guard<std::mutex> lock(other.m);
            data=other.data;
        }
        threadsafe_stack& operator=(const threadsafe_stack&) = delete;

        void push(T new_value)
        {
            std::lock_guard<std::mutex> lock(m);
            data.push(new_value);
        }
        std::shared_ptr<T> pop()
        {
            std::lock_guard<std::mutex> lock(m);
            if(data.empty()) throw empty_stack();
            std::shared_ptr<T> const res(std::make_shared<T>(data.top()));
            data.pop();
            return res;
        }
        void pop(T& value)
        {
            std::lock_guard<std::mutex> lock(m);
            if(data.empty()) throw empty_stack();
            value=data.top();
            data.pop();
        }
        bool empty() const
        {
            std::lock_guard<std::mutex> lock(m);
            return data.empty();
        }
};

note: when initializer-list is not useful
This stack implementation is actually copyable; the copy constructor locks the
mutex in the source object and then copies the internal stack. You do the copy
in the constructor body rather than the member initializer list in order to
ensure that the mutex is held across the copy.

note: no need empty() since use exception.
Your five stack operations have now become three: push(), pop(), and empty().
Even empty() is superfluous.


={============================================================================
*kt_dev_ccon_005* cpp-con-lock-guard cpp-deadlock

<cpp-deadlock>
deadlock does not just occur with locks: can occur any synchronization
construct that can lead to a wait cycle. "neither thread can make progress
because it is waiting for the other to finish."

Simple rules that can help you to write deadlock-free code.

o Avoid nested locks
o Avoid calling user-supplied code while holding a lock
o Acquire locks in a fixed or the same order

Although fixed order used, deadlock can still occur. Consider that use a mutex
to protect each instance of the same class, use operation that exchanges data
between two instances. The mutexes on both instances must be locked. If two
threads calls this operation with the parametars(instances) swapped then you
have deadlock. 

std::lock() can lock two or more mutexes at 'once' without risk of deadlock and
provides 'all-or-nothing' semantics.

class X
{
  private:
    std::mutex m;

  public:

    friend void swap( X& lhs, X& rhs )
    {
      if( &lhs == &rhs )
        return;

      // lock two mutexes
      std::lock( lhs.m, rhs.m );

      // std::adopt_lock to indicate to std::lock_guard objects that the
      // mutexes are 'already' locked.

      std::lock_guard<std::mutex> lock_a( lhs.m, std::adopt_lock );
      std::lock_guard<std::mutex> lock_b( rhs.m, std::adopt_lock );

      swap( lhs.some_detail, rhs.some_detail );
    }
};


o Use a lock hierarchy

This is really a particular case of lock-ordering and can provide a means of
checking at runtime. The idea is to divide an application into 'layers' and
identify all the mutexes that may be locked in any given layer.

hierarchical_mutex high_level_mutex(10000);
hierarchical_mutex low_level_mutex(5000);

int do_low_level_stuff();

int low_level_func()
{
    std::lock_guard< hierarchical_mutex> lk( low_level_mutex );
    return do_low_level_stuff();
}

void high_level_stuff(int some_param);

void high_level_func()
{
    std::lock_guard< hierarchical_mutex > lk( high_level_mutex );
    high_level_stuff( low_level_func() );
}

void thread_a()
{
    high_level_func();
}

hierarchical_mutex other_mutex(100);

void do_other_stuff();

void other_stuff()
{
    high_level_func();
    do_other_stuff();
}

void thread_b()
{
    std::lock_guard< hierarchical_mutex > lk(other_mutex);
    other_stuff();
}

1. thread_b() is not fine. this does mean that can't hold two locks at the same time if they're the
same level in the hierarchy so hand-over-hand locking schemes require that each mutex in the chain
have a lower value than the prior one which my be impractical in some cases.

<user-defined-mutex>
2. show the use of std::lock_guard with user-defined mutex type. should have three member functions:
lock, unlock and try_lock which forward to the same name on the underlying mutex. 

class hierarchical_mutex
{
    std::mutex internal_mutex;

    unsigned long const hierarchy_value;
    uisigned long previous_hierarchy_value;

    static thread_local unsigned long this_thread_hierarchy_value;

    void check_for_hierarchy_violation()
    {
        if( this_threa_hierarchy_value <= hierarchy_value )
        {
            throw std::logic_error( "mutex hierarchy violated" );
        }
    }

    void update_hierarchy_value()
    {
        previous_hierarchy_value = this_thread_hierarchy_value;
        this_thread_hierarchy_value = hierarchy_value;
    }

    public:
    explicit hierarchical_mutex( unsigned long value ):
        hierarchy_value( value ), previous_hierarchy_value( 0 )
    {}

    void lock()
    {
        check_for_hierarchy_violation();
        internal_mutex.lock();
        update_hierarchy_value();
    }

    void unlock()
    {
        this_thread_hierarchy_value = previous_hierarchy_value;
        internal_mutex.unlock();
    }

    bool try_lock()
    {
        check_for_hierarchy_violation();
        if( internal_mutex.try_lock() )
            return false;
        update_hierarchy_value();
        return true;
    }
};

// <thread-local> since it is declared thread_local, every thread has its 'own' copy
thread_local unsigned long
   hierarchical_mutex::this_thread_hierarchy_value( ULONG_MAX );


={============================================================================
*kt_dev_ccon_006* cpp-con-unique-lock

The standard library offers help in the form of an operation for acquiring
several locks simultaneously with regard to deadlock problem.

std::unique_lock provides more 'flexibility' than std::lock_guard.

o std::defer_lock to indicate that the mutex should remian unlocked on
  construction then later locked by calling std::unique_lock.lock().

o std::uniqie_lock is typically larger and has a slight performance penalty so
  lock_guard is in preference if it suits.

class X
{
  private:
    std::mutex m;

  public:

    friend void swap( X& lhs, X& rhs )
    {
      if( &lhs == &rhs )
        return;

      std::unique_lock<std::mutex> lock_a( lhs.m, std::defer_lock );
      std::unique_lock<std::mutex> lock_b( rhs.m, std::defer_lock );

      // lock two mutexes
      std::lock( lock_a, lock_b );

      swap( lhs.some_detail, rhs.some_detail );
    }
};


={============================================================================
*kt_dev_ccon_007* std::unique_lock and transferring mutex

{flexible-unique-lock}
Because unique_lock instances don't have to own their associated mutexes, the ownership of a mutex
can be transferred between instances by moving the instances around.

One possible use is to allow a function to lock a mutex and transfer ownership of that lock to the
caller, so the caller can then perform additional actions under the protection of the same lock.

std::unique_lock<std::mutex> get_lock()
{
    extern std::mutex some_mutex;

    std::unique_lock<std::mutex> lk( some_mutex );
    prepare_data();

    return lk;
}

note: lk is local variable and can be returned without calling std::move since the compiler takes
care of calling the move constructor.

note: some_mutex is 'extern'

void process_data()
{
    std::unique_lock<std::mutex> lk(get_lock());
    do_something();
}

<gatweay-class>
One such usage is where the lock isn't returned directly but is a data member of a gateway class
used to ensure correctly locked access to some protected data. 

In this case, all access to the data is through this gateway class; when you wish to access the
data, you obtain an instance of the gateway class (by calling a function such as get_lock() in the
        preceding example), which acquires the lock. You can then access the data through member
functions of the gateway object. 
        
When you're finished, you destroy the gateway object, which releases the lock and allows other
threads to access the protected data. Such a gateway object may well be movable so that it can be
returned from a function, in which case the lock object data member also needs to be movable.

<manual-option>
The flexibility of std::unique_lock also allows instances to relinquish their locks before they're
destroyed. You can do this with the unlock() member function, just like for a mutex:
std::unique_lock supports the same basic set of member functions for locking and unlocking as a
mutex does, in order that it can be used with generic functions such as std::lock.


={============================================================================
*kt_dev_ccon_008* std::unique_lock and granulity

Not only is it important to choose a sufficiently coarse lock granularity to ensure the required
data is protected, but it's also important to ensure that a lock is held only for the operations
that actually require it since holding the lock will 'delay' other threads unnecessary. less
contention.

std::unique_lock works well in this situation, because you can call unlock() when the code no longer
needs access to the shared data and then call lock() again if access is required later in the code:

void get_and_process_data()
{
    std::unique_lock<std::mutex> my_lock(the_mutex);

    some_class data_to_process = get_next_data_chunk();

    my_lock.unlock();

    retult_type result = process( data_to_process );

    my_lock.lock();

    write_result( data_to_process, result );
}

The previous swap examples using locks must lock both instance. If you were trying to compare a
simple data member that is int and is cheap to copy compared to big_data in previous examples then
can minimize locking time by holding single lock as below?

// listing 3.10

class Y
{
    private:
        int some_detail;
        mutable std::mutex m;
        int get_detail() const
        {
            std::lock_guard<std::mutex> lock_a(m);
            return some_detail;
        }
    public:
        Y(int sd):some_detail(sd){}
        friend bool operator==(Y const& lhs, Y const& rhs)
        {
            if(&lhs==&rhs)
                return true;
            int const lhs_value=lhs.get_detail();
            int const rhs_value=rhs.get_detail();
            return lhs_value==rhs_value;
        }
};

NO. this has changed the semantics of operations since compare values from different point in time.
So comparison is meaningless and race condition.

To be careful that the semantics of the operation are not changed in a problematic fashion.


={============================================================================
*kt_dev_ccon_009* std::call_once and protecting during initialization

One particularly extreme (but remarkably common) case is where the shared data needs protection only
from concurrent access while it’s being initialized, but after that no explicit synchronization is
required. This might be because the data is read-only once created, and so there are no possible
synchronization issues, or it might be because the necessary protection is performed implicitly as
part of the operations on the data.

It's for this reason that the C++ Standard provides a mechanism purely for protecting shared data
during initialization.

Suppose you have a shared resource that's so expensive to construct that you want to do so only if
it's actually required; maybe it opens a database connection or allocates a lot of memory. Lazy
initialization such as this is common in single-threaded code

std::shared_ptr<some_resource> resource_ptr;

void foo()
{
    if(!resource_ptr)
    {
        resource_ptr.reset(new some_resource);
    }
    resource_ptr->do_something();
}


A naive translation to multithreaded code which cause unnecessary serialization of threads using the
resource. This is because each thread must wait on the mutex in order to check whether the resource
has already been initialized.


std::shared_ptr<some_resource> resource_ptr;

std::mutex resource_mutex;

void foo()
{
    std::unique_lock<std::mutex> lk(resource_mutex);
    if(!resource_ptr)
    {
        resource_ptr.reset(new some_resource);
    }
    lk.unlock();

    resource_ptr->do_something();
}


<data-race>
This so called "double-checked locking" is better?

void undefined_behaviour_with_double_checked_locking()
{
    if(!resource_ptr)
    {
        std::lock_guard<std::mutex> lk(resource_mutex);
        if(!resource_ptr)
        {
            resource_ptr.reset(new some_resource);
        }
    }
    resource_ptr->do_something();
}


No it cause race condition since read to resource_ptr outside the lock and write inside the lock are
not synchronized. May run on different instance. This is defined "data race".


<std-once>
C++ provides std::once_flag and std::call_once to handle this situation. Every thread can just use
std::call_once and this do the same as "naive translation" but has a lower overhead.


std::shared_ptr<some_resource> resource_ptr;

std::once_flag resource_flag;

void init_resource()
{
    resource_ptr.reset(new some_resource);
}

void foo()
{
    std::call_once(resource_flag,init_resource);      // is called exactly once
    resource_ptr->do_something();
}


The example when used with a class:

class X
{
    private:
        connection_info connection_details;
        connection_handle connection;
        std::once_flag connection_init_flag;
        void open_connection()
        {
            connection=connection_manager.open(connection_details);
        }
    public:
        X(connection_info const& connection_details_):
            connection_details(connection_details_)
    {}

        void send_data(data_packet const& data)
        {
            std::call_once(connection_init_flag,&X::open_connection,this);
            connection.send_data(data);
        }

        data_packet receive_data()
        {
            std::call_once(connection_init_flag,&X::open_connection,this);
            return connection.receive_data();
        }
};

As with std::thread and std::bind, used additional argument to call_once.


note:
It's worth noting that, like std::mutex, std::once_flag instances can't be copied or moved, so if
you use them as a class member like this, you'll have to explicitly define these special member
functions should you require them.


<alternative-to-call-once>
One scenario where there's a potential race condition over initialization is that of a local
variable declared with static.

see <init-order-problem>

In C++11 this problem is solved: the initialization is defined to happen on exactly one thread, and
no other threads will proceed until that initialization is complete, so the race condition is just
over which thread gets to do the initialization rather than anything more problematic. This can be
used as an alternative to std::call_once for those cases where a single global instance is required:


Protecting data only for initialization is a special case of a more general scenario: that of a
rarely updated data structure. For most of the time, such a data structure is read-only and can
therefore be merrily read by multiple threads concurrently.

note: singleton is read-only


={============================================================================
*kt_dev_ccon_010* boost::shared_lock and read-write lock

For most of the time, such a data structure is read-only and can therefore be merrily read by
multiple threads concurrently, but on occasion the data structure may need updating?

What's needed is a different kind of mutex. This new kind of mutex is typically called a
reader-writer mutex, because it allows for two different kinds of usage: exclusive access by a
single "writer" thread or shared, concurrent access by multiple "reader" threads.

The new C++ Standard Library doesn't provide such a mutex out of the box and is provided by the
boost library, which is based on the proposal.

note: 
The performance is dependent on the number of processors involved and the relative workloads of the
reader and updater threads. therefore important to profile the performance of the code on the target
system to ensure that there's actually a benefit to the additional complexity.

Typically, a given DNS entry will remain unchanged for a long period of time in many cases DNS
entries remain unchanged for years. Although new entries may be added to the table from time to time
as users access different websites, this data will therefore remain largely unchanged throughout its
life.

Those threads that don't need to update the data structure can instead use
boost::shared_lock<boost::shared_mutex> to obtain shared access. This is used just the same as
std::unique_lock, except that multiple threads may have a shared lock on the same
boost::shared_mutex at the same time. 

#include <map>
#include <string>
#include <mutex>
#include <boost/thread/shared_mutex.hpp>

class dns_entry;

class dns_cache
{
    std::map<std::string,dns_entry> entries;

    mutable boost::shared_mutex entry_mutex;          // <mutable>

    public:
    dns_entry find_entry(std::string const& domain) const
    {
        boost::shared_lock<boost::shared_mutex> lk(entry_mutex);

        std::map<std::string,dns_entry>::const_iterator const it= entries.find(domain);
        return (it==entries.end()) ? dns_entry() : it->second;
    }

    void update_or_add_entry(std::string const& domain, dns_entry const& dns_details)
    {
        std::lock_guard<boost::shared_mutex> lk(entry_mutex);
        entries[domain]=dns_details;
    }
};

The only constraint is that if any thread has a shared lock, a thread that tries to acquire an
exclusive lock will block until all other threads have relinquished their locks, and likewise if any
thread has an exclusive lock, no other thread may acquire a shared or exclusive lock until the first
thread has relinquished its lock.

So update_or_add_entry() uses an instance of std::lock_guard<> to provide exclusive access while the
table is updated; not only are other threads prevented from doing updates in a call
update_or_add_entry(), but threads that call find_entry() are blocked too.


={============================================================================
*kt_dev_ccon_011* recursive lock

With std::mutex, it's an error for a thread to try to lock a mutex it already owns, and attempting
to do so will result in undefined behavior. However, in some circumstances it would be desirable for
a thread to reacquire the same mutex several times without having first released it. For this
purpose, the C++ Standard Library provides std::recursive_mutex.

Most of the time, if you think you want a recursive mutex, you probably need to change your design
instead.

Since, in particular, the class invariants are typically broken while the lock is held.


={============================================================================
*kt_dev_ccon_012* std::condition_variable

Because std::condition_variable_any is more general, there's the potential for additional costs in
terms of size, performance, or operating system resources, so std::condition_variable should be
preferred unless the additional flexibility is required.

std::mutex mut;
std::queue<data_chunk> data_queue;
std::condition_variable data_cond;

void data_preparation_thread()
{
    while(more_data_to_prepare())
    {
        data_chunk const data=prepare_data();

        std::lock_guard<std::mutex> lk(mut);                   // note

        data_queue.push(data);
        data_cond.notify_one();
    }
}

void data_processing_thread()
{
    while(true)
    {
        std::unique_lock<std::mutex> lk(mut);                  // note

        data_cond.wait(lk,[]{return !data_queue.empty();});    // note

        data_chunk data=data_queue.front();
        data_queue.pop();

        lk.unlock();                                           // note

        process(data);

        if(is_last_chunk(data))
            break;
    }
}

note: condition and why unique_lock
a lambda function that expresses the condition being waited for. checks to see if the data_queue is
not empty() - that is, there's some data in the queue ready for processing.

The implementation of wait() then checks the condition (by calling the supplied lambda function) and
returns if the expression returned true. If the condition isn't satisfied, wait() unlocks the mutex
and puts the thread in a blocked or waiting state.

the thread wakes from its slumber (unblocks it), reacquires the lock on the mutex, and checks the
condition again, returning from wait() with the mutex still locked if the condition has been
satisfied. If the condition hasn't been satisfied, the thread unlocks the mutex and resumes waiting.
This is 'why' you need the std::unique_lock rather than the std::lock_guard.

The flexibility to unlock a std::unique_lock isn't just used for the call to wait(); it's also used
once you have the data to process but before processing it

<suprious-wake>
When the waiting thread reacquires the mutex and checks the condition, if it isn't in direct
response to a notification from another thread, it's called a spurious wake. Because the number and
frequency of any such spurious wakes are by definition indeterminate, it is 'not' advisable to use a
function with side effects for the condition check. If you do so, you must be prepared for the "side
effects" to occur multiple times.


={============================================================================
*kt_dev_ccon_013* thread-safe queue

TODO 4.1.2


={============================================================================
*kt_dev_ccon_014* cpp-con-task-model cpp-future

From C++PL 42.4.

<task-model>
Focuses on specifying a simple kind of task: a task that does one thing given
arguments and produces one result. Hiding uses of the messier
threads-and-locks level.

Often, we would like to provide a lot of small tasks and let 'the system'
worry about how to map their execution onto hardware resources and how to keep
them out of problems with data races, spurious wake-ups, excessive waits, etc.

The importance of these facilities is their 'simplicity'. In a sequential
program, we usually write something like:

// perform a task given arguments and get the result
res = task(args);

The concurrent version becomes:

// perform a task given arguments
auto handle = async(task,args);  

// ... do something else ...
//
// get the result
res = handle.get()               


<shared-or-call-and-return>
Communicating through shared data is pretty low level. In particular, the
programmer has to devise ways of knowing what work has and has not been done
by various tasks. In that regard, use of shared data is inferior to the notion
of call and return. On the other hand, some people are convinced that sharing
must be more efficient than copying arguments and returns. That can indeed be
so when large amounts of data are involved, but locking and unlocking are
relatively expensive operations. On the other hand, modern machines are very
good at copying data, especially compact data, such as vector elements. So
don’t choose shared data for communication because of “efficiency” without
thought and preferably not without measurement.

    
{future-and-promise}
`communication between tasks` is handled by a future/promise pair. A task
'puts' its result into a promise, and a task that needs the result 'retrieves'
the result from the corresponding future:

task 1                             task 2:
-----------------------            ------------------------------------------
get() -> future  <->  value   <->  promise    <- set_value(), set_exception()

The value is known as "shared state". In addition to the return value or
exception, it contains the information needed for two threads to 'safely'
exchange the information. For example:

o A ready bit to indicate whether a value or exception is ready to be
  extracted by a future.

An implementation can take action on a shared state:

o Make ready: Set the 'ready bit' and unblock any waiting threads.


  "Please note the absence of explicit mention of locks in this code: we are
  able to concentrate on tasks to be done, rather than on the mechanisms used
  to manage their communication."


{promise}
A promise is the 'handle' to a shared state. It is where a task can deposit its
result to be retrieved through a future.

<operations>
promise pr {};       
Default constructor: pr has a shared state that is not yet ready

fu=pr.get_future()   fu is the future corresponding to pr

pr.set_value(x)      The result of the task is the value x
pr.set_value()       Set the result of the task for a void future

pr.set_exception(p)  
The result of the task is the exception pointed to by p; p is an exception_ptr

note: there are 'no' copy operations for a promise. A set function throws
future_error if a value or exception is already set.


<single-value>
Only possible to transmit a 'single' result value through a promise. That may
seem restrictive, but remember that the value is 'moved' into and out of the
shared state, rather than copied, so that we can cheaply pass a collection of
objects. For example:

promise<map<string,int>> pr;
map<string,int>> m;

// ... fill m with a million <string,int> pairs ...

pr.set_value(m);

A task may then extract that map from a corresponding future at essentially zero
cost.


{future}
A future is a handle to a shared state. It is where a task can retrieve a result
deposited by a promise.

<operations>
future fu {fu2};
Move constructor: fu gets fu2's shared state, if any; fu2 no longer has a shared
state; noexcept

fu.get()
For future<void>: like x=fu.get(), but don't move any value

fu.wait() 
Block until a value arrives

<ex>

I can easily implement a version of wait_for_all():

template<typename T>
vector<T> wait_for_all(vector<future<T>>& vf)
{
    vector<T> res;
    for (auto& fu : vf)
        res.push_back(fu.get());
    return res;
}


={============================================================================
*kt_dev_ccon_014* cpp-con-async

note: this way is to set future 'implicitly'.

<one-off-event-and-asynchronous-result>
The C++ Standard Library models this sort of one-off event with a future. Wait
for the future to become ready. A future may have 'data' associated with it or
    it may not. Once an event has happened (and the future has become ready),
       the future can't be 'reset'.

<two-types>
There are two sorts of futures in the C++ Standard Library, implemented as two
class templates declared in the <future> library header: unique futures
(std::future<>) and shared futures (std::shared_future<>). These are modeled
after std::unique_ptr and std::shared_ptr. An instance of std::future is the one
and only instance that refers to its associated event, whereas multiple
instances of std::shared_future may refer to the same event. In the latter case,
all the instances will become ready at the same time, and they may all access
    any data associated with the event. 

This associated data is the reason these are templates; just like
std::unique_ptr and std::shared_ptr, the template parameter is the type of the
associated data.

<no-data>
The std:future<void>, std::shared_future<void> template specializations should
be used where there's no associated data.


{return-from-task}
std::thread doesn't provide an easy means of returning a value from such a task.
This is where the std::async function template (also declared in the <future>
        header) comes in.

Use std::async to start an asynchronous task for which you don't need the result
right away. Rather than giving you back a std::thread object to wait on,
      std::async returns a std::future object, which will eventually hold the
      return value of the function. 

When you need the value, you just call get() on the future, and the thread
blocks until the future is ready and then returns the value. 

#include <future>
#include <iostream>

int find_the_answer_to_ltuae();

void do_other_stuff();

int main()
{
    std::future<int> the_answer = std::async( find_the_answer_to_ltuae );
    do_other_stuff();
    std::cout << "The answer is " << the_answer.get() << std::endl;
}


std::async allows you to pass additional arguments to the function by adding
extra arguments to the call, in the same way that std::thread does. If the
arguments are rvalues, the copies are created by moving the originals. This
allows the use of move-only types as both the function object and the arguments.

#include <string>
#include <future>

struct X
{
    void foo(int,std::string const&);
    std::string bar(std::string const&);
};

X x;

// arg1 is a pointer to a member function
// arg2 is the object on which apply the member function
// args... are passed as args to the member function

// calls p->foo(42, "hello") where p is &x
auto f1=std::async(&X::foo,&x,42,"hello"); 

// calls tempx.bar("goodbye") where tempx is a copy of x
auto f2=std::async(&X::bar,x,"goodbye");   

struct Y
{
    double operator()(double);
};

Y y;

// arg1 is function or callable
// args... are passed as args

// calls tempy(3.141) where tempy is move-constructed
auto f3=std::async(Y(),3.141);         

// calls y(2.718)
auto f4=std::async(std::ref(y),2.718); 

X baz(X&);

std::async(baz,std::ref(x));

class move_only
{
    public:
        move_only();
        move_only(move_only&&);
        move_only(const &move_only) = delete;
        move_only& operator=(move_only&&);
        move_only& operator=(const &move_only) = delete;
        void operator()();
};

// calls tmp() where tmp is constructed from std::move(move_only())
auto f5=std::async(move_only()); 


<ex> C++ SRL 18

note: As std::thread example, must build with -lpthread.

Here, async() 'tries' to start the passed functionality immediately
asynchronously in a separate thread.

#include <future>
#include <thread>
#include <chrono>
#include <random>
#include <iostream>
#include <exception>

using namespace std;

int doSomething (char c)
{
    default_random_engine dre(c);
    uniform_int_distribution<int> id(10, 1000);

    for(int i=0; i<10; ++i)
    {
        this_thread::sleep_for(chrono::milliseconds( id(dre) ));
        cout.put(c).flush();
    }

    return c;
}

int func1()
{
    return doSomething('.');
}

int func2()
{
    return doSomething('+');
}

int main()
{
    cout << "starting func1() in background"
        << " and func2() in foreground:" << endl;

    future<int> result1(std::async(func1));

    int result2 = func2();

    int result = result1.get() + result2;

    cout << "\nresult of func1()+func2(): " << result << endl;
}

note:
Here, with the call of get(), one of three things might happen:

1. If func1() was started with async() in a separate thread and has already
finished, you immediately get its result.

2. If func1() was started but has not finished yet, get() blocks and waits for
its end and yields the result.

3. If func1() was not started yet, it will be forced to start now and, like a
synchronous function call, get() will block until it yields the result.

This behavior is important because it ensures that the program 'still' works on
a single-threaded environment or, if for any other reason, it was not possible
for async() to start a new thread.


Thus, the combination of

std::future<int> result1(std::async(func1)); and result1.get()

allows you to optimize a program in a way that, if possible, func1() runs in
parallel while the next statements in the main thread are processed. If it is
not possible to run it in parallel, it will be called sequentially when get()
    gets called. This means that, in any case, it is guaranteed that after
    get(), func1() was called either asynchronously or synchronously.

Two kinds of outputs are possible for this program. If async() could
successfully start func1(), the output might be something like the following:

starting func1() in background and func2() in foreground:
++..++++.++.+.+. ...
result of func1()+func2(): 89

If async() couldn't start func1(), it will run after func2(), when get() gets
called, so that the program will have the following output:

starting func1() in background and func2() in foreground:
++++++++++..........
result of func1()+func2(): 89

Note that without calling get(), there is no guarantee that func1() will ever be
called. As written, if async() couldn't start the passed functionality
immediately, it will defer the call so that it gets called only when the outcome
of the passed functionality explicitly is requested with get()

Note also that you have to ensure that you ask for the result of a functionality
started with async() no earlier than necessary. For example, the following
"optimization" is probably not what you want:

std::future<int> result1(std::async(func1));
int result = func2() + result1.get(); // might call func2() after func1() ends

Because the evaluation order on the right side of the second statement is
unspecified, result1.get() might be called before func2() so that you have
sequential processing again.


{specify-how-to-run}
By default, it's up to the implementation whether std::async starts a new
thread, or whether the task runs synchronously when the future is waited for.
You can specify which to use with an additional parameter to std::async. 

std::launch::deferred

This parameter is of the type std::launch, std::launch::deferred to indicate
that the function call is to be deferred until either wait() or get() is called
on the future. If the function call is deferred, it may never actually run
because it is guaranteed that func1() never gets called without get() (or
        wait(); see page 953).


std::launch::async to indicate that the function must be run on its own thread

From C++ SRL 18

If the asynchronous call is not possible here, the program will throw a
std::system_error exception (see Section 4.3.1, page 43) with the error code
resource_unavailable_try_again, which is equivalent to the POSIX errno EAGAIN
(see Section 4.3.2, page 45).

note:
If don't assign the result of std::async(std::launch::async,...) anywhere, the
caller will block until the passed functionality has finished, which would mean
that this is nothing but a synchronous call.


#include <future>
#include <thread>
#include <chrono>
#include <random>
#include <iostream>
#include <exception>

using namespace std;

int doSomething (char c)
{
    default_random_engine dre(c);
    uniform_int_distribution<int> id(10, 1000);

    for(int i=0; i<10; ++i)
    {
        this_thread::sleep_for(chrono::milliseconds( id(dre) ));
        cout.put(c).flush();
    }

    return c;
}

int func1()
{
    return doSomething('.');
}

int func2()
{
    return doSomething('+');
}

int main()
{
    cout << "starting func1() in background"
        << " and func2() in foreground:" << endl;

    future<int> result1(std::async(std::launch::async, func1));

    int result2 = func2();

    try 
    {
        int result = result1.get() + result2;

        cout << "\nresult of func1()+func2(): " << result << endl;
    }
    catch( const exception& e )
    {
        cerr << "\nEXCEPTION: " << e.what() << endl;
    }
}

starting func1() in background and func2() in foreground:
+..+..+...+..+.+++++
result of func1()+func2(): 89


std::launch::deferred | std::launch::async to indicate that the implementation
may choose. This last option is the 'default'. 

auto f6=std::async(std::launch::async,Y(),1.2);
auto f7=std::async(std::launch::deferred,baz,std::ref(x));

auto f8=std::async(std::launch::deferred | std::launch::async, baz,std::ref(x));
auto f9=std::async(baz,std::ref(x));

f7.wait();

f8 and f9 that implementation chooses and f7 is a sync call.


{care-with-future-scope}
With the async launch policy, you don't necessarily have to call get() anymore
because, if the lifetime of the returned future ends, the program will wait for
func1() to finish. Thus, if you don’t call get(), leaving the scope of the
future object (here the end of main()) will wait for the background task to end.
Nevertheless, also calling get() here before a program ends makes the behavior
clearer.

From C++ SLR 18 Waiting and polling

int bestResultInTime()
{
    // define time slot to get the answer:
    auto tp = std::chrono::system_clock::now() + std::chrono::minutes(1);

    // start both a quick and an accurate computation:
    f = std::async (std::launch::async, accurateComputation);
    int guess = quickComputation();

    // give accurate computation the rest of the time slot:
    std::future_status s = f.wait_until(tp);

    // return the best computation result we have:
    if (s == std::future_status::ready) {
        return f.get();
    }
    else {
        return guess; // accurateComputation() continues
    }
}

Note that the future f can't be a local object declared inside
bestResultInTime() because when the time was too short to finish
accurateComputation(), bestResultInTime() returns and the destructor of the
future would block until that asynchronous task has finished.

So "also calling get() here before a program ends makes the behavior clearer."
is not always clear.


{with-exception}
What happens when an exception occurs? The good news is: Nothing special; get()
for futures also handles exceptions. In fact, when get() is called and the
background operation was or gets terminated by an exception, which was/is not
handled inside the thread, this exception gets propagated again.

#include <future>
#include <thread>
#include <chrono>
#include <random>
#include <iostream>
#include <exception>

using namespace std;

int doSomething (char c)
{
    default_random_engine dre(c);
    uniform_int_distribution<int> id(10, 1000);

    for(int i=0; i<10; ++i)
    {
        this_thread::sleep_for(chrono::milliseconds( id(dre) ));
        cout.put(c).flush();
    }

    return c;
}

int func1()
{
    return doSomething('.');
}

int func2()
{
    return doSomething('+');
}

int main()
{
    cout << "starting func1() in background"
        << " and func2() in foreground:" << endl;

    future<int> result1(std::async(func1));

    int result2 = func2();

    try 
    {
        int result = result1.get() + result2;

        cout << "\nresult of func1()+func2(): " << result << endl;
    }
    catch( const exception& e )
    {
        cerr << "\nEXCEPTION: " << e.what() << endl;
    }
}

With get(), the exception gets further propagated inside main().


note: see that build without -lpthread

keitee@debian-keitee:~/work$ ./cppbl.sh t_async_02.cpp 
keitee@debian-keitee:~/work$ ./a.out 
starting func1() in background and func2() in foreground:
++++++++++
EXCEPTION: Unknown error 4294967295

note: see that build without -lpthread and this use the previous which don't
have try and catch.

starting func1() in background and func2() in foreground:
++++++++++terminate called after throwing an instance of 'std::system_error'
  what():  Unknown error 4294967295
Aborted


{why-async}
the use of std::async makes it easy to divide algorithms into tasks that can be
run concurrently.

C++ SLR 18. Thus, you have the same behavior but the 'chance' of better
performance because f might run in parallel before the outcome of f is needed.


={============================================================================
*kt_dev_ccon_015* wait(): wait and poll

You can call get() for a future<> 'only' once. After get(), the future is in an
    invalid state, which can be checked only by calling valid() for the future.

Just calling wait() forces the start of a thread a future represents and waits
for the termination of the background operation:

std::future<...> f(std::async(func)); // try to call func asynchronously
...
f.wait(); // wait for func to be done (might start background task)

But futures also provide an interface to wait for a background operation to
finish without processing its outcome. This interface is callable more than once
and might be combined with a duration or timepoint to limit the amount of
waiting time.

Two other wait() functions exist for futures, but those functions do 'not' force
the thread to get started, if it hasn't started yet:

1. With wait_for(), you can wait for a limited time for an asynchronously
running operation by passing a duration:

std::future<...> f(std::async(func)); // try to call func asynchronously
...
f.wait_for(std::chrono::seconds(10)); // wait at most 10 seconds for func

2. With wait_until(), you can wait until a specific timepoint has reached:

std::future<...> f(std::async(func)); // try to call func asynchronously
...
f.wait_until(std::system_clock::now()+std::chrono::minutes(1));

Both wait_for() and wait_until() return one of the following:

* std::future_status::deferred if async() deferred the operation and no calls to
wait() or get() have yet forced it to start (both function return immediately in
        this case)

* std::future_status::timeout if the operation was started asynchronously but
hasn't finished yet (if the waiting expired due to the passed timeout)

* std::future_status::ready if the operation has finished

By passing a zero duration or a timepoint that has passed, you can simply "poll"
to see whether a background task has started and/or is (still) running:

note: useful case? skipped for now.

C++ SRL 18.1.2 

note: On VM, do not work and do not understand. maybe different on PC linux?

#include <future>
#include <thread>
#include <chrono>
#include <random>
#include <iostream>
#include <exception>

using namespace std;

int doSomething (char c)
{
    default_random_engine dre(c);
    uniform_int_distribution<int> id(10, 1000);

    for(int i=0; i<10; ++i)
    {
        this_thread::sleep_for(chrono::milliseconds( id(dre) ));
        cout.put(c).flush();
    }

    return c;
}

int main()
{
    cout << "starting 2 operations asynchronously" << endl;

    // start two loops in the background printing characters . or +
    auto f1 = async([]{ doSomething('.'); });
    auto f2 = async([]{ doSomething('+'); });

    // if at least one of the background tasks is running
    if (f1.wait_for(chrono::seconds(0)) != future_status::deferred ||
        f2.wait_for(chrono::seconds(0)) != future_status::deferred) {
        // poll until at least one of the loops finished
        while (f1.wait_for(chrono::seconds(0)) != future_status::ready &&
               f2.wait_for(chrono::seconds(0)) != future_status::ready) {
            //...;
            this_thread::yield();  // hint to reschedule to the next thread
        }
    }
    cout.put('\n').flush();

    // wait for all loops to be finished and process any exception
    try {
        f1.get();
        f2.get();
    }
    catch (const exception& e) {
        cout << "\nEXCEPTION: " << e.what() << endl;
    }
    cout << "\ndone" << endl;
}


={============================================================================
*kt_dev_ccon_017* std::packaged_task

std::async is not the only way to associate a std::future with a task; you can
also do it by wrapping the task in an instance of the std::packaged_task<> class
template which is a higher-level abstraction


{packaged-task}
A packaged_task holds a 'task' and a future/promise 'pair'.

task 1                             packaged_task: 
                                                                  task 2:
-----------------------            ------------------------------------------
get()  ->  future  <-> value  <->  promise  <- set_value(x)       <- return x
                                            <- set_exception(px)  <- throw x

We pass a task (a function or a function object) that we want executed to a
packaged_task. When our task executes a return x, it 'causes' a set_value(x) on
the packaged_task's promise. Similarly, a throw x causes a set_exception(px)
where px is an exception_ptr for x. Basically, the packaged_task executes its
task, f(args), like this:

try {
   pr.set_value(f(args));  // assume that the promise is called pr
}
catch(...) {
   pr.set_exception(current_exception());
}

<operations>

packaged_task pt {f};

Construct pt holding f; f is moved into pt; use the default allocator; explicit

pt()(args)     
    
Execute f(args); a return x in f() does a set_value(x) to pt's promise, a throw x in f() does a
set_exception(px) to pt's promise; px is an exception_ptr to x

fu=pt.get_future()

fu is the future for pt's promise; throws future_error if called twice
<how-works>
When the std::packaged_task<> object is invoked, it calls the associated function or callable object
and makes the future ready, with the return value stored as the associated data.


<why-packaged-task>
This can be used as a building block for thread pools or other task management schemes, such as
running each task on its own thread, or running them all sequentially on a particular background
thread. If a large operation can be divided into "self-contained sub-tasks", each of these can be
wrapped in a std::packaged_task<> instance, and then that instance passed to the task scheduler or
thread pool. This abstracts out the details of the tasks; the scheduler 'just' deals with
std::packaged_ task<> instances rather than individual functions.


{associate-a-task-with-future}
The template parameter for the std::packaged_task<> class template is a function signature. The
return type of the specified function signature identifies the type of the std::future<> returned
from the get_future() member function, whereas the argument list of the function signature is used
to specify the signature of the packaged task's function call operator.

A partial class definition for std::packaged_task <std::string(std::vector<char>*,int)> would be: 

template<>
class packaged_task<std::string(std::vector<char>*,int)>
{
    public:
        template<typename Callable>
            explicit packaged_task(Callable&& f);

        std::future<std::string> get_future();

        void operator()(std::vector<char>*,int);
};

The std::packaged_task object is thus a 'callable' object, and it can be wrapped in a std::function
object, passed to a std::thread as the thread function, passed to another function that requires a
callable object, or even invoked directly. 

note: packaged_task is itself callable object which is different from async.

When the std::packaged_task is invoked as a function object, the arguments supplied to the function
call operator are passed on to the contained function, and the return value is stored as the
asynchronous result in the std::future obtained from get_future(). You can thus wrap a task in a
std::packaged_task and retrieve the future before passing the std::packaged_task object elsewhere to
be invoked in due course. When you need the result, you can wait for the future to become ready.


<example>
Many GUI frameworks require that updates to the GUI be done from specific threads, so if another
thread needs to update the GUI, it must send a message to the right thread in order to do so.
std:packaged_task provides one way of doing this without requiring a custom message for each and
every GUI-related activity.

#include <deque>
#include <mutex>
#include <future>
#include <thread>
#include <utility>

std::mutex m;
std::deque<std::packaged_task<void()> > tasks;

bool gui_shutdown_message_received();
void get_and_process_gui_message();

the GUI thread loops until a message has been received telling the GUI to shut down, repeatedly
'polling' for GUI messages to handle, such as user clicks, and for tasks on the task queue. If there
are no tasks on the queue, it loops again; otherwise, it extracts the task from the queue, and then
runs the task. The future associated with the task will then be made ready when the task completes.

void gui_thread()
{
    while(!gui_shutdown_message_received())
    {
        get_and_process_gui_message();

        std::packaged_task<void()> task;
        {
            std::lock_guard<std::mutex> lk(m);

            if(tasks.empty())
                continue;

            task=std::move(tasks.front());

            tasks.pop_front();
        }

        task();
    }
}

std::thread gui_bg_thread(gui_thread);


Posting a task on the queue is equally simple: a new packaged task is created from the supplied
function, the future is obtained from that task by calling the get_future() member function, and the
task is put on the list before the future is returned to the caller. The code that posted the
message to the GUI thread can then wait for the future if it needs to know that the task has been
completed, or it can discard the future if it doesn't need to know.

note: this uses a future as a completion indicator since no associated data, future<void>.

template<typename Func>
std::future<void> post_task_for_gui_thread(Func f)
{
    std::packaged_task<void()> task(f);
    std::future<void> res=task.get_future();
    std::lock_guard<std::mutex> lk(m);
    tasks.push_back(std::move(task));
    return res;
}

std::packaged_task can also be used in more complex situations; by specifying a different function
signature as the template parameter, can change the return type and thus the type of data stored in
the future's associated state and also the argument types of the function call operator.


={============================================================================
*kt_dev_ccon_018* std::promise

What about those tasks that can't be expressed as a simple function call or those tasks where the
result may come from more than one place? These cases are dealt with by the third way of creating a
future: using a std::promise to set the value 'explicitly'.

std::promise<T> provides a means of setting a value (of type T), which can later be read through an
associated std::future<T> object. A std::promise/std::future pair would provide one possible
mechanism for this facility; the waiting thread could block on the future, while the thread
providing the data could use the promise half of the pairing to set the associated value and make
the future ready.

You can obtain the std::future object associated with a given std::promise by calling the
get_future() member function, just like with std::packaged_task. When the value of the promise is
set (using the set_value() member function), the future becomes ready and can be used to retrieve
the stored value. 

If you destroy the std::promise without setting a value, an exception is stored instead.

#include <future>

void process_connections(connection_set& connections)
{
    while(!done(connections))
    {
        for(connection_iterator
                connection=connections.begin(),end=connections.end();
                connection!=end;
                ++connection)
        {
            // This assumes that an incoming packet has some ID and a payload with the actual data
            // in it. The ID is mapped to a std::promise
            //
            // For incoming packets, the data associated with the future is the 'payload' of the
            // data packet.

            if(connection->has_incoming_data())
            {
                data_packet data=connection->incoming();

                std::promise<payload_type>& p = connection->get_promise(data.id);
                p.set_value(data.payload);
            }

            // the promise associated with the outgoing data is set to true to indicate successful
            // transmission

            if(connection->has_outgoing_data())
            {
                outgoing_packet data = connection->top_of_outgoing_queue();

                connection->send(data.payload);
                data.promise.set_value(true);
            }
        }
    }
}


{exception-for-future}
If you pass in -1 to the square_root() function, it throws an exception, and this gets seen by the
caller:

double square_root(double x)
{
    if(x<0)
    {
        throw std::out_of_range(“x<0”);
    }
    return sqrt(x);
}

Now suppose that instead of just invoking square_root() from the current thread,

double y=square_root(-1);

you run the call as an asynchronous call:

std::future<double> f=std::async(square_root,-1);
double y=f.get();

If the function call invoked as part of std::async throws an exception, that exception is stored in
the future "in place of" a stored value, the future becomes ready, and a call to get() rethrows that
stored exception. The same happens if you wrap the function in a std::packaged_task.

If you wish to store an exception rather than a value, you call the set_exception() member function
rather than set_value().

extern std::promise<double> some_promise;

try
{
    some_promise.set_value(calculate_value());
}
catch(...)
{
    some_promise.set_exception(std::current_exception());      // note: std::current_ex
}

the alternative here would be to use std::copy_exception() to store a new exception directly without
throwing: some_promise.set_exception(std::copy_exception(std::logic_error("foo "))); This is much
cleaner than using a try/catch block if the type of the exception is known, and it should be used in
preference; not only does it simplify the code, but it also provides the compiler with greater
opportunity to optimize the code.

note: ?

<broken-promise>
Another way to store an exception in a future is to destroy the std::promise or std::packaged_task
associated with the future 'without' calling either of the set functions on the promise or invoking
the packaged task. In either case, the destructor of the std::promise or std::packaged_task will
store a std::future_error exception with an error code of std::future_errc::broken_promise in the
associated state if the future isn't already ready; by creating a future you make a promise to
provide a value or exception, and by destroying the source of that value or exception without
providing one, you break that promise.


={============================================================================
*kt_dev_ccon_018* std::shared_future in multiple threads

std::future has its limitations, not the least of which being that only one thread can wait for the
result. If you need to wait for the same event from more than one thread, you need to use
std::shared_future instead.

Although std::future handles all the 'synchronization' necessary to transfer data from one thread to
another, calls to the member functions of a particular std::future instance are not synchronized
with each other. If you access a single std::future object from multiple threads without additional
synchronization, you have a data race and undefined behavior. This is by design: std::future models
"unique ownership of the asynchronous result", and the one-shot nature of get() makes such
concurrent access pointless anyway-only one thread can retrieve the value, because after the first
call to get() there's no value left to retrieve.

note: what will happen if do call get() more than once?

<shared-is-copyable>
Whereas std::future is only moveable, so ownership can be transferred between instances, but only
one instance refers to a particular asynchronous result at a time, std::shared_future instances are
copyable, so you can have multiple (future) objects referring to "the same associated state".


<no-additional-sync>
Now, with std::shared_future, member functions on an individual object are still unsynchronized, so
to avoid data races when accessing a single future object from multiple threads, you must protect
accesses with a lock. The preferred way to use it would be to take a copy of the object instead and
have each thread access its own copy of future since accesses to the shared asynchronous state from
multiple threads are 'safe' if each thread accesses that state through its own std::shared_future
object.

note: why safe? not sure about figure 4.1

<constructed-from-future>
std::shared_future that reference some asynchronous state are constructed 'from' instances of
std::future that reference that state. Since std::future objects don't share ownership of the
asynchronous state with any other object, the ownership 'must' be transferred into the
std::shared_future using std::move, leaving the std::future in an empty state, as if it was default
constructed.

std::promise<int> p;
std::future<int> f(p.get_future());
assert(f.valid());

std::shared_future<int> sf(std::move(f));
assert(!f.valid());                             // f is no longer valid
assert(sf.valid());

can construct a std::shared_future 'directly' from the return value of the get_future() member
    function of a std::promise object since transfer is implicit for rvalue.

std::promise<std::string> p;
std::shared_future<std::string> sf(p.get_future());

The other eay that save a lot of typing and makes code easier to change since

std::future also has an additional feature to automatically deducing the type of a variable from its
initializer and has a share() member function that creates a new std::shared_future and transfers
ownership to it directly.

std::promise< std::map< SomeIndexType, SomeDataType, SomeComparator, SomeAllocator>::iterator> p;
auto sf=p.get_future().share();

If type of variable changes, you only need to change the type of the promise; the type of the future
is automatically updated to match.


={============================================================================
*kt_dev_ccon_002* std::future

<example>
For a really simple example we don't even need any threads. First define a simple task:

int ff(int i)
{
    if (i) return i;
    throw runtime_error("ff(0)");
}

packaged_task<int(int)> pt1 {ff};   // store ff in pt1
packaged_task<int(int)> pt2 {ff};   // store ff in pt2

pt1(1);  // let pt1 call ff(1);
pt2(0);  // let pt2 call ff(0);

So far, nothing appears to have happened. In particular, we don't see the exception triggered by
ff(0). In fact, pt1(1) did a set_value(1) on the promise attached to pt1, and pt1(0) did a
set_exception(px) on the promise attached to pt2; that px is an exception_ptr to a
runtime_error("ff(0)").

'later', we can try to retrieve the results. The get_future() operation is used to get hold of the
future into which the packaged thread will deposit the result of its task.

auto v1 = pt1.get_future();
auto v2 = pt2.get_future();

try {
    cout << v1.get() << '\n'; // will print
    cout << v2.get() << '\n'; // will throw
}
catch (exception& e) {
    cout << "exception: " << e.what() << '\n';
}

The output is:

1
exception: ff(0)

We could have gotten exactly the same effect by simply writing:

try {
    cout << ff(1) << '\n'; // will print
    cout << ff(0) << '\n'; // will throw
}
catch (exception& e) {
    cout << "exception: " << e.what() << '\n';
}

Then why use task model?

note:
The 'point' is that the packaged_task version works exactly like the version using 'ordinary'
function calls even when the calls of the task (here ff) and the calls of the get()s are in
'different' 'threads'. We can concentrate on specifying the tasks 'rather' than thinking about
threads and locks.

We can move the future, the packaged_task, or both around. Eventually, the packaged_task is invoked
and its task deposits its result in the future without having to know either which thread executed
it or which thread will receive the result. This is simple and general.

The packaged_tasks are actually easier for the server to use than ordinary functions because the
handling of their exceptions has been taken care of.

From C++ CIA 4.2.1. The use of task make it easy to 'divide' algorithms into tasks taht can be run
concurrently.


<example> From C++ CIA 4.2.2
This can be used as a building block for thread pools (see chapter 9) or other task management
schemes, such as running each task on its own thread, or running them all sequentially on a
particular background thread. 

If a large operation can be divided into 'self-contained' sub-tasks, each of these can be wrapped in
a std::packaged_task<> instance, and then that instance passed to the task scheduler or thread pool.
This abstracts out the details of the tasks; the scheduler just deals with std::packaged_task<>
instances rather than individual functions.

The template parameter for the std::packaged_task<> class template is a function signature. The
return type of the specified function signature identifies the type of the std::future<> returned
from the get_future() member function, whereas the argument list of the function signature is used
to specify the signature of the packaged task's function call operator.

Partial class definition for a specialization of std::packaged_task<>

template<>
class packaged_task<std::string(std::vector<char>*,int)>
{
    public:
        template<typename Callable>
            explicit packaged_task(Callable&& f);
        std::future<std::string> get_future();
        void operator()(std::vector<char>*,int);
};

Can thus wrap a task in a std::packaged_task and retrieve the future 'before' passing the
std::packaged_task object elsewhere to be invoked in due course. When you need the result, you can
wait for the future to become ready.

Many GUI frameworks require that updates to the GUI be done from specific threads, so if another
thread needs to update the GUI, it must send a message to the right thread in order to do so.

std:packaged_task provides one way of doing this 'without' requiring a 'custom' message for each and
every GUI-related activity, as shown here.

#include <deque>
#include <mutex>
#include <future>
#include <thread>
#include <utility>

std::mutex m;
std::deque<std::packaged_task<void()> > tasks;

bool gui_shutdown_message_received();
void get_and_process_gui_message();

// note: future will be fired
// The future associated with the task will then be 'made' 'ready' when the task completes.

// loops until a message has been received telling the GUI to shut down.
void gui_thread()
{
    // polling for GUI message
    while(!gui_shutdown_message_received())
    {
        get_and_process_gui_message();

        std::packaged_task<void()> task;
        {
            std::lock_guard<std::mutex> lk(m);

            // 'tasks' but not task. loops again if there are no tasks on the queue.
            if(tasks.empty())
                continue;

            task=std::move(tasks.front());
            tasks.pop_front();
        }
        task();
    }
}


std::thread gui_bg_thread(gui_thread);

// The code that posted the message to the GUI thread can then wait for the future if it needs to
// know that the task has been completed, or it can discard the future if it doesn’t need to know.

template<typename Func>
std::future<void> post_task_for_gui_thread(Func f)
{
    std::packaged_task<void()> task(f);
    std::future<void> res=task.get_future();
    std::lock_guard<std::mutex> lk(m);
    tasks.push_back(std::move(task));
    return res;
}

note: That is packaged_task is a callable which wraps the given f and associated future and returns
a future. The user has a returnted future and can wait on that.

note: this way is to set future 'implicitly'.


{promise}
What about those tasks that can't be expressed as a simple function call or those tasks where the
result may come from more than one place? These cases are dealt with by the 'third' way of creating
a future: using a std::promise to set the value 'explicitly'.

std::promise<T> provides a means of setting a value (of type T), which can later be read through an
associated std::future<T> object. A std::promise/std::future pair would provide one possible
mechanism for this facility; the waiting thread could block on the future, while the thread
providing the data could use the promise half of the pairing to set the associated value and make
the future ready.

When the value of the promise is set (using the set_value() member function), the future becomes
'ready' and can be used to retrieve the stored value.

#include <future>

void process_connections(connection_set& connections)
{
    // every time through the loop, checks each connection in turn.
    while(!done(connections))
    {
        for(connection_iterator
                connection=connections.begin(),end=connections.end();
                connection!=end;
                ++connection)
        {
            // assumes that packet has some ID and payload
            if(connection->has_incoming_data())
            {
                data_packet data=connection->incoming();

                // ID is mapped to 'promise' and the value is set to payload. future is assocoated
                // with payload.

                std::promise<payload_type>& p = connection->get_promise(data.id);
                p.set_value(data.payload);
            }

            if(connection->has_outgoing_data())
            {
                outgoing_packet data= connection->top_of_outgoing_queue();

                connection->send(data.payload);

                // set to true to indicate successful transmission. std::promise<bool> and
                // std::future<bool>. The value associated with the future is a simple
                // success/failure flag.

                data.promise.set_value(true);
            }
        }
    }
}

note: there is no section that describe get_promise() so don't know how to associate promise/future
pair with user data.

The C++PL says: There is no get_promise() operation to match get_future(). The use of the promise is
completely handled by the packaged_task.


# ============================================================================
#{
={============================================================================
# ============================================================================
#{
={============================================================================
*kt_dev_blush_001*	accessing neighbors in array

2013.10. when had a problem solving which is to find a path in a maze, wrote a func like:

bool checkWhite( const Pos& pos)
{
	// upper-left
	if( A[pos.xpos-1][pos.ypos-1] == WHITE )
	{
		return true;
	}
	// upper
	else if ( A[pos.xpos][pos.ypos-1] == WHITE )
	{
		return true;
	}
	// upper-right
	else if ( A[pos.xpos+1][pos.ypos-1] == WHITE )
	{
		return true;
	}
	// same-left
	else if ( A[pos.xpos-1][pos.ypos] == WHITE )
	{
		return true;
	}
	// same-right
	else if ( A[pos.xpos+1][pos.ypos] == WHITE )
	{
		return true;
	}
	// lower-left
	else if ( A[pos.xpos-1][pos.ypos+1] == WHITE )
	{
		return true;
	}
	// lower
	else if ( A[pos.xpos][pos.ypos+1] == WHITE )
	{
		return true;
	}
	// lower-right
	else if ( A[pos.xpos+1][pos.ypos+1] == WHITE )
	{
		return true;
	}
	else
		return false;
}

Although the above tried to give it some priority, this should be something like used in
*kt_dev_algo_006* :

int NeighborCount( Grid map, int row, int col)
{
	 int i, j, count = 0;

	 for( i = row-1; i <= row+1; i++ )
		  for( j = col-1; j <= col+1; j++ )
				if( map[i][j] == ALIVE )
					 count++;

	 // exclude one for itself
	 if( map[row][col] == ALIVE )
		  count--;

	 return count;
}


# ============================================================================
#{ design
={============================================================================
*kt_dev_design_001* generic structure access

Q: How to design generic interface to support different structures in size or format?

{one} 
As shown in *kt_linux_core_300* ipc: socket: LPI 56, socket system calls uses generic interface to
supports different address structures with common call signatures.

See {generic-address-structure} for more details and accept() is an example:

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

Here, since kernel do not know the type of structure and no type in call signature, uses lenth and
kernel use this to move addr structure between user and kernel space and to check size and report
back the size written.


{two}
This is the way that NDS CDI ioctl use.

note: capabilitySize is really no use since version(type) tells you what type it uses.
note: then why *CapEx structure? Appears that CDI limits the number of arguments in ioctl() to 3
although POSIX ioctl() supports ioctl with varying arguments. That's why it uses *CapEx structure to
use more arguments. Not sure the background of this limitation.

Q: what's call signature of ioctl in kernel?

int ioctl(int fd, int request == VIDEO_DECODER_GET_CAP_EX_VERSION, uint32_t *version);

#define VIDEO_DECODER_CAP_V0     (0x00000001)
#define VIDEO_DECODER_CAP_V1     (0x00000002)
#define VIDEO_DECODER_CAP_V2     (0x00000004)
#define VIDEO_DECODER_CAP_V3     (0x00000008)

typedef struct {
  ...
} VideoDecoderCapsV2;

typedef struct {
  ...
} VideoDecoderCapsV3;

typedef struct {
   uint32_t    version;             // @in
   void        *capability;         // @out
   uint32_t    capabilitySize;      // @in
} VideoDecoderCapEx;

int ioctl(int fd, int request == VIDEO_DECODER_GET_CAP_EX, VideoDecoderCapEx *arg);


{
  uint32_t                video_dec_caps_version;
  VideoDecoderCapsEx      video_decoder_caps;
  VideoDecoderCapsV0      caps_v0 = {0U, 0U, 0U, 0U, 0U, 0U, 0U};
  VideoDecoderCapsV1      caps_v1 = {0U, 0U, 0U, 0U, 0U, 0U, 0U};
  VideoDecoderCapsV2      caps_v2 = {0U, 0U, 0U, 0U, 0U, 0U, 0U};

  if (ioctl(fd, VIDEO_DECODER_GET_CAPS_EX_VERSIONS, &video_dec_caps_version) == 0)
  {
    if (video_dec_caps_version & VIDEO_DECODER_CAP_V2)
    {
      video_decoder_caps.version = VIDEO_DECODER_CAP_V2;
      video_decoder_caps.capability = &caps_v2;
      video_decoder_caps.capabilitySize = sizeof(caps_v2);

      if (ioctl( fd, VIDEO_DECODER_GET_CAPS_EX, &video_decoder_caps) == 0)
      {
        *(uint32_t *)data = caps_v2.decodingModes;
      }
      else
      {
        *(uint32_t *)data = VIDEO_DECODER_SKIP_NONE;
      }
    }
    else (video_dec_caps_version & VIDEO_DECODER_CAP_V1)
    {
      video_decoder_caps.version = VIDEO_DECODER_CAP_V1;
      video_decoder_caps.capability = &caps_v1;
      video_decoder_caps.capabilitySize = sizeof(caps_v1);

      if (ioctl( fd, VIDEO_DECODER_GET_CAPS_EX, &video_decoder_caps) == 0)
      {
        *(uint32_t *)data = caps_v1.decodingModes;
      }
      else
      {
        *(uint32_t *)data = VIDEO_DECODER_SKIP_NONE;
      }
    }
  }
}


# ============================================================================
#{
={{===========================================================================
*kt_dev_uml_001*	aggragation

Two aggregations: weak and strong.

1) weak. white diamond-shaped arrowhead pointing towards the target or parent class.

2) strong. a black diamond-shaped arrowhead. composite aggragation.

# example

AddressBook <*>----------- ContactGroup
            1         0..*

(copied from *kt_dev_ecpp_011* )

# 03 : classic strategy pattern

hierarchy 01:

GameCharacter <--- CharacterX
                |- CharacterY
					 |- ...
    <*>
	  |
	  | composition aggregation
	 1|
HealCalcFunc  <--- SlowHealthLoser
                |- FastHealthLoser
					 |- ...


# ============================================================================
#{
={============================================================================
*kt_dev_ref_001* references

{ref-001} data structure and program design in C/C++, 2nd Ed, Robert Kruse, Prentice Hall.
ftp://ftp.prenhall.com/pub/esm/computer_science.s-041/kruse/cpp/

{ref-002} thinking in C++. 
http://www.mindviewinc.com/Books/

RDP, design patterns, Erich Gamma and et el. Addison Wesley

{ref-004} cracking the coding interview, 5th Ed.

RCPR, C++ primer, 5th Ed.
http://www.informit.com/store/c-plus-plus-primer-9780321714114


={============================================================================
*kt_dev_ref_002* sites

http://eli.thegreenplace.net/


==============================================================================
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:
