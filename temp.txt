*kt_linux*                                                           tw=100

/^[#=]{ 

aWed 18 Dec 2013 09:47:23 GMT

KT KB. Linux

|kt_linux_bash_001| bash: history <reverse-search>

# ============================================================================
#{
={============================================================================
*kt_linux_bash_001* bash: variable

{global-and-local}
Global variables or environment variables are available in all shells. The env or printenv commands
can be used to display environment variables.

Local variables are only available in the current shell. Using the set built-in command without any
options will display a list of all variables (including environment variables) and functions.


{set-variable}
Putting spaces around the equal sign will cause errors.

VARNAME="value"

A variable created like the ones in the example above is only available to the current shell. It is
a local variable: child processes of the current shell will not be aware of this variable. In order
to pass variables to a subshell, we need to export them using the export built-in command.

export VARNAME="value"

note: parent can export variables to child but not vice versa.

<reserved-variables>
PATH        A colon−separated list of directories in which the shell looks for commands.
PS1         The primary prompt string. The default value is "'\s-\v\$ '".
PS2         The secondary prompt string. The default value is "'> '".


{constant}
The readonly built−in marks each specified variable as unchangeable. When tried to set, displays
error but execution continues.

readonly CONST=100
echo "my const var is $CONST.."
CONST=200
echo "my const var is $CONST.."


{array}
<set>
FRUIT[0]=apple
FRUIT[1]=banana
FRUIT[2]=orange

Or,

FRUIT=(apple plum blackberry)

<use>
echo "idx 0 = ${FRUIT[0]}"    # idx 0 = apple. just a string
echo "idx 1 = ${FRUIT[1]}"
echo "idx 2 = ${FRUIT[2]}"

echo "all = ${FRUIT[*]}"      # to reference all
echo "all = ${FRUIT[@]}"      # same as above

<example>
farm_hosts=(web03 web04 web05 web06 web07)

for i in ${farm_hosts[@]}; do
  su $login −c "scp $httpd_conf_new ${i}:${httpd_conf_path}"
  su $login −c "ssh $i sudo /usr/local/apache/bin/apachectl graceful"
done

<example> for use of array and here document
A cron job that fills an array with the possible candidates, uses date +%W to find the week of the
year, and does a modulo operation to find the correct index. The lucky person gets notified by
e-mail.


#!/bin/bash
# This is get−tester−address.sh
#
# First, we test whether bash supports arrays. (Support for arrays was only added recently.)
#
whotest[0]='test' || (echo 'Failure: arrays not supported in this version of bash.' && exit 2)
#
# Our list of candidates. (Feel free to add or
# remove candidates.)
#
wholist=(
  'Bob Smith <bob@example.com>'
  'Jane L. Williams <jane@example.com>'
  'Eric S. Raymond <esr@example.com>'
  'Larry Wall <wall@example.com>'
  'Linus Torvalds <linus@example.com>'
)
#
# Count the number of possible testers.
# (Loop until we find an empty string.)
#
count=0
while [ "x${wholist[count]}" != "x" ]
do
   count=$(( $count + 1 ))
done
#
# Now we calculate whose turn it is.
#
week=`date '+%W'`             # The week of the year (0..53).
week=${week#0}                # Remove possible leading zero.
let "index = $week % $count"  # week modulo count = the lucky person
email=${wholist[index]}       # Get the lucky person's e−mail address.
echo $email                   # Output the person's e−mail address.

This script is then used in other scripts, such as this one, which uses a here document:

email=`get−tester−address.sh` # Find who to e−mail.
hostname=`hostname` # This machine's name.

# Send e−mail to the right person.

mail $email -s '[Demo Testing]' <<EOF
  The lucky tester this week is: $email
  Reminder: the list of demos is here:
  http://web.example.com:8080/DemoSites
  (This e−mail was generated by $0 on ${hostname}.)
EOF


{unset}
The unset built-in is used to destroy arrays or member variables of an array:


{substitution}

${parameter:-word} 
If parameter is null or unset, word is substituted for parameter. The value of parameter does not
change. In other words, if unset, word is used and if set, parameter used.

This use 'default' to make sure that the prompt is always set correctly.
PS1=${HOST:-localhost}"$ " ; export PS1 ;

This from often used in conditional tests and this set 80 when it is not defined before. That is
default.

# [ −z STRING ] True of the length of "STRING" is zero.

[ −z "${COLUMNS:−}" ] && COLUMNS=80

It is a shorter notation for

if [ −z "${COLUMNS:−}" ]; then
   COLUMNS=80
fi

note: In this form, the value of parameter does not change. Here TEST is not defined.

$ echo $TEST
$ echo ${TEST:−test}
test
$ echo $TEST
$


${parameter:=word} 
If parameter is null or unset, parameter is set to the value of word.

$ echo $TEST
$ echo ${TEST:=test}
test
$ echo $TEST
test
$


{substring}
The LENGTH parameter defines how many characters to keep, starting from the first character after
the offset point. If LENGTH is omitted, the remainder of the variable content is taken

${VAR:OFFSET:LENGTH}

$ STRING="thisisaverylongname"
$ echo ${STRING:4}
isaverylongname
$ echo ${STRING:6:5}
avery


={============================================================================
*kt_linux_bash_006* bash: args

<special-parameters>


={============================================================================
*kt_linux_tool_026* cmd: rsync

Rsync, which stands for "remote sync", is a remote and local file synchronization tool. It uses an
algorithm that minimizes the amount of data copied by only moving the portions of files that have
changed.

<example>
$ mkdir dir1 dir2
$ touch dir1/file{1..10}
$ ls dir1
file1  file10  file2  file3  file4  file5  file6  file7  file8  file9

$ rsync -r dir1/ dir2      " okay as synced
$ ls dir2
file1  file10  file2  file3  file4  file5  file6  file7  file8  file9

note: This trailing / is necessary to mean "the contents of dir1".

$ rsync -r dir1 dir2       " not okay as
$ ls dir2
dir1

The -a option is a combination flag.

It stands for "archive" and syncs recursively and preserves symbolic links, special and device
files, modification times, group, owner, and permissions. It is more commonly used than -r and is
usually what you want to use.

The -n or --dry-run options. 

The -v flag (for verbose). 

The -P flag is very helpful. 
It combines the flags --progress and --partial. The first of these gives you a progress bar for the
transfers and the second allows you to resume interrupted transfers:

The -z flag. 
If you are transferring files that have not already been compressed, like text files, you can reduce
the network transfer by adding compression with the -z option.

<update>
Update the modification time on some of the files and see that rsync intelligently re-copies only
the changed files:

<delete>
By default, rsync does not delete anything from the destination directory. We can change this
behavior with the --delete option. Before using this option, use the --dry-run option and do testing
to prevent data loss:

rsync -a --delete source destination


<example> over SSH
rsync -a ~/dir1 username@remote_host:destination_directory
rsync -a username@remote_host:/home/username/dir1 place_to_sync_on_local_machine


-------------------------------------------------------------------------------
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:

