*kt_linux*                                                           tw=100

/^[#=]{ 

aWed 18 Dec 2013 09:47:23 GMT

KT KB. Linux

={============================================================================
*kt_linux_core_107* shared library

LPI 41.

{static-library}
<create-static> ar-command
The archive also records various attributes of each of the component object files, including file
permissions, numeric user and group IDs, and last modification time.

r (replace): Insert an object file into the archive, replacing any previous object file of the same
             name. This is the standard method for creating and updating an archive. Thus, we might
             build an archive with the following commands:

$ cc -g -c mod1.c mod2.c mod3.c
$ ar r libdemo.a mod1.o mod2.o mod3.o

t (table of contents): Display a table of contents of the archive. By default, this lists just the
                       names of the object files in the archive. By adding the v (verbose) modifier,
                       we additionally see all of the other attributes recorded in the archive for
                       each object file, as in the following example:

$ ar tv libdemo.a
rw-r--r-- 1000/100 1001016 Nov 15 12:26 2009 mod1.o
rw-r--r-- 1000/100 406668 Nov 15 12:21 2009 mod2.o
rw-r--r-- 1000/100 46672 Nov 15 12:21 2009 mod3.o

<link-static>
Couple of ways in linking:

1. The first is to name the static library as part of the link command, as in the following:

$ cc -g -c prog.c
$ cc -g -o prog prog.o libdemo.a

note: 'linktime' search
2. can place the library in one of the 'standard' directories searched by the linker such as
/usr/lib, and then specify the library name; the filename of the library without the lib prefix and
.a suffix using the -l option:

$ cc -g -o prog prog.o -ldemo

3. If the library resides in a directory not normally searched by the linker, we can specify that
the linker should search this additional directory using the -L option:

$ cc -g -o prog prog.o -Lmylibdir -ldemo

Although a static library may contain many object modules, the linker includes 'only' those modules
that the program requires.


{downside-of-static}
1. Duplicates in disk and ram spce.

2. If a change is required perhaps a security or bug fix to an object module in a static library,
  then all executables using that module must be relinked in order to incorporate the change. This
  disadvantage is further compounded by the fact that the system administrator needs to be aware of
  which applications were linked against the library.


{what-is-shared}
Although the code of a shared library is shared among multiple processes, its variables are not.
Each process that uses the library has its own copies of the global and static variables that are
defined within the library.


{further-advantages}
@ Because overall program size is smaller, in some cases, programs can be loaded into memory and
started more quickly. This point holds true only for large shared libraries that are already in use
by another program.

@ Such changes can be carried out even while running programs are using an existing version of the
shared library.


{cost-of-shared}
@ Shared libraries are more complex than static libraries, both at the conceptual level, and at the
practical level of creating shared libraries and building the programs that use them.

@ Shared libraries must be compiled to use position-independent code, which has a performance
overhead on most architectures because it requires the use of an extra register 

@ Symbol relocation must be performed at run time. During symbol relocation, references to each
symbol (a variable or function) in a shared library need to be modified to correspond to the actual
run-time location at which the symbol is placed in virtual memory. Take a little more time to
execute.


{create-shared}
$ gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c
$ gcc -g -shared -o libfoo.so mod1.o mod2.o mod3.o

or 

$ gcc -g -fPIC -Wall mod1.c mod2.c mod3.c -shared -o libfoo.so

Unlike static libraries, it is not possible to add or remove individual object modules from a
previously built shared library. As with normal executables, the object files within a shared
library no longer maintain distinct identities.


{shared-vs-static} <do-not-use-single-line>

$ cat main.c 
#include <stdio.h>

extern void foo(void);

int main(void)
{
  foo();
  return 0;
}

$ cat foo.c 
#include <stdio.h>

void foo(void)
{
  printf("foo: this is foo...\n");
}

$ ls -alR 
drwxr-xr-x 2 kpark kpark 4096 Feb  5 09:34 one
drwxr-xr-x 2 kpark kpark 4096 Feb  5 09:37 two
drwxr-xr-x 2 kpark kpark 4096 Feb  5 09:46 thr

<used-seperated-step> shared library
./one:
-rw-r--r-- 1 kpark kpark   73 Feb  5 09:32 foo.c
-rw-r--r-- 1 kpark kpark 1528 Feb  5 09:33 foo.o
-rwxr-xr-x 1 kpark kpark 6407 Feb  5 09:33 libfoo.so
-rw-r--r-- 1 kpark kpark   82 Feb  5 09:32 main.c
-rwxr-xr-x 1 kpark kpark 7120 Feb  5 09:34 one

note:
-shared
Produce a shared object which can then be linked with other objects to form an executable. Not all
systems support this option. For predictable results, you must also specify the same set of options
used for compilation (-fpic, -fPIC, or model suboptions) when you specify this linker option

$ gcc -c -fpic foo.c 
$ gcc -shared -o libfoo.so foo.o
$ gcc -o one main.c libfoo.so 

$ ./one 
./one: error while loading shared libraries: libfoo.so: cannot open shared object file: No such file
or directory

$ readelf -d one | grep NEEDED
(standard input):4: 0x0000000000000001 (NEEDED)             Shared library: [libfoo.so]
(standard input):5: 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]

$ file libfoo.so 
libfoo.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked,
  BuildID[sha1]=0x7c5aa43368b2a98af48a1558d7e2c5a010d238b0, not stripped

$ readelf -s libfoo.so | grep _OFFSET_TA
(standard input):64:    43: 0000000000200978     0 OBJECT  LOCAL  DEFAULT  ABS _GLOBAL_OFFSET_TABLE_

<used-single-step>
./two:
-rw-r--r-- 1 kpark kpark   73 Feb  5 09:32 foo.c
-rw-r--r-- 1 kpark kpark 1528 Feb  5 09:37 libfoo.so
-rw-r--r-- 1 kpark kpark   82 Feb  5 09:32 main.c
-rwxr-xr-x 1 kpark kpark 6872 Feb  5 09:37 two

$ gcc -c -fpic foo.c -shared -o libfoo.so
$ gcc -o two main.c libfoo.so

$ ./two 
foo: this is foo...

$ readelf -d two | grep NEEDED
(standard input):4: 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]

$ readelf -s libfoo.so | grep _OFFSET_TA
(standard input):14:    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_

$ file libfoo.so 
libfoo.so: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped

<used-static-build>
./thr:
-rw-r--r-- 1 kpark kpark   73 Feb  5 09:45 foo.c
-rw-r--r-- 1 kpark kpark 1480 Feb  5 09:46 foo.o
-rw-r--r-- 1 kpark kpark   82 Feb  5 09:45 main.c
-rwxr-xr-x 1 kpark kpark 6872 Feb  5 09:46 thr

$ gcc -c foo.c -o foo.o 
$ gcc -o thr main.c foo.o 

$ ./thr 
foo: this is foo...

$ file foo.o 
foo.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped

$ readelf -s foo.o | grep _OFFSET_TA
$ readelf -d thr | grep NEEDED
(standard input):4: 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]


{position-independent-code}
These changes allow the code to be located at any virtual address at run time. This is necessary for
shared libraries, since there is no way of knowing at link time where the shared library code will
be located in memory.

In order to determine whether an existing object file has been compiled with the -fPIC option, we
can check for the presence of the name _GLOBAL_OFFSET_TABLE_ in the object file's symbol table,
    using either of the following commands:

$ nm mod1.o | grep _GLOBAL_OFFSET_TABLE_
$ readelf -s mod1.o | grep _GLOBAL_OFFSET_TABLE_

note: as shown above, this not necessarily means 'shared' object. It's only tell -fPIC used.

<pic-vs-relocatable>
This is talking about position independent code, which is 'not' the same as relocatable code.
Relocatable code is code whose address may be assigned at link time. Position independent code is
code whose address may be assigned at run time.

'all' object files are relocatable. For most targets, only object files compiled with -fpic or -fPIC
or -pie are position independent.

For more about relocatable code: http://www.airs.com/blog/archives/41


{dynamic-linker}
note: From GCC doc, the dynamic loader is not part of GCC; it is part of the operating system.

Two steps must occur that are not required for programs that use static libraries:

$ gcc -c -fpic foo.c 
$ gcc -shared -o libfoo.so foo.o
$ gcc -o one main.c libfoo.so          <embedding-the-name-of-lib>

1. At 'linktime'. Since the executable file 'no' longer contains copies of the object files that it
requires, must have some mechanism for identifying the shared library that it needs at run time.
This is done by 'embedding' the name of the shared library inside the executable during the link
phase. DT_NEEDED tag in ELF.

$ readelf -d one | grep NEED
 0x00000001 (NEEDED)                     Shared library: [libfoo.so]
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]

2. At 'runtime', there must be some mechanism for 'resolving' the embedded library name-that is, for
finding the shared library file corresponding to the name specified in the executable file-and then
loading the library into memory, if it is not already present.

<dynamic-linking>
The dynamic linking, which is the task of resolving the embedded library name at run time. This task
is performed by the dynamic linker (also called the dynamic linking loader or the run-time linker).
The dynamic linker is 'itself' a 'shared' library, named /lib/ld-linux.so.2, which is employed by
every ELF executable that uses shared libraries.

$ ls -l /lib/ld-linux.so.2 
lrwxrwxrwx 1 root root 25 Oct 17 00:50 /lib/ld-linux.so.2 -> i386-linux-gnu/ld-2.13.so

note:
Every program-including those that use shared libraries-goes through a static-linking phase. At run
time, a program that employs shared libraries additionally undergoes dynamic linking.


{ld-library-path}
Some of these rules specify a set of 'standard' directories in which shared libraries normally
reside. To inform the dynamic linker that a shared library resides in a nonstandard directory

If LD_LIBRARY_PATH is defined, then the dynamic linker searches for the shared library in the
directories it lists before looking in the standard library directories.

note: Creates an environment variable definition 'within' the process executing prog. Since if you
don't export the changes to an environment variable, they won't be inherited by the child processes.
The loader and our test program didn't inherit the changes we made.

$ LD_LIBRARY_PATH=. ./one 
foo: this is foo...

$ ./one 
./one: error while loading shared libraries: libfoo.so: cannot open shared object file: No such file
or directory

$ export LD_LIBRARY_PATH=.
$ ./one 
foo: this is foo...


{soname-and-realname}
In the above example, libfoo is realname. As with a realname, soname is used in linking and is
embedded in the executable, and used by the linker at runtime.

Why soname? The purpose of the soname is to provide a level of 'indirection' that permits an
executable to use, at run time, a version of the shared library that is different from (but
    compatible with) the library against which it was linked.

$ gcc -c -fpic foo.c
$ gcc -shared -Wl,-soname,libbar.so -o libfoo.so foo.o      note: shall no space between -soname
$ readelf -d libfoo.so | grep SONAME
(standard input):5: 0x000000000000000e (SONAME)             Library soname: [libbar.so]
$ gcc -o one main.c libfoo.so

$ ./one 
./one: error while loading shared libraries: libbar.so: cannot open shared object file: No such file
or directory

$ LD_LIBRARY_PATH=. ./one
./one: error while loading shared libraries: libbar.so: cannot open shared object file: No such file
or directory

note: ld looks for libbar but not libfoo

When using a soname, one further step is required: we must create a symbolic link from the soname to
the real name of the library. This symbolic link must be created in one of the directories searched
by the dynamic linker. Thus, we could run our program as follows:

$ ln -s libfoo.so libbar.so 
$ ll
lrwxrwxrwx 1 kpark kpark    9 Feb  5 11:22 libbar.so -> libfoo.so*
$ ./one 
foo: this is foo...


{versioning}
<requirement>
The same calling interface and are semantically equivalent (they achieve identical results). Such
differing but compatible versions are referred to as 'minor' versions of a shared library.

Occasionally, however, it is necessary to create a new 'major' version of a library-one that is
incompatible with a previous version. At the same time, it must still be possible to continue
running programs that require the older version of the library.

<realname>
libdemo.so.1.0.1
libdemo.so.1.0.2        Minor version, compatible with version 1.0.1
libdemo.so.2.0.0        New major version, incompatible with version 1.*

<soname> minor-independent link
The soname of the shared library includes the same 'major' version identifier as its corresponding
real library name, but excludes the minor version identifier. Thus, the soname has the form
libname.so.major-id.

Usually, the soname is created as a relative symbolic link in the directory that contains the real
name. The following are some examples of sonames, along with the real names to which they might be
symbolically linked:

libdemo.so.1   -> libdemo.so.1.0.2
libdemo.so.2   -> libdemo.so.2.0.0

Normally, the soname corresponding to each major library version points to the most recent 'minor'
version within the major version. This setup allows for the correct versioning semantics during the
run-time operation of shared libraries. 

Because the static-linking phase embeds a copy of the soname in the executable which has major, and
the soname symbolic link may subsequently be modified to point to a newer (minor) version of the
shared library, it is possible to ensure that an executable loads the most up-to-date minor version
of the library at run time.

Furthermore, since different major versions of a library have different sonames, they can happily
coexist and be accessed by the programs that require them.

note: Due to this indirection, possible to meet versioning requirement by changing a sym link.

<linkername> version-independent link
The linker name, which is used when linking an executable against the shared library. The linker
name is a symbolic link containing just the library name and thus has the form libname.so. The
linker name allows us to construct version-independent link commands that automatically operate with
the correct version of the shared library.

libdemo.so ->  libdemo.so.2


real name          <-   soname                <-   linker name         
lib name.so.2.0.0       libname.so.2               lib name.so
(regular file)          (symbolic link)            (symbolic link)
Object code for         lib name.so.maj.min        libname.so.maj
library modules


$ gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c

# created a realname and soname
$ gcc -g -shared -Wl,-soname,libdemo.so.1 -o libdemo.so.1.0.1 mod1.o mod2.o mod3.o

$ ln -s libdemo.so.1.0.1 libdemo.so.1
$ ln -s libdemo.so.1 libdemo.so

$ ls -l libdemo.so* | awk '{print $1, $9, $10, $11}'
lrwxrwxrwx libdemo.so -> libdemo.so.1
lrwxrwxrwx libdemo.so.1 -> libdemo.so.1.0.1
-rwxr-xr-x libdemo.so.1.0.1

# use linkername when link
$ gcc -g -Wall -o prog prog.c -L. -ldemo

$ LD_LIBRARY_PATH=. ./prog
Called mod1-x1
Called mod2-x2

note: this linkername is only for admin purpose since the executable only have soname in it even if
uesed -l during the link.


={============================================================================
*kt_linux_core_107* shared library: ld --as-needed problem

--as-needed 
--no-as-needed

This option affects ELF DT_NEEDED tags for dynamic libraries mentioned on the command line 'after'
the --as-needed option. Normally the linker will add a DT_NEEDED tag for each dynamic library
mentioned on the command line, 'regardless' of whether the library is actually needed or not.
--as-needed causes a DT_NEEDED tag to 'only' be emitted for a library that at that point in the link
satisfies a non-weak undefined symbol reference from a regular object file or, if the library is not
found in the DT_NEEDED lists of other needed libraries, a non-weak undefined symbol reference from
another needed dynamic library. Object files or libraries appearing on the command line after the
library in question do not affect whether the library is seen as needed. This is similar to the
rules for extraction of object files from archives. --no-as-needed restores the 'default' behaviour. 

<example>
$ gcc -c -fpic foo.c 
$ gcc -shared -o libfoo.so foo.o
$ gcc -o one main.c libfoo.so          <embedding-the-name-of-lib>

or 

$ gcc -L. -lfoo -o one main.c

However, when tried:

$ gcc -Wl,--as-needed -L. -lfoo -o one main.c
/tmp/ccUshwwe.o: In function `main':
main.c:(.text+0x7): undefined reference to `foo'
collect2: error: ld returned 1 exit status

The followings are okay.

$ gcc -L. -lfoo -Wl,--as-needed -o one main.c
$ gcc -Wl,--as-needed -o one main.c libfoo.so


note: Seen this which is a bit different from 'default' option but showed the point.
http://stackoverflow.com/questions/8140494/why-am-i-getting-a-gcc-undefined-reference-error-trying-to-create-shared-objec

TODO
http://wiki.gentoo.org/wiki/Project:Quality_Assurance/As-needed#What_is_--as-needed.3F


={============================================================================
*kt_linux_core_107* shared library: search and resove

{search-rules}

note: >
LD_LIBRARY_PATH is broken and should 'not' be used if at all possible since LD_LIBRARY_PATH is great
for quick tests and for systems on which you don't have admin privileges. However, as a downside,
    exporting the LD_LIBRARY_PATH variable means it may cause problems with other programs if you
    don't reset it to its previous state when you're done.


The dynamic linker searches for the shared library using the following rules:

1. If the executable has any directories listed in its DT_RPATH run-time library path list (rpath)
  and the executable does not contain a DT_RUNPATH list, then these directories are searched (in
      the order that they were supplied when linking the program).

2. If the LD_LIBRARY_PATH environment variable is defined, then each of the colon-separated
directories listed in its value is searched in turn. 

<security>
If the executable is a set-user-ID or set-group-ID program, then LD_LIBRARY_PATH is ignored. This is
a security measure to prevent users from tricking the dynamic linker into loading a private version
of a library with the same name as a library required by the executable.

3. If the executable has any directories listed in its DT_RUNPATH run-time library path list, then
these directories are searched (in the order that they were supplied when linking the program).

4. The file /etc/ld.so.cache is checked to see if it contains an entry for the library.

5. The directories /lib and /usr/lib are searched (in that order).

<rpath>
There is a third way: during the static editing phase, we can insert into the exe- cutable a list of
directories that should be searched at run time for shared libraries.  This is useful if we have
libraries that reside in fixed locations that are not among the standard locations searched by the
dynamic linker. To do this, we employ the -rpath linker option when creating an executable:

$ gcc -g -Wall -Wl,-rpath,/home/mtk/pdir -o prog prog.c libdemo.so

note: From ld linker docs:

2. Any directories specified by -rpath options. The difference between -rpath and -rpath-link is
that directories specified by -rpath options are included in the executable and used at runtime,
     whereas the -rpath-link option is only effective at link time. Searching -rpath in this way is
     only supported by native linkers and cross linkers which have been configured with the
     --with-sysroot option.


{runtime-resolution}
Suppose that a global symbol (i.e., a 'function' or variable) is defined in multiple locations, such
as in an executable and in a shared library, or in 'multiple' shared libraries. How is a reference
to that symbol resolved?

         prog                                   libfoo.so
-----------------------------          -----------------------------
xyz() {                                xyz() {               
  printf("main-xyz\n");                  printf("foo-xyz\n");
}                                      }
                                       
main() {                               func() {
  func();    -->                         xyz();                
}                                      }       

$ gcc -g -c -fPIC -Wall -c foo.c
$ gcc -g -shared -o libfoo.so foo.o
$ gcc -g -o prog prog.c libfoo.so
$ LD_LIBRARY_PATH=. ./prog
main-xyz

See that the definition of xyz() in the main program overrides the one in the shared library.

The following semantics apply:

@ A definition of a global symbol in the 'main' program 'overrides' a definition in a library.

@ If a global symbol is defined in multiple libraries, then a reference to that symbol is bound to
the 'first' definition found by scanning libraries in the left-to-right 'order' in which they were
listed on the static 'link' command line.

<problem>
Although these semantics make the transition from static to shared libraries relatively
straightforward, they can cause some problems. The most significant problem is that these semantics
conflict with the model of a shared library as implementing a 'self'-contained subsystem. 

By default, a shared library can 'not' guarantee that a reference to one of its own global symbols
will actually be bound to the library's definition of that symbol.

<case-example>
03/07/2014. At samsung. 
When moves application which was a process and uses static link to the shared library application to
be used by other processes. The codes which works well before starts to fail since crash happens
when try to create a thread using custom thread library. 

Problem of linking? Problem of the thread library when used in shared library application? Somehow
linker picks up the wrong libaray since a debugger shows odd address when thread creation call is
made and causes a crash? 

Tried various directions and spent many days. Eventually, found out that PCThread::Create() is a
problem and works fine when changes parameter orders. The problem was that the process loads a lot
of shared library and one of those has the same PCThread class in it but different signature. When
our library make a call, it picks it up from the other shared library in which has different
signature so crashes. Sovled when wraps PCThread class with a namespace.

note: So this was a problem of symbols between shared libraries.

<Q> so when say 'symbol' in runtime resolution, does it mean 'name' only or the whole signature?

# foo.c

#include <stdio.h>

void foo()           <1>
void foo(int x)      <2>
{
  printf("foo: this is foo... %d \n", x );
}

# main.c

#include <stdio.h>

// extern void foo(void);
void foo()
{
  printf("main: this is foo...\n");
}

int main(void)
{
  foo();       <1>
  foo(5);      <2>
  return 0;
}

$ gcc -c -fpic foo.c
$ gcc -shared -o libfoo.so foo.o
$ gcc -o prog main.c libfoo.so 
$ LD_LIBRARY_PATH=. ./prog
main: this is foo...
$ gcc -c -fpic foo.c
$ gcc -shared -o libfoo.so foo.o
$ gcc -o prog main.c libfoo.so 
$ LD_LIBRARY_PATH=. ./prog
main: this is foo...
$ 

note: Unlike the case-example, this is a problem between main and shared library.

<Q> So always picks up the main version and suggest that only use 'name' in C. Given the real-case
above, C++ may be different?

<Q> If multiple shared library are used in a process, all constitute a single lookup space?

<solution> to the case-example

1. As the case-example, can use namespace which effectively make a different symbol.

2. As shown here, can use linker option, -Bsymbolic to ensure that the invocation of the same symbol
in the shared library actually called the version of the function defined 'within' the library.

$ gcc -g -shared -Wl,-Bsymbolic -o libfoo.so foo.o

note: this means that main version gets called for the above example but would solve the
case-example since it force to pick up the one in the same library.


={============================================================================
*kt_linux_core_107* shared library: dl and ABI

When an executable starts, the dynamic linker loads 'all' of the shared libraries in the program's
dynamic dependency list. Sometimes, however, it can be useful to load libraries at a later time. For
example, a plug-in is loaded only when it is needed. This functionality is provided by an API to the
dynamic linker.

{symbol-name} from LPI 42.1
The dlsym() function searches a library for a symbol (a string containing the 'name' of a function
    or variable) and returns its address.

{link-option}
To build programs that use the dlopen API on Linux, we must specify the -ldl option, in order to
link against the libdl library.


{access-symbols-in-main}
Sometimes, it is desirable instead to have x() in shared library invoke an implementation of y() in
the main program. In order to do this, we must make the (global-scope) symbols in the main program
available to the dynamic linker, by linking the program using the --export-dynamic linker option:

$ gcc -Wl,--export-dynamic main.c (plus further options and arguments)

Equivalently, we can write the following:

$ gcc -export-dynamic main.c

Using either of these options allows a dynamically loaded library to access global symbols in the
main program.


{visibility}
A well-designed shared library should make visible only those symbols (functions and variables) that
form part of its specified application binary interface (ABI). The reasons for this are as follows:

@ If the shared library designer accidentally exports unspecified interfaces, then authors of
applications that use the library may choose to employ these interfaces. This creates a
'compatibility' problem for future upgrades of the shared library.

The library developer expects to be able to change or remove any interfaces 'other' than those in
the documented ABI, while the library user expects to continue using the same interfaces (with the
    same semantics) that they currently employ.

@ During run-time symbol resolution, any symbols that are exported by a shared library might
interpose definitions that are provided in other shared libraries.

note: needs more about problems in other shared libraries.

@ Exporting unnecessary symbols increases the size of the dynamic symbol table that must be loaded
at run time.

All of these problems can be minimized or avoided altogether if the library designer ensures that
only the symbols required by the library's specified ABI are exported. 

The following techniques can be used to control the export of symbols:

@ In a C program, we can use the static keyword to make a symbol private to a source-code module,
  thus rendering it unavailable for binding by other object files.

note:
As well as making a symbol private to a source-code module, the static keyword also has a converse
effect. If a symbol is marked as static, then all references to the symbol in the same source file
will be bound to that definition of the symbol. Consequently, these references won't be subject to
run-time interposition by definitions from other shared libraries in the manner described in Section
41.12. This effect of the static keyword is similar to the -Bsymbolic linker option described in
Section 41.12, with the difference that the static keyword affects a 'single' symbol within a single
source file.

@ The GNU C complier, gcc, provides a compiler-specific attribute declaration that performs a
similar task to the static keyword:

void __attribute__ ((visibility("hidden")))
func(void) {
   /* Code */
}

note: see *kt_dev_gcc_110* gcc: attributes

Whereas the static keyword limits the visibility of a symbol to a single source code file, the
hidden attribute makes the symbol available across all source code files that compose the shared
library, but prevents it from being visible outside the library.

As with the static keyword, the hidden attribute also has the converse effect of preventing symbol
interposition at run time.

note: there are more ways in LPI 42.3.


={============================================================================
*kt_linux_core_107* shared library: preload and monitor ld

{ld-preload}
For testing purposes, it can sometimes be useful to 'selectively' override functions and other symbols
that would normally be found by the dynamic linker using the search rules. 

To do this, we can define the environment variable LD_PRELOAD as a string consisting of
space-separated or colon-separated names of shared libraries that should be loaded 'before' any
other shared libraries. 

Since these libraries are loaded first, any functions they define will automatically be used if
required by the executable, thus overriding any other functions of the same 'name' that the dynamic
linker would otherwise have searched for.

$ ./prog
Called mod1-x1 DEMO
Called mod2-x2 DEMO

$ LD_PRELOAD=libalt.so ./prog
Called mod1-x1 ALT                  # x1 in libalt.so and changed this only, selectively.
Called mod2-x2 DEMO

<process-and-system-wide>
The LD_PRELOAD environment variable controls preloading on a per-process basis. Alternatively, the
file /etc/ld.so.preload, which lists libraries separated by white space, can be used to perform the
same task on a system-wide basis. Libraries specified by LD_PRELOAD are loaded before those
specified in /etc/ld.so.preload. 

<security>
For security reasons, set-user-ID and set-group-ID programs ignore LD_PRELOAD.


{ld-debug}
Sometimes, it is useful to monitor the operation of the dynamic linker in order to know, for
example, where it is searching for libraries. We can use the LD_DEBUG environment variable to do
this. By setting this variable to one (or more) of a set of standard keywords, we can obtain various
kinds of tracing information from the dynamic linker.

If we assign the value help to LD_DEBUG, the dynamic linker displays help information about
LD_DEBUG, and the specified command is not executed:

note: can be any command other 
$ LD_DEBUG=help ls  
Valid options for the LD_DEBUG environment variable are:

  libs        display library search paths
  reloc       display relocation processing
  files       display progress for input file
  symbols     display symbol table processing
  bindings    display information about symbol binding
  versions    display version dependencies
  all         all previous options combined
  statistics  display relocation statistics
  unused      determined unused DSOs
  help        display this help message and exit

To direct the debugging output into a file instead of standard output
a filename can be specified using the LD_DEBUG_OUTPUT environment variable.


$ LD_DEBUG=libs ls
     20177:	find library=libselinux.so.1 [0]; searching
     20177:	 search path=./tls/x86_64:./tls:./x86_64:.		(LD_LIBRARY_PATH)
     20177:	  trying file=./tls/x86_64/libselinux.so.1
     20177:	  trying file=./tls/libselinux.so.1
     20177:	  trying file=./x86_64/libselinux.so.1
     20177:	  trying file=./libselinux.so.1
     20177:	 search cache=/etc/ld.so.cache
     20177:	  trying file=/lib/x86_64-linux-gnu/libselinux.so.1
     20177:	
     20177:	find library=librt.so.1 [0]; searching
     20177:	 search path=./tls/x86_64:./tls:./x86_64:.		(LD_LIBRARY_PATH)
     20177:	  trying file=./tls/x86_64/librt.so.1
     20177:	  trying file=./tls/librt.so.1
     20177:	  trying file=./x86_64/librt.so.1
     20177:	  trying file=./librt.so.1
     ...
     20177:	
install-sh  ltmain.sh  Makefile.am  Makefile.in  missing  src $ 

note: ls command was executed.

The PID value displayed at the start of each line and this is useful if we are monitoring several
processes (e.g., parent and child).

If desired, we can assign multiple options to LD_DEBUG by separating them with commas (no spaces
    should appear). 

<symbol-option>
The output of the symbols option (which traces symbol resolution by the dynamic linker) is
particularly voluminous.

LD_DEBUG is effective both for libraries implicitly loaded by the dynamic linker and for libraries
dynamically loaded by dlopen().

For security reasons, LD_DEBUG is (since glibc 2.2.5) ignored in set-user-ID and set- group-ID
programs.


={============================================================================
*kt_linux_core_107* shared library: further information

Further information

Various information related to static and shared libraries can be found in the ar(1), gcc(1), ld(1),
ldconfig(8), ld.so(8), dlopen(3), and objdump(1) manual pages and in the info documentation for ld
  and readelf. [Drepper, 2004 (b)] covers many of the finer details of writing shared libraries on
  Linux. Further useful information can also be found in David Wheeler's Program Library HOWTO,
which is online at the LDP web site, http://www.tldp.org/. 

The GNU shared library scheme has many similarities to that implemented in Solaris, and therefore it
is worth reading Sun¿s Linker and Libraries Guide (available at http://docs.sun.com/) for further
information and examples. [Levine, 2000] provides an introduction to the operation of static and
dynamic linkers.

Information about GNU Libtool, a tool that shields the programmer from the implementation-specific
details of building shared libraries, can be found online at http://www.gnu.org/software/libtool and
in [Vaughan et al., 2000].

The document Executable and Linking Format, from the Tools Interface Standards committee, provides
details on ELF. This document can be found online at http://refspecs.freestandards.org/elf/elf.pdf.
[Lu, 1995] also provides a lot of useful detail on ELF.


={============================================================================
*kt_linux_core_107* shared library: sandbox

There are occasional situations where static libraries may be appropriate. If the program is to be
run in an environment (perhaps a chroot jail, for example) where shared libraries are unavailable.


={============================================================================
*kt_linux_core_107* shared library: md5sum

{can-use-on-library-to-check-integrity}
The idea is that can use md5sum on a library to confirm that it uses the exact same compile and link
options. The assumption is that if both party has the same build configuration, the library made
from the same source 'must' have the same md5 checksum. If that is the case, can use the md5
checksum as a quick way to check if both party has and uses the same build configuration.

Is it true?

https://gcc.gnu.org/ml/gcc-help/2010-01/msg00082.html
beaugy.a@free.fr wrote:

    Hi all,
    So, to put it in a nutshell, all my generated objects file are
    identical on dev1 and dev2 and object files contained in my
    convenience libraries are all identical. The only difference
    remaining, before I generate my binary, resides in the generated
    convenience libraries which are not identical, but their contents
    are. So AFAK, this slight difference shall not make the difference. So
    "why does gcc output (MD5 checksum) differs when I build a binary
    using the project object files (*.o) or the project convenience
    libraries (*.a)?" and "what can I do to fix that?".

Your *.o files are proceeded in a different order when on the command line and on the .a archive,
     putting symbols on different addresses, so obviously different binaries are produced.

Even if you do:
gcc 1.o 2.o
And:
gcc 2.o 1.o

you get binaries with different md5.

<example>
This is example from "*kt_dev_gcc_103* gcc link and ld"

$ cat simplefunc.c
int func(int i) {
    return i + 21;
}

$ cat simplemain.c
int func(int);

int main(int argc, const char* argv[])
{
    return func(argc);
}

$ gcc -c simplefunc.c
$ gcc -c simplemain.c
$ gcc simplefunc.o simplemain.o
$ ./a.out ; echo $?
22

:~/work$ nm simplefunc.o
00000000 T func

:~/work$ nm simplemain.o 
         U func
00000000 T main

$ ar r libsimplefunc.a simplefunc.o    // ar rs to skip ranlib command.
$ ranlib libsimplefunc.a
$ gcc simplemain.o -L. -lsimplefunc
$ ./a.out ; echo $?
22

Now we have *.o and *.a files and run the same build and ar command without changes in source. Just
make o and a files.

<o-files-are-the-same>
keitee@debian-keitee:~/work$ ll simplefunc.*
-rw-r--r-- 1 keitee keitee 848 Jan 20 22:15 simplefunc.o
-rw-r--r-- 1 keitee keitee 848 Jan 20 22:06 simplefunc.o.old
keitee@debian-keitee:~/work$ diff simplefunc.o simplefunc.o.old 
keitee@debian-keitee:~/work$ 

<a-files-are-different>
keitee@debian-keitee:~/work$ ll libsimplefunc.a*
-rw-r--r-- 1 keitee keitee 990 Jan 20 22:14 libsimplefunc.a
-rw-r--r-- 1 keitee keitee 990 Jan 20 22:14 libsimplefunc.a.old
keitee@debian-keitee:~/work$ diff libsimplefunc.a libsimplefunc.a.old 
Binary files libsimplefunc.a and libsimplefunc.a.old differ
keitee@debian-keitee:~/work$ 

The md5 checksum result shows the same.

keitee@debian-keitee:~/work$ md5sum simplefunc.o*
3acb728c611c4c936320d64c1b360633  simplefunc.o
3acb728c611c4c936320d64c1b360633  simplefunc.o.old

keitee@debian-keitee:~/work$ md5sum libsimplefunc.a*
87663beba78feef15106bf156a8f6ef3  libsimplefunc.a
02a369c6a4476eea407bec53beaa7b95  libsimplefunc.a.old

So even when make a library from the same object at 'different' time, it will create different
library file.

<Q> However, when do the md5sum on library files created from project build at different time, the
libraries are the same on diff and md5. WHY?

Tried to make a shared library with the same code:

gcc -fpic -shared -o simple.so simplefunc.c
ar rs libsimple.so simple.so

Again, simple.so files are the same but libsimple.so are differ. This means that when run ar, will
have different output files. Then how were the libraries the same for the above case?

<A> The answer is that do not use ar when make a shared library and then will the same md5sum.

-rw-r--r-- 1 kpark kpark 1528 Feb  5 10:02 foo.o
-rw-r--r-- 1 kpark kpark 1528 Feb  5 09:33 foo.o.old
-rwxr-xr-x 1 kpark kpark 6407 Feb  5 10:03 libfoo.so*
-rwxr-xr-x 1 kpark kpark 6407 Feb  5 09:33 libfoo.so.old*

$ diff foo.o foo.o.old 
$ diff libfoo.so libfoo.so.old 
$ md5sum foo.o*
1f87ad103b677a3090707fee9daaea33  foo.o
1f87ad103b677a3090707fee9daaea33  foo.o.old

$ md5sum libfoo.so*
e64fd5c673979f09360178f938e6e1b7  libfoo.so
e64fd5c673979f09360178f938e6e1b7  libfoo.so.old


={============================================================================
*kt_linux_core_107* shared library: md5sum

int ioctl(int fd, int request == VIDEO_DECODER_GET_CAP_EX_VERSION, uint32_t *version);

#define VIDEO_DECODER_CAP_V0     (0x00000001)
#define VIDEO_DECODER_CAP_V1     (0x00000002)
#define VIDEO_DECODER_CAP_V2     (0x00000004)
#define VIDEO_DECODER_CAP_V3     (0x00000008)

typedef struct {
  ...
} VideoDecoderCapsV2;

typedef struct {
  ...
} VideoDecoderCapsV3;

typedef struct {
   uint32_t    version;
   void        *capability;
   uint32_t    capabilitySize;
} VideoDecoderCapEx;

int ioctl(int fd, int request == VIDEO_DECODER_GET_CAP_EX, VideoDecoderCapEx *arg);


{
  uint32_t                video_dec_caps_version;
  VideoDecoderCapsEx      video_decoder_caps;
  VideoDecoderCapsV0      caps_v0 = {0U, 0U, 0U, 0U, 0U, 0U, 0U};
  VideoDecoderCapsV1      caps_v1 = {0U, 0U, 0U, 0U, 0U, 0U, 0U};
  VideoDecoderCapsV2      caps_v2 = {0U, 0U, 0U, 0U, 0U, 0U, 0U};

  if (ioctl(fd, VIDEO_DECODER_GET_CAPS_EX_VERSIONS, &video_dec_caps_version) == 0)
  {
    if (video_dec_caps_version & VIDEO_DECODER_CAP_V2)
    {
      video_decoder_caps.version = VIDEO_DECODER_CAP_V2;
      video_decoder_caps.capability = &caps_v2;
      video_decoder_caps.capabilitySize = sizeof(caps_v2);

      if (ioctl( fd, VIDEO_DECODER_GET_CAPS_EX, &video_decoder_caps) == 0)
      {
        *(uint32_t *)data = caps_v2.decodingModes;
      }
      else
      {
        *(uint32_t *)data = VIDEO_DECODER_SKIP_NONE;
      }
    }
    else (video_dec_caps_version & VIDEO_DECODER_CAP_V1)
    {
      video_decoder_caps.version = VIDEO_DECODER_CAP_V1;
      video_decoder_caps.capability = &caps_v1;
      video_decoder_caps.capabilitySize = sizeof(caps_v1);

      if (ioctl( fd, VIDEO_DECODER_GET_CAPS_EX, &video_decoder_caps) == 0)
      {
        *(uint32_t *)data = caps_v1.decodingModes;
      }
      else
      {
        *(uint32_t *)data = VIDEO_DECODER_SKIP_NONE;
      }
    }
  }
}


-------------------------------------------------------------------------------
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:

