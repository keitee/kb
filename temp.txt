*kt_linux*                                                           tw=100

/^[#=]{ 

aWed 18 Dec 2013 09:47:23 GMT

KT KB. Linux

={============================================================================
*kt_linux_core_107* 

// called from static gboolean gst_nexus_sink_open_locked( GstNexusSink * sink)
// means each sink has Mgr*?
//
GstNexusMgr * gst_nexus_mgr_new ()
{
	gmgr = g_slice_new (GstNexusMgr);

   // note: this is uses in sink_init as well?
	gst_context_init_stream_setting(&gmgr->settings);
   {
       // note: <null>
       settings->callbacks.error=NULL;
       settings->callbacks.context=NULL;
   }

	memset(&gmgr->callback_contexts, 0, sizeof(gmgr->callback_contexts));
}

// sink calls this to access "resource"
//
BcmNexus_StreamPlayer_Resources* 
gst_nexus_mgr_get_resources(GstNexusMgr * mgr, const GstNexusStreamSetting * settings)
{
  if(gst_nexus_mgr_acquire_playpumps(mgr, settings)){
	return mgr->resources;
  }
  return NULL;
}

// this is called two times for each sink
gst_nexus_mgr_acquire_playpumps(GstNexusMgr * mgr, 
								const GstNexusStreamSetting * settings)
{
    // only use video for "delegate_callback" <null>
    mgr->callback_contexts.video_error.delegate_callback = mgr->settings.callbacks.error;
    mgr->callback_contexts.video_error.delegate_context = mgr->settings.callbacks.context;

    // use video and audio context
    video_decoder_settings.decodeError.callback = &gst_nexus_mgr_error_1st_level_cb;
    video_decoder_settings.decodeError.context = &mgr->callback_contexts.video_error;

    audio_decoder_settings.ptsError.callback = &gst_nexus_mgr_error_1st_level_cb;
    audio_decoder_settings.ptsError.context = &mgr->callback_contexts.audio_error;
}


// use registered "delegate_callback" if it is not null
//
static void gst_nexus_mgr_error_1st_level_cb(void* context, int reason)
{
  GstNexusMgrCallbackInfo* cb = context;
  if (cb->delegate_callback) {
    cb->delegate_callback(cb->delegate_context, reason);
  }
  else{
    const char* error_type = cb->callback_id == CB_VIDEO_ERROR
        ? "VideoError" : "AudioError";
    GST_WARNING("=> KT: VAudioError: %s: 0x%04x", error_type, reason);
  }
}


// no one calls this???
//
static void gst_nexus_sink_init( GstNexusSink * sink )
{
  sink->settings.callbacks.error = gst_nexus_sink_on_error;
}


={============================================================================
*kt_linux_core_107* 

see template and bind example

template<typename T>
void MetadataObserver::notify(std::vector<boost::weak_ptr<T> >& collection, boost::function<void (T*)> method)
{
    cleanupDeadPointers<T>(collection);

    BOOST_FOREACH(boost::weak_ptr<T> weak, collection)
    {
        boost::shared_ptr<T> strong = weak.lock();

        if(strong)
        {
            method(strong.get());
        }
    }
}

void MetadataObserver::notifyServicesChanged(const vector<string>& changedServiceLocators)
{
    notify<SystemClientEventRepository>(clientEventRepos, boost::bind(&SystemClientEventRepository::ServicesChanged, _1, changedServiceLocators));
}


={============================================================================
*kt_linux_core_107* 

see how iter declared in a function

const string extractValueFromMap(const map<string,string>& m, const string& key)
{
    map<string,string>::const_iterator iter;
    if((iter = m.find(key)) != m.end())
    {
        return iter->second;
    }
    return string();
}


={============================================================================
*kt_linux_core_107* 


int main(int argc, char *argv[])
{
    YVWindow window;
}

class YVWindow : public QWidget
{
private:
    void init();

    boost::scoped_ptr<QSocketNotifier> snTerm;
    boost::scoped_ptr<QSocketNotifier> snInt;
};

YVWindow::YVWindow(QWidget *parent)
    : QWidget(parent),
      fullScreenWidth(1280),
      fullScreenHeight(720)
{
    init();
}

void YVWindow::init()
{
    struct sigaction sInt, sTerm;
    sTerm.sa_handler = posixSignalHandler;
    sInt.sa_handler = posixSignalHandler;
    sigaction(SIGTERM, &sTerm, 0);
    sigaction(SIGINT, &sInt, 0);
    sigset_t signalSet;
    sigfillset(&signalSet);
    sigdelset(&signalSet, SIGTERM);
    sigdelset(&signalSet, SIGINT);
    pthread_sigmask(SIG_SETMASK, &signalSet, NULL);

    snTerm.reset(new QSocketNotifier(sigtermFd[1], QSocketNotifier::Read, this));
    connect(snTerm.get(), SIGNAL(activated(int)), this, SLOT(handleSigTerm()));

    snInt.reset(new QSocketNotifier(sigintFd[1], QSocketNotifier::Read, this));
    connect(snInt.get(), SIGNAL(activated(int)), this, SLOT(handleSigInt()));
}

void YVWindow::posixSignalHandler(int signo)
{
    if (signo == SIGTERM)
    {
        char a = SOCKET_SIGTERM_CODE;
        ::write(sigtermFd[0], &a, sizeof(a));
    }
    else if (signo == SIGINT)
    {
        char a = SOCKET_SIGINT_CODE;
        ::write(sigintFd[0], &a, sizeof(a));
    }
}

void YVWindow::handleSigTerm()
{
    VANADIUM_INFO("Handling SIGTERM");
    snTerm->setEnabled(false);
    char tmp;
    ::read(sigtermFd[1], &tmp, sizeof(tmp));

    if( tmp != SOCKET_SIGTERM_CODE ){
        std::cerr << "WARNING: Unexpected value received from sigTerm socket." << std::endl;
    }

    QApplication::instance()->quit();
}

void YVWindow::handleSigInt()
{
    VANADIUM_INFO("Handling SIGINT");
    snInt->setEnabled(false);
    char tmp;
    ::read(sigintFd[1], &tmp, sizeof(tmp));

    if( tmp != SOCKET_SIGINT_CODE ){
        std::cerr << "WARNING: Unexpected value received from sigTerm socket." << std::endl;
    }

    QApplication::instance()->quit();
}

Q:

Lukasz Forynski

Lukasz Forynski created a pull request2 days ago

Build with c++0x flags with mipsel-linux-gcc 4.4 reported following error:
"narrowing conversion of '({...})' from 'unsigned int' to 'in_port_t' inside { }"
for code where sockaddr_in structure was initialised in a C-style.

This syntax is not type-safe, and in C++0x yields an 'initialisation list',
for which all the items are required to be of the same type.
This with this simple fix fields of the sockaddr_in are assigned explicitly.

-   sockaddr_in addr = { AF_INET,htons(server.getPort()),{htonl(INADDR_LOOPBACK)} };

    sockaddr_in addr     = {0};
    addr.sin_family      = AF_INET;
    addr.sin_port        = htons(server.getPort());
    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);


#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>

typedef struct {
  int a;
  int b;
  int arr[2];
} NODE;

int main()
{

  // -Wextra
  // sample.c:11:3: warning: missing initializer [-Wmissing-field-initializers]
  // sample.c:11:3: warning: (near initialization for 'node.arr') [-Wmissing-field-initializers]
  // NODE node = {0,0};
  //


  // uint16_t htons(uint16_t hostshort);
  // uint32_t ntohl(uint32_t netlong);
  
// /* Structure describing an Internet (IP) socket address. */
// #define __SOCK_SIZE__	16		/* sizeof(struct sockaddr)	*/
// struct sockaddr_in {
//   __kernel_sa_family_t	sin_family;	/* Address family		*/
//   __be16		sin_port;	/* Port number			*/
//   struct in_addr	sin_addr;	/* Internet address		*/
// 
//   /* Pad to size of `struct sockaddr'. */
//   unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) -
// 			sizeof(unsigned short int) - sizeof(struct in_addr)];
// };
//  sockaddr_in addr = { AF_INET,htons(8080),{htonl(INADDR_LOOPBACK)} };

  // sockaddr_in addr = {0};
  sockaddr_in addr;
  addr.sin_family      = AF_INET;
  addr.sin_port        = htons(8080);
  addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

  NODE node = {0,0,{0,0}};

  printf("this is main. node(%d, %d) \n", node.a, node.b);
  return 0;
}

template <class T>
class MovingAverage
{
public:
    MovingAverage(size_t initial_size=10)
    {
        resize(initial_size);
    }

    void reset()
    {
        accumulated_value = T();
        head = 0;
        tail = 0;
    }

    void resize(size_t new_size)
    {
        reset();
        values.resize(new_size, T());
    }

    T add(T new_value)
    {
        const size_t max_size = values.size();
        if((head + 1) % max_size == tail)
        {
            accumulated_value -= values[tail];
            tail = (tail + 1) % max_size;
        }
        values[head] = new_value;
        head = (head + 1) % max_size;
        accumulated_value += new_value;

        return value();
    }

    T value() const
    {
        return accumulated_value / size();
    }

    size_t size() const
    {
        return (head - tail + values.size()) % values.size();
    }

    size_t max_size() const
    {
        return values.empty() ? 0 : values.size() - 1; // there's always one empty slot
    }

private:
    size_t head;
    size_t tail;

    std::vector<T> values;
    T accumulated_value;
};


struct ProcStats
{
    long user;   // Time spent executing user applications (user mode).
    long nice;   // Time spent executing user applications with low priority (nice).
    long system; // Time spent executing system calls (system mode).
    long idle;   // Idle time.
    long iowait; // Time waiting for I/O operations to complete.
    long irq;    // Time spent servicing interrupts.
    long softirq;// Time spent servicing soft-interrupts.

    ProcStats operator-(const ProcStats& other)
    {
        ProcStats res;
        res.user    = other.user   - user;
        res.nice    = other.nice   - nice;
        res.system  = other.system - system;
        res.idle    = other.idle   - idle;
        res.iowait  = other.iowait - iowait;
        res.irq     = other.irq    - irq;
        res.softirq = other.softirq- softirq;

        return res;
    }

    double cpu_utilisation() const
    {
        double cpu_total = user + nice + system + irq + softirq;
        double cpu_idle  = idle + iowait;

        return cpu_total / (cpu_total + cpu_idle) * 100; // in percentage
    }
};

std::istream& operator>>(std::istream& in, ProcStats& st)
{
    std::string cpu;
    if (in >> cpu)
    {
        in >> st.user >> st.nice >> st.system >> st.idle;
        in >> st.iowait >> st.irq >> st.softirq;
    }
    return in;
}


class CpuProcStatsReader
{
public:
    CpuProcStatsReader() : now_first(false)
    {
    }

    ProcStats get()
    {
        std::string cpu;
        std::ifstream f("/proc/stat");
        ProcStats& st = curr();
        f >> st;
        now_first = !now_first;
        return now_first ? stats.first - stats.second : stats.second - stats.first;
    }

private:
    ProcStats& curr()
    {
        return now_first ? stats.first : stats.second;
    }

    std::pair<ProcStats, ProcStats> stats;
    bool now_first;
};


int main(int argc, char **argv)
{
    unsigned int window_size = 20;
    unsigned int sampling_period_ms = 100;
    unsigned long timeout = 0;
    double exit_treshold = 1.0;
    std::string output_filename;

    po::options_description desc("\nWaits until the system becomes idle and exits."
                                 "\nOptions");
    desc.add_options()
            ("help,h", "Show this help")
            ("window_size,w", po::value(&window_size), "Size of moving-average window (in number of values)")
            ("sampling_period,s", po::value(&sampling_period_ms), "Number of milliseconds between each sample")
            ("output,o", po::value(&output_filename), "File name to print the values to (default=stdout)")
            ("exit_treshlod,e", po::value(&exit_treshold), "If specified specified (in %) - program will exit if "
                                                           "CPU utilisation will fall below this value (default=1)")
            ("timeout,t", po::value(&timeout), "Timeout in seconds (default=infinite)")
            ;

    po::variables_map vm;
    po::store(po::parse_command_line(argc, argv, desc), vm);
    po::notify(vm);
    if (vm.count("help"))
    {
        std::cout << desc << std::endl;
        return 0;
    }

    std::ofstream file;
    std::ostream* os = &std::cout;
    if(vm.count("output"))
    {
        file.open(output_filename.c_str());
        os = &file;
    }

    *os << "sampling period: " << sampling_period_ms << " ms\n";
    *os << "window size    : " << window_size << " samples\n";
    *os << "exit threshold : " << exit_treshold << " %\n";
    *os << "timeout        : " << timeout << " s" << std::endl;

    MovingAverage<double> ma(window_size);
    CpuProcStatsReader reader;

    if(timeout)
    {
        timeout = timeout * 1000;      // convert timeout to ms
        timeout += sampling_period_ms; // and add one sampling period
    }

    *os << std::setprecision(2) << std::fixed;
    while(1)
    {
        const ProcStats& st = reader.get();
        const double& avg = ma.add(st.cpu_utilisation());

        *os << "CPU load (%)   : avg: " << avg;
        *os << ", curr: " << st.cpu_utilisation() << "\r";
        *os << std::flush;

        if(avg < exit_treshold && ma.size() == ma.max_size())
        {
            *os << "\nexiting" << std::endl;
            break;
        }
        usleep(sampling_period_ms * 1000);

        if(timeout)
        {
            timeout -= sampling_period_ms;
            if(timeout <= sampling_period_ms)
            {
                *os << "\ntimed-out" << std::endl;
                return EXIT_FAILURE;
            }
        }
    }
    return EXIT_SUCCESS;
}

-------------------------------------------------------------------------------
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:

