*kt_linux*                                                           tw=100

/^[#=]{ 

aWed 18 Dec 2013 09:47:23 GMT

KT KB. Linux


={============================================================================
*kt_linux_core_107* 

see template and bind example

template<typename T>
void MetadataObserver::notify(std::vector<boost::weak_ptr<T> >& collection, boost::function<void (T*)> method)
{
    cleanupDeadPointers<T>(collection);

    BOOST_FOREACH(boost::weak_ptr<T> weak, collection)
    {
        boost::shared_ptr<T> strong = weak.lock();

        if(strong)
        {
            method(strong.get());
        }
    }
}

void MetadataObserver::notifyServicesChanged(const vector<string>& changedServiceLocators)
{
    notify<SystemClientEventRepository>(clientEventRepos, boost::bind(&SystemClientEventRepository::ServicesChanged, _1, changedServiceLocators));
}


={============================================================================
*kt_linux_core_107* 

see how iter declared in a function

const string extractValueFromMap(const map<string,string>& m, const string& key)
{
    map<string,string>::const_iterator iter;
    if((iter = m.find(key)) != m.end())
    {
        return iter->second;
    }
    return string();
}


={============================================================================
*kt_linux_core_107* 


int main(int argc, char *argv[])
{
    YVWindow window;
}

class YVWindow : public QWidget
{
private:
    void init();

    boost::scoped_ptr<QSocketNotifier> snTerm;
    boost::scoped_ptr<QSocketNotifier> snInt;
};

YVWindow::YVWindow(QWidget *parent)
    : QWidget(parent),
      fullScreenWidth(1280),
      fullScreenHeight(720)
{
    init();
}

void YVWindow::init()
{
    struct sigaction sInt, sTerm;
    sTerm.sa_handler = posixSignalHandler;
    sInt.sa_handler = posixSignalHandler;
    sigaction(SIGTERM, &sTerm, 0);
    sigaction(SIGINT, &sInt, 0);
    sigset_t signalSet;
    sigfillset(&signalSet);
    sigdelset(&signalSet, SIGTERM);
    sigdelset(&signalSet, SIGINT);
    pthread_sigmask(SIG_SETMASK, &signalSet, NULL);

    snTerm.reset(new QSocketNotifier(sigtermFd[1], QSocketNotifier::Read, this));
    connect(snTerm.get(), SIGNAL(activated(int)), this, SLOT(handleSigTerm()));

    snInt.reset(new QSocketNotifier(sigintFd[1], QSocketNotifier::Read, this));
    connect(snInt.get(), SIGNAL(activated(int)), this, SLOT(handleSigInt()));
}

void YVWindow::posixSignalHandler(int signo)
{
    if (signo == SIGTERM)
    {
        char a = SOCKET_SIGTERM_CODE;
        ::write(sigtermFd[0], &a, sizeof(a));
    }
    else if (signo == SIGINT)
    {
        char a = SOCKET_SIGINT_CODE;
        ::write(sigintFd[0], &a, sizeof(a));
    }
}

void YVWindow::handleSigTerm()
{
    VANADIUM_INFO("Handling SIGTERM");
    snTerm->setEnabled(false);
    char tmp;
    ::read(sigtermFd[1], &tmp, sizeof(tmp));

    if( tmp != SOCKET_SIGTERM_CODE ){
        std::cerr << "WARNING: Unexpected value received from sigTerm socket." << std::endl;
    }

    QApplication::instance()->quit();
}

void YVWindow::handleSigInt()
{
    VANADIUM_INFO("Handling SIGINT");
    snInt->setEnabled(false);
    char tmp;
    ::read(sigintFd[1], &tmp, sizeof(tmp));

    if( tmp != SOCKET_SIGINT_CODE ){
        std::cerr << "WARNING: Unexpected value received from sigTerm socket." << std::endl;
    }

    QApplication::instance()->quit();
}

Q:

Lukasz Forynski

Lukasz Forynski created a pull request2 days ago

Build with c++0x flags with mipsel-linux-gcc 4.4 reported following error:
"narrowing conversion of '({...})' from 'unsigned int' to 'in_port_t' inside { }"
for code where sockaddr_in structure was initialised in a C-style.

This syntax is not type-safe, and in C++0x yields an 'initialisation list',
for which all the items are required to be of the same type.
This with this simple fix fields of the sockaddr_in are assigned explicitly.

-   sockaddr_in addr = { AF_INET,htons(server.getPort()),{htonl(INADDR_LOOPBACK)} };

    sockaddr_in addr     = {0};
    addr.sin_family      = AF_INET;
    addr.sin_port        = htons(server.getPort());
    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);


#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>

typedef struct {
  int a;
  int b;
  int arr[2];
} NODE;

int main()
{

  // -Wextra
  // sample.c:11:3: warning: missing initializer [-Wmissing-field-initializers]
  // sample.c:11:3: warning: (near initialization for 'node.arr') [-Wmissing-field-initializers]
  // NODE node = {0,0};
  //


  // uint16_t htons(uint16_t hostshort);
  // uint32_t ntohl(uint32_t netlong);
  
// /* Structure describing an Internet (IP) socket address. */
// #define __SOCK_SIZE__	16		/* sizeof(struct sockaddr)	*/
// struct sockaddr_in {
//   __kernel_sa_family_t	sin_family;	/* Address family		*/
//   __be16		sin_port;	/* Port number			*/
//   struct in_addr	sin_addr;	/* Internet address		*/
// 
//   /* Pad to size of `struct sockaddr'. */
//   unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) -
// 			sizeof(unsigned short int) - sizeof(struct in_addr)];
// };
//  sockaddr_in addr = { AF_INET,htons(8080),{htonl(INADDR_LOOPBACK)} };

  // sockaddr_in addr = {0};
  sockaddr_in addr;
  addr.sin_family      = AF_INET;
  addr.sin_port        = htons(8080);
  addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

  NODE node = {0,0,{0,0}};

  printf("this is main. node(%d, %d) \n", node.a, node.b);
  return 0;
}


-------------------------------------------------------------------------------
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:

